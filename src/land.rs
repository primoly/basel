use geojson::GeoJson;
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;

#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub struct GeoPoint2d {
    pub lat: f64,
    pub lon: f64,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct File {
    pub url: String,
    pub width: u16,
    pub height: u16,
}

pub type Date = String;

fn escape(value: &str) -> String {
    value.replace('\\', "\\\\").replace('"', "\\\"")
}

/// Covid-19 (Breites Testen BL): Wöchentliche Anzahl Pools bzw. positive Pools (März 2021 - Dezember 2022)
pub mod covid_19_breites_testen_bl_woechentliche_anzahl_pools_bzw_positive_pools_maerz_2021_dezember_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Erster Tag der Kalenderwoche
        pub datum: Option<Date>,
        /// Kalenderwoche
        ///
        /// Jahr_Kalenderwoche
        pub kalenderwoche: Option<String>,
        /// Anzahl_Pools
        ///
        /// Zahl der analysierten Pools
        pub anzahl_pools: Option<f64>,
        /// Anzahl_positive_Pools
        ///
        /// Zahl der positiven Pools
        pub anzahl_positive_pools: Option<f64>,
        /// Anteil_positive_Pools
        ///
        /// Prozent positive Pools
        pub anteil_positive_pools: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Kalenderwoche,
        AnzahlPools,
        AnzahlPositivePools,
        AnteilPositivePools,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Kalenderwoche => "kalenderwoche",
                Field::AnzahlPools => "anzahl_pools",
                Field::AnzahlPositivePools => "anzahl_positive_pools",
                Field::AnteilPositivePools => "anteil_positive_pools",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11960/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Wöchentliche Fallzahlen, Hospitalisierungen und Tests (seit Februar 2020)
pub mod covid_19_woechentliche_fallzahlen_hospitalisierungen_und_tests_seit_februar_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// valueCategory
        pub valuecategory: Option<String>,
        pub temporal: Option<String>,
        pub temporal_type: Option<String>,
        pub georegion: Option<String>,
        /// testResult
        pub testresult: Option<String>,
        /// testResult_type
        pub testresult_type: Option<String>,
        pub value: Option<i64>,
        pub pop: Option<i64>,
        /// incValue
        pub incvalue: Option<f64>,
        pub prct: Option<f64>,
        pub inc14d: Option<f64>,
        pub trend: Option<String>,
        /// dataComplete
        pub datacomplete: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Valuecategory,
        Temporal,
        TemporalType,
        Georegion,
        Testresult,
        TestresultType,
        Value,
        Pop,
        Incvalue,
        Prct,
        Inc14d,
        Trend,
        Datacomplete,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Valuecategory => "valuecategory",
                Field::Temporal => "temporal",
                Field::TemporalType => "temporal_type",
                Field::Georegion => "georegion",
                Field::Testresult => "testresult",
                Field::TestresultType => "testresult_type",
                Field::Value => "value",
                Field::Pop => "pop",
                Field::Incvalue => "incvalue",
                Field::Prct => "prct",
                Field::Inc14d => "inc14d",
                Field::Trend => "trend",
                Field::Datacomplete => "datacomplete",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11050/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Unternehmensneugründungen und Unternehmensschliessungen nach Wirtschaftssektor, Gemeinde und Jahr (seit 2013)
pub mod unternehmensneugruendungen_und_unternehmensschliessungen_nach_wirtschaftssektor_gemeinde_und_jahr_seit_2013 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// BFS_Bezeichnung
        pub bfs_bezeichnung: Option<String>,
        /// Administrative_Ebene
        pub administrative_ebene: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wirtschaftssektor
        pub wirtschaftssektor: Option<String>,
        /// Anzahl
        pub anzahl: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        BfsBezeichnung,
        AdministrativeEbene,
        Indikator,
        Wirtschaftssektor,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::BfsBezeichnung => "bfs_bezeichnung",
                Field::AdministrativeEbene => "administrative_ebene",
                Field::Indikator => "indikator",
                Field::Wirtschaftssektor => "wirtschaftssektor",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10180/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratswahlen 2023: Kandidierendenresultate
pub mod regierungsratswahlen_2023_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11600/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2007: Kandidierendenresultate
pub mod staenderatswahlen_2007_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11860/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Volksinitiative vom 16. Dezember 2021 «Für Freiheit und körperliche Unversehrtheit»
pub mod volksinitiative_vom_16_dezember_2021_fuer_freiheit_und_koerperliche_unversehrtheit {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12540/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2015: Kandidierendenresultate, Wahlberechtigte und Parteistimmen
pub mod landratswahlen_2015_kandidierendenresultate_wahlberechtigte_und_parteistimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub compound_id: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        CompoundId,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CompoundId => "compound_id",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11770/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Tägliche Todesfälle (Februar 2020 - Januar 2023)
pub mod covid_19_taegliche_todesfaelle_februar_2020_januar_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// geoRegion
        ///
        /// Kanton
        pub georegion: Option<String>,
        /// Tägliche Todesfälle
        pub entries: Option<i64>,
        /// sumTotal
        ///
        /// Total Todesfälle
        pub sumtotal: Option<i64>,
        /// Version
        pub version: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Georegion,
        Entries,
        Sumtotal,
        Version,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Georegion => "georegion",
                Field::Entries => "entries",
                Field::Sumtotal => "sumtotal",
                Field::Version => "version",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10350/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratswahlen 2007: Kandidierendenresultate
pub mod regierungsratswahlen_2007_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11880/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratswahlen 2003: Kandidierendenresultate
pub mod regierungsratswahlen_2003_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11920/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratsersatzwahl 2013: Kandidierendenresultate
pub mod regierungsratsersatzwahl_2013_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11930/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Arealstatistik: Bodennutzung und -bedeckung nach Hauptbereich, Klasse und Gemeinde (seit 1982)
pub mod arealstatistik_bodennutzung_und_bedeckung_nach_hauptbereich_klasse_und_gemeinde_seit_1982 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Erhebungsperiode
        ///
        /// Periode der Erhebung im Kanton BL
        pub erhebungsperiode: Option<String>,
        /// Erhebungsjahr/e
        ///
        /// Jahr(e) der Erhebung (Luftbilder) im Kanton BL
        pub erhebungsjahr_e: Option<String>,
        /// BFS_Nummer
        ///
        /// Gemeindenummer gemäss Bundesamt für Statistik
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        ///
        /// Gemeindename
        pub gemeinde: Option<String>,
        /// Hauptbereich
        ///
        /// 4 Hauptbereiche und 2 Totale. Punktfläche = Summer der 4 Hauptbereiche
        pub hauptbereich: Option<String>,
        /// Klasse
        ///
        /// 17 Klassen
        pub klasse: Option<String>,
        /// Hektaren
        ///
        /// Wert in ha
        pub wert: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Erhebungsperiode,
        ErhebungsjahrE,
        BfsNummer,
        Gemeinde,
        Hauptbereich,
        Klasse,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Erhebungsperiode => "erhebungsperiode",
                Field::ErhebungsjahrE => "erhebungsjahr_e",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Hauptbereich => "hauptbereich",
                Field::Klasse => "klasse",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11970/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wetterstation Basel / Binningen: Monatswerte Klimamessnetz (seit 1901)
pub mod wetterstation_basel_binningen_monatswerte_klimamessnetz_seit_1901 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Erster Tag des Monats
        pub date: Option<Date>,
        /// station/location
        ///
        /// Messstation_Code
        pub station_location: Option<String>,
        /// Messstation
        pub station_name: Option<String>,
        /// Globalstrahlung (Monatsmittel)
        pub gre000m0: Option<i64>,
        /// Gesamtschneehöhe (Monatsmittel)
        pub hto000m0: Option<i64>,
        /// Gesamtbewölkung (Monatsmittel)
        pub nto000m0: Option<i64>,
        /// Luftdruck auf Stationshöhe (Monatsmittel)
        pub prestam0: Option<f64>,
        /// Niederschlag (Monatssumme)
        pub rre150m0: Option<f64>,
        /// Sonnenscheindauer (Monatssumme)
        pub sre000m0: Option<i64>,
        /// Lufttemperatur 2 m über Boden (Monatsmittel)
        pub tre200m0: Option<f64>,
        /// Lufttemperatur 2 m über Boden (absolutes Monatsminimum)
        pub tre200mn: Option<f64>,
        /// Lufttemperatur 2 m über Boden (absolutes Monatsmaximum)
        pub tre200mx: Option<f64>,
        /// Relative Luftfeuchtigkeit 2 m über Boden (Monatsmittel)
        pub ure200m0: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        StationLocation,
        StationName,
        Gre000m0,
        Hto000m0,
        Nto000m0,
        Prestam0,
        Rre150m0,
        Sre000m0,
        Tre200m0,
        Tre200mn,
        Tre200mx,
        Ure200m0,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::StationLocation => "station_location",
                Field::StationName => "station_name",
                Field::Gre000m0 => "gre000m0",
                Field::Hto000m0 => "hto000m0",
                Field::Nto000m0 => "nto000m0",
                Field::Prestam0 => "prestam0",
                Field::Rre150m0 => "rre150m0",
                Field::Sre000m0 => "sre000m0",
                Field::Tre200m0 => "tre200m0",
                Field::Tre200mn => "tre200mn",
                Field::Tre200mx => "tre200mx",
                Field::Ure200m0 => "ure200m0",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10130/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2007: Kandidierendenresultate, Wahlberechtigte und Listenstimmen
pub mod nationalratswahlen_2007_kandidierendenresultate_wahlberechtigte_und_listenstimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_panachage_votes_from_list_01: Option<i64>,
        pub candidate_panachage_votes_from_list_02: Option<i64>,
        pub candidate_panachage_votes_from_list_03: Option<i64>,
        pub candidate_panachage_votes_from_list_04: Option<i64>,
        pub candidate_panachage_votes_from_list_05: Option<i64>,
        pub candidate_panachage_votes_from_list_06: Option<String>,
        pub candidate_panachage_votes_from_list_07: Option<i64>,
        pub candidate_panachage_votes_from_list_08: Option<String>,
        pub candidate_panachage_votes_from_list_09: Option<String>,
        pub candidate_panachage_votes_from_list_12: Option<String>,
        pub candidate_panachage_votes_from_list_33: Option<String>,
        pub candidate_panachage_votes_from_list_55: Option<i64>,
        pub candidate_panachage_votes_from_list_77: Option<String>,
        pub candidate_panachage_votes_from_list_999: Option<i64>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_connection: Option<i64>,
        pub list_connection_parent: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_panachage_votes_from_list_01: Option<i64>,
        pub list_panachage_votes_from_list_02: Option<i64>,
        pub list_panachage_votes_from_list_03: Option<i64>,
        pub list_panachage_votes_from_list_04: Option<i64>,
        pub list_panachage_votes_from_list_05: Option<String>,
        pub list_panachage_votes_from_list_06: Option<i64>,
        pub list_panachage_votes_from_list_07: Option<i64>,
        pub list_panachage_votes_from_list_08: Option<i64>,
        pub list_panachage_votes_from_list_09: Option<i64>,
        pub list_panachage_votes_from_list_12: Option<i64>,
        pub list_panachage_votes_from_list_33: Option<i64>,
        pub list_panachage_votes_from_list_55: Option<i64>,
        pub list_panachage_votes_from_list_77: Option<i64>,
        pub list_panachage_votes_from_list_999: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidatePanachageVotesFromList01,
        CandidatePanachageVotesFromList02,
        CandidatePanachageVotesFromList03,
        CandidatePanachageVotesFromList04,
        CandidatePanachageVotesFromList05,
        CandidatePanachageVotesFromList06,
        CandidatePanachageVotesFromList07,
        CandidatePanachageVotesFromList08,
        CandidatePanachageVotesFromList09,
        CandidatePanachageVotesFromList12,
        CandidatePanachageVotesFromList33,
        CandidatePanachageVotesFromList55,
        CandidatePanachageVotesFromList77,
        CandidatePanachageVotesFromList999,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListConnection,
        ListConnectionParent,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListPanachageVotesFromList01,
        ListPanachageVotesFromList02,
        ListPanachageVotesFromList03,
        ListPanachageVotesFromList04,
        ListPanachageVotesFromList05,
        ListPanachageVotesFromList06,
        ListPanachageVotesFromList07,
        ListPanachageVotesFromList08,
        ListPanachageVotesFromList09,
        ListPanachageVotesFromList12,
        ListPanachageVotesFromList33,
        ListPanachageVotesFromList55,
        ListPanachageVotesFromList77,
        ListPanachageVotesFromList999,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidatePanachageVotesFromList01 => {
                    "candidate_panachage_votes_from_list_01"
                }
                Field::CandidatePanachageVotesFromList02 => {
                    "candidate_panachage_votes_from_list_02"
                }
                Field::CandidatePanachageVotesFromList03 => {
                    "candidate_panachage_votes_from_list_03"
                }
                Field::CandidatePanachageVotesFromList04 => {
                    "candidate_panachage_votes_from_list_04"
                }
                Field::CandidatePanachageVotesFromList05 => {
                    "candidate_panachage_votes_from_list_05"
                }
                Field::CandidatePanachageVotesFromList06 => {
                    "candidate_panachage_votes_from_list_06"
                }
                Field::CandidatePanachageVotesFromList07 => {
                    "candidate_panachage_votes_from_list_07"
                }
                Field::CandidatePanachageVotesFromList08 => {
                    "candidate_panachage_votes_from_list_08"
                }
                Field::CandidatePanachageVotesFromList09 => {
                    "candidate_panachage_votes_from_list_09"
                }
                Field::CandidatePanachageVotesFromList12 => {
                    "candidate_panachage_votes_from_list_12"
                }
                Field::CandidatePanachageVotesFromList33 => {
                    "candidate_panachage_votes_from_list_33"
                }
                Field::CandidatePanachageVotesFromList55 => {
                    "candidate_panachage_votes_from_list_55"
                }
                Field::CandidatePanachageVotesFromList77 => {
                    "candidate_panachage_votes_from_list_77"
                }
                Field::CandidatePanachageVotesFromList999 => {
                    "candidate_panachage_votes_from_list_999"
                }
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListConnection => "list_connection",
                Field::ListConnectionParent => "list_connection_parent",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListPanachageVotesFromList01 => "list_panachage_votes_from_list_01",
                Field::ListPanachageVotesFromList02 => "list_panachage_votes_from_list_02",
                Field::ListPanachageVotesFromList03 => "list_panachage_votes_from_list_03",
                Field::ListPanachageVotesFromList04 => "list_panachage_votes_from_list_04",
                Field::ListPanachageVotesFromList05 => "list_panachage_votes_from_list_05",
                Field::ListPanachageVotesFromList06 => "list_panachage_votes_from_list_06",
                Field::ListPanachageVotesFromList07 => "list_panachage_votes_from_list_07",
                Field::ListPanachageVotesFromList08 => "list_panachage_votes_from_list_08",
                Field::ListPanachageVotesFromList09 => "list_panachage_votes_from_list_09",
                Field::ListPanachageVotesFromList12 => "list_panachage_votes_from_list_12",
                Field::ListPanachageVotesFromList33 => "list_panachage_votes_from_list_33",
                Field::ListPanachageVotesFromList55 => "list_panachage_votes_from_list_55",
                Field::ListPanachageVotesFromList77 => "list_panachage_votes_from_list_77",
                Field::ListPanachageVotesFromList999 => "list_panachage_votes_from_list_999",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11870/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2019: Kandidierendenresultate, Wahlberechtigte und Parteistimmen
pub mod landratswahlen_2019_kandidierendenresultate_wahlberechtigte_und_parteistimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub compound_id: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        CompoundId,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CompoundId => "compound_id",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11720/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2011: Kandidierendenresultate, Wahlberechtigte und Parteistimmen
pub mod landratswahlen_2011_kandidierendenresultate_wahlberechtigte_und_parteistimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub compound_id: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        CompoundId,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CompoundId => "compound_id",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11810/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2003: Kandidierendenresultate
pub mod staenderatswahlen_2003_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11900/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Hotels und Kurbetriebe: Angebot und Nachfrage nach Gemeinde und Jahr (seit 2005)
pub mod hotels_und_kurbetriebe_angebot_und_nachfrage_nach_gemeinde_und_jahr_seit_2005 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Geoeffnete_Betriebe
        pub geoeffnete_betriebe: Option<f64>,
        /// Verfuegbare_Zimmer
        pub verfuegbare_zimmer: Option<i64>,
        /// Verfuegbare_Betten
        pub verfuegbare_betten: Option<i64>,
        /// Ankuenfte
        pub ankuenfte: Option<String>,
        /// Logiernaechte
        pub logiernaechte: Option<String>,
        /// Zimmernaechte
        pub zimmernaechte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        GeoeffneteBetriebe,
        VerfuegbareZimmer,
        VerfuegbareBetten,
        Ankuenfte,
        Logiernaechte,
        Zimmernaechte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::GeoeffneteBetriebe => "geoeffnete_betriebe",
                Field::VerfuegbareZimmer => "verfuegbare_zimmer",
                Field::VerfuegbareBetten => "verfuegbare_betten",
                Field::Ankuenfte => "ankuenfte",
                Field::Logiernaechte => "logiernaechte",
                Field::Zimmernaechte => "zimmernaechte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10160/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Vornamen der Neugeborenen nach Geschlecht und Jahr (seit 2021)
pub mod vornamen_der_neugeborenen_nach_geschlecht_und_jahr_seit_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
        /// Rang_nach_Jahr
        pub rang_nach_jahr: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Vorname,
        Geschlecht,
        Anzahl,
        RangNachJahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
                Field::RangNachJahr => "rang_nach_jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10070/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeinnützige Wohnungen nach Zimmerzahl, Gemeinde und Jahr (seit 2016)
pub mod gemeinnuetzige_wohnungen_nach_zimmerzahl_gemeinde_und_jahr_seit_2016 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Zimmerzahl
        pub zimmerzahl: Option<i64>,
        /// ANZAHL
        ///
        /// Anzahl gemeinnützige Wohnungen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Gemeinde,
        Zimmerzahl,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Zimmerzahl => "zimmerzahl",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12250/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überbauungsstand nach Zone, Erschliessung, Gemeinde und Jahr (seit 2016)
pub mod ueberbauungsstand_nach_zone_erschliessung_gemeinde_und_jahr_seit_2016 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Ueberbaut
        pub ueberbaut: Option<i64>,
        /// Erschlossen
        pub erschlossen: Option<i64>,
        /// Zone_Code
        pub zone_code: Option<i64>,
        /// Zone
        pub zone: Option<String>,
        /// Flaeche_m2
        pub flaeche_m2: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Ueberbaut,
        Erschlossen,
        ZoneCode,
        Zone,
        FlaecheM2,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Ueberbaut => "ueberbaut",
                Field::Erschlossen => "erschlossen",
                Field::ZoneCode => "zone_code",
                Field::Zone => "zone",
                Field::FlaecheM2 => "flaeche_m2",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10090/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2003: Kandidierendenresultate, Wahlberechtigte und Listenstimmen
pub mod nationalratswahlen_2003_kandidierendenresultate_wahlberechtigte_und_listenstimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_panachage_votes_from_list_01: Option<i64>,
        pub candidate_panachage_votes_from_list_02: Option<i64>,
        pub candidate_panachage_votes_from_list_03: Option<i64>,
        pub candidate_panachage_votes_from_list_04: Option<i64>,
        pub candidate_panachage_votes_from_list_05: Option<i64>,
        pub candidate_panachage_votes_from_list_06: Option<String>,
        pub candidate_panachage_votes_from_list_07: Option<i64>,
        pub candidate_panachage_votes_from_list_09: Option<String>,
        pub candidate_panachage_votes_from_list_10: Option<String>,
        pub candidate_panachage_votes_from_list_13: Option<String>,
        pub candidate_panachage_votes_from_list_44: Option<String>,
        pub candidate_panachage_votes_from_list_77: Option<String>,
        pub candidate_panachage_votes_from_list_999: Option<i64>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_connection: Option<i64>,
        pub list_connection_parent: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_panachage_votes_from_list_01: Option<i64>,
        pub list_panachage_votes_from_list_02: Option<i64>,
        pub list_panachage_votes_from_list_03: Option<i64>,
        pub list_panachage_votes_from_list_04: Option<i64>,
        pub list_panachage_votes_from_list_05: Option<String>,
        pub list_panachage_votes_from_list_06: Option<i64>,
        pub list_panachage_votes_from_list_07: Option<i64>,
        pub list_panachage_votes_from_list_09: Option<i64>,
        pub list_panachage_votes_from_list_10: Option<i64>,
        pub list_panachage_votes_from_list_13: Option<i64>,
        pub list_panachage_votes_from_list_44: Option<i64>,
        pub list_panachage_votes_from_list_77: Option<i64>,
        pub list_panachage_votes_from_list_999: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidatePanachageVotesFromList01,
        CandidatePanachageVotesFromList02,
        CandidatePanachageVotesFromList03,
        CandidatePanachageVotesFromList04,
        CandidatePanachageVotesFromList05,
        CandidatePanachageVotesFromList06,
        CandidatePanachageVotesFromList07,
        CandidatePanachageVotesFromList09,
        CandidatePanachageVotesFromList10,
        CandidatePanachageVotesFromList13,
        CandidatePanachageVotesFromList44,
        CandidatePanachageVotesFromList77,
        CandidatePanachageVotesFromList999,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListConnection,
        ListConnectionParent,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListPanachageVotesFromList01,
        ListPanachageVotesFromList02,
        ListPanachageVotesFromList03,
        ListPanachageVotesFromList04,
        ListPanachageVotesFromList05,
        ListPanachageVotesFromList06,
        ListPanachageVotesFromList07,
        ListPanachageVotesFromList09,
        ListPanachageVotesFromList10,
        ListPanachageVotesFromList13,
        ListPanachageVotesFromList44,
        ListPanachageVotesFromList77,
        ListPanachageVotesFromList999,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidatePanachageVotesFromList01 => {
                    "candidate_panachage_votes_from_list_01"
                }
                Field::CandidatePanachageVotesFromList02 => {
                    "candidate_panachage_votes_from_list_02"
                }
                Field::CandidatePanachageVotesFromList03 => {
                    "candidate_panachage_votes_from_list_03"
                }
                Field::CandidatePanachageVotesFromList04 => {
                    "candidate_panachage_votes_from_list_04"
                }
                Field::CandidatePanachageVotesFromList05 => {
                    "candidate_panachage_votes_from_list_05"
                }
                Field::CandidatePanachageVotesFromList06 => {
                    "candidate_panachage_votes_from_list_06"
                }
                Field::CandidatePanachageVotesFromList07 => {
                    "candidate_panachage_votes_from_list_07"
                }
                Field::CandidatePanachageVotesFromList09 => {
                    "candidate_panachage_votes_from_list_09"
                }
                Field::CandidatePanachageVotesFromList10 => {
                    "candidate_panachage_votes_from_list_10"
                }
                Field::CandidatePanachageVotesFromList13 => {
                    "candidate_panachage_votes_from_list_13"
                }
                Field::CandidatePanachageVotesFromList44 => {
                    "candidate_panachage_votes_from_list_44"
                }
                Field::CandidatePanachageVotesFromList77 => {
                    "candidate_panachage_votes_from_list_77"
                }
                Field::CandidatePanachageVotesFromList999 => {
                    "candidate_panachage_votes_from_list_999"
                }
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListConnection => "list_connection",
                Field::ListConnectionParent => "list_connection_parent",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListPanachageVotesFromList01 => "list_panachage_votes_from_list_01",
                Field::ListPanachageVotesFromList02 => "list_panachage_votes_from_list_02",
                Field::ListPanachageVotesFromList03 => "list_panachage_votes_from_list_03",
                Field::ListPanachageVotesFromList04 => "list_panachage_votes_from_list_04",
                Field::ListPanachageVotesFromList05 => "list_panachage_votes_from_list_05",
                Field::ListPanachageVotesFromList06 => "list_panachage_votes_from_list_06",
                Field::ListPanachageVotesFromList07 => "list_panachage_votes_from_list_07",
                Field::ListPanachageVotesFromList09 => "list_panachage_votes_from_list_09",
                Field::ListPanachageVotesFromList10 => "list_panachage_votes_from_list_10",
                Field::ListPanachageVotesFromList13 => "list_panachage_votes_from_list_13",
                Field::ListPanachageVotesFromList44 => "list_panachage_votes_from_list_44",
                Field::ListPanachageVotesFromList77 => "list_panachage_votes_from_list_77",
                Field::ListPanachageVotesFromList999 => "list_panachage_votes_from_list_999",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11910/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2023: Wahlberechtigte nach Geschlecht, briefliche Stimmabgaben, unveränderte und veränderte Wahlzettel nach Gemeinde
pub mod nationalratswahlen_2023_wahlberechtigte_nach_geschlecht_briefliche_stimmabgaben_unveraenderte_und_veraenderte_wahlzettel_nach_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<i64>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmberechtigte
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte_Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte_Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte_Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche_Stimmabgaben
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige_Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere_Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte_Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte_Wahlzettel_mit_Bezeichnung
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte_Wahlzettel_ohne_Bezeichnung
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere_Stimmen
        pub leere_stimmen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsGemeindenummer,
        Gemeinde,
        Stimmberechtigte,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12310/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2023: Unveränderte und veränderte Wahlzettel nach Partei und Gemeinde
pub mod landratswahlen_2023_unveraenderte_und_veraenderte_wahlzettel_nach_partei_und_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezirk-Nummer
        pub entity_district_id: Option<i64>,
        /// Wahlbezirk-Name
        pub entity_district_name: Option<String>,
        /// Gemeindenummer gemäss Bundesamt für Statistik
        pub entity_id: Option<i64>,
        /// Gemeindename
        pub entity_name: Option<String>,
        /// Wahlberechtigte in der Gemeinde
        pub entity_eligible_voters: Option<i64>,
        /// Listennummer
        pub list_id: Option<String>,
        /// Partei
        pub party: Option<String>,
        /// Gültige Wahlzettel
        pub accounted_ballots: Option<i64>,
        /// Unveränderte Wahlzettel
        pub unmodified_ballots: Option<i64>,
        /// Veränderte Wahlzettel
        pub modified_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        EntityDistrictId,
        EntityDistrictName,
        EntityId,
        EntityName,
        EntityEligibleVoters,
        ListId,
        Party,
        AccountedBallots,
        UnmodifiedBallots,
        ModifiedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::EntityDistrictId => "entity_district_id",
                Field::EntityDistrictName => "entity_district_name",
                Field::EntityId => "entity_id",
                Field::EntityName => "entity_name",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::ListId => "list_id",
                Field::Party => "party",
                Field::AccountedBallots => "accounted_ballots",
                Field::UnmodifiedBallots => "unmodified_ballots",
                Field::ModifiedBallots => "modified_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12000/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung des Energiegesetzes vom 19. Oktober 2023
pub mod aenderung_des_energiegesetzes_vom_19_oktober_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12560/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Klimanormwerte nach ausgewählten Messstationen
pub mod klimanormwerte_nach_ausgewaehlten_messstationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Referenzperiode
        pub referenzperiode: Option<String>,
        /// Station
        pub station: Option<String>,
        /// Parameter
        pub parameter: Option<String>,
        /// Einheit
        pub einheit: Option<String>,
        /// Jan
        pub jan: Option<f64>,
        /// Feb
        pub feb: Option<f64>,
        /// Mar
        pub mar: Option<f64>,
        /// Apr
        pub apr: Option<f64>,
        /// Mai
        pub mai: Option<f64>,
        /// Jun
        pub jun: Option<f64>,
        /// Jul
        pub jul: Option<f64>,
        /// Aug
        pub aug: Option<f64>,
        /// Sep
        pub sep: Option<f64>,
        /// Okt
        pub okt: Option<f64>,
        /// Nov
        pub nov: Option<f64>,
        /// Dez
        pub dez: Option<f64>,
        /// Jahr
        pub jahr: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Referenzperiode,
        Station,
        Parameter,
        Einheit,
        Jan,
        Feb,
        Mar,
        Apr,
        Mai,
        Jun,
        Jul,
        Aug,
        Sep,
        Okt,
        Nov,
        Dez,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Referenzperiode => "referenzperiode",
                Field::Station => "station",
                Field::Parameter => "parameter",
                Field::Einheit => "einheit",
                Field::Jan => "jan",
                Field::Feb => "feb",
                Field::Mar => "mar",
                Field::Apr => "apr",
                Field::Mai => "mai",
                Field::Jun => "jun",
                Field::Jul => "jul",
                Field::Aug => "aug",
                Field::Sep => "sep",
                Field::Okt => "okt",
                Field::Nov => "nov",
                Field::Dez => "dez",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10140/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Parteistimmen und Parteistärken bei den Nationalratswahlen nach Gemeinde und Jahr (seit 1971)
pub mod parteistimmen_und_parteistaerken_bei_den_nationalratswahlen_nach_gemeinde_und_jahr_seit_1971 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Partei
        pub partei: Option<String>,
        /// Stimmen
        pub stimmen: Option<i64>,
        /// Parteistärke
        pub parteistarke: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Partei,
        Stimmen,
        Parteistarke,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Partei => "partei",
                Field::Stimmen => "stimmen",
                Field::Parteistarke => "parteistarke",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10520/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Volksinitiative vom 16. Juli 2021 «Für eine sichere und nachhaltige Altersvorsorge (Renteninitiative)»
pub mod volksinitiative_vom_16_juli_2021_fuer_eine_sichere_und_nachhaltige_altersvorsorge_renteninitiative {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub answer: Option<String>,
        pub counted: Option<i64>,
        pub date: Option<String>,
        pub district: Option<String>,
        /// domain
        pub domain0: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub expats: Option<i64>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        pub id: Option<String>,
        pub shortcode: Option<String>,
        pub status: Option<String>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        /// type
        pub r#type: Option<String>,
        pub ballot_answer: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Answer,
        Counted,
        Date,
        District,
        Domain0,
        EntityId,
        Name,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        Id,
        Shortcode,
        Status,
        TitleDeCh,
        RType,
        BallotAnswer,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Answer => "answer",
                Field::Counted => "counted",
                Field::Date => "date",
                Field::District => "district",
                Field::Domain0 => "domain0",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::Id => "id",
                Field::Shortcode => "shortcode",
                Field::Status => "status",
                Field::TitleDeCh => "title_de_ch",
                Field::RType => "type",
                Field::BallotAnswer => "ballot_answer",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12400/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahlen Gemeindepräsidien
pub mod wahlen_gemeindepraesidien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Anzahl Stimmen
        pub anzahl_stimmen: Option<String>,
        /// Gewählt
        pub gewahlt: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// Stille Wahl
        pub stille_wahl: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Bisher,
        AnzahlStimmen,
        Gewahlt,
        Parteibezeichnung,
        StilleWahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Bisher => "bisher",
                Field::AnzahlStimmen => "anzahl_stimmen",
                Field::Gewahlt => "gewahlt",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::StilleWahl => "stille_wahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12490/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerungsbestand nach Geschlecht, Nationalität, Zivilstand und Konfession (seit 1980)
pub mod bevoelkerungsbestand_nach_geschlecht_nationalitaet_zivilstand_und_konfession_seit_1980 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub geschlecht_code: Option<i64>,
        pub geschlecht: Option<String>,
        pub nationalitaet_code: Option<i64>,
        pub nationalitaet: Option<String>,
        pub zivilstand_aggregiert_code: Option<i64>,
        pub zivilstand_aggregiert: Option<String>,
        pub konfession_code: Option<i64>,
        pub konfession: Option<String>,
        pub anzahl_personen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        GeschlechtCode,
        Geschlecht,
        NationalitaetCode,
        Nationalitaet,
        ZivilstandAggregiertCode,
        ZivilstandAggregiert,
        KonfessionCode,
        Konfession,
        AnzahlPersonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::GeschlechtCode => "geschlecht_code",
                Field::Geschlecht => "geschlecht",
                Field::NationalitaetCode => "nationalitaet_code",
                Field::Nationalitaet => "nationalitaet",
                Field::ZivilstandAggregiertCode => "zivilstand_aggregiert_code",
                Field::ZivilstandAggregiert => "zivilstand_aggregiert",
                Field::KonfessionCode => "konfession_code",
                Field::Konfession => "konfession",
                Field::AnzahlPersonen => "anzahl_personen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10030/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnungsbestand nach Zimmerzahl, Gemeinde und Jahr (seit 1994)
pub mod wohnungsbestand_nach_zimmerzahl_gemeinde_und_jahr_seit_1994 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Zimmerzahl
        pub zimmerzahl: Option<String>,
        /// Anzahl_Wohnungen
        pub anzahl_wohnungen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Zimmerzahl,
        AnzahlWohnungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Zimmerzahl => "zimmerzahl",
                Field::AnzahlWohnungen => "anzahl_wohnungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10220/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Sissach West (halbstündliche Messdaten Januar 2007 - April 2017)
pub mod luftqualitaet_station_sissach_west_halbstuendliche_messdaten_januar_2007_april_2017 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Anfangszeit
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// PM10
        ///
        /// Lungengängiger Feinstaub PM10
        pub pm10: Option<f64>,
        /// NO2
        ///
        /// Stickstoffdioxid
        pub no2: Option<f64>,
        /// O3
        ///
        /// Ozon
        pub o3: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        Pm10,
        No2,
        O3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::Pm10 => "pm10",
                Field::No2 => "no2",
                Field::O3 => "o3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10910/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2023: Panaschierstimmen der Kandidierenden
pub mod landratswahlen_2023_panaschierstimmen_der_kandidierenden {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub entity_district_id: Option<i64>,
        pub entity_district_name: Option<String>,
        pub election_status: Option<String>,
        pub entity_id: Option<i64>,
        pub entity_name: Option<String>,
        pub list_name: Option<String>,
        pub list_id: Option<i64>,
        pub list_number_of_mandates: Option<i64>,
        pub list_votes: Option<i64>,
        pub candidate_id: Option<String>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_elected: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_gender: Option<String>,
        pub candidate_year_of_birth: Option<String>,
        pub candidate_votes: Option<i64>,
        /// votes_from_FDP
        pub votes_from_fdp: Option<i64>,
        /// votes_from_SP
        pub votes_from_sp: Option<i64>,
        /// votes_from_SVP
        pub votes_from_svp: Option<i64>,
        /// votes_from_EVP
        pub votes_from_evp: Option<i64>,
        /// votes_from_DieMitteBL
        pub votes_from_diemittebl: Option<i64>,
        /// votes_from_Grüne
        pub votes_from_grune: Option<i64>,
        /// votes_from_GLP
        pub votes_from_glp: Option<i64>,
        /// votes_from_CuP
        pub votes_from_cup: Option<i64>,
        /// votes_from_AVP
        pub votes_from_avp: Option<i64>,
        /// votes_from_Leer
        pub votes_from_leer: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        EntityDistrictId,
        EntityDistrictName,
        ElectionStatus,
        EntityId,
        EntityName,
        ListName,
        ListId,
        ListNumberOfMandates,
        ListVotes,
        CandidateId,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateElected,
        CandidateParty,
        CandidateGender,
        CandidateYearOfBirth,
        CandidateVotes,
        VotesFromFdp,
        VotesFromSp,
        VotesFromSvp,
        VotesFromEvp,
        VotesFromDiemittebl,
        VotesFromGrune,
        VotesFromGlp,
        VotesFromCup,
        VotesFromAvp,
        VotesFromLeer,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::EntityDistrictId => "entity_district_id",
                Field::EntityDistrictName => "entity_district_name",
                Field::ElectionStatus => "election_status",
                Field::EntityId => "entity_id",
                Field::EntityName => "entity_name",
                Field::ListName => "list_name",
                Field::ListId => "list_id",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
                Field::CandidateId => "candidate_id",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateElected => "candidate_elected",
                Field::CandidateParty => "candidate_party",
                Field::CandidateGender => "candidate_gender",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CandidateVotes => "candidate_votes",
                Field::VotesFromFdp => "votes_from_fdp",
                Field::VotesFromSp => "votes_from_sp",
                Field::VotesFromSvp => "votes_from_svp",
                Field::VotesFromEvp => "votes_from_evp",
                Field::VotesFromDiemittebl => "votes_from_diemittebl",
                Field::VotesFromGrune => "votes_from_grune",
                Field::VotesFromGlp => "votes_from_glp",
                Field::VotesFromCup => "votes_from_cup",
                Field::VotesFromAvp => "votes_from_avp",
                Field::VotesFromLeer => "votes_from_leer",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11610/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Historische Gebäude: Firstständerbauten nach Haustyp und Gemeinde
pub mod historische_gebaeude_firststaenderbauten_nach_haustyp_und_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Nummer
        ///
        /// Gemeindenummer gemäss Bundesamt für Statistik
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        ///
        /// Gemeindename
        pub gemeinde: Option<String>,
        /// Akte
        ///
        /// Aktennummer
        pub akte: Option<String>,
        /// Strasse
        pub strasse: Option<String>,
        /// Koordinate_X_LV95
        ///
        /// X-Koordinate, auf Meter genau gerundet
        pub koordinate_x_lv95: Option<String>,
        /// Koordinate_Y_LV95
        ///
        /// Y-Koordinate, auf Meter genau gerundet
        pub koordinate_y_lv95: Option<String>,
        /// Schutzstatus
        ///
        /// Rechtlicher Schutzstatus des Gebäudes. keiner; Kantonal; Kommunal; Ortsbild.
        pub schutzstatus: Option<String>,
        /// Abgebrochen
        ///
        /// Vollständiger Abbruch des Gebäudes. Ja; Nein; -.
        pub abgebrochen: Option<String>,
        /// Erhaltung_Holzkonstruktion_Prozent
        ///
        /// Erhaltung der Holzkonstruktion des Kernbaus in Prozent, auf 25% gerundet.
        pub erhaltung_holzkonstruktion_prozent: Option<f64>,
        /// Kernbau_Datierung
        ///
        /// Datierung des Kernbaus, Angabe des Jahrhunderts.
        pub kernbau_datierung: Option<String>,
        /// Kernbau_Datierung_von
        ///
        /// Älteste mögliche Jahreszahl der Datierung des Kernbaus (t.p.q). Bei einer Inschrift oder Dendro bleibt das Feld leer.
        pub kernbau_datierung_von: Option<String>,
        /// Kernbau_Datierung_bis
        ///
        /// Jüngste mögliche Jahreszahl der Datierung Kernbau (t.a.q). Bei Dendro jüngst mögliches Schlagjahr.
        pub kernbau_datierung_bis: Option<String>,
        /// Kernbau_Datierung_Quelle
        ///
        /// Art der Datierung des Kernbaus. Dendro; Inschrift; Historisch; Quelle.
        pub kernbau_datierung_quelle: Option<String>,
        /// Haustyp
        ///
        /// Haustyp Firstständerbau. Siehe pdf-Beilage.
        pub haustyp: Option<String>,
        /// Holzarten
        ///
        /// In der Kernkonstruktion vorhandene Holzarten. Bei mehr als einer Angabe Trennung durch Semikolon.
        pub holzarten: Option<String>,
        /// Firstständer
        ///
        /// Anzahl der ursprünglich vorhandenen Firstständer im Kernbau.
        pub firststander: Option<f64>,
        /// Geschosse_Wohnteil
        ///
        /// Anzahl Geschosse des Wohnteils im Kernbau, ohne Dachgeschosse.
        pub geschosse_wohnteil: Option<f64>,
        /// Funktionsachsen
        ///
        /// Anzahl Funktionsachsen des Kernbaus.
        pub funktionsachsen: Option<f64>,
        /// Wohnbereich_Prozent
        ///
        /// Prozentualer Anteil der Fläche des Wohnbereiches im Verhältnis zum gesamten Kernbau, auf 5% gerundet.
        pub wohnbereich_prozent: Option<f64>,
        /// Keller
        ///
        /// Bauzeitlicher Keller vorhanden. Ja; Nein.
        pub keller: Option<String>,
        /// Bundflucht_Regelkonform
        ///
        /// Regelkonforme Bundseiten in Stube (rundherum voneinander abgewandte Bundseiten) und Tenn (zueinander blickende Bundseiten) nach Gut 2018. Angaben Stube und Tenn mit Semikolon getrennt. Ja; Nein.
        pub bundflucht_regelkonform: Option<String>,
        /// Wandverschluss
        ///
        /// Art der Wandverschlüsse im Kernbau. Bohlen; Flecklinge; Lehmflechtwerk.
        pub wandverschluss: Option<String>,
        /// Abstand_Bundfluchten
        ///
        /// Abstände der Firstständer im Kernbau, gemessen von Bundflucht zu Bundflucht. Die einzelnen Zahlen werden mit einem Semikolon getrennt.
        pub abstand_bundfluchten: Option<String>,
        /// Raumtiefe_Wohnteil
        ///
        /// Anzahl hintereinanderliegender Räume im Wohnteil des Kernbaus.
        pub raumtiefe_wohnteil: Option<String>,
        /// Länge_m
        ///
        /// Länge des Kernbaus in Metern, auf 0.1 m gerundet.
        pub lange_m: Option<f64>,
        /// Breite_m
        ///
        /// Breite des Kernbaus in Metern, auf 0.1 m gerundet.
        pub breite_m: Option<f64>,
        /// Höhe_m
        ///
        /// Höhe des Kernbaus in Metern, auf 0.1 m gerundet.
        pub hohe_m: Option<f64>,
        /// Dachform
        ///
        /// Art der bauzeitlichen Dachform des Kernbaus. Vollwalmdach; Satteldach; Schopfwalmdach.
        pub dachform: Option<String>,
        /// Dachbedeckung
        ///
        /// Material / Art der bauzeitlichen Dachbedeckung. Stroh; Brettschindel; Ziegel.
        pub dachbedeckung: Option<String>,
        /// Neigungs_Winkel_Rafen-Bundbalken_Grad
        ///
        /// Bauzeitliche Dachneigung. Gemessen zwischen Rafen und Bundbalken, auf 1 Grad gerundet.
        pub neigungs_winkel_rafen_bundbalken_grad: Option<f64>,
        /// Versteinerung
        ///
        /// Nachträgliche Versteinerung der Holzkonstruktion des Kernbaus. Ja; Nein.
        pub versteinerung: Option<String>,
        /// Versteinerung_Datierung
        ///
        /// Datierung der Versteinerung des Kernbaus, Angabe des Jahrhunderts.
        pub versteinerung_datierung: Option<String>,
        /// Versteinerung_Datierung_von
        ///
        /// Älteste mögliche Jahreszahl der Datierung der Versteinerung (t.p.q). Bei einer Inschrift oder Dendro bleibt das Feld leer.
        pub versteinerung_datierung_von: Option<String>,
        /// Versteinerung_Datierung_bis
        ///
        /// Jüngste mögliche Jahreszahl der Datierung der Versteinerung (t.a.q). Bei Dendro jüngst mögliches Schlagjahr.
        pub versteinerung_datierung_bis: Option<String>,
        /// Versteinerung_Datierung_Quelle
        ///
        /// Art der Datierung der Versteinerung. Dendro; Inschrift; Historisch; Quelle.
        pub versteinerung_datierung_quelle: Option<String>,
        /// Kommentar
        ///
        /// Ergänzende Bemerkungen zum Objekt.
        pub kommentar: Option<String>,
        pub geom: Option<GeoJson>,
        pub centroid: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsNummer,
        Gemeinde,
        Akte,
        Strasse,
        KoordinateXLv95,
        KoordinateYLv95,
        Schutzstatus,
        Abgebrochen,
        ErhaltungHolzkonstruktionProzent,
        KernbauDatierung,
        KernbauDatierungVon,
        KernbauDatierungBis,
        KernbauDatierungQuelle,
        Haustyp,
        Holzarten,
        Firststander,
        GeschosseWohnteil,
        Funktionsachsen,
        WohnbereichProzent,
        Keller,
        BundfluchtRegelkonform,
        Wandverschluss,
        AbstandBundfluchten,
        RaumtiefeWohnteil,
        LangeM,
        BreiteM,
        HoheM,
        Dachform,
        Dachbedeckung,
        NeigungsWinkelRafenBundbalkenGrad,
        Versteinerung,
        VersteinerungDatierung,
        VersteinerungDatierungVon,
        VersteinerungDatierungBis,
        VersteinerungDatierungQuelle,
        Kommentar,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Akte => "akte",
                Field::Strasse => "strasse",
                Field::KoordinateXLv95 => "koordinate_x_lv95",
                Field::KoordinateYLv95 => "koordinate_y_lv95",
                Field::Schutzstatus => "schutzstatus",
                Field::Abgebrochen => "abgebrochen",
                Field::ErhaltungHolzkonstruktionProzent => "erhaltung_holzkonstruktion_prozent",
                Field::KernbauDatierung => "kernbau_datierung",
                Field::KernbauDatierungVon => "kernbau_datierung_von",
                Field::KernbauDatierungBis => "kernbau_datierung_bis",
                Field::KernbauDatierungQuelle => "kernbau_datierung_quelle",
                Field::Haustyp => "haustyp",
                Field::Holzarten => "holzarten",
                Field::Firststander => "firststander",
                Field::GeschosseWohnteil => "geschosse_wohnteil",
                Field::Funktionsachsen => "funktionsachsen",
                Field::WohnbereichProzent => "wohnbereich_prozent",
                Field::Keller => "keller",
                Field::BundfluchtRegelkonform => "bundflucht_regelkonform",
                Field::Wandverschluss => "wandverschluss",
                Field::AbstandBundfluchten => "abstand_bundfluchten",
                Field::RaumtiefeWohnteil => "raumtiefe_wohnteil",
                Field::LangeM => "lange_m",
                Field::BreiteM => "breite_m",
                Field::HoheM => "hohe_m",
                Field::Dachform => "dachform",
                Field::Dachbedeckung => "dachbedeckung",
                Field::NeigungsWinkelRafenBundbalkenGrad => "neigungs_winkel_rafen_bundbalken_grad",
                Field::Versteinerung => "versteinerung",
                Field::VersteinerungDatierung => "versteinerung_datierung",
                Field::VersteinerungDatierungVon => "versteinerung_datierung_von",
                Field::VersteinerungDatierungBis => "versteinerung_datierung_bis",
                Field::VersteinerungDatierungQuelle => "versteinerung_datierung_quelle",
                Field::Kommentar => "kommentar",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11100/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Liestal (halbstündliche Messdaten Januar 2000 - November 2016)
pub mod luftqualitaet_station_liestal_halbstuendliche_messdaten_januar_2000_november_2016 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Anfangszeit
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// NO2
        ///
        /// Stickstoffdioxid
        pub no2: Option<f64>,
        /// O3
        ///
        /// Ozon
        pub o3: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        No2,
        O3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::No2 => "no2",
                Field::O3 => "o3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11540/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen: Wahlkreise
pub mod landratswahlen_wahlkreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlkreis_Nr
        pub wahlkreisn: Option<i64>,
        /// Wahlkreis
        pub wahlkreis: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlkreisn,
        Wahlkreis,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlkreisn => "wahlkreisn",
                Field::Wahlkreis => "wahlkreis",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11710/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohngebäude nach Energieträger der Heizung, Bauperiode, Gemeinde und Jahr (2022)
pub mod wohngebaeude_nach_energietraeger_der_heizung_bauperiode_gemeinde_und_jahr_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Gemeindenummer Bundesamt für Statistik
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Code Energieträger gemäss GWR-Katalog
        pub energietraeger_code: Option<String>,
        /// Code Bauperiode gemäss GWR-Katalog
        pub bauperiode_code: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Absoluter Wert
        pub wert: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Gemeinde,
        EnergietraegerCode,
        BauperiodeCode,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::EnergietraegerCode => "energietraeger_code",
                Field::BauperiodeCode => "bauperiode_code",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11940/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2007: Kandidierendenresultate, Wahlberechtigte und Parteistimmen
pub mod landratswahlen_2007_kandidierendenresultate_wahlberechtigte_und_parteistimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub compound_id: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        CompoundId,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CompoundId => "compound_id",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11850/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Durchschnittlicher Quadratmeterpreis von Wohnbauland nach Gemeinde und Jahr (seit 1979)
pub mod durchschnittlicher_quadratmeterpreis_von_wohnbauland_nach_gemeinde_und_jahr_seit_1979 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Fälle
        pub falle: Option<String>,
        /// Fläche_in_m2
        pub flache_in_m2: Option<String>,
        /// Quadratmeterpreis_CHF
        pub quadratmeterpreis_chf: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Falle,
        FlacheInM2,
        QuadratmeterpreisChf,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Falle => "falle",
                Field::FlacheInM2 => "flache_in_m2",
                Field::QuadratmeterpreisChf => "quadratmeterpreis_chf",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10200/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Schönenbuch (halbstündliche Messdaten Januar 2000 - April 2016)
pub mod luftqualitaet_station_schoenenbuch_halbstuendliche_messdaten_januar_2000_april_2016 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Anfangzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangzeit: Option<OffsetDateTime>,
        /// PM10
        ///
        /// Lungengängiger Feinstaub PM10
        pub pm10: Option<f64>,
        /// NO2
        ///
        /// Stickstoffdioxid
        pub no2: Option<f64>,
        /// O3
        ///
        /// Ozon
        pub o3: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangzeit,
        Pm10,
        No2,
        O3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangzeit => "anfangzeit",
                Field::Pm10 => "pm10",
                Field::No2 => "no2",
                Field::O3 => "o3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12580/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Altersprognose nach Versorgungsregion, Geschlecht, Alter und Jahr (2020 mit Basis 2018)
pub mod altersprognose_nach_versorgungsregion_geschlecht_alter_und_jahr_2020_mit_basis_2018 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Erhebungsjahr
        pub jahr: Option<String>,
        /// Code der Versorgungsregion
        pub versorgungsregion_code: Option<i64>,
        /// Name der Versorgungsregion
        pub versorgungsregion: Option<String>,
        /// Geschlechter-Code
        pub geschlecht_code: Option<i64>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Alter in ganzen Jahren (Personen ≥100 werden mit 100 erfasst)
        pub altersjahr_100_plus: Option<i64>,
        /// Code der Altersklasse (in 5-Jahr-Schritten)
        pub altersklasse_5_jahre_code: Option<i64>,
        /// Altersklasse (in 5-Jahr-Schritten)
        pub altersklasse_5_jahre: Option<String>,
        /// Anzahl Personen
        pub anzahl_personen: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        VersorgungsregionCode,
        Versorgungsregion,
        GeschlechtCode,
        Geschlecht,
        Altersjahr100Plus,
        Altersklasse5JahreCode,
        Altersklasse5Jahre,
        AnzahlPersonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::VersorgungsregionCode => "versorgungsregion_code",
                Field::Versorgungsregion => "versorgungsregion",
                Field::GeschlechtCode => "geschlecht_code",
                Field::Geschlecht => "geschlecht",
                Field::Altersjahr100Plus => "altersjahr_100_plus",
                Field::Altersklasse5JahreCode => "altersklasse_5_jahre_code",
                Field::Altersklasse5Jahre => "altersklasse_5_jahre",
                Field::AnzahlPersonen => "anzahl_personen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10050/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Durchschnittlicher Quadratmeterpreis von Bauland nach Gemeinde und Jahr (seit 1979)
pub mod durchschnittlicher_quadratmeterpreis_von_bauland_nach_gemeinde_und_jahr_seit_1979 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Fälle
        pub falle: Option<String>,
        /// Fläche_in_m2
        pub flache_in_m2: Option<String>,
        /// Quadratmeterpreis_CHF
        pub quadratmeterpreis_chf: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Falle,
        FlacheInM2,
        QuadratmeterpreisChf,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Falle => "falle",
                Field::FlacheInM2 => "flache_in_m2",
                Field::QuadratmeterpreisChf => "quadratmeterpreis_chf",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12070/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Durchschnittlicher Verkaufspreis von Eigentumswohnungen nach Zimmerzahl, Bezirk und Jahr (seit 2011)
pub mod durchschnittlicher_verkaufspreis_von_eigentumswohnungen_nach_zimmerzahl_bezirk_und_jahr_seit_2011 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Bezirk_Nummer
        pub bezirk_nummer: Option<String>,
        /// Bezirk
        pub bezirk: Option<String>,
        /// Zimmerzahl
        pub zimmerzahl: Option<String>,
        /// Verkaufspreis_CHF
        pub verkaufspreis_chf: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BezirkNummer,
        Bezirk,
        Zimmerzahl,
        VerkaufspreisChf,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::Zimmerzahl => "zimmerzahl",
                Field::VerkaufspreisChf => "verkaufspreis_chf",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10210/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19 (Breites Testen BL): Wöchentlich getestete bzw. positive Personen in Betrieben nach Kategorie (März 2021 - Dezember 2022)
pub mod covid_19_breites_testen_bl_woechentlich_getestete_bzw_positive_personen_in_betrieben_nach_kategorie_maerz_2021_dezember_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Erster Tag der Kalenderwoche
        pub datum: Option<Date>,
        /// Kalenderwoche
        ///
        /// Jahr_Kalenderwoche
        pub kalenderwoche: Option<String>,
        /// Kategorie
        ///
        /// Art der teilnehmenden Organisation
        pub kategorie: Option<String>,
        /// Anzahl_getestete_Personen
        pub anzahl_getestete_personen: Option<f64>,
        /// Anzahl_positive_Personen
        pub anzahl_positive_personen: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Kalenderwoche,
        Kategorie,
        AnzahlGetestetePersonen,
        AnzahlPositivePersonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Kalenderwoche => "kalenderwoche",
                Field::Kategorie => "kategorie",
                Field::AnzahlGetestetePersonen => "anzahl_getestete_personen",
                Field::AnzahlPositivePersonen => "anzahl_positive_personen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11950/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2011: Kandidierendenresultate
pub mod staenderatswahlen_2011_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11820/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Adressen der Primar-, Sekundar- und Musikschulen (Juni 2024)
pub mod adressen_der_primar_sekundar_und_musikschulen_juni_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Schule_Code
        pub schule_code: Option<String>,
        /// Schule_Name
        pub schule_name: Option<String>,
        /// Sekundarschulkreis_Code
        pub sekundarschulkreis_code: Option<String>,
        /// Sekundarschulkreis
        pub sekundarschulkreis: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// E_Mail
        pub e_mail: Option<String>,
        /// URL
        pub url: Option<String>,
        pub e_eingangskoordinate: Option<i64>,
        pub n_eingangskoordinate: Option<i64>,
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsGemeindenummer,
        Gemeinde,
        SchuleCode,
        SchuleName,
        SekundarschulkreisCode,
        Sekundarschulkreis,
        Adresse,
        Plz,
        Ort,
        Kategorie,
        Telefon,
        EMail,
        Url,
        EEingangskoordinate,
        NEingangskoordinate,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::SchuleCode => "schule_code",
                Field::SchuleName => "schule_name",
                Field::SekundarschulkreisCode => "sekundarschulkreis_code",
                Field::Sekundarschulkreis => "sekundarschulkreis",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kategorie => "kategorie",
                Field::Telefon => "telefon",
                Field::EMail => "e_mail",
                Field::Url => "url",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11150/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bewilligte Spitex-Organisationen nach Standort (August 2024)
pub mod bewilligte_spitex_organisationen_nach_standort_august_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Organisation
        pub organisation: Option<String>,
        /// Post_Adresse
        pub post_adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// E_Mail
        pub e_mail: Option<String>,
        /// GWR_Adresse
        pub gwr_adresse: Option<String>,
        /// GKODE
        pub gkode: Option<f64>,
        /// GKODN
        pub gkodn: Option<f64>,
        /// Koordinaten
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Organisation,
        PostAdresse,
        Plz,
        Ort,
        Telefon,
        EMail,
        GwrAdresse,
        Gkode,
        Gkodn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Organisation => "organisation",
                Field::PostAdresse => "post_adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::EMail => "e_mail",
                Field::GwrAdresse => "gwr_adresse",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10330/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Endverbrauch von Elektrizität nach Gemeinde und Jahr (seit 1990)
pub mod endverbrauch_von_elektrizitaet_nach_gemeinde_und_jahr_seit_1990 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        pub gemeinde: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10190/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Tägliche Fallzahlen (Februar 2020 - Januar 2023)
pub mod covid_19_taegliche_fallzahlen_februar_2020_januar_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// geoRegion
        ///
        /// Kanton
        pub georegion: Option<String>,
        /// Tägliche Fälle
        pub entries: Option<i64>,
        /// sumTotal
        ///
        /// Total Fälle
        pub sumtotal: Option<i64>,
        /// Ständige Wohnbevölkerung 2020
        pub pop: Option<i64>,
        /// Version
        pub version: Option<String>,
        /// Tägliche Fälle pro 1000 Personen
        pub per1000persons: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Georegion,
        Entries,
        Sumtotal,
        Pop,
        Version,
        Per1000persons,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Georegion => "georegion",
                Field::Entries => "entries",
                Field::Sumtotal => "sumtotal",
                Field::Pop => "pop",
                Field::Version => "version",
                Field::Per1000persons => "per1000persons",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10340/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gebäude nach Eigentümertyp, Wirtschaftsabschnitt, Gemeinde und Jahr (seit 2020)
pub mod gebaeude_nach_eigentuemertyp_wirtschaftsabschnitt_gemeinde_und_jahr_seit_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Eigentümertyp
        pub eigentumertyp: Option<String>,
        /// Wirtschaftsabschnitt
        pub wirtschaftsabschnitt: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Gebäude
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Gemeinde,
        Eigentumertyp,
        Wirtschaftsabschnitt,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Eigentumertyp => "eigentumertyp",
                Field::Wirtschaftsabschnitt => "wirtschaftsabschnitt",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12240/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Volksinitiative vom 17. September 2019 "Keine Massentierhaltung in der Schweiz" (Massentierhaltungsinitiative)
pub mod volksinitiative_vom_17_september_2019_keine_massentierhaltung_in_der_schweiz_massentierhaltungsinitiative {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10530/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung des Steuergesetzes, Vermögenssteuerreform I
pub mod aenderung_des_steuergesetzes_vermoegenssteuerreform_i {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10670/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Tägliche Tests nach Typ des Tests (Februar 2020 - Januar 2023)
pub mod covid_19_taegliche_tests_nach_typ_des_tests_februar_2020_januar_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// geoRegion
        ///
        /// Kanton
        pub georegion: Option<String>,
        /// Tägliche Tests
        pub entries: Option<i64>,
        /// sumTotal
        ///
        /// Total Tests
        pub sumtotal: Option<i64>,
        /// Tägliche positive Tests
        pub entries_pos: Option<i64>,
        /// Tägliche negative Tests
        pub entries_neg: Option<i64>,
        /// Anteil tägliche positive Tests
        pub pos_anteil: Option<f64>,
        /// Version
        pub version: Option<String>,
        /// Typ des Tests
        pub nachweismethode: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Georegion,
        Entries,
        Sumtotal,
        EntriesPos,
        EntriesNeg,
        PosAnteil,
        Version,
        Nachweismethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Georegion => "georegion",
                Field::Entries => "entries",
                Field::Sumtotal => "sumtotal",
                Field::EntriesPos => "entries_pos",
                Field::EntriesNeg => "entries_neg",
                Field::PosAnteil => "pos_anteil",
                Field::Version => "version",
                Field::Nachweismethode => "nachweismethode",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10380/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung der Kantonsverfassung vom 13. Januar 2022 betreffend Anpassung der Bestimmungen über die Ombudsperson
pub mod aenderung_der_kantonsverfassung_vom_13_januar_2022_betreffend_anpassung_der_bestimmungen_ueber_die_ombudsperson {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        /// BFS-Gemeindenummer (0 = Auslandschweizer)
        pub entity_id: Option<String>,
        /// Gemeindename
        pub name: Option<String>,
        /// Anzahl Stimmberechtigter
        pub eligible_voters: Option<i64>,
        /// Anzahl leerer Stimmen
        pub empty: Option<i64>,
        /// Anzahl Auslandschweizer
        pub expats: Option<String>,
        /// Anzahl ungültiger Stimmen
        pub invalid: Option<i64>,
        /// Anzahl Ja-Stimmen
        pub yeas: Option<i64>,
        /// Anzahl Nein-Stimmen
        pub nays: Option<i64>,
        /// title_de_CH
        ///
        /// Vorlagentitel
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10480/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bundesbeschluss vom 17. Dezember 2021 über die Zusatzfinanzierung der AHV durch eine Erhöhung der Mehrwertsteuer
pub mod bundesbeschluss_vom_17_dezember_2021_ueber_die_zusatzfinanzierung_der_ahv_durch_eine_erhoehung_der_mehrwertsteuer {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10540/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung vom 17. Dezember 2021 des Bundesgesetzes über die Alters- und Hinterlassenenversicherung (AHVG) (AHV 21)
pub mod aenderung_vom_17_dezember_2021_des_bundesgesetzes_ueber_die_alters_und_hinterlassenenversicherung_ahvg_ahv_21 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10550/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Übernahme der EU-Verordnung über die Europäische Grenz- und Küstenwache
pub mod uebernahme_der_eu_verordnung_ueber_die_europaeische_grenz_und_kuestenwache {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub eligible_voters: Option<i64>,
        pub expats: Option<String>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        TitleDeCh,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::TitleDeCh => "title_de_ch",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10470/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Teilrevision des Sozialhilfegesetzes vom 4. November 2021 betreffend «Anreize stärken – Arbeitsintegration fördern»
pub mod teilrevision_des_sozialhilfegesetzes_vom_4_november_2021_betreffend_anreize_staerken_arbeitsintegration_foerdern {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<String>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10490/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung vom 16. Dezember 2022 des Bundesgesetzes über die gesetzlichen Grundlagen für Verordnungen des Bundesrates zur Bewältigung der Covid-19-Epidemie (Covid-19-Gesetz)
pub mod aenderung_vom_16_dezember_2022_des_bundesgesetzes_ueber_die_gesetzlichen_grundlagen_fuer_verordnungen_des_bundesrates_zur_bewaeltigung_der_covid_19_epidemie_covid_19_gesetz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12100/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bundesgesetz vom 30. September 2022 über die Ziele im Klimaschutz, die Innovation und die Stärkung der Energiesicherheit (KIG)
pub mod bundesgesetz_vom_30_september_2022_ueber_die_ziele_im_klimaschutz_die_innovation_und_die_staerkung_der_energiesicherheit_kig {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12090/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bundesbeschluss vom 16. Dezember 2022 über eine besondere Besteuerung grosser Unternehmensgruppen
pub mod bundesbeschluss_vom_16_dezember_2022_ueber_eine_besondere_besteuerung_grosser_unternehmensgruppen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12080/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung vom 17. Dezember 2021 des Bundesgesetzes über die Verrechnungssteuer (Verrechnungssteuergesetz, VStG) (Stärkung des Fremdkapitalmarkts)
pub mod aenderung_vom_17_dezember_2021_des_bundesgesetzes_ueber_die_verrechnungssteuer_verrechnungssteuergesetz_vstg_staerkung_des_fremdkapitalmarkts {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10560/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abfallmengen nach Kategorie, Gemeinde und Jahr (seit 2017)
pub mod abfallmengen_nach_kategorie_gemeinde_und_jahr_seit_2017 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Einheit
        pub einheit: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Gemeinde,
        Kategorie,
        Einheit,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Kategorie => "kategorie",
                Field::Einheit => "einheit",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12060/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abschlüsse von Studierenden mit Wohnkanton BL an Schweizer Hochschulen nach Hochschultyp, Fachbereich, Geschlecht, Examensstufe und Jahr (seit 1980)
pub mod abschluesse_von_studierenden_mit_wohnkanton_bl_an_schweizer_hochschulen_nach_hochschultyp_fachbereich_geschlecht_examensstufe_und_jahr_seit_1980 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Hochschultyp
        pub hochschultyp: Option<String>,
        /// Fachbereich
        pub fachbereich: Option<String>,
        /// Geschlecht_Code
        pub geschlecht_code: Option<i64>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Examensstufe
        pub examensstufe: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Hochschultyp,
        Fachbereich,
        GeschlechtCode,
        Geschlecht,
        Examensstufe,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Hochschultyp => "hochschultyp",
                Field::Fachbereich => "fachbereich",
                Field::GeschlechtCode => "geschlecht_code",
                Field::Geschlecht => "geschlecht",
                Field::Examensstufe => "examensstufe",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10430/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baukosten nach Art und Kategorie der Auftraggeber, Bezirk und Jahr (seit 1994)
pub mod baukosten_nach_art_und_kategorie_der_auftraggeber_bezirk_und_jahr_seit_1994 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Bezirk_Nummer
        pub bezirk_nummer: Option<String>,
        /// Bezirk
        pub bezirk: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BezirkNummer,
        Bezirk,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10240/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Geschlecht, Altersgruppe, Gemeinde und Jahr (1941 - 2000)
pub mod wohnbevoelkerung_nach_geschlecht_altersgruppe_gemeinde_und_jahr_1941_2000 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Gemeindenummer
        pub gemeindenummer: Option<String>,
        /// Gemeindename
        pub gemeindename: Option<String>,
        /// Altersgruppe
        pub altersgruppe: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Gemeindenummer,
        Gemeindename,
        Altersgruppe,
        Geschlecht,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Gemeindenummer => "gemeindenummer",
                Field::Gemeindename => "gemeindename",
                Field::Altersgruppe => "altersgruppe",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12140/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2023: Kandidierendenresultate, Wahlberechtigte und Parteistimmen
pub mod landratswahlen_2023_kandidierendenresultate_wahlberechtigte_und_parteistimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_gender: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub compound_id: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        /// Parteistimmen
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateGender,
        CandidateId,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        CompoundId,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateGender => "candidate_gender",
                Field::CandidateId => "candidate_id",
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CompoundId => "compound_id",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11590/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Sozialhilfe nach Gemeinde und Jahr (seit 2005)
pub mod kennzahlen_der_sozialhilfe_nach_gemeinde_und_jahr_seit_2005 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub bfs_nummer: Option<String>,
        pub bfs_bezeichnung: Option<String>,
        pub administrative_ebene: Option<String>,
        pub kennzahl_mind_50_unterstuetze_personen: Option<String>,
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        BfsBezeichnung,
        AdministrativeEbene,
        KennzahlMind50UnterstuetzePersonen,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::BfsBezeichnung => "bfs_bezeichnung",
                Field::AdministrativeEbene => "administrative_ebene",
                Field::KennzahlMind50UnterstuetzePersonen => {
                    "kennzahl_mind_50_unterstuetze_personen"
                }
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10300/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2023: Kandidierende nach Liste, Geschlecht, Jahrgang, Beruf und Wahlkreis
pub mod landratswahlen_2023_kandidierende_nach_liste_geschlecht_jahrgang_beruf_und_wahlkreis {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlkreis-Nr
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis
        pub wahlkreis: Option<String>,
        /// Region
        pub region: Option<String>,
        /// Wahltermin
        pub wahltermin: Option<Date>,
        /// Anzahl_Sitze
        pub anzahl_sitze: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// Anzahl_leere_Linien
        pub anzahl_leere_linien: Option<i64>,
        /// Zeilen-Nr
        pub zeilen_nr: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Kumulation
        pub kumulation: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Beruf_Tätigkeit
        pub beruf_tatigkeit: Option<String>,
        /// Zusatz
        pub zusatz: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Wohnort
        pub ort: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahlkreisNr,
        Wahlkreis,
        Region,
        Wahltermin,
        AnzahlSitze,
        ListenNr,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlLeereLinien,
        ZeilenNr,
        KandidatenNr,
        Kumulation,
        Bisher,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Titel,
        BerufTatigkeit,
        Zusatz,
        Plz,
        Ort,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::Wahlkreis => "wahlkreis",
                Field::Region => "region",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::ListenNr => "listen_nr",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlLeereLinien => "anzahl_leere_linien",
                Field::ZeilenNr => "zeilen_nr",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Titel => "titel",
                Field::BerufTatigkeit => "beruf_tatigkeit",
                Field::Zusatz => "zusatz",
                Field::Plz => "plz",
                Field::Ort => "ort",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11660/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Alterszentren und Pflegeheime nach Standort (Januar 2024)
pub mod alterszentren_und_pflegeheime_nach_standort_januar_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Nummer
        ///
        /// BFS-Gemeindenummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        ///
        /// Gemeindename
        pub gemeinde: Option<String>,
        /// Versorgungsregion_Code
        pub versorgungsregion_code: Option<i64>,
        /// Versorgungsregion
        pub versorgungsregion: Option<String>,
        /// Institution
        ///
        /// Name der Institution
        pub institution: Option<String>,
        /// Post_Adresse
        ///
        /// Post-Adresse
        pub post_adresse: Option<String>,
        /// PLZ_Ort
        ///
        /// Postleitzahl Ort
        pub plz_ort: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// E_Mail
        ///
        /// E-Mail-Adresse
        pub e_mail: Option<String>,
        /// Website
        ///
        /// Internetadresse
        pub website: Option<String>,
        /// GWR_Adresse
        ///
        /// GWR-Adresse
        pub gwr_adresse: Option<String>,
        /// GKODE
        ///
        /// Gebäudekoordinate Ost
        pub gkode: Option<f64>,
        /// GKODN
        ///
        /// Gebäudekoordinate West
        pub gkodn: Option<f64>,
        /// Koordinaten
        ///
        /// Koordinaten gemäss World Geodetic System 1984 (WGS84)
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsNummer,
        Gemeinde,
        VersorgungsregionCode,
        Versorgungsregion,
        Institution,
        PostAdresse,
        PlzOrt,
        Telefon,
        EMail,
        Website,
        GwrAdresse,
        Gkode,
        Gkodn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::VersorgungsregionCode => "versorgungsregion_code",
                Field::Versorgungsregion => "versorgungsregion",
                Field::Institution => "institution",
                Field::PostAdresse => "post_adresse",
                Field::PlzOrt => "plz_ort",
                Field::Telefon => "telefon",
                Field::EMail => "e_mail",
                Field::Website => "website",
                Field::GwrAdresse => "gwr_adresse",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10310/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bundesgesetz vom 29. September 2023 über eine sichere Stromversorgung mit erneuerbaren Energien (Änderung des Energiegesetzes und des Stromversorgungsgesetzes)
pub mod bundesgesetz_vom_29_september_2023_ueber_eine_sichere_stromversorgung_mit_erneuerbaren_energien_aenderung_des_energiegesetzes_und_des_stromversorgungsgesetzes {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12550/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Landratswahlen 2003: Kandidierendenresultate, Wahlberechtigte und Parteistimmen
pub mod landratswahlen_2003_kandidierendenresultate_wahlberechtigte_und_parteistimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub compound_id: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        CompoundId,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::CompoundId => "compound_id",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11890/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratswahlen 2011: Kandidierendenresultate
pub mod regierungsratswahlen_2011_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11840/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Jugend und Sport: Anzahl Kurse, Teilnehmende und Leitende nach Sportart und Jahr (seit 2005)
pub mod jugend_und_sport_anzahl_kurse_teilnehmende_und_leitende_nach_sportart_und_jahr_seit_2005 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Sportart
        pub sportart: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Sportart,
        Indikator,
        Geschlecht,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Sportart => "sportart",
                Field::Indikator => "indikator",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11470/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Volksinitiative vom 23. Januar 2020 «Maximal 10 % des Einkommens für die Krankenkassenprämien (Prämien-Entlastungs-Initiative)»
pub mod volksinitiative_vom_23_januar_2020_maximal_10_des_einkommens_fuer_die_krankenkassenpraemien_praemien_entlastungs_initiative {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12520/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratswahlen 2019: Kandidierendenresultate
pub mod regierungsratswahlen_2019_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11750/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Volksinitiative vom 10. März 2020 «Für tiefere Prämien – Kostenbremse im Gesundheitswesen (Kostenbremse-Initiative)»
pub mod volksinitiative_vom_10_maerz_2020_fuer_tiefere_praemien_kostenbremse_im_gesundheitswesen_kostenbremse_initiative {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12530/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Swisslos-Fonds: Unterstützte Projekte nach Sparte und Betrag (seit 2011)
pub mod swisslos_fonds_unterstuetzte_projekte_nach_sparte_und_betrag_seit_2011 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Begünstigte
        pub begunstigte: Option<String>,
        /// Unterstütztes_Projekt
        pub unterstutztes_projekt: Option<String>,
        /// Sparte
        pub sparte: Option<String>,
        /// Beitrag_CHF
        pub beitrag_chf: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Begunstigte,
        UnterstutztesProjekt,
        Sparte,
        BeitragChf,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Begunstigte => "begunstigte",
                Field::UnterstutztesProjekt => "unterstutztes_projekt",
                Field::Sparte => "sparte",
                Field::BeitragChf => "beitrag_chf",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11460/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeinderatsnachwahlen 2024: Kandidierendenresultate
pub mod gemeinderatsnachwahlen_2024_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Anzahl Stimmen
        pub anzahl_stimmen: Option<String>,
        /// Gewählt
        pub gewahlt: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        KandidatenNr,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Bisher,
        AnzahlStimmen,
        Gewahlt,
        Parteibezeichnung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Bisher => "bisher",
                Field::AnzahlStimmen => "anzahl_stimmen",
                Field::Gewahlt => "gewahlt",
                Field::Parteibezeichnung => "parteibezeichnung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12430/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Raumgliederungen nach Gemeinde (März 2024)
pub mod raumgliederungen_nach_gemeinde_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Bezirk_Nummer
        pub bezirk_nummer: Option<String>,
        /// Bezirk
        pub bezirk: Option<String>,
        /// Grossregion_Code
        pub grossregion_code: Option<i64>,
        /// Grossregion
        pub grossregion: Option<String>,
        /// Agglomeration_2020_Code
        pub agglomeration_2020_code: Option<String>,
        /// Agglomeration_2020
        pub agglomeration_2020: Option<String>,
        /// Agglomerationsgrössenklasse_2020_Code
        pub agglomerationsgrossenklasse_2020_code: Option<i64>,
        /// Agglomerationsgrössenklasse_2020
        pub agglomerationsgrossenklasse_2020: Option<String>,
        /// Städtischer_Charakter_2020_Code
        pub stadtischer_charakter_2020_code: Option<i64>,
        /// Städtischer_Charakter_2020
        pub stadtischer_charakter_2020: Option<String>,
        /// Statistische_Stadt_2020_Code
        pub statistische_stadt_2020_code: Option<i64>,
        /// Statistische_Stadt_2020
        pub statistische_stadt_2020: Option<String>,
        /// Städtisch_Ländlich_2020_Code
        pub stadtisch_landlich_2020_code: Option<i64>,
        /// Städtisch_Ländlich_2020
        pub stadtisch_landlich_2020: Option<String>,
        /// Gemeindetypologie_2020_9_Code
        pub gemeindetypologie_2020_9_code: Option<i64>,
        /// Gemeindetypologie_2020_9
        pub gemeindetypologie_2020_9: Option<String>,
        /// Gemeindetypologie_2020_25_Code
        pub gemeindetypologie_2020_25_code: Option<i64>,
        /// Gemeindetypologie_2020_25
        pub gemeindetypologie_2020_25: Option<String>,
        /// Arbeitsmarktgrossregion_2018_Code
        pub arbeitsmarktgrossregion_2018_code: Option<String>,
        /// Arbeitsmarktgrossregion_2018
        pub arbeitsmarktgrossregion_2018: Option<String>,
        /// Arbeitsmarktregion_2018_Code
        pub arbeitsmarktregion_2018_code: Option<String>,
        /// Arbeitsmarktregion_2018
        pub arbeitsmarktregion_2018: Option<String>,
        /// Berggebiet_2019_Code
        pub berggebiet_2019_code: Option<i64>,
        /// Berggebiet_2019
        pub berggebiet_2019: Option<String>,
        /// Urbanisierungsgrad_2011_Code
        pub urbanisierungsgrad_2011_code: Option<i64>,
        /// Urbanisierungsgrad_2011
        pub urbanisierungsgrad_2011: Option<String>,
        /// Erweiterte_Stadt_2011_Code
        pub erweiterte_stadt_2011_code: Option<String>,
        /// Erweiterte_Stadt_2011
        pub erweiterte_stadt_2011: Option<String>,
        /// Funktionales_städtisches_Gebiet_2014_Code
        pub funktionales_stadtisches_gebiet_2014_code: Option<String>,
        /// Funktionales_städtisches_Gebiet_2014
        pub funktionales_stadtisches_gebiet_2014: Option<String>,
        /// Geometrie
        pub geometry: Option<GeoJson>,
        /// Geometrisches_Zentrum
        pub centroid: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsNummer,
        Gemeinde,
        BezirkNummer,
        Bezirk,
        GrossregionCode,
        Grossregion,
        Agglomeration2020Code,
        Agglomeration2020,
        Agglomerationsgrossenklasse2020Code,
        Agglomerationsgrossenklasse2020,
        StadtischerCharakter2020Code,
        StadtischerCharakter2020,
        StatistischeStadt2020Code,
        StatistischeStadt2020,
        StadtischLandlich2020Code,
        StadtischLandlich2020,
        Gemeindetypologie20209Code,
        Gemeindetypologie20209,
        Gemeindetypologie202025Code,
        Gemeindetypologie202025,
        Arbeitsmarktgrossregion2018Code,
        Arbeitsmarktgrossregion2018,
        Arbeitsmarktregion2018Code,
        Arbeitsmarktregion2018,
        Berggebiet2019Code,
        Berggebiet2019,
        Urbanisierungsgrad2011Code,
        Urbanisierungsgrad2011,
        ErweiterteStadt2011Code,
        ErweiterteStadt2011,
        FunktionalesStadtischesGebiet2014Code,
        FunktionalesStadtischesGebiet2014,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::GrossregionCode => "grossregion_code",
                Field::Grossregion => "grossregion",
                Field::Agglomeration2020Code => "agglomeration_2020_code",
                Field::Agglomeration2020 => "agglomeration_2020",
                Field::Agglomerationsgrossenklasse2020Code => {
                    "agglomerationsgrossenklasse_2020_code"
                }
                Field::Agglomerationsgrossenklasse2020 => "agglomerationsgrossenklasse_2020",
                Field::StadtischerCharakter2020Code => "stadtischer_charakter_2020_code",
                Field::StadtischerCharakter2020 => "stadtischer_charakter_2020",
                Field::StatistischeStadt2020Code => "statistische_stadt_2020_code",
                Field::StatistischeStadt2020 => "statistische_stadt_2020",
                Field::StadtischLandlich2020Code => "stadtisch_landlich_2020_code",
                Field::StadtischLandlich2020 => "stadtisch_landlich_2020",
                Field::Gemeindetypologie20209Code => "gemeindetypologie_2020_9_code",
                Field::Gemeindetypologie20209 => "gemeindetypologie_2020_9",
                Field::Gemeindetypologie202025Code => "gemeindetypologie_2020_25_code",
                Field::Gemeindetypologie202025 => "gemeindetypologie_2020_25",
                Field::Arbeitsmarktgrossregion2018Code => "arbeitsmarktgrossregion_2018_code",
                Field::Arbeitsmarktgrossregion2018 => "arbeitsmarktgrossregion_2018",
                Field::Arbeitsmarktregion2018Code => "arbeitsmarktregion_2018_code",
                Field::Arbeitsmarktregion2018 => "arbeitsmarktregion_2018",
                Field::Berggebiet2019Code => "berggebiet_2019_code",
                Field::Berggebiet2019 => "berggebiet_2019",
                Field::Urbanisierungsgrad2011Code => "urbanisierungsgrad_2011_code",
                Field::Urbanisierungsgrad2011 => "urbanisierungsgrad_2011",
                Field::ErweiterteStadt2011Code => "erweiterte_stadt_2011_code",
                Field::ErweiterteStadt2011 => "erweiterte_stadt_2011",
                Field::FunktionalesStadtischesGebiet2014Code => {
                    "funktionales_stadtisches_gebiet_2014_code"
                }
                Field::FunktionalesStadtischesGebiet2014 => "funktionales_stadtisches_gebiet_2014",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10110/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerungsbestand nach Nationalität, Konfession, Gemeinde und Quartal (seit 2003)
pub mod bevoelkerungsbestand_nach_nationalitaet_konfession_gemeinde_und_quartal_seit_2003 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub quartal: Option<i64>,
        pub gemeinde_nummer: Option<String>,
        pub gemeinde: Option<String>,
        pub bezirk_nummer: Option<String>,
        pub bezirk: Option<String>,
        pub nationalitaet_code: Option<i64>,
        pub nationalitaet: Option<String>,
        pub konfession_code: Option<i64>,
        pub konfession: Option<String>,
        pub anzahl_personen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Quartal,
        GemeindeNummer,
        Gemeinde,
        BezirkNummer,
        Bezirk,
        NationalitaetCode,
        Nationalitaet,
        KonfessionCode,
        Konfession,
        AnzahlPersonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Quartal => "quartal",
                Field::GemeindeNummer => "gemeinde_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::NationalitaetCode => "nationalitaet_code",
                Field::Nationalitaet => "nationalitaet",
                Field::KonfessionCode => "konfession_code",
                Field::Konfession => "konfession",
                Field::AnzahlPersonen => "anzahl_personen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10020/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung des Umweltschutzgesetzes Basel-Landschaft betreffend Einführung kantonaler Deponieabgaben (Massnahme des Massnahmenpakets zur Förderung des Baustoffkreislaufs Regio Basel)
pub mod aenderung_des_umweltschutzgesetzes_basel_landschaft_betreffend_einfuehrung_kantonaler_deponieabgaben_massnahme_des_massnahmenpakets_zur_foerderung_des_baustoffkreislaufs_regio_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Abstimmungsdatum
        pub date: Option<String>,
        /// Gemeindenummer (BFS)
        pub entity_id: Option<String>,
        /// Gemeinde
        pub name: Option<String>,
        /// Stimmberechtigte total
        pub eligible_voters: Option<i64>,
        /// davon Stimmberechtigte Auslandschweizer/innen
        pub expats: Option<i64>,
        /// Leere Stimmen
        pub empty: Option<i64>,
        /// Ungültige Stimmen
        pub invalid: Option<i64>,
        /// Ja-Stimmen
        pub yeas: Option<i64>,
        /// Nein-Stimmen
        pub nays: Option<i64>,
        /// Ja-Stimmen (%)
        pub yeas_percent: Option<f64>,
        /// Nein-Stimmen (%)
        pub nays_percent: Option<f64>,
        /// title_de_CH
        ///
        /// Abstimmungstitel
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        YeasPercent,
        NaysPercent,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::YeasPercent => "yeas_percent",
                Field::NaysPercent => "nays_percent",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12330/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Finanzausgleich nach Gemeinde und Jahr (seit 2010)
pub mod finanzausgleich_nach_gemeinde_und_jahr_seit_2010 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10570/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeindefinanzen nach Rechnungsteil, Funktion, Kontenart und Jahr (seit 2014)
pub mod gemeindefinanzen_nach_rechnungsteil_funktion_kontenart_und_jahr_seit_2014 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Rechnungsteil
        pub rechnungsteil: Option<String>,
        /// Funktion_Nr
        pub funktion_nr: Option<String>,
        /// Funktion_Name
        pub funktion_name: Option<String>,
        /// Kontenart_aggregiert
        pub kontenart_aggregiert: Option<i64>,
        /// Kontenart_aggregiert_Name
        pub kontenart_aggregiert_name: Option<String>,
        /// Kontenart_Nr
        pub kontenart_nr: Option<String>,
        /// Kontenart_Name
        pub kontenart_name: Option<String>,
        /// Betrag_CHF
        pub betrag_chf: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Rechnungsteil,
        FunktionNr,
        FunktionName,
        KontenartAggregiert,
        KontenartAggregiertName,
        KontenartNr,
        KontenartName,
        BetragChf,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Rechnungsteil => "rechnungsteil",
                Field::FunktionNr => "funktion_nr",
                Field::FunktionName => "funktion_name",
                Field::KontenartAggregiert => "kontenart_aggregiert",
                Field::KontenartAggregiertName => "kontenart_aggregiert_name",
                Field::KontenartNr => "kontenart_nr",
                Field::KontenartName => "kontenart_name",
                Field::BetragChf => "betrag_chf",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10640/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Altersbetreuung: Versorgungsregionen
pub mod altersbetreuung_versorgungsregionen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Versorgungsregion_Code
        pub versorgung: Option<i64>,
        /// Versorgungsregion
        pub versorgu_1: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Versorgung,
        Versorgu1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Versorgung => "versorgung",
                Field::Versorgu1 => "versorgu_1",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10740/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Staatssteuern der natürlichen Personen nach Gemeinde und Jahr (seit 2013)
pub mod staatssteuern_der_natuerlichen_personen_nach_gemeinde_und_jahr_seit_2013 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10630/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung der Kantonsverfassung betreffend Einführung kantonaler Deponieabgaben (Massnahme des Massnahmenpakets zur Förderung des Baustoffkreislaufs Regio Basel)
pub mod aenderung_der_kantonsverfassung_betreffend_einfuehrung_kantonaler_deponieabgaben_massnahme_des_massnahmenpakets_zur_foerderung_des_baustoffkreislaufs_regio_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Abstimmungsdatum
        pub date: Option<String>,
        /// Gemeindenummer (BFS)
        pub entity_id: Option<String>,
        /// Gemeinde
        pub name: Option<String>,
        /// Stimmberechtigte total
        pub eligible_voters: Option<i64>,
        /// davon Stimmberechtigte Auslandschweizer/innen
        pub expats: Option<i64>,
        /// Leere Stimmen
        pub empty: Option<i64>,
        /// Ungültige Stimmen
        pub invalid: Option<i64>,
        /// Ja-Stimmen
        pub yeas: Option<i64>,
        /// Nein-Stimmen
        pub nays: Option<i64>,
        /// title_de_CH
        ///
        /// Abstimmungstitel
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12320/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Staatssteuern der natürlichen Personen nach Vermögensklasse und Jahr (seit 2013)
pub mod staatssteuern_der_natuerlichen_personen_nach_vermoegensklasse_und_jahr_seit_2013 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<i64>,
        /// Klasse_Steuerbares_Vermoegen_Code
        pub klasse_steuerbares_vermoegen_code: Option<f64>,
        /// Klasse_Steuerbares_Vermoegen_CHF
        pub klasse_steuerbares_vermoegen_chf: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        KlasseSteuerbaresVermoegenCode,
        KlasseSteuerbaresVermoegenChf,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::KlasseSteuerbaresVermoegenCode => "klasse_steuerbares_vermoegen_code",
                Field::KlasseSteuerbaresVermoegenChf => "klasse_steuerbares_vermoegen_chf",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10600/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Tägliche Spitalkapazität (März 2020 - Mai 2023)
pub mod covid_19_taegliche_spitalkapazitaet_maerz_2020_mai_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// geoRegion
        ///
        /// Kanton
        pub georegion: Option<String>,
        /// ICU_AllPatients
        ///
        /// Patienten Intensivstation
        pub icu_allpatients: Option<i64>,
        /// ICU_Covid19Patients
        ///
        /// Covid-19-Patienten
        pub icu_covid19patients: Option<i64>,
        /// ICU_Capacity
        ///
        /// Kapazität Intensivstation
        pub icu_capacity: Option<i64>,
        /// Total_AllPatients
        ///
        /// Total Patienten
        pub total_allpatients: Option<i64>,
        /// Total_Covid19Patients
        ///
        /// Total Covid-19-Patienten
        pub total_covid19patients: Option<i64>,
        /// Total_Capacity
        ///
        /// Total Kapazität
        pub total_capacity: Option<i64>,
        /// ICU_NonCovid19Patients
        ///
        /// Non-Covid-19-Patienten Intensivstation
        pub icu_noncovid19patients: Option<i64>,
        /// ICU_FreeCapacity
        ///
        /// Freie Kapazität Intensivstation
        pub icu_freecapacity: Option<i64>,
        /// Total_NonCovid19Patients
        ///
        /// Total Non-Covid-19-Patienten
        pub total_noncovid19patients: Option<i64>,
        /// Total_FreeCapacity
        ///
        /// Total Freie Kapazität
        pub total_freecapacity: Option<i64>,
        /// Typ_Variante
        pub type_variant: Option<String>,
        /// ICUPercent_AllPatients
        ///
        /// Anteil Patienten Intensivstation
        pub icupercent_allpatients: Option<f64>,
        /// ICUPercent_NonCovid19Patients
        ///
        /// Anteil Non-Covid-19-Patienten Intensivstation
        pub icupercent_noncovid19patients: Option<f64>,
        /// ICUPercent_Covid19Patients
        ///
        /// Anteil Covid-19-Patienten Intensivstation
        pub icupercent_covid19patients: Option<f64>,
        /// ICUPercent_FreeCapacity
        ///
        /// Anteil Freie Kapazität Intensivstation
        pub icupercent_freecapacity: Option<f64>,
        /// TotalPercent_AllPatients
        ///
        /// Total Auslastung
        pub totalpercent_allpatients: Option<f64>,
        /// TotalPercent_NonCovid19Patients
        ///
        /// Anteil Non-Covid-19-Patienten
        pub totalpercent_noncovid19patients: Option<f64>,
        /// TotalPercent_Covid19Patients
        ///
        /// Anteil Covid-19-Patienten
        pub totalpercent_covid19patients: Option<f64>,
        /// TotalPercent_FreeCapacity
        ///
        /// Anteil Freie Kapazität
        pub totalpercent_freecapacity: Option<f64>,
        /// Version
        pub version: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Georegion,
        IcuAllpatients,
        IcuCovid19patients,
        IcuCapacity,
        TotalAllpatients,
        TotalCovid19patients,
        TotalCapacity,
        IcuNoncovid19patients,
        IcuFreecapacity,
        TotalNoncovid19patients,
        TotalFreecapacity,
        TypeVariant,
        IcupercentAllpatients,
        IcupercentNoncovid19patients,
        IcupercentCovid19patients,
        IcupercentFreecapacity,
        TotalpercentAllpatients,
        TotalpercentNoncovid19patients,
        TotalpercentCovid19patients,
        TotalpercentFreecapacity,
        Version,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Georegion => "georegion",
                Field::IcuAllpatients => "icu_allpatients",
                Field::IcuCovid19patients => "icu_covid19patients",
                Field::IcuCapacity => "icu_capacity",
                Field::TotalAllpatients => "total_allpatients",
                Field::TotalCovid19patients => "total_covid19patients",
                Field::TotalCapacity => "total_capacity",
                Field::IcuNoncovid19patients => "icu_noncovid19patients",
                Field::IcuFreecapacity => "icu_freecapacity",
                Field::TotalNoncovid19patients => "total_noncovid19patients",
                Field::TotalFreecapacity => "total_freecapacity",
                Field::TypeVariant => "type_variant",
                Field::IcupercentAllpatients => "icupercent_allpatients",
                Field::IcupercentNoncovid19patients => "icupercent_noncovid19patients",
                Field::IcupercentCovid19patients => "icupercent_covid19patients",
                Field::IcupercentFreecapacity => "icupercent_freecapacity",
                Field::TotalpercentAllpatients => "totalpercent_allpatients",
                Field::TotalpercentNoncovid19patients => "totalpercent_noncovid19patients",
                Field::TotalpercentCovid19patients => "totalpercent_covid19patients",
                Field::TotalpercentFreecapacity => "totalpercent_freecapacity",
                Field::Version => "version",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10370/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Täglich geimpfte Personen nach Impfstoff und Typ der Impfung (Dezember 2020 - Mai 2023)
pub mod covid_19_taeglich_geimpfte_personen_nach_impfstoff_und_typ_der_impfung_dezember_2020_mai_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// geoRegion
        ///
        /// Kanton
        pub georegion: Option<String>,
        /// Impfstoff
        pub vaccine: Option<String>,
        /// Tägliche Impfungen
        pub entries: Option<i64>,
        /// Ständige Wohnbevölkerung 2020
        pub pop: Option<i64>,
        /// sumTotal
        ///
        /// Total Impfungen
        pub sumtotal: Option<i64>,
        /// per100Persons
        ///
        /// Tägliche Impfungen pro 100 Personen
        pub per100persons: Option<f64>,
        /// per100PersonsTotal
        ///
        /// Total Impfungen pro 100 Personen
        pub per100personstotal: Option<f64>,
        /// type
        ///
        /// Typ der Impfung
        pub r#type: Option<String>,
        /// Version
        pub version: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Georegion,
        Vaccine,
        Entries,
        Pop,
        Sumtotal,
        Per100persons,
        Per100personstotal,
        RType,
        Version,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Georegion => "georegion",
                Field::Vaccine => "vaccine",
                Field::Entries => "entries",
                Field::Pop => "pop",
                Field::Sumtotal => "sumtotal",
                Field::Per100persons => "per100persons",
                Field::Per100personstotal => "per100personstotal",
                Field::RType => "type",
                Field::Version => "version",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10390/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Erwerbstätige nach Wohngemeinde, Arbeitsort und Jahr (seit 2014)
pub mod erwerbstaetige_nach_wohngemeinde_arbeitsort_und_jahr_seit_2014 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Wohngemeinde
        pub wohngemeinde: Option<String>,
        /// Wohnbezirk_Code
        pub wohnbezirk_code: Option<String>,
        /// Wohnbezirk
        pub wohnbezirk: Option<String>,
        /// Arbeitsort
        pub arbeitsort: Option<String>,
        /// Kennzahl
        pub kennzahl: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Wohngemeinde,
        WohnbezirkCode,
        Wohnbezirk,
        Arbeitsort,
        Kennzahl,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Wohngemeinde => "wohngemeinde",
                Field::WohnbezirkCode => "wohnbezirk_code",
                Field::Wohnbezirk => "wohnbezirk",
                Field::Arbeitsort => "arbeitsort",
                Field::Kennzahl => "kennzahl",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10950/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Räumliche Grundlagedaten nach Gemeinde (Januar 2024)
pub mod raeumliche_grundlagedaten_nach_gemeinde_januar_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Nummer
        ///
        /// Gemeindenummer
        pub gmdnr: Option<String>,
        /// Gemeinde
        pub gmdname: Option<String>,
        /// AREA_HA
        pub area_ha: Option<i64>,
        /// E_MIN
        ///
        /// E-Koordinate Minimum
        pub e_min: Option<i64>,
        /// E_MAX
        ///
        /// E-Koordinate Maximum
        pub e_max: Option<i64>,
        /// N_MIN
        ///
        /// N-Koordinate Minimum
        pub n_min: Option<i64>,
        /// N_MAX
        ///
        /// N-Koordinate Maximum
        pub n_max: Option<i64>,
        /// E_CNTR
        ///
        /// E-Koordinate Zentrum
        pub e_cntr: Option<i64>,
        /// N_CNTR
        ///
        /// N-Koordinate Zentrum
        pub n_cntr: Option<i64>,
        /// Z_MIN
        ///
        /// Minimale Höhe über Meer
        pub z_min: Option<i64>,
        /// Z_MAX
        ///
        /// Maximale Höhe über Meer
        pub z_max: Option<i64>,
        /// Z_AVG
        ///
        /// Durchschnittliche Höhe über Meer
        pub z_avg: Option<i64>,
        /// Z_CNTR
        ///
        /// Zentrale Höhe über Meer
        pub z_cntr: Option<i64>,
        /// Zentrumskoordinaten
        pub zentrumskoordinaten: Option<GeoPoint2d>,
        /// Geometrie
        pub geometry: Option<GeoJson>,
        /// Geometrisches Zentrum
        pub centroid: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Gmdnr,
        Gmdname,
        AreaHa,
        EMin,
        EMax,
        NMin,
        NMax,
        ECntr,
        NCntr,
        ZMin,
        ZMax,
        ZAvg,
        ZCntr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Gmdnr => "gmdnr",
                Field::Gmdname => "gmdname",
                Field::AreaHa => "area_ha",
                Field::EMin => "e_min",
                Field::EMax => "e_max",
                Field::NMin => "n_min",
                Field::NMax => "n_max",
                Field::ECntr => "e_cntr",
                Field::NCntr => "n_cntr",
                Field::ZMin => "z_min",
                Field::ZMax => "z_max",
                Field::ZAvg => "z_avg",
                Field::ZCntr => "z_cntr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10100/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2015: Kandidierendenresultate, Wahlberechtigte und Listenstimmen
pub mod nationalratswahlen_2015_kandidierendenresultate_wahlberechtigte_und_listenstimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_gender: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_panachage_votes_from_list_01: Option<String>,
        pub candidate_panachage_votes_from_list_02: Option<i64>,
        pub candidate_panachage_votes_from_list_03: Option<i64>,
        pub candidate_panachage_votes_from_list_04: Option<String>,
        pub candidate_panachage_votes_from_list_05: Option<String>,
        pub candidate_panachage_votes_from_list_06: Option<String>,
        pub candidate_panachage_votes_from_list_07: Option<String>,
        pub candidate_panachage_votes_from_list_08: Option<i64>,
        pub candidate_panachage_votes_from_list_10: Option<String>,
        pub candidate_panachage_votes_from_list_11: Option<i64>,
        pub candidate_panachage_votes_from_list_14: Option<String>,
        pub candidate_panachage_votes_from_list_22: Option<String>,
        pub candidate_panachage_votes_from_list_34: Option<String>,
        pub candidate_panachage_votes_from_list_55: Option<String>,
        pub candidate_panachage_votes_from_list_70: Option<String>,
        pub candidate_panachage_votes_from_list_77: Option<String>,
        pub candidate_panachage_votes_from_list_999: Option<i64>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_connection: Option<i64>,
        pub list_connection_parent: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_panachage_votes_from_list_01: Option<i64>,
        pub list_panachage_votes_from_list_02: Option<i64>,
        pub list_panachage_votes_from_list_03: Option<i64>,
        pub list_panachage_votes_from_list_04: Option<i64>,
        pub list_panachage_votes_from_list_05: Option<i64>,
        pub list_panachage_votes_from_list_06: Option<i64>,
        pub list_panachage_votes_from_list_07: Option<i64>,
        pub list_panachage_votes_from_list_08: Option<String>,
        pub list_panachage_votes_from_list_10: Option<i64>,
        pub list_panachage_votes_from_list_11: Option<i64>,
        pub list_panachage_votes_from_list_14: Option<i64>,
        pub list_panachage_votes_from_list_22: Option<i64>,
        pub list_panachage_votes_from_list_34: Option<i64>,
        pub list_panachage_votes_from_list_55: Option<i64>,
        pub list_panachage_votes_from_list_70: Option<i64>,
        pub list_panachage_votes_from_list_77: Option<i64>,
        pub list_panachage_votes_from_list_999: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateGender,
        CandidateId,
        CandidatePanachageVotesFromList01,
        CandidatePanachageVotesFromList02,
        CandidatePanachageVotesFromList03,
        CandidatePanachageVotesFromList04,
        CandidatePanachageVotesFromList05,
        CandidatePanachageVotesFromList06,
        CandidatePanachageVotesFromList07,
        CandidatePanachageVotesFromList08,
        CandidatePanachageVotesFromList10,
        CandidatePanachageVotesFromList11,
        CandidatePanachageVotesFromList14,
        CandidatePanachageVotesFromList22,
        CandidatePanachageVotesFromList34,
        CandidatePanachageVotesFromList55,
        CandidatePanachageVotesFromList70,
        CandidatePanachageVotesFromList77,
        CandidatePanachageVotesFromList999,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListConnection,
        ListConnectionParent,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListPanachageVotesFromList01,
        ListPanachageVotesFromList02,
        ListPanachageVotesFromList03,
        ListPanachageVotesFromList04,
        ListPanachageVotesFromList05,
        ListPanachageVotesFromList06,
        ListPanachageVotesFromList07,
        ListPanachageVotesFromList08,
        ListPanachageVotesFromList10,
        ListPanachageVotesFromList11,
        ListPanachageVotesFromList14,
        ListPanachageVotesFromList22,
        ListPanachageVotesFromList34,
        ListPanachageVotesFromList55,
        ListPanachageVotesFromList70,
        ListPanachageVotesFromList77,
        ListPanachageVotesFromList999,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateGender => "candidate_gender",
                Field::CandidateId => "candidate_id",
                Field::CandidatePanachageVotesFromList01 => {
                    "candidate_panachage_votes_from_list_01"
                }
                Field::CandidatePanachageVotesFromList02 => {
                    "candidate_panachage_votes_from_list_02"
                }
                Field::CandidatePanachageVotesFromList03 => {
                    "candidate_panachage_votes_from_list_03"
                }
                Field::CandidatePanachageVotesFromList04 => {
                    "candidate_panachage_votes_from_list_04"
                }
                Field::CandidatePanachageVotesFromList05 => {
                    "candidate_panachage_votes_from_list_05"
                }
                Field::CandidatePanachageVotesFromList06 => {
                    "candidate_panachage_votes_from_list_06"
                }
                Field::CandidatePanachageVotesFromList07 => {
                    "candidate_panachage_votes_from_list_07"
                }
                Field::CandidatePanachageVotesFromList08 => {
                    "candidate_panachage_votes_from_list_08"
                }
                Field::CandidatePanachageVotesFromList10 => {
                    "candidate_panachage_votes_from_list_10"
                }
                Field::CandidatePanachageVotesFromList11 => {
                    "candidate_panachage_votes_from_list_11"
                }
                Field::CandidatePanachageVotesFromList14 => {
                    "candidate_panachage_votes_from_list_14"
                }
                Field::CandidatePanachageVotesFromList22 => {
                    "candidate_panachage_votes_from_list_22"
                }
                Field::CandidatePanachageVotesFromList34 => {
                    "candidate_panachage_votes_from_list_34"
                }
                Field::CandidatePanachageVotesFromList55 => {
                    "candidate_panachage_votes_from_list_55"
                }
                Field::CandidatePanachageVotesFromList70 => {
                    "candidate_panachage_votes_from_list_70"
                }
                Field::CandidatePanachageVotesFromList77 => {
                    "candidate_panachage_votes_from_list_77"
                }
                Field::CandidatePanachageVotesFromList999 => {
                    "candidate_panachage_votes_from_list_999"
                }
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListConnection => "list_connection",
                Field::ListConnectionParent => "list_connection_parent",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListPanachageVotesFromList01 => "list_panachage_votes_from_list_01",
                Field::ListPanachageVotesFromList02 => "list_panachage_votes_from_list_02",
                Field::ListPanachageVotesFromList03 => "list_panachage_votes_from_list_03",
                Field::ListPanachageVotesFromList04 => "list_panachage_votes_from_list_04",
                Field::ListPanachageVotesFromList05 => "list_panachage_votes_from_list_05",
                Field::ListPanachageVotesFromList06 => "list_panachage_votes_from_list_06",
                Field::ListPanachageVotesFromList07 => "list_panachage_votes_from_list_07",
                Field::ListPanachageVotesFromList08 => "list_panachage_votes_from_list_08",
                Field::ListPanachageVotesFromList10 => "list_panachage_votes_from_list_10",
                Field::ListPanachageVotesFromList11 => "list_panachage_votes_from_list_11",
                Field::ListPanachageVotesFromList14 => "list_panachage_votes_from_list_14",
                Field::ListPanachageVotesFromList22 => "list_panachage_votes_from_list_22",
                Field::ListPanachageVotesFromList34 => "list_panachage_votes_from_list_34",
                Field::ListPanachageVotesFromList55 => "list_panachage_votes_from_list_55",
                Field::ListPanachageVotesFromList70 => "list_panachage_votes_from_list_70",
                Field::ListPanachageVotesFromList77 => "list_panachage_votes_from_list_77",
                Field::ListPanachageVotesFromList999 => "list_panachage_votes_from_list_999",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11790/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Swisslos Sportfonds: Bilanz nach Gesuchsteller, Kategorie, Objekt und Jahr (seit 2011)
pub mod swisslos_sportfonds_bilanz_nach_gesuchsteller_kategorie_objekt_und_jahr_seit_2011 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Gesuchsteller
        pub gesuchsteller: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Objekt
        pub objekt: Option<String>,
        /// Ausbezahlter_Betrag_CHF
        pub ausbezahlter_betrag_chf: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Gesuchsteller,
        Kategorie,
        Objekt,
        AusbezahlterBetragChf,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Gesuchsteller => "gesuchsteller",
                Field::Kategorie => "kategorie",
                Field::Objekt => "objekt",
                Field::AusbezahlterBetragChf => "ausbezahlter_betrag_chf",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11450/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2023: Kandidierende nach Liste, Geschlecht, Jahrgang und Beruf
pub mod nationalratswahlen_2023_kandidierende_nach_liste_geschlecht_jahrgang_und_beruf {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahltermin
        pub wahltermin: Option<Date>,
        /// Anzahl_Sitze
        pub anzahl_sitze: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// Anzahl_leere_Linien
        pub anzahl_leere_linien: Option<i64>,
        /// HLV-Nr
        ///
        /// Nummer der Hauptlistenverbindung
        pub hlv_nr: Option<i64>,
        /// HLV-Bezeichnung
        ///
        /// Hauptlistenverbindung
        pub hlv_bezeichnung: Option<String>,
        /// ULV-Nr
        ///
        /// Nummer der Unterlistenverbindung (mit Bezug zur Hauptlistenverbindung eindeutig)
        pub ulv_nr: Option<i64>,
        /// ULV-Bezeichnung
        ///
        /// Unterlistenverbindung
        pub ulv_bezeichnung: Option<String>,
        /// Zeilen-Nr
        ///
        /// Zeilen-Nr. auf dem Wahlzettel
        pub zeilen_nr: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Kumulation
        pub kumulation: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Beruf_Tätigkeit
        pub beruf_tatigkeit: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Wohnort
        pub wohnort: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahltermin,
        AnzahlSitze,
        ListenNr,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlLeereLinien,
        HlvNr,
        HlvBezeichnung,
        UlvNr,
        UlvBezeichnung,
        ZeilenNr,
        KandidatenNr,
        Kumulation,
        Bisher,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Titel,
        BerufTatigkeit,
        Plz,
        Wohnort,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::ListenNr => "listen_nr",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlLeereLinien => "anzahl_leere_linien",
                Field::HlvNr => "hlv_nr",
                Field::HlvBezeichnung => "hlv_bezeichnung",
                Field::UlvNr => "ulv_nr",
                Field::UlvBezeichnung => "ulv_bezeichnung",
                Field::ZeilenNr => "zeilen_nr",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Titel => "titel",
                Field::BerufTatigkeit => "beruf_tatigkeit",
                Field::Plz => "plz",
                Field::Wohnort => "wohnort",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12190/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Staatssteuern der natürlichen Personen nach Einkommensklasse und Jahr (seit 2013)
pub mod staatssteuern_der_natuerlichen_personen_nach_einkommensklasse_und_jahr_seit_2013 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Klasse_Steuerbares_Einkommen_Code
        pub klasse_steuerbares_einkommen_code: Option<f64>,
        /// Klasse_Steuerbares_Einkommen_CHF
        pub klasse_steuerbares_einkommen_chf: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        KlasseSteuerbaresEinkommenCode,
        KlasseSteuerbaresEinkommenChf,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::KlasseSteuerbaresEinkommenCode => "klasse_steuerbares_einkommen_code",
                Field::KlasseSteuerbaresEinkommenChf => "klasse_steuerbares_einkommen_chf",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10590/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2015: Kandidierendenresultate
pub mod staenderatswahlen_2015_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11780/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// OGD-Portal: Tägliche Nutzung nach Datensatz (seit Januar 2024)
pub mod ogd_portal_taegliche_nutzung_nach_datensatz_seit_januar_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub dataset_id: Option<Date>,
        /// Datensatztitel
        pub date: Option<String>,
        /// Datensatz ID
        pub dataset_title: Option<String>,
        /// Visitors
        ///
        /// Unique IPs
        pub visitors: Option<i64>,
        /// Interactions
        ///
        /// API calls auf Datensätze
        pub interactions: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatasetId,
        Date,
        DatasetTitle,
        Visitors,
        Interactions,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatasetId => "dataset_id",
                Field::Date => "date",
                Field::DatasetTitle => "dataset_title",
                Field::Visitors => "visitors",
                Field::Interactions => "interactions",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12610/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2023: Kandidierendenresultate, Wahlberechtigte und Listenstimmen
pub mod nationalratswahlen_2023_kandidierendenresultate_wahlberechtigte_und_listenstimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_gender: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_panachage_votes_from_list_01: Option<i64>,
        pub candidate_panachage_votes_from_list_02: Option<i64>,
        pub candidate_panachage_votes_from_list_03: Option<i64>,
        pub candidate_panachage_votes_from_list_04: Option<i64>,
        pub candidate_panachage_votes_from_list_05: Option<i64>,
        pub candidate_panachage_votes_from_list_06: Option<i64>,
        pub candidate_panachage_votes_from_list_07: Option<i64>,
        pub candidate_panachage_votes_from_list_08: Option<i64>,
        pub candidate_panachage_votes_from_list_11: Option<i64>,
        pub candidate_panachage_votes_from_list_12: Option<i64>,
        pub candidate_panachage_votes_from_list_13: Option<i64>,
        pub candidate_panachage_votes_from_list_14: Option<i64>,
        pub candidate_panachage_votes_from_list_16: Option<i64>,
        pub candidate_panachage_votes_from_list_17: Option<i64>,
        pub candidate_panachage_votes_from_list_18: Option<i64>,
        pub candidate_panachage_votes_from_list_22: Option<i64>,
        pub candidate_panachage_votes_from_list_23: Option<i64>,
        pub candidate_panachage_votes_from_list_24: Option<i64>,
        pub candidate_panachage_votes_from_list_33: Option<i64>,
        pub candidate_panachage_votes_from_list_44: Option<i64>,
        pub candidate_panachage_votes_from_list_55: Option<i64>,
        pub candidate_panachage_votes_from_list_56: Option<i64>,
        pub candidate_panachage_votes_from_list_57: Option<i64>,
        pub candidate_panachage_votes_from_list_58: Option<i64>,
        pub candidate_panachage_votes_from_list_70: Option<i64>,
        pub candidate_panachage_votes_from_list_71: Option<i64>,
        pub candidate_panachage_votes_from_list_77: Option<i64>,
        pub candidate_panachage_votes_from_list_999: Option<i64>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<i64>,
        pub election_date: Option<Date>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_counted: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_connection: Option<i64>,
        pub list_connection_parent: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_panachage_votes_from_list_01: Option<i64>,
        pub list_panachage_votes_from_list_02: Option<i64>,
        pub list_panachage_votes_from_list_03: Option<i64>,
        pub list_panachage_votes_from_list_04: Option<i64>,
        pub list_panachage_votes_from_list_05: Option<i64>,
        pub list_panachage_votes_from_list_06: Option<i64>,
        pub list_panachage_votes_from_list_07: Option<i64>,
        pub list_panachage_votes_from_list_08: Option<i64>,
        pub list_panachage_votes_from_list_11: Option<i64>,
        pub list_panachage_votes_from_list_12: Option<i64>,
        pub list_panachage_votes_from_list_13: Option<i64>,
        pub list_panachage_votes_from_list_14: Option<i64>,
        pub list_panachage_votes_from_list_16: Option<i64>,
        pub list_panachage_votes_from_list_17: Option<i64>,
        pub list_panachage_votes_from_list_18: Option<i64>,
        pub list_panachage_votes_from_list_22: Option<i64>,
        pub list_panachage_votes_from_list_23: Option<i64>,
        pub list_panachage_votes_from_list_24: Option<i64>,
        pub list_panachage_votes_from_list_33: Option<i64>,
        pub list_panachage_votes_from_list_44: Option<i64>,
        pub list_panachage_votes_from_list_55: Option<i64>,
        pub list_panachage_votes_from_list_56: Option<i64>,
        pub list_panachage_votes_from_list_57: Option<i64>,
        pub list_panachage_votes_from_list_58: Option<i64>,
        pub list_panachage_votes_from_list_70: Option<i64>,
        pub list_panachage_votes_from_list_71: Option<i64>,
        pub list_panachage_votes_from_list_77: Option<i64>,
        pub list_panachage_votes_from_list_999: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateGender,
        CandidateId,
        CandidatePanachageVotesFromList01,
        CandidatePanachageVotesFromList02,
        CandidatePanachageVotesFromList03,
        CandidatePanachageVotesFromList04,
        CandidatePanachageVotesFromList05,
        CandidatePanachageVotesFromList06,
        CandidatePanachageVotesFromList07,
        CandidatePanachageVotesFromList08,
        CandidatePanachageVotesFromList11,
        CandidatePanachageVotesFromList12,
        CandidatePanachageVotesFromList13,
        CandidatePanachageVotesFromList14,
        CandidatePanachageVotesFromList16,
        CandidatePanachageVotesFromList17,
        CandidatePanachageVotesFromList18,
        CandidatePanachageVotesFromList22,
        CandidatePanachageVotesFromList23,
        CandidatePanachageVotesFromList24,
        CandidatePanachageVotesFromList33,
        CandidatePanachageVotesFromList44,
        CandidatePanachageVotesFromList55,
        CandidatePanachageVotesFromList56,
        CandidatePanachageVotesFromList57,
        CandidatePanachageVotesFromList58,
        CandidatePanachageVotesFromList70,
        CandidatePanachageVotesFromList71,
        CandidatePanachageVotesFromList77,
        CandidatePanachageVotesFromList999,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityCounted,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListConnection,
        ListConnectionParent,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListPanachageVotesFromList01,
        ListPanachageVotesFromList02,
        ListPanachageVotesFromList03,
        ListPanachageVotesFromList04,
        ListPanachageVotesFromList05,
        ListPanachageVotesFromList06,
        ListPanachageVotesFromList07,
        ListPanachageVotesFromList08,
        ListPanachageVotesFromList11,
        ListPanachageVotesFromList12,
        ListPanachageVotesFromList13,
        ListPanachageVotesFromList14,
        ListPanachageVotesFromList16,
        ListPanachageVotesFromList17,
        ListPanachageVotesFromList18,
        ListPanachageVotesFromList22,
        ListPanachageVotesFromList23,
        ListPanachageVotesFromList24,
        ListPanachageVotesFromList33,
        ListPanachageVotesFromList44,
        ListPanachageVotesFromList55,
        ListPanachageVotesFromList56,
        ListPanachageVotesFromList57,
        ListPanachageVotesFromList58,
        ListPanachageVotesFromList70,
        ListPanachageVotesFromList71,
        ListPanachageVotesFromList77,
        ListPanachageVotesFromList999,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateGender => "candidate_gender",
                Field::CandidateId => "candidate_id",
                Field::CandidatePanachageVotesFromList01 => {
                    "candidate_panachage_votes_from_list_01"
                }
                Field::CandidatePanachageVotesFromList02 => {
                    "candidate_panachage_votes_from_list_02"
                }
                Field::CandidatePanachageVotesFromList03 => {
                    "candidate_panachage_votes_from_list_03"
                }
                Field::CandidatePanachageVotesFromList04 => {
                    "candidate_panachage_votes_from_list_04"
                }
                Field::CandidatePanachageVotesFromList05 => {
                    "candidate_panachage_votes_from_list_05"
                }
                Field::CandidatePanachageVotesFromList06 => {
                    "candidate_panachage_votes_from_list_06"
                }
                Field::CandidatePanachageVotesFromList07 => {
                    "candidate_panachage_votes_from_list_07"
                }
                Field::CandidatePanachageVotesFromList08 => {
                    "candidate_panachage_votes_from_list_08"
                }
                Field::CandidatePanachageVotesFromList11 => {
                    "candidate_panachage_votes_from_list_11"
                }
                Field::CandidatePanachageVotesFromList12 => {
                    "candidate_panachage_votes_from_list_12"
                }
                Field::CandidatePanachageVotesFromList13 => {
                    "candidate_panachage_votes_from_list_13"
                }
                Field::CandidatePanachageVotesFromList14 => {
                    "candidate_panachage_votes_from_list_14"
                }
                Field::CandidatePanachageVotesFromList16 => {
                    "candidate_panachage_votes_from_list_16"
                }
                Field::CandidatePanachageVotesFromList17 => {
                    "candidate_panachage_votes_from_list_17"
                }
                Field::CandidatePanachageVotesFromList18 => {
                    "candidate_panachage_votes_from_list_18"
                }
                Field::CandidatePanachageVotesFromList22 => {
                    "candidate_panachage_votes_from_list_22"
                }
                Field::CandidatePanachageVotesFromList23 => {
                    "candidate_panachage_votes_from_list_23"
                }
                Field::CandidatePanachageVotesFromList24 => {
                    "candidate_panachage_votes_from_list_24"
                }
                Field::CandidatePanachageVotesFromList33 => {
                    "candidate_panachage_votes_from_list_33"
                }
                Field::CandidatePanachageVotesFromList44 => {
                    "candidate_panachage_votes_from_list_44"
                }
                Field::CandidatePanachageVotesFromList55 => {
                    "candidate_panachage_votes_from_list_55"
                }
                Field::CandidatePanachageVotesFromList56 => {
                    "candidate_panachage_votes_from_list_56"
                }
                Field::CandidatePanachageVotesFromList57 => {
                    "candidate_panachage_votes_from_list_57"
                }
                Field::CandidatePanachageVotesFromList58 => {
                    "candidate_panachage_votes_from_list_58"
                }
                Field::CandidatePanachageVotesFromList70 => {
                    "candidate_panachage_votes_from_list_70"
                }
                Field::CandidatePanachageVotesFromList71 => {
                    "candidate_panachage_votes_from_list_71"
                }
                Field::CandidatePanachageVotesFromList77 => {
                    "candidate_panachage_votes_from_list_77"
                }
                Field::CandidatePanachageVotesFromList999 => {
                    "candidate_panachage_votes_from_list_999"
                }
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityCounted => "entity_counted",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListConnection => "list_connection",
                Field::ListConnectionParent => "list_connection_parent",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListPanachageVotesFromList01 => "list_panachage_votes_from_list_01",
                Field::ListPanachageVotesFromList02 => "list_panachage_votes_from_list_02",
                Field::ListPanachageVotesFromList03 => "list_panachage_votes_from_list_03",
                Field::ListPanachageVotesFromList04 => "list_panachage_votes_from_list_04",
                Field::ListPanachageVotesFromList05 => "list_panachage_votes_from_list_05",
                Field::ListPanachageVotesFromList06 => "list_panachage_votes_from_list_06",
                Field::ListPanachageVotesFromList07 => "list_panachage_votes_from_list_07",
                Field::ListPanachageVotesFromList08 => "list_panachage_votes_from_list_08",
                Field::ListPanachageVotesFromList11 => "list_panachage_votes_from_list_11",
                Field::ListPanachageVotesFromList12 => "list_panachage_votes_from_list_12",
                Field::ListPanachageVotesFromList13 => "list_panachage_votes_from_list_13",
                Field::ListPanachageVotesFromList14 => "list_panachage_votes_from_list_14",
                Field::ListPanachageVotesFromList16 => "list_panachage_votes_from_list_16",
                Field::ListPanachageVotesFromList17 => "list_panachage_votes_from_list_17",
                Field::ListPanachageVotesFromList18 => "list_panachage_votes_from_list_18",
                Field::ListPanachageVotesFromList22 => "list_panachage_votes_from_list_22",
                Field::ListPanachageVotesFromList23 => "list_panachage_votes_from_list_23",
                Field::ListPanachageVotesFromList24 => "list_panachage_votes_from_list_24",
                Field::ListPanachageVotesFromList33 => "list_panachage_votes_from_list_33",
                Field::ListPanachageVotesFromList44 => "list_panachage_votes_from_list_44",
                Field::ListPanachageVotesFromList55 => "list_panachage_votes_from_list_55",
                Field::ListPanachageVotesFromList56 => "list_panachage_votes_from_list_56",
                Field::ListPanachageVotesFromList57 => "list_panachage_votes_from_list_57",
                Field::ListPanachageVotesFromList58 => "list_panachage_votes_from_list_58",
                Field::ListPanachageVotesFromList70 => "list_panachage_votes_from_list_70",
                Field::ListPanachageVotesFromList71 => "list_panachage_votes_from_list_71",
                Field::ListPanachageVotesFromList77 => "list_panachage_votes_from_list_77",
                Field::ListPanachageVotesFromList999 => "list_panachage_votes_from_list_999",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12270/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung vom 1. Oktober 2021 des Bundesgesetzes über die Transplantation von Organen, Geweben und ZeIlen
pub mod aenderung_vom_1_oktober_2021_des_bundesgesetzes_ueber_die_transplantation_von_organen_geweben_und_zeilen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<String>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10460/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Volksinitiative vom 28. Mai 2021 «Für ein besseres Leben im Alter (Initiative für eine 13. AHV-Rente)»
pub mod volksinitiative_vom_28_mai_2021_fuer_ein_besseres_leben_im_alter_initiative_fuer_eine_13_ahv_rente {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub answer: Option<String>,
        pub counted: Option<i64>,
        pub date: Option<String>,
        pub district: Option<String>,
        /// domain
        pub domain0: Option<String>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub expats: Option<i64>,
        pub empty: Option<i64>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        pub id: Option<String>,
        pub shortcode: Option<String>,
        pub status: Option<String>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        /// type
        pub r#type: Option<String>,
        pub ballot_answer: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Answer,
        Counted,
        Date,
        District,
        Domain0,
        EntityId,
        Name,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        Id,
        Shortcode,
        Status,
        TitleDeCh,
        RType,
        BallotAnswer,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Answer => "answer",
                Field::Counted => "counted",
                Field::Date => "date",
                Field::District => "district",
                Field::Domain0 => "domain0",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::Id => "id",
                Field::Shortcode => "shortcode",
                Field::Status => "status",
                Field::TitleDeCh => "title_de_ch",
                Field::RType => "type",
                Field::BallotAnswer => "ballot_answer",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12390/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratsnachwahl 2019: Kandidierendenresultate
pub mod staenderatsnachwahl_2019_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11760/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2023: Kandidierendenresultate
pub mod staenderatswahlen_2023_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<Date>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_counted: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityCounted,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityCounted => "entity_counted",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12280/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Adressen der Privatschulen (Juni 2024)
pub mod adressen_der_privatschulen_juni_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Schule_Code
        pub schule_code: Option<String>,
        /// Schule_Name
        pub schule_name: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Schulstufe
        pub schulstufe: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// E_Mail
        pub e_mail: Option<String>,
        /// URL
        pub url: Option<String>,
        pub e_eingangskoordinate: Option<i64>,
        pub n_eingangskoordinate: Option<i64>,
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsGemeindenummer,
        Gemeinde,
        SchuleCode,
        SchuleName,
        Adresse,
        Plz,
        Ort,
        Kategorie,
        Schulstufe,
        Telefon,
        EMail,
        Url,
        EEingangskoordinate,
        NEingangskoordinate,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::SchuleCode => "schule_code",
                Field::SchuleName => "schule_name",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kategorie => "kategorie",
                Field::Schulstufe => "schulstufe",
                Field::Telefon => "telefon",
                Field::EMail => "e_mail",
                Field::Url => "url",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11160/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Staatssteuern der juristischen Personen nach Gewinnklasse und Jahr (seit 2013)
pub mod staatssteuern_der_juristischen_personen_nach_gewinnklasse_und_jahr_seit_2013 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Klasse_Steuerbarer_Gewinn_Code
        pub klasse_steuerbarer_gewinn_code: Option<f64>,
        /// Klasse_Steuerbarer_Gewinn_CHF
        pub klasse_steuerbarer_gewinn_chf: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        KlasseSteuerbarerGewinnCode,
        KlasseSteuerbarerGewinnChf,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::KlasseSteuerbarerGewinnCode => "klasse_steuerbarer_gewinn_code",
                Field::KlasseSteuerbarerGewinnChf => "klasse_steuerbarer_gewinn_chf",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10610/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonales Gebäude- und Wohnungsregister (kGWR): Wohnungen
pub mod kantonales_gebaeude_und_wohnungsregister_kgwr_wohnungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<String>,
        /// Eidgenössischer Wohnungsidentifikator
        pub ewid: Option<i64>,
        pub gemeindenummer_bfs: Option<String>,
        pub gemeindename: Option<String>,
        /// EDID
        pub eidgenoessischer_eingangsidentifikator: Option<i64>,
        pub strassenbezeichnung: Option<String>,
        pub eingangsnummer_gebaeude: Option<String>,
        /// WHGNR
        pub administrative_wohnungsnummer: Option<String>,
        /// WEINR
        pub physische_wohnungsnummer: Option<String>,
        /// WSTWK
        pub stockwerk_code: Option<i64>,
        ///
        pub stockwerk_bezeichnung: Option<String>,
        /// WBEZ
        pub lage_auf_dem_stockwerk: Option<String>,
        /// WMEHRG
        pub mehrgeschossige_wohnung_code: Option<i64>,
        pub mehrgeschossige_wohnung_bezeichnung: Option<String>,
        /// WBAUJ
        pub baujahr_der_wohnung: Option<String>,
        pub abbruchjahr_der_wohnung: Option<i64>,
        /// WSTAT
        pub wohnungsstatus_code: Option<i64>,
        pub wohnungsstatus_bezeichnung: Option<String>,
        /// WAREA
        pub wohnungsflaeche: Option<i64>,
        /// WAZIM
        pub anzahl_zimmer: Option<i64>,
        /// WKCHE
        pub kocheinrichtung_code: Option<i64>,
        pub kocheinrichtung_bezeichnung: Option<String>,
        pub exportdatum: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Egid,
        Ewid,
        GemeindenummerBfs,
        Gemeindename,
        EidgenoessischerEingangsidentifikator,
        Strassenbezeichnung,
        EingangsnummerGebaeude,
        AdministrativeWohnungsnummer,
        PhysischeWohnungsnummer,
        StockwerkCode,
        StockwerkBezeichnung,
        LageAufDemStockwerk,
        MehrgeschossigeWohnungCode,
        MehrgeschossigeWohnungBezeichnung,
        BaujahrDerWohnung,
        AbbruchjahrDerWohnung,
        WohnungsstatusCode,
        WohnungsstatusBezeichnung,
        Wohnungsflaeche,
        AnzahlZimmer,
        KocheinrichtungCode,
        KocheinrichtungBezeichnung,
        Exportdatum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Ewid => "ewid",
                Field::GemeindenummerBfs => "gemeindenummer_bfs",
                Field::Gemeindename => "gemeindename",
                Field::EidgenoessischerEingangsidentifikator => {
                    "eidgenoessischer_eingangsidentifikator"
                }
                Field::Strassenbezeichnung => "strassenbezeichnung",
                Field::EingangsnummerGebaeude => "eingangsnummer_gebaeude",
                Field::AdministrativeWohnungsnummer => "administrative_wohnungsnummer",
                Field::PhysischeWohnungsnummer => "physische_wohnungsnummer",
                Field::StockwerkCode => "stockwerk_code",
                Field::StockwerkBezeichnung => "stockwerk_bezeichnung",
                Field::LageAufDemStockwerk => "lage_auf_dem_stockwerk",
                Field::MehrgeschossigeWohnungCode => "mehrgeschossige_wohnung_code",
                Field::MehrgeschossigeWohnungBezeichnung => "mehrgeschossige_wohnung_bezeichnung",
                Field::BaujahrDerWohnung => "baujahr_der_wohnung",
                Field::AbbruchjahrDerWohnung => "abbruchjahr_der_wohnung",
                Field::WohnungsstatusCode => "wohnungsstatus_code",
                Field::WohnungsstatusBezeichnung => "wohnungsstatus_bezeichnung",
                Field::Wohnungsflaeche => "wohnungsflaeche",
                Field::AnzahlZimmer => "anzahl_zimmer",
                Field::KocheinrichtungCode => "kocheinrichtung_code",
                Field::KocheinrichtungBezeichnung => "kocheinrichtung_bezeichnung",
                Field::Exportdatum => "exportdatum",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12170/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Firmenmutationen nach Rechtsform, NOGA-Einteilung und Gemeinde (seit Februar 2016)
pub mod firmenmutationen_nach_rechtsform_noga_einteilung_und_gemeinde_seit_februar_2016 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kategorie
        pub kategorie: Option<String>,
        /// Publikationsdatum im Schweizerischen Handelsamtsblatt
        pub publikationsdatum_shab: Option<Date>,
        /// Journaldatum im Handelsregister BL
        pub journaldatum_handelsregister: Option<Date>,
        /// Nummer im Schweizerischen Handelsamtsblatt
        pub id_shab: Option<i64>,
        /// BFS-Gemeindenummer des Firmensitzes zum Zeitpunkt der Mutation
        pub firmensitz_code: Option<String>,
        /// Gemeinde des Firmensitzes zum Zeitpunkt der Mutation
        pub firmensitz: Option<String>,
        /// Meldung
        pub meldung: Option<String>,
        /// Unternehmens-Identifikationsnummer
        pub uid: Option<String>,
        /// Name der Firma
        pub firmenname: Option<String>,
        /// Code der Rechtsform
        pub rechtsform_code: Option<String>,
        /// Rechtsform
        pub rechtsform: Option<String>,
        /// 6-stelliger NOGA-Code
        pub noga_code: Option<String>,
        /// NOGA-Art
        pub noga: Option<String>,
        /// 1-stelliger NOGA-Code
        pub noga_abschnitt_code: Option<String>,
        /// NOGA-Abschnitt
        pub noga_abschnitt: Option<String>,
        /// NOGA-Abteilung
        pub noga_abteilung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Kategorie,
        PublikationsdatumShab,
        JournaldatumHandelsregister,
        IdShab,
        FirmensitzCode,
        Firmensitz,
        Meldung,
        Uid,
        Firmenname,
        RechtsformCode,
        Rechtsform,
        NogaCode,
        Noga,
        NogaAbschnittCode,
        NogaAbschnitt,
        NogaAbteilung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Kategorie => "kategorie",
                Field::PublikationsdatumShab => "publikationsdatum_shab",
                Field::JournaldatumHandelsregister => "journaldatum_handelsregister",
                Field::IdShab => "id_shab",
                Field::FirmensitzCode => "firmensitz_code",
                Field::Firmensitz => "firmensitz",
                Field::Meldung => "meldung",
                Field::Uid => "uid",
                Field::Firmenname => "firmenname",
                Field::RechtsformCode => "rechtsform_code",
                Field::Rechtsform => "rechtsform",
                Field::NogaCode => "noga_code",
                Field::Noga => "noga",
                Field::NogaAbschnittCode => "noga_abschnitt_code",
                Field::NogaAbschnitt => "noga_abschnitt",
                Field::NogaAbteilung => "noga_abteilung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12460/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Staatssteuern der juristischen Personen nach Kapitalklasse und Jahr (seit 2013)
pub mod staatssteuern_der_juristischen_personen_nach_kapitalklasse_und_jahr_seit_2013 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Klasse_Steuerbares_Kapital_Code
        pub klasse_steuerbares_kapital_code: Option<f64>,
        /// Klasse_Steuerbares_Kapital_CHF
        pub klasse_steuerbares_kapital_chf: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        KlasseSteuerbaresKapitalCode,
        KlasseSteuerbaresKapitalChf,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::KlasseSteuerbaresKapitalCode => "klasse_steuerbares_kapital_code",
                Field::KlasseSteuerbaresKapitalChf => "klasse_steuerbares_kapital_chf",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10620/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Publikationsarchiv Amt für Daten und Statistik BL (seit 2000)
pub mod publikationsarchiv_amt_fuer_daten_und_statistik_bl_seit_2000 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationsdatum
        pub publikationsdatum: Option<Date>,
        /// Publikationsreihe
        pub publikationsreihe: Option<String>,
        /// Themenbereich
        pub themenbereich: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Untertitel
        pub untertitel: Option<String>,
        /// Link
        pub link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Publikationsdatum,
        Publikationsreihe,
        Themenbereich,
        Titel,
        Untertitel,
        Link,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Publikationsdatum => "publikationsdatum",
                Field::Publikationsreihe => "publikationsreihe",
                Field::Themenbereich => "themenbereich",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Link => "link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12570/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Steuerfüsse und Steuersätze nach Gemeinde und Jahr (seit 1975)
pub mod steuerfuesse_und_steuersaetze_nach_gemeinde_und_jahr_seit_1975 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10580/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Covid-19: Tägliche Hospitalisierungen (Februar 2020 - Januar 2023)
pub mod covid_19_taegliche_hospitalisierungen_februar_2020_januar_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// geoRegion
        ///
        /// Kanton
        pub georegion: Option<String>,
        /// Tägliche Hospitalisierungen
        pub entries: Option<i64>,
        /// sumTotal
        ///
        /// Total Hospitalisierungen
        pub sumtotal: Option<i64>,
        /// Version
        pub version: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Georegion,
        Entries,
        Sumtotal,
        Version,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Georegion => "georegion",
                Field::Entries => "entries",
                Field::Sumtotal => "sumtotal",
                Field::Version => "version",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10360/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerungsbilanz nach Gemeinde und Quartal (seit 2003)
pub mod bevoelkerungsbilanz_nach_gemeinde_und_quartal_seit_2003 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub quartal: Option<i64>,
        pub gemeinde_nummer: Option<String>,
        pub gemeinde: Option<String>,
        pub bezirk_nummer: Option<String>,
        pub bezirk: Option<String>,
        pub anfangsbestand: Option<i64>,
        pub geburten: Option<i64>,
        pub todesfaelle: Option<i64>,
        pub geburtenueberschuss: Option<i64>,
        pub zuzuege: Option<i64>,
        pub wegzuege: Option<i64>,
        pub wanderungssaldo: Option<i64>,
        pub bereinigung_saldo: Option<i64>,
        pub gesamtveraenderung: Option<i64>,
        pub endbestand: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Quartal,
        GemeindeNummer,
        Gemeinde,
        BezirkNummer,
        Bezirk,
        Anfangsbestand,
        Geburten,
        Todesfaelle,
        Geburtenueberschuss,
        Zuzuege,
        Wegzuege,
        Wanderungssaldo,
        BereinigungSaldo,
        Gesamtveraenderung,
        Endbestand,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Quartal => "quartal",
                Field::GemeindeNummer => "gemeinde_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::Anfangsbestand => "anfangsbestand",
                Field::Geburten => "geburten",
                Field::Todesfaelle => "todesfaelle",
                Field::Geburtenueberschuss => "geburtenueberschuss",
                Field::Zuzuege => "zuzuege",
                Field::Wegzuege => "wegzuege",
                Field::Wanderungssaldo => "wanderungssaldo",
                Field::BereinigungSaldo => "bereinigung_saldo",
                Field::Gesamtveraenderung => "gesamtveraenderung",
                Field::Endbestand => "endbestand",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10680/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Im kantonalen Personenregister abfrageberechtigte Stellen (Anmeldungs- und Registerverordnung)
pub mod im_kantonalen_personenregister_abfrageberechtigte_stellen_anmeldungs_und_registerverordnung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kürzel
        pub kurzel: Option<String>,
        /// Direktion
        pub direktion: Option<String>,
        /// Abfrageberechtigte Stelle
        pub abfrageberechtigte_stelle: Option<String>,
        /// Aufgabenbereich
        pub aufgabenbereich: Option<String>,
        /// RRB-Nr. (Neuzugriff)
        ///
        /// Nummer des Regierungsratsbeschlusses betreffend Einrichtung des neuen Zugriffs
        pub rrb_nr_neuzugriff: Option<String>,
        /// Beschluss (N)
        ///
        /// Datum des Regierungsratsbeschlusses betreffend Einrichtung des neuen Zugriffs
        pub beschluss_n: Option<Date>,
        /// GS-Nr. (N)
        ///
        /// Nummer in der Gesetzessammlung betreffend Einrichtung des neuen Zugriffs
        pub gs_nr_n: Option<String>,
        /// GS-Link (N)
        ///
        /// Link auf die Gesetzessammlung betreffend Einrichtung des neuen Zugriffs
        pub gs_link_n: Option<String>,
        /// Inkrafttreten (N)
        ///
        /// Rechtliches Inkrafttreten des neuen Zugriffs
        pub inkrafttreten_n: Option<Date>,
        /// RRB-Nr. (Änderungen)
        ///
        /// Nummer des Regierungsratsbeschlusses betreffend Änderungen des Zugriffs
        pub rrb_nr_anderungen: Option<String>,
        /// Beschluss (Ä)
        ///
        /// Datum des Regierungsratsbeschlusses betreffend Änderungen des Zugriffs
        pub beschluss_a: Option<String>,
        /// GS-Nr. (Ä)
        ///
        /// Nummer in der Gesetzessammlung betreffend Änderungen des Zugriffs
        pub gs_nr_a: Option<String>,
        /// Inkrafttreten (Ä)
        ///
        /// Rechtliches Inkrafttreten des geänderten Zugriffs
        pub inkrafttreten_a: Option<String>,
        /// Web-GUI
        ///
        /// Zugriff über Webapplikation (manuelle Einzelabfragen)
        pub web_gui: Option<String>,
        /// Webservice synchron
        ///
        /// Zugriff über Webservice (automatisierte Einzelabfragen)
        pub webservice_synchron: Option<String>,
        /// Webservice asynchron
        ///
        /// Zugriff über Webservice (automatisierte Massenabfragen)
        pub webservice_asynchron: Option<String>,
        /// Listen
        ///
        /// Periodischer Erhalt von csv-Listen (manuell exportiert durch Fachstelle Register)
        pub listen: Option<String>,
        /// Meldungen
        ///
        /// Laufender Erhalt einzelner Mutationsmeldungen (automatisiert nach eCH-0020)
        pub meldungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Kurzel,
        Direktion,
        AbfrageberechtigteStelle,
        Aufgabenbereich,
        RrbNrNeuzugriff,
        BeschlussN,
        GsNrN,
        GsLinkN,
        InkrafttretenN,
        RrbNrAnderungen,
        BeschlussA,
        GsNrA,
        InkrafttretenA,
        WebGui,
        WebserviceSynchron,
        WebserviceAsynchron,
        Listen,
        Meldungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Kurzel => "kurzel",
                Field::Direktion => "direktion",
                Field::AbfrageberechtigteStelle => "abfrageberechtigte_stelle",
                Field::Aufgabenbereich => "aufgabenbereich",
                Field::RrbNrNeuzugriff => "rrb_nr_neuzugriff",
                Field::BeschlussN => "beschluss_n",
                Field::GsNrN => "gs_nr_n",
                Field::GsLinkN => "gs_link_n",
                Field::InkrafttretenN => "inkrafttreten_n",
                Field::RrbNrAnderungen => "rrb_nr_anderungen",
                Field::BeschlussA => "beschluss_a",
                Field::GsNrA => "gs_nr_a",
                Field::InkrafttretenA => "inkrafttreten_a",
                Field::WebGui => "web_gui",
                Field::WebserviceSynchron => "webservice_synchron",
                Field::WebserviceAsynchron => "webservice_asynchron",
                Field::Listen => "listen",
                Field::Meldungen => "meldungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12200/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Motorfahrzeugbestand nach Fahrzeugart, Treibstoff, Gemeinde und Monat (seit Mai 2024)
pub mod motorfahrzeugbestand_nach_fahrzeugart_treibstoff_gemeinde_und_monat_seit_mai_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr_Monat
        pub jahr_monat: Option<Date>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Fahrzeugart
        pub fahrzeugart: Option<String>,
        /// Treibstoff
        pub treibstoff: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        JahrMonat,
        BfsGemeindenummer,
        Gemeinde,
        Fahrzeugart,
        Treibstoff,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::JahrMonat => "jahr_monat",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Fahrzeugart => "fahrzeugart",
                Field::Treibstoff => "treibstoff",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12410/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2011: Kandidierendenresultate, Wahlberechtigte und Listenstimmen
pub mod nationalratswahlen_2011_kandidierendenresultate_wahlberechtigte_und_listenstimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_panachage_votes_from_list_01: Option<i64>,
        pub candidate_panachage_votes_from_list_02: Option<i64>,
        pub candidate_panachage_votes_from_list_03: Option<i64>,
        pub candidate_panachage_votes_from_list_04: Option<String>,
        pub candidate_panachage_votes_from_list_05: Option<i64>,
        pub candidate_panachage_votes_from_list_06: Option<String>,
        pub candidate_panachage_votes_from_list_07: Option<String>,
        pub candidate_panachage_votes_from_list_08: Option<i64>,
        pub candidate_panachage_votes_from_list_09: Option<String>,
        pub candidate_panachage_votes_from_list_11: Option<String>,
        pub candidate_panachage_votes_from_list_22: Option<String>,
        pub candidate_panachage_votes_from_list_44: Option<String>,
        pub candidate_panachage_votes_from_list_55: Option<String>,
        pub candidate_panachage_votes_from_list_77: Option<String>,
        pub candidate_panachage_votes_from_list_999: Option<i64>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_connection: Option<i64>,
        pub list_connection_parent: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_panachage_votes_from_list_01: Option<i64>,
        pub list_panachage_votes_from_list_02: Option<i64>,
        pub list_panachage_votes_from_list_03: Option<i64>,
        pub list_panachage_votes_from_list_04: Option<i64>,
        pub list_panachage_votes_from_list_05: Option<i64>,
        pub list_panachage_votes_from_list_06: Option<i64>,
        pub list_panachage_votes_from_list_07: Option<i64>,
        pub list_panachage_votes_from_list_08: Option<String>,
        pub list_panachage_votes_from_list_09: Option<i64>,
        pub list_panachage_votes_from_list_11: Option<i64>,
        pub list_panachage_votes_from_list_22: Option<i64>,
        pub list_panachage_votes_from_list_44: Option<i64>,
        pub list_panachage_votes_from_list_55: Option<i64>,
        pub list_panachage_votes_from_list_77: Option<i64>,
        pub list_panachage_votes_from_list_999: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidatePanachageVotesFromList01,
        CandidatePanachageVotesFromList02,
        CandidatePanachageVotesFromList03,
        CandidatePanachageVotesFromList04,
        CandidatePanachageVotesFromList05,
        CandidatePanachageVotesFromList06,
        CandidatePanachageVotesFromList07,
        CandidatePanachageVotesFromList08,
        CandidatePanachageVotesFromList09,
        CandidatePanachageVotesFromList11,
        CandidatePanachageVotesFromList22,
        CandidatePanachageVotesFromList44,
        CandidatePanachageVotesFromList55,
        CandidatePanachageVotesFromList77,
        CandidatePanachageVotesFromList999,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListConnection,
        ListConnectionParent,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListPanachageVotesFromList01,
        ListPanachageVotesFromList02,
        ListPanachageVotesFromList03,
        ListPanachageVotesFromList04,
        ListPanachageVotesFromList05,
        ListPanachageVotesFromList06,
        ListPanachageVotesFromList07,
        ListPanachageVotesFromList08,
        ListPanachageVotesFromList09,
        ListPanachageVotesFromList11,
        ListPanachageVotesFromList22,
        ListPanachageVotesFromList44,
        ListPanachageVotesFromList55,
        ListPanachageVotesFromList77,
        ListPanachageVotesFromList999,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidatePanachageVotesFromList01 => {
                    "candidate_panachage_votes_from_list_01"
                }
                Field::CandidatePanachageVotesFromList02 => {
                    "candidate_panachage_votes_from_list_02"
                }
                Field::CandidatePanachageVotesFromList03 => {
                    "candidate_panachage_votes_from_list_03"
                }
                Field::CandidatePanachageVotesFromList04 => {
                    "candidate_panachage_votes_from_list_04"
                }
                Field::CandidatePanachageVotesFromList05 => {
                    "candidate_panachage_votes_from_list_05"
                }
                Field::CandidatePanachageVotesFromList06 => {
                    "candidate_panachage_votes_from_list_06"
                }
                Field::CandidatePanachageVotesFromList07 => {
                    "candidate_panachage_votes_from_list_07"
                }
                Field::CandidatePanachageVotesFromList08 => {
                    "candidate_panachage_votes_from_list_08"
                }
                Field::CandidatePanachageVotesFromList09 => {
                    "candidate_panachage_votes_from_list_09"
                }
                Field::CandidatePanachageVotesFromList11 => {
                    "candidate_panachage_votes_from_list_11"
                }
                Field::CandidatePanachageVotesFromList22 => {
                    "candidate_panachage_votes_from_list_22"
                }
                Field::CandidatePanachageVotesFromList44 => {
                    "candidate_panachage_votes_from_list_44"
                }
                Field::CandidatePanachageVotesFromList55 => {
                    "candidate_panachage_votes_from_list_55"
                }
                Field::CandidatePanachageVotesFromList77 => {
                    "candidate_panachage_votes_from_list_77"
                }
                Field::CandidatePanachageVotesFromList999 => {
                    "candidate_panachage_votes_from_list_999"
                }
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListConnection => "list_connection",
                Field::ListConnectionParent => "list_connection_parent",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListPanachageVotesFromList01 => "list_panachage_votes_from_list_01",
                Field::ListPanachageVotesFromList02 => "list_panachage_votes_from_list_02",
                Field::ListPanachageVotesFromList03 => "list_panachage_votes_from_list_03",
                Field::ListPanachageVotesFromList04 => "list_panachage_votes_from_list_04",
                Field::ListPanachageVotesFromList05 => "list_panachage_votes_from_list_05",
                Field::ListPanachageVotesFromList06 => "list_panachage_votes_from_list_06",
                Field::ListPanachageVotesFromList07 => "list_panachage_votes_from_list_07",
                Field::ListPanachageVotesFromList08 => "list_panachage_votes_from_list_08",
                Field::ListPanachageVotesFromList09 => "list_panachage_votes_from_list_09",
                Field::ListPanachageVotesFromList11 => "list_panachage_votes_from_list_11",
                Field::ListPanachageVotesFromList22 => "list_panachage_votes_from_list_22",
                Field::ListPanachageVotesFromList44 => "list_panachage_votes_from_list_44",
                Field::ListPanachageVotesFromList55 => "list_panachage_votes_from_list_55",
                Field::ListPanachageVotesFromList77 => "list_panachage_votes_from_list_77",
                Field::ListPanachageVotesFromList999 => "list_panachage_votes_from_list_999",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11830/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen: Wähleranteil, Anzahl Kandidierende, Anzahl Listen, Anzahl Gewählte nach Partei und Jahr (seit 1991)
pub mod nationalratswahlen_waehleranteil_anzahl_kandidierende_anzahl_listen_anzahl_gewaehlte_nach_partei_und_jahr_seit_1991 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub wahl_jahr: Option<String>,
        pub partei_id: Option<i64>,
        pub partei_bezeichnung_de: Option<String>,
        pub partei_staerke: Option<f64>,
        pub anzahl_listen: Option<i64>,
        pub anzahl_kandidierende: Option<i64>,
        pub anzahl_kandidierende_f: Option<i64>,
        pub anzahl_kandidierende_m: Option<i64>,
        pub anzahl_gewaehlte: Option<i64>,
        pub anzahl_gewaehlte_f: Option<i64>,
        pub anzahl_gewaehlte_m: Option<i64>,
        pub frauen_anteil: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahlJahr,
        ParteiId,
        ParteiBezeichnungDe,
        ParteiStaerke,
        AnzahlListen,
        AnzahlKandidierende,
        AnzahlKandidierendeF,
        AnzahlKandidierendeM,
        AnzahlGewaehlte,
        AnzahlGewaehlteF,
        AnzahlGewaehlteM,
        FrauenAnteil,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlJahr => "wahl_jahr",
                Field::ParteiId => "partei_id",
                Field::ParteiBezeichnungDe => "partei_bezeichnung_de",
                Field::ParteiStaerke => "partei_staerke",
                Field::AnzahlListen => "anzahl_listen",
                Field::AnzahlKandidierende => "anzahl_kandidierende",
                Field::AnzahlKandidierendeF => "anzahl_kandidierende_f",
                Field::AnzahlKandidierendeM => "anzahl_kandidierende_m",
                Field::AnzahlGewaehlte => "anzahl_gewaehlte",
                Field::AnzahlGewaehlteF => "anzahl_gewaehlte_f",
                Field::AnzahlGewaehlteM => "anzahl_gewaehlte_m",
                Field::FrauenAnteil => "frauen_anteil",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12290/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Shared Mobility Angebote nach Anbieter und Standort
pub mod shared_mobility_angebote_nach_anbieter_und_standort {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub coordinates: Option<GeoPoint2d>,
        pub station_id: Option<String>,
        pub provider_id: Option<String>,
        pub name: Option<String>,
        pub gemeinde: Option<String>,
        pub record_date: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        StationId,
        ProviderId,
        Name,
        Gemeinde,
        RecordDate,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::ProviderId => "provider_id",
                Field::Name => "name",
                Field::Gemeinde => "gemeinde",
                Field::RecordDate => "record_date",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10290/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Öffentlich zugängliche Gastwirtschaften nach Betriebsart und Standort (Februar 2024)
pub mod oeffentlich_zugaengliche_gastwirtschaften_nach_betriebsart_und_standort_februar_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Betriebsnummer
        pub betriebsnummer: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Betriebsart
        pub betriebsart: Option<String>,
        /// Post_Adresse
        pub post_adresse: Option<String>,
        /// PLZ_Ort
        pub plz_ort: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
        /// GWR_Adresse
        pub gwr_adresse: Option<String>,
        pub e_eingangskoordinate: Option<f64>,
        pub n_eingangskoordinate: Option<f64>,
        pub koordinaten: Option<GeoPoint2d>,
        pub egid: Option<i64>,
        pub baujahr_des_gebaeudes: Option<String>,
        pub name_des_gebaeudes: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Betriebsnummer,
        BfsGemeindenummer,
        Gemeinde,
        Name,
        Betriebsart,
        PostAdresse,
        PlzOrt,
        Bemerkung,
        GwrAdresse,
        EEingangskoordinate,
        NEingangskoordinate,
        Egid,
        BaujahrDesGebaeudes,
        NameDesGebaeudes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Betriebsnummer => "betriebsnummer",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Name => "name",
                Field::Betriebsart => "betriebsart",
                Field::PostAdresse => "post_adresse",
                Field::PlzOrt => "plz_ort",
                Field::Bemerkung => "bemerkung",
                Field::GwrAdresse => "gwr_adresse",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
                Field::Egid => "egid",
                Field::BaujahrDesGebaeudes => "baujahr_des_gebaeudes",
                Field::NameDesGebaeudes => "name_des_gebaeudes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10170/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Apotheken mit Betriebsbewilligung oder Impfberechtigung nach Standort (April 2024)
pub mod apotheken_mit_betriebsbewilligung_oder_impfberechtigung_nach_standort_april_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Firma
        pub firma: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// Herstellung
        pub herstellung: Option<String>,
        /// Impfen
        pub impfen: Option<String>,
        /// Vorname_Name
        pub vorname_name: Option<String>,
        pub e_eingangskoordinate: Option<i64>,
        pub n_eingangskoordinate: Option<i64>,
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Firma,
        Adresse,
        Plz,
        Ort,
        Telefon,
        Herstellung,
        Impfen,
        VornameName,
        EEingangskoordinate,
        NEingangskoordinate,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firma => "firma",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::Herstellung => "herstellung",
                Field::Impfen => "impfen",
                Field::VornameName => "vorname_name",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10320/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsratswahlen 2015: Kandidierendenresultate
pub mod regierungsratswahlen_2015_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11800/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Gemeinde und Jahr (1699 - 2000)
pub mod wohnbevoelkerung_nach_gemeinde_und_jahr_1699_2000 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// Datenquelle
        pub datenquelle: Option<String>,
        /// Bevölkerungsbegriff
        ///
        /// Bevölkerungsdefinition
        pub bevolkerungsbegriff: Option<String>,
        /// BFS_Gemeindenummer
        ///
        /// Gemeindenummer gemäss Bundesamt für Statistik (Jahr 2000)
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        ///
        /// Gemeindename
        pub gemeinde: Option<String>,
        /// Bezirk_historisch
        ///
        /// Historische Bezirkszugehörigkeit
        pub bezirk_historisch: Option<String>,
        /// Kanton_historisch
        ///
        /// Historische Kantonszugehörigkeit
        pub kanton_historisch: Option<String>,
        /// Bevölkerung_total
        ///
        /// Bevölkerung total
        pub bevolkerung_total: Option<i64>,
        /// Schweizer_innen
        ///
        /// davon Schweizer/innen
        pub schweizer_innen: Option<i64>,
        /// Ausländer_innen
        ///
        /// davon Ausländer/innen
        pub auslander_innen: Option<i64>,
        /// Männer
        ///
        /// davon männliches Geschlecht
        pub manner: Option<i64>,
        /// Frauen
        ///
        /// davon weibliches Geschlecht
        pub frauen: Option<i64>,
        /// Reformierte
        ///
        /// davon reformiert
        pub reformierte: Option<i64>,
        /// Katholische
        ///
        /// davon katholisch
        pub katholische: Option<i64>,
        /// Andere_Religion
        ///
        /// davon andere Religion/Konfession
        pub andere_religion: Option<i64>,
        /// Deutschsprachige
        ///
        /// davon Deutsch sprechende
        pub deutschsprachige: Option<i64>,
        /// Französischsprachige
        ///
        /// davon Französisch sprechende
        pub franzosischsprachige: Option<i64>,
        /// Italienischsprachige
        ///
        /// davon Italienisch sprechende
        pub italienischsprachige: Option<i64>,
        /// Rätoromanischsprachige
        ///
        /// davon Rätoromanisch sprechende
        pub ratoromanischsprachige: Option<i64>,
        /// Nichtlandessprache
        ///
        /// davon andere Sprachen sprechende
        pub nichtlandessprache: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Datenquelle,
        Bevolkerungsbegriff,
        BfsGemeindenummer,
        Gemeinde,
        BezirkHistorisch,
        KantonHistorisch,
        BevolkerungTotal,
        SchweizerInnen,
        AuslanderInnen,
        Manner,
        Frauen,
        Reformierte,
        Katholische,
        AndereReligion,
        Deutschsprachige,
        Franzosischsprachige,
        Italienischsprachige,
        Ratoromanischsprachige,
        Nichtlandessprache,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Datenquelle => "datenquelle",
                Field::Bevolkerungsbegriff => "bevolkerungsbegriff",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkHistorisch => "bezirk_historisch",
                Field::KantonHistorisch => "kanton_historisch",
                Field::BevolkerungTotal => "bevolkerung_total",
                Field::SchweizerInnen => "schweizer_innen",
                Field::AuslanderInnen => "auslander_innen",
                Field::Manner => "manner",
                Field::Frauen => "frauen",
                Field::Reformierte => "reformierte",
                Field::Katholische => "katholische",
                Field::AndereReligion => "andere_religion",
                Field::Deutschsprachige => "deutschsprachige",
                Field::Franzosischsprachige => "franzosischsprachige",
                Field::Italienischsprachige => "italienischsprachige",
                Field::Ratoromanischsprachige => "ratoromanischsprachige",
                Field::Nichtlandessprache => "nichtlandessprache",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12150/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Strompreise nach Netzbetreiber, Kategorie, Gemeinde und Jahr (seit 2018)
pub mod strompreise_nach_netzbetreiber_kategorie_gemeinde_und_jahr_seit_2018 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Verbrauchskategorie_Beschreibung
        pub verbrauchskategorie_beschreibung: Option<String>,
        /// Verbrauchskategorie
        pub verbrauchskategorie: Option<String>,
        /// Verteilnetzbetreiber
        pub verteilnetzbetreiber: Option<String>,
        /// UID_Verteilnetzbetreiber
        pub uid_verteilnetzbetreiber: Option<String>,
        /// Variable_Kosten_Rp_pro_kWh
        pub variable_kosten_rp_pro_kwh: Option<f64>,
        /// Fixe_Kosten_Rp_pro_Monat
        pub fixe_kosten_rp_pro_monat: Option<f64>,
        /// Typischer_Verbrauch_kWh_pro_Jahr
        pub typischer_verbrauch_kwh_pro_jahr: Option<i64>,
        /// Kosten_typischer_Verbrauch_CHF_pro_Monat
        pub kosten_typischer_verbrauch_chf_pro_monat: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Gemeinde,
        VerbrauchskategorieBeschreibung,
        Verbrauchskategorie,
        Verteilnetzbetreiber,
        UidVerteilnetzbetreiber,
        VariableKostenRpProKwh,
        FixeKostenRpProMonat,
        TypischerVerbrauchKwhProJahr,
        KostenTypischerVerbrauchChfProMonat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::VerbrauchskategorieBeschreibung => "verbrauchskategorie_beschreibung",
                Field::Verbrauchskategorie => "verbrauchskategorie",
                Field::Verteilnetzbetreiber => "verteilnetzbetreiber",
                Field::UidVerteilnetzbetreiber => "uid_verteilnetzbetreiber",
                Field::VariableKostenRpProKwh => "variable_kosten_rp_pro_kwh",
                Field::FixeKostenRpProMonat => "fixe_kosten_rp_pro_monat",
                Field::TypischerVerbrauchKwhProJahr => "typischer_verbrauch_kwh_pro_jahr",
                Field::KostenTypischerVerbrauchChfProMonat => {
                    "kosten_typischer_verbrauch_chf_pro_monat"
                }
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12340/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Änderung vom 1. Oktober 2021 des Bundesgesetzes über Filmproduktion und Filmkultur
pub mod aenderung_vom_1_oktober_2021_des_bundesgesetzes_ueber_filmproduktion_und_filmkultur {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub date: Option<Date>,
        pub entity_id: Option<String>,
        pub name: Option<String>,
        pub eligible_voters: Option<i64>,
        pub empty: Option<i64>,
        pub expats: Option<String>,
        pub invalid: Option<i64>,
        pub yeas: Option<i64>,
        pub nays: Option<i64>,
        /// title_de_CH
        pub title_de_ch: Option<String>,
        pub answer: Option<String>,
        pub ballot_answer: Option<String>,
        pub id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        EligibleVoters,
        Empty,
        Expats,
        Invalid,
        Yeas,
        Nays,
        TitleDeCh,
        Answer,
        BallotAnswer,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::EligibleVoters => "eligible_voters",
                Field::Empty => "empty",
                Field::Expats => "expats",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::TitleDeCh => "title_de_ch",
                Field::Answer => "answer",
                Field::BallotAnswer => "ballot_answer",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10450/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Sitzverlegungen und Domiziländerungen von Firmen nach Rechtsform, NOGA-Einteilung und Gemeinde (seit Februar 2016)
pub mod sitzverlegungen_und_domizilaenderungen_von_firmen_nach_rechtsform_noga_einteilung_und_gemeinde_seit_februar_2016 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kategorie
        pub kategorie: Option<String>,
        /// Publikationsdatum im Schweizerischen Handelsamtsblatt
        pub publikationsdatum_shab: Option<Date>,
        /// Journaldatum im Handelsregister BL
        pub journaldatum_handelsregister: Option<Date>,
        /// Nummer im Schweizerischen Handelsamtsblatt
        pub id_shab: Option<i64>,
        /// Aktuelle BFS-Gemeindenummer des Firmensitzes
        pub firmensitz_neu_code: Option<String>,
        /// Aktuelle Gemeinde des Firmensitzes
        pub firmensitz_neu: Option<String>,
        /// Aktueller Kanton
        pub firmensitz_neu_canton: Option<String>,
        /// Frühere BFS-Gemeindenummer des Firmensitzes
        pub firmensitz_bisher_code: Option<String>,
        /// Frühere Gemeinde des Firmensitzes
        pub firmensitz_bisher: Option<String>,
        /// Früherer Kanton
        pub firmensitz_bisher_canton: Option<String>,
        /// Meldung
        pub meldung: Option<String>,
        /// Unternehmens-Identifikationsnummer
        pub uid: Option<String>,
        /// Name der Firma
        pub firmenname: Option<String>,
        /// Code der Rechtsform
        pub rechtsform_code: Option<String>,
        /// Rechtsform
        pub rechtsform: Option<String>,
        /// 6-stelliger NOGA-Code
        pub noga_code: Option<String>,
        /// NOGA-Art
        pub noga: Option<String>,
        /// 1-stelliger NOGA-Code
        pub noga_abschnitt_code: Option<String>,
        /// NOGA-Abschnitt
        pub noga_abschnitt: Option<String>,
        /// NOGA-Abteilung
        pub noga_abteilung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Kategorie,
        PublikationsdatumShab,
        JournaldatumHandelsregister,
        IdShab,
        FirmensitzNeuCode,
        FirmensitzNeu,
        FirmensitzNeuCanton,
        FirmensitzBisherCode,
        FirmensitzBisher,
        FirmensitzBisherCanton,
        Meldung,
        Uid,
        Firmenname,
        RechtsformCode,
        Rechtsform,
        NogaCode,
        Noga,
        NogaAbschnittCode,
        NogaAbschnitt,
        NogaAbteilung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Kategorie => "kategorie",
                Field::PublikationsdatumShab => "publikationsdatum_shab",
                Field::JournaldatumHandelsregister => "journaldatum_handelsregister",
                Field::IdShab => "id_shab",
                Field::FirmensitzNeuCode => "firmensitz_neu_code",
                Field::FirmensitzNeu => "firmensitz_neu",
                Field::FirmensitzNeuCanton => "firmensitz_neu_canton",
                Field::FirmensitzBisherCode => "firmensitz_bisher_code",
                Field::FirmensitzBisher => "firmensitz_bisher",
                Field::FirmensitzBisherCanton => "firmensitz_bisher_canton",
                Field::Meldung => "meldung",
                Field::Uid => "uid",
                Field::Firmenname => "firmenname",
                Field::RechtsformCode => "rechtsform_code",
                Field::Rechtsform => "rechtsform",
                Field::NogaCode => "noga_code",
                Field::Noga => "noga",
                Field::NogaAbschnittCode => "noga_abschnitt_code",
                Field::NogaAbschnitt => "noga_abschnitt",
                Field::NogaAbteilung => "noga_abteilung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12470/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Mittlere Wohnbevölkerung nach Nationalität, Gemeinde und Jahr (seit 1980)
pub mod mittlere_wohnbevoelkerung_nach_nationalitaet_gemeinde_und_jahr_seit_1980 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub gemeinde_nummer: Option<String>,
        pub gemeinde: Option<String>,
        pub bfs_bezirk: Option<String>,
        pub bezirk: Option<String>,
        pub nationalitaet_code: Option<i64>,
        pub nationalitaet: Option<String>,
        pub anzahl_personen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        GemeindeNummer,
        Gemeinde,
        BfsBezirk,
        Bezirk,
        NationalitaetCode,
        Nationalitaet,
        AnzahlPersonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::GemeindeNummer => "gemeinde_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BfsBezirk => "bfs_bezirk",
                Field::Bezirk => "bezirk",
                Field::NationalitaetCode => "nationalitaet_code",
                Field::Nationalitaet => "nationalitaet",
                Field::AnzahlPersonen => "anzahl_personen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10080/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Haushalte nach Haushaltsgrösse, Gemeinde und Jahr (seit 2012)
pub mod haushalte_nach_haushaltsgroesse_gemeinde_und_jahr_seit_2012 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Haushaltgrösse
        pub haushaltgrosse: Option<String>,
        /// Wert
        pub wert: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Haushaltgrosse,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Haushaltgrosse => "haushaltgrosse",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10060/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2019: Kandidierendenresultate
pub mod staenderatswahlen_2019_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_id: Option<i64>,
        pub candidate_votes: Option<i64>,
        pub election_absolute_majority: Option<i64>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<String>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateId,
        CandidateVotes,
        ElectionAbsoluteMajority,
        ElectionDate,
        ElectionId,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateId => "candidate_id",
                Field::CandidateVotes => "candidate_votes",
                Field::ElectionAbsoluteMajority => "election_absolute_majority",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11730/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonales Gebäude- und Wohnungsregister (kGWR): Gebäudeadressen
pub mod kantonales_gebaeude_und_wohnungsregister_kgwr_gebaeudeadressen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<String>,
        pub gemeindenummer_bfs: Option<String>,
        pub gemeindename: Option<String>,
        /// EDID
        pub eidgenoessischer_eingangsidentifikator: Option<i64>,
        /// EGAID
        pub eidgenoessischer_gebaeudeadressidentifikator: Option<String>,
        /// DEINR
        pub eingangsnummer_gebaeude: Option<String>,
        /// ESID
        pub eidgenoessischer_strassenidentifikator: Option<String>,
        pub strassenbezeichnung: Option<String>,
        pub strassenbezeichnung_kurz: Option<String>,
        pub strassenbezeichnung_index: Option<String>,
        pub strassenbezeichnung_offiziell_code: Option<i64>,
        pub strassenbezeichnung_offiziell_bezeichnung: Option<String>,
        /// PLZ
        pub postleitzahl: Option<String>,
        pub postleitzahl_zusatzziffer: Option<String>,
        pub postleitzahl_name: Option<String>,
        pub e_eingangskoordinate: Option<f64>,
        pub n_eingangskoordinate: Option<f64>,
        pub offizielle_adresse_code: Option<i64>,
        pub offizielle_adresse_bezeichnung: Option<String>,
        pub exportdatum: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Egid,
        GemeindenummerBfs,
        Gemeindename,
        EidgenoessischerEingangsidentifikator,
        EidgenoessischerGebaeudeadressidentifikator,
        EingangsnummerGebaeude,
        EidgenoessischerStrassenidentifikator,
        Strassenbezeichnung,
        StrassenbezeichnungKurz,
        StrassenbezeichnungIndex,
        StrassenbezeichnungOffiziellCode,
        StrassenbezeichnungOffiziellBezeichnung,
        Postleitzahl,
        PostleitzahlZusatzziffer,
        PostleitzahlName,
        EEingangskoordinate,
        NEingangskoordinate,
        OffizielleAdresseCode,
        OffizielleAdresseBezeichnung,
        Exportdatum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::GemeindenummerBfs => "gemeindenummer_bfs",
                Field::Gemeindename => "gemeindename",
                Field::EidgenoessischerEingangsidentifikator => {
                    "eidgenoessischer_eingangsidentifikator"
                }
                Field::EidgenoessischerGebaeudeadressidentifikator => {
                    "eidgenoessischer_gebaeudeadressidentifikator"
                }
                Field::EingangsnummerGebaeude => "eingangsnummer_gebaeude",
                Field::EidgenoessischerStrassenidentifikator => {
                    "eidgenoessischer_strassenidentifikator"
                }
                Field::Strassenbezeichnung => "strassenbezeichnung",
                Field::StrassenbezeichnungKurz => "strassenbezeichnung_kurz",
                Field::StrassenbezeichnungIndex => "strassenbezeichnung_index",
                Field::StrassenbezeichnungOffiziellCode => "strassenbezeichnung_offiziell_code",
                Field::StrassenbezeichnungOffiziellBezeichnung => {
                    "strassenbezeichnung_offiziell_bezeichnung"
                }
                Field::Postleitzahl => "postleitzahl",
                Field::PostleitzahlZusatzziffer => "postleitzahl_zusatzziffer",
                Field::PostleitzahlName => "postleitzahl_name",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
                Field::OffizielleAdresseCode => "offizielle_adresse_code",
                Field::OffizielleAdresseBezeichnung => "offizielle_adresse_bezeichnung",
                Field::Exportdatum => "exportdatum",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12180/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahlen Gemeindekommissionen 2024: Kandidierendenresultate
pub mod wahlen_gemeindekommissionen_2024_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Stimmen
        pub stimmen: Option<i64>,
        /// Gewählt
        pub gewahlt: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        KandidatenNr,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Bisher,
        Stimmen,
        Gewahlt,
        Parteibezeichnung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Bisher => "bisher",
                Field::Stimmen => "stimmen",
                Field::Gewahlt => "gewahlt",
                Field::Parteibezeichnung => "parteibezeichnung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12380/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Adressen der Gemeindeverwaltungen (August 2024)
pub mod adressen_der_gemeindeverwaltungen_august_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Nummer
        ///
        /// BFS-Gemeindenummer
        pub bfs_nummer: Option<String>,
        /// Name
        ///
        /// Name der Gemeindeverwaltung
        pub name: Option<String>,
        /// Post_Adresse
        ///
        /// Post-Adresse
        pub post_adresse: Option<String>,
        /// PLZ_Ort
        ///
        /// Postleitzahl Ort
        pub plz_ort: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// Fax
        ///
        /// Faxnummer
        pub fax: Option<String>,
        /// E_Mail
        ///
        /// E-Mail-Adresse
        pub e_mail: Option<String>,
        /// Website
        pub website: Option<String>,
        /// GKODE
        ///
        /// Gebäudekoordinate Ost
        pub gkode: Option<f64>,
        /// GKODN
        ///
        /// Gebäudekoordinate Nord
        pub gkodn: Option<f64>,
        /// Koordinaten
        ///
        /// Koordinaten gemäss World Geodetic System 1984 (WGS84)
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsNummer,
        Name,
        PostAdresse,
        PlzOrt,
        Telefon,
        Fax,
        EMail,
        Website,
        Gkode,
        Gkodn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsNummer => "bfs_nummer",
                Field::Name => "name",
                Field::PostAdresse => "post_adresse",
                Field::PlzOrt => "plz_ort",
                Field::Telefon => "telefon",
                Field::Fax => "fax",
                Field::EMail => "e_mail",
                Field::Website => "website",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10510/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2023: Unveränderte und veränderte Wahlzettel nach Liste und Gemeinde
pub mod nationalratswahlen_2023_unveraenderte_und_veraenderte_wahlzettel_nach_liste_und_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<i64>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Listen_Nr
        pub listen_nr: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// Unveränderte_Wahlzettel_Liste
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte_Wahlzettel_Liste
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen_unveränderte_Wahlzettel
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen_unveränderte_Wahlzettel
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen_veränderte_Wahlzettel
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen_veränderte_Wahlzettel
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsGemeindenummer,
        Gemeinde,
        ListenNr,
        Parteibezeichnung,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::ListenNr => "listen_nr",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12300/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Lernende an Baselbieter Schulen nach Schulstufe und Geschlecht (seit 1986)
pub mod lernende_an_baselbieter_schulen_nach_schulstufe_und_geschlecht_seit_1986 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Schulstufe_grob_Code
        pub schulstufe_grob_code: Option<i64>,
        /// Schulstufe_grob
        pub schulstufe_grob: Option<String>,
        /// Schulstufe_mittel_Code
        pub schulstufe_mittel_code: Option<i64>,
        /// Schulstufe_mittel
        pub schulstufe_mittel: Option<String>,
        /// Schulstufe_fein_Code
        pub schulstufe_fein_code: Option<i64>,
        /// Schulstufe_fein
        pub schulstufe_fein: Option<String>,
        /// Geschlecht_Code
        pub geschlecht_code: Option<i64>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Indikator
        pub indikator: Option<String>,
        /// Wert
        pub wert: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        SchulstufeGrobCode,
        SchulstufeGrob,
        SchulstufeMittelCode,
        SchulstufeMittel,
        SchulstufeFeinCode,
        SchulstufeFein,
        GeschlechtCode,
        Geschlecht,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::SchulstufeGrobCode => "schulstufe_grob_code",
                Field::SchulstufeGrob => "schulstufe_grob",
                Field::SchulstufeMittelCode => "schulstufe_mittel_code",
                Field::SchulstufeMittel => "schulstufe_mittel",
                Field::SchulstufeFeinCode => "schulstufe_fein_code",
                Field::SchulstufeFein => "schulstufe_fein",
                Field::GeschlechtCode => "geschlecht_code",
                Field::Geschlecht => "geschlecht",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10410/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Arbeitsstätten und Beschäftigte nach Wirtschaftssektor, Gemeinde und Jahr (seit 2011)
pub mod arbeitsstaetten_und_beschaeftigte_nach_wirtschaftssektor_gemeinde_und_jahr_seit_2011 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeindename
        pub gemeindename: Option<String>,
        /// Wirtschaftssektor
        pub wirtschaftssektor: Option<String>,
        /// Arbeitsstätten
        pub arbeitsstatten: Option<i64>,
        /// Beschäftigte
        pub beschaftigte: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsGemeindenummer,
        Gemeindename,
        Wirtschaftssektor,
        Arbeitsstatten,
        Beschaftigte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeindename => "gemeindename",
                Field::Wirtschaftssektor => "wirtschaftssektor",
                Field::Arbeitsstatten => "arbeitsstatten",
                Field::Beschaftigte => "beschaftigte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10990/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Lernendenprognose nach Bildungsinstitution, Schulstufe und Klassentyp
pub mod lernendenprognose_nach_bildungsinstitution_schulstufe_und_klassentyp {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Bildungsinstitution_ID
        pub bildungsinstitution_id: Option<i64>,
        /// Bildungsinstitution
        pub bildungsinstitution: Option<String>,
        /// Schulstufe_Code
        pub schulstufe_code: Option<i64>,
        /// Schulstufe
        pub schulstufe: Option<String>,
        /// Klassentyp
        pub klassentyp: Option<String>,
        /// Anzahl_Lernende
        pub anzahl_lernende: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BildungsinstitutionId,
        Bildungsinstitution,
        SchulstufeCode,
        Schulstufe,
        Klassentyp,
        AnzahlLernende,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BildungsinstitutionId => "bildungsinstitution_id",
                Field::Bildungsinstitution => "bildungsinstitution",
                Field::SchulstufeCode => "schulstufe_code",
                Field::Schulstufe => "schulstufe",
                Field::Klassentyp => "klassentyp",
                Field::AnzahlLernende => "anzahl_lernende",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11010/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonales Gebäude- und Wohnungsregister (kGWR): Gebäude
pub mod kantonales_gebaeude_und_wohnungsregister_kgwr_gebaeude {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<String>,
        pub gemeindenummer_bfs: Option<String>,
        pub gemeindename: Option<String>,
        /// Eidgenössischer Grundstücksidentifikator
        pub egrid: Option<String>,
        /// grundstücksnummer
        ///
        /// LPARZ
        pub grundstucksnummer: Option<String>,
        /// GBEZ
        pub name_des_gebaeudes: Option<String>,
        pub e_gebaeudekoordinate: Option<f64>,
        pub n_gebaeudekoordinate: Option<f64>,
        pub koordinatenherkunft_code: Option<i64>,
        pub koordinatenherkunft_bezeichnung: Option<String>,
        /// GSTAT
        pub gebaeudestatus_code: Option<i64>,
        pub gebaeudestatus_bezeichnung: Option<String>,
        /// GKAT
        pub gebaeudekategorie_code: Option<i64>,
        pub gebaeudekategorie_bezeichnung: Option<String>,
        /// GKLAS
        pub gebaeudeklasse_code: Option<i64>,
        pub gebaeudeklasse_bezeichnung: Option<String>,
        /// GBAUJ
        pub baujahr_des_gebaeudes: Option<String>,
        /// GBAUM
        pub baumonat_des_gebaeudes: Option<i64>,
        /// GBAUP
        pub bauperiode_code: Option<i64>,
        pub bauperiode_bezeichnung: Option<String>,
        /// GABBJ
        pub abbruchjahr_des_gebaeudes: Option<i64>,
        /// GAREA
        pub gebaeudeflaeche: Option<i64>,
        /// GASTW
        pub anzahl_geschosse: Option<i64>,
        pub anzahl_separate_wohnraeume: Option<i64>,
        /// GVOL
        pub gebaeudevolumen: Option<i64>,
        pub gebaeudevolumen_norm_code: Option<i64>,
        pub gebaeudevolumen_norm_bezeichnung: Option<String>,
        pub informationsquelle_zum_gebaeudevolumen_code: Option<i64>,
        pub informationsquelle_zum_gebaeudevolumen_bezeichnung: Option<String>,
        /// GEBF
        pub energiebezugsflaeche: Option<i64>,
        /// GSCHUTZR
        pub zivilschutzraum_code: Option<i64>,
        pub zivilschutzraum_bezeichnung: Option<String>,
        /// GWAERZH1
        pub waermeerzeuger_heizung_primaer_code: Option<i64>,
        pub waermeerzeuger_heizung_primaer_bezeichnung: Option<String>,
        /// GENH1
        pub energie_waermequelle_heizung_primaer_code: Option<i64>,
        pub energie_waermequelle_heizung_primaer_bezeichnung: Option<String>,
        pub informationsquelle_heizung_primaer_code: Option<i64>,
        pub informationsquelle_heizung_primaer_bezeichnung: Option<String>,
        pub aktualisierungsdatum_heizung_primaer: Option<Date>,
        /// GWAERZH2
        pub waermeerzeuger_heizung_sekundaer_code: Option<i64>,
        pub waermeerzeuger_heizung_sekundaer_bezeichnung: Option<String>,
        /// GENH2
        pub energie_waermequelle_heizung_sekundaer_code: Option<i64>,
        pub energie_waermequelle_heizung_sekundaer_bezeichnung: Option<String>,
        pub informationsquelle_heizung_sekundaer_code: Option<i64>,
        pub informationsquelle_heizung_sekundaer_bezeichnung: Option<String>,
        pub aktualisierungsdatum_heizung_sekundaer: Option<Date>,
        /// GWAERZW1
        pub waermeerzeuger_warmwasser_primaer_code: Option<i64>,
        pub waermeerzeuger_warmwasser_primaer_bezeichnung: Option<String>,
        /// GENW1
        pub energie_waermequelle_warmwasser_primaer_code: Option<i64>,
        pub energie_waermequelle_warmwasser_primaer_bezeichnung: Option<String>,
        pub informationsquelle_warmwasser_primaer_code: Option<i64>,
        pub informationsquelle_warmwasser_primaer_bezeichnung: Option<String>,
        pub aktualisierungsdatum_warmwasser_primaer: Option<Date>,
        /// GWAERZW2
        pub waermeerzeuger_warmwasser_sekundaer_code: Option<i64>,
        pub waermeerzeuger_warmwasser_sekundaer_bezeichnung: Option<String>,
        /// GENW2
        pub energie_waermequelle_warmwasser_sekundaer_code: Option<i64>,
        pub energie_waermequelle_warmwasser_sekundaer_bezeichnung: Option<String>,
        pub informationsquelle_warmwasser_sekundaer_code: Option<i64>,
        pub informationsquelle_warmwasser_sekundaer_bezeichnung: Option<String>,
        pub aktualisierungsdatum_warmwasser_sekundaer: Option<Date>,
        pub photovoltaik: Option<String>,
        pub leistung_photovoltaik_kwp: Option<f64>,
        pub datenquelle_photovoltaik: Option<String>,
        pub exportdatum: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Egid,
        GemeindenummerBfs,
        Gemeindename,
        Egrid,
        Grundstucksnummer,
        NameDesGebaeudes,
        EGebaeudekoordinate,
        NGebaeudekoordinate,
        KoordinatenherkunftCode,
        KoordinatenherkunftBezeichnung,
        GebaeudestatusCode,
        GebaeudestatusBezeichnung,
        GebaeudekategorieCode,
        GebaeudekategorieBezeichnung,
        GebaeudeklasseCode,
        GebaeudeklasseBezeichnung,
        BaujahrDesGebaeudes,
        BaumonatDesGebaeudes,
        BauperiodeCode,
        BauperiodeBezeichnung,
        AbbruchjahrDesGebaeudes,
        Gebaeudeflaeche,
        AnzahlGeschosse,
        AnzahlSeparateWohnraeume,
        Gebaeudevolumen,
        GebaeudevolumenNormCode,
        GebaeudevolumenNormBezeichnung,
        InformationsquelleZumGebaeudevolumenCode,
        InformationsquelleZumGebaeudevolumenBezeichnung,
        Energiebezugsflaeche,
        ZivilschutzraumCode,
        ZivilschutzraumBezeichnung,
        WaermeerzeugerHeizungPrimaerCode,
        WaermeerzeugerHeizungPrimaerBezeichnung,
        EnergieWaermequelleHeizungPrimaerCode,
        EnergieWaermequelleHeizungPrimaerBezeichnung,
        InformationsquelleHeizungPrimaerCode,
        InformationsquelleHeizungPrimaerBezeichnung,
        AktualisierungsdatumHeizungPrimaer,
        WaermeerzeugerHeizungSekundaerCode,
        WaermeerzeugerHeizungSekundaerBezeichnung,
        EnergieWaermequelleHeizungSekundaerCode,
        EnergieWaermequelleHeizungSekundaerBezeichnung,
        InformationsquelleHeizungSekundaerCode,
        InformationsquelleHeizungSekundaerBezeichnung,
        AktualisierungsdatumHeizungSekundaer,
        WaermeerzeugerWarmwasserPrimaerCode,
        WaermeerzeugerWarmwasserPrimaerBezeichnung,
        EnergieWaermequelleWarmwasserPrimaerCode,
        EnergieWaermequelleWarmwasserPrimaerBezeichnung,
        InformationsquelleWarmwasserPrimaerCode,
        InformationsquelleWarmwasserPrimaerBezeichnung,
        AktualisierungsdatumWarmwasserPrimaer,
        WaermeerzeugerWarmwasserSekundaerCode,
        WaermeerzeugerWarmwasserSekundaerBezeichnung,
        EnergieWaermequelleWarmwasserSekundaerCode,
        EnergieWaermequelleWarmwasserSekundaerBezeichnung,
        InformationsquelleWarmwasserSekundaerCode,
        InformationsquelleWarmwasserSekundaerBezeichnung,
        AktualisierungsdatumWarmwasserSekundaer,
        Photovoltaik,
        LeistungPhotovoltaikKwp,
        DatenquellePhotovoltaik,
        Exportdatum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::GemeindenummerBfs => "gemeindenummer_bfs",
                Field::Gemeindename => "gemeindename",
                Field::Egrid => "egrid",
                Field::Grundstucksnummer => "grundstucksnummer",
                Field::NameDesGebaeudes => "name_des_gebaeudes",
                Field::EGebaeudekoordinate => "e_gebaeudekoordinate",
                Field::NGebaeudekoordinate => "n_gebaeudekoordinate",
                Field::KoordinatenherkunftCode => "koordinatenherkunft_code",
                Field::KoordinatenherkunftBezeichnung => "koordinatenherkunft_bezeichnung",
                Field::GebaeudestatusCode => "gebaeudestatus_code",
                Field::GebaeudestatusBezeichnung => "gebaeudestatus_bezeichnung",
                Field::GebaeudekategorieCode => "gebaeudekategorie_code",
                Field::GebaeudekategorieBezeichnung => "gebaeudekategorie_bezeichnung",
                Field::GebaeudeklasseCode => "gebaeudeklasse_code",
                Field::GebaeudeklasseBezeichnung => "gebaeudeklasse_bezeichnung",
                Field::BaujahrDesGebaeudes => "baujahr_des_gebaeudes",
                Field::BaumonatDesGebaeudes => "baumonat_des_gebaeudes",
                Field::BauperiodeCode => "bauperiode_code",
                Field::BauperiodeBezeichnung => "bauperiode_bezeichnung",
                Field::AbbruchjahrDesGebaeudes => "abbruchjahr_des_gebaeudes",
                Field::Gebaeudeflaeche => "gebaeudeflaeche",
                Field::AnzahlGeschosse => "anzahl_geschosse",
                Field::AnzahlSeparateWohnraeume => "anzahl_separate_wohnraeume",
                Field::Gebaeudevolumen => "gebaeudevolumen",
                Field::GebaeudevolumenNormCode => "gebaeudevolumen_norm_code",
                Field::GebaeudevolumenNormBezeichnung => "gebaeudevolumen_norm_bezeichnung",
                Field::InformationsquelleZumGebaeudevolumenCode => {
                    "informationsquelle_zum_gebaeudevolumen_code"
                }
                Field::InformationsquelleZumGebaeudevolumenBezeichnung => {
                    "informationsquelle_zum_gebaeudevolumen_bezeichnung"
                }
                Field::Energiebezugsflaeche => "energiebezugsflaeche",
                Field::ZivilschutzraumCode => "zivilschutzraum_code",
                Field::ZivilschutzraumBezeichnung => "zivilschutzraum_bezeichnung",
                Field::WaermeerzeugerHeizungPrimaerCode => "waermeerzeuger_heizung_primaer_code",
                Field::WaermeerzeugerHeizungPrimaerBezeichnung => {
                    "waermeerzeuger_heizung_primaer_bezeichnung"
                }
                Field::EnergieWaermequelleHeizungPrimaerCode => {
                    "energie_waermequelle_heizung_primaer_code"
                }
                Field::EnergieWaermequelleHeizungPrimaerBezeichnung => {
                    "energie_waermequelle_heizung_primaer_bezeichnung"
                }
                Field::InformationsquelleHeizungPrimaerCode => {
                    "informationsquelle_heizung_primaer_code"
                }
                Field::InformationsquelleHeizungPrimaerBezeichnung => {
                    "informationsquelle_heizung_primaer_bezeichnung"
                }
                Field::AktualisierungsdatumHeizungPrimaer => "aktualisierungsdatum_heizung_primaer",
                Field::WaermeerzeugerHeizungSekundaerCode => {
                    "waermeerzeuger_heizung_sekundaer_code"
                }
                Field::WaermeerzeugerHeizungSekundaerBezeichnung => {
                    "waermeerzeuger_heizung_sekundaer_bezeichnung"
                }
                Field::EnergieWaermequelleHeizungSekundaerCode => {
                    "energie_waermequelle_heizung_sekundaer_code"
                }
                Field::EnergieWaermequelleHeizungSekundaerBezeichnung => {
                    "energie_waermequelle_heizung_sekundaer_bezeichnung"
                }
                Field::InformationsquelleHeizungSekundaerCode => {
                    "informationsquelle_heizung_sekundaer_code"
                }
                Field::InformationsquelleHeizungSekundaerBezeichnung => {
                    "informationsquelle_heizung_sekundaer_bezeichnung"
                }
                Field::AktualisierungsdatumHeizungSekundaer => {
                    "aktualisierungsdatum_heizung_sekundaer"
                }
                Field::WaermeerzeugerWarmwasserPrimaerCode => {
                    "waermeerzeuger_warmwasser_primaer_code"
                }
                Field::WaermeerzeugerWarmwasserPrimaerBezeichnung => {
                    "waermeerzeuger_warmwasser_primaer_bezeichnung"
                }
                Field::EnergieWaermequelleWarmwasserPrimaerCode => {
                    "energie_waermequelle_warmwasser_primaer_code"
                }
                Field::EnergieWaermequelleWarmwasserPrimaerBezeichnung => {
                    "energie_waermequelle_warmwasser_primaer_bezeichnung"
                }
                Field::InformationsquelleWarmwasserPrimaerCode => {
                    "informationsquelle_warmwasser_primaer_code"
                }
                Field::InformationsquelleWarmwasserPrimaerBezeichnung => {
                    "informationsquelle_warmwasser_primaer_bezeichnung"
                }
                Field::AktualisierungsdatumWarmwasserPrimaer => {
                    "aktualisierungsdatum_warmwasser_primaer"
                }
                Field::WaermeerzeugerWarmwasserSekundaerCode => {
                    "waermeerzeuger_warmwasser_sekundaer_code"
                }
                Field::WaermeerzeugerWarmwasserSekundaerBezeichnung => {
                    "waermeerzeuger_warmwasser_sekundaer_bezeichnung"
                }
                Field::EnergieWaermequelleWarmwasserSekundaerCode => {
                    "energie_waermequelle_warmwasser_sekundaer_code"
                }
                Field::EnergieWaermequelleWarmwasserSekundaerBezeichnung => {
                    "energie_waermequelle_warmwasser_sekundaer_bezeichnung"
                }
                Field::InformationsquelleWarmwasserSekundaerCode => {
                    "informationsquelle_warmwasser_sekundaer_code"
                }
                Field::InformationsquelleWarmwasserSekundaerBezeichnung => {
                    "informationsquelle_warmwasser_sekundaer_bezeichnung"
                }
                Field::AktualisierungsdatumWarmwasserSekundaer => {
                    "aktualisierungsdatum_warmwasser_sekundaer"
                }
                Field::Photovoltaik => "photovoltaik",
                Field::LeistungPhotovoltaikKwp => "leistung_photovoltaik_kwp",
                Field::DatenquellePhotovoltaik => "datenquelle_photovoltaik",
                Field::Exportdatum => "exportdatum",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12160/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baugesuche und Baubewilligungen nach Gebäudeart, Gemeinde und Jahr (seit 1991/1992)
pub mod baugesuche_und_baubewilligungen_nach_gebaeudeart_gemeinde_und_jahr_seit_1991_1992 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Typ
        pub typ: Option<String>,
        /// Gebäudeart
        pub gebaudeart: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Typ,
        Gebaudeart,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Typ => "typ",
                Field::Gebaudeart => "gebaudeart",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10270/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2019: Kandidierendenresultate, Wahlberechtigte und Listenstimmen
pub mod nationalratswahlen_2019_kandidierendenresultate_wahlberechtigte_und_listenstimmen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub candidate_elected: Option<i64>,
        pub candidate_family_name: Option<String>,
        pub candidate_first_name: Option<String>,
        pub candidate_gender: Option<String>,
        pub candidate_id: Option<String>,
        pub candidate_panachage_votes_from_list_01: Option<String>,
        pub candidate_panachage_votes_from_list_02: Option<String>,
        pub candidate_panachage_votes_from_list_03: Option<String>,
        pub candidate_panachage_votes_from_list_04: Option<String>,
        pub candidate_panachage_votes_from_list_05: Option<String>,
        pub candidate_panachage_votes_from_list_06: Option<String>,
        pub candidate_panachage_votes_from_list_07: Option<String>,
        pub candidate_panachage_votes_from_list_08: Option<i64>,
        pub candidate_panachage_votes_from_list_11: Option<String>,
        pub candidate_panachage_votes_from_list_12: Option<String>,
        pub candidate_panachage_votes_from_list_13: Option<String>,
        pub candidate_panachage_votes_from_list_22: Option<String>,
        pub candidate_panachage_votes_from_list_23: Option<String>,
        pub candidate_panachage_votes_from_list_33: Option<String>,
        pub candidate_panachage_votes_from_list_34: Option<String>,
        pub candidate_panachage_votes_from_list_44: Option<String>,
        pub candidate_panachage_votes_from_list_55: Option<String>,
        pub candidate_panachage_votes_from_list_56: Option<String>,
        pub candidate_panachage_votes_from_list_70: Option<String>,
        pub candidate_panachage_votes_from_list_77: Option<String>,
        pub candidate_panachage_votes_from_list_999: Option<i64>,
        pub candidate_party: Option<String>,
        pub candidate_votes: Option<i64>,
        pub candidate_year_of_birth: Option<String>,
        pub election_date: Option<String>,
        pub election_id: Option<String>,
        pub election_mandates: Option<i64>,
        pub election_status: Option<String>,
        /// election_title_de_CH
        pub election_title_de_ch: Option<String>,
        pub entity_accounted_ballots: Option<i64>,
        pub entity_accounted_votes: Option<i64>,
        pub entity_blank_ballots: Option<i64>,
        pub entity_blank_votes: Option<i64>,
        pub entity_district: Option<String>,
        pub entity_eligible_voters: Option<i64>,
        pub entity_id: Option<i64>,
        pub entity_invalid_ballots: Option<i64>,
        pub entity_invalid_votes: Option<i64>,
        pub entity_name: Option<String>,
        pub entity_received_ballots: Option<i64>,
        pub entity_superregion: Option<String>,
        pub entity_unaccounted_ballots: Option<i64>,
        pub list_connection: Option<i64>,
        pub list_connection_parent: Option<i64>,
        pub list_id: Option<String>,
        pub list_name: Option<String>,
        pub list_number_of_mandates: Option<i64>,
        pub list_panachage_votes_from_list_01: Option<i64>,
        pub list_panachage_votes_from_list_02: Option<i64>,
        pub list_panachage_votes_from_list_03: Option<i64>,
        pub list_panachage_votes_from_list_04: Option<i64>,
        pub list_panachage_votes_from_list_05: Option<i64>,
        pub list_panachage_votes_from_list_06: Option<i64>,
        pub list_panachage_votes_from_list_07: Option<i64>,
        pub list_panachage_votes_from_list_08: Option<String>,
        pub list_panachage_votes_from_list_11: Option<i64>,
        pub list_panachage_votes_from_list_12: Option<i64>,
        pub list_panachage_votes_from_list_13: Option<i64>,
        pub list_panachage_votes_from_list_22: Option<i64>,
        pub list_panachage_votes_from_list_23: Option<i64>,
        pub list_panachage_votes_from_list_33: Option<i64>,
        pub list_panachage_votes_from_list_34: Option<String>,
        pub list_panachage_votes_from_list_44: Option<i64>,
        pub list_panachage_votes_from_list_55: Option<i64>,
        pub list_panachage_votes_from_list_56: Option<i64>,
        pub list_panachage_votes_from_list_70: Option<i64>,
        pub list_panachage_votes_from_list_77: Option<i64>,
        pub list_panachage_votes_from_list_999: Option<i64>,
        pub list_votes: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CandidateElected,
        CandidateFamilyName,
        CandidateFirstName,
        CandidateGender,
        CandidateId,
        CandidatePanachageVotesFromList01,
        CandidatePanachageVotesFromList02,
        CandidatePanachageVotesFromList03,
        CandidatePanachageVotesFromList04,
        CandidatePanachageVotesFromList05,
        CandidatePanachageVotesFromList06,
        CandidatePanachageVotesFromList07,
        CandidatePanachageVotesFromList08,
        CandidatePanachageVotesFromList11,
        CandidatePanachageVotesFromList12,
        CandidatePanachageVotesFromList13,
        CandidatePanachageVotesFromList22,
        CandidatePanachageVotesFromList23,
        CandidatePanachageVotesFromList33,
        CandidatePanachageVotesFromList34,
        CandidatePanachageVotesFromList44,
        CandidatePanachageVotesFromList55,
        CandidatePanachageVotesFromList56,
        CandidatePanachageVotesFromList70,
        CandidatePanachageVotesFromList77,
        CandidatePanachageVotesFromList999,
        CandidateParty,
        CandidateVotes,
        CandidateYearOfBirth,
        ElectionDate,
        ElectionId,
        ElectionMandates,
        ElectionStatus,
        ElectionTitleDeCh,
        EntityAccountedBallots,
        EntityAccountedVotes,
        EntityBlankBallots,
        EntityBlankVotes,
        EntityDistrict,
        EntityEligibleVoters,
        EntityId,
        EntityInvalidBallots,
        EntityInvalidVotes,
        EntityName,
        EntityReceivedBallots,
        EntitySuperregion,
        EntityUnaccountedBallots,
        ListConnection,
        ListConnectionParent,
        ListId,
        ListName,
        ListNumberOfMandates,
        ListPanachageVotesFromList01,
        ListPanachageVotesFromList02,
        ListPanachageVotesFromList03,
        ListPanachageVotesFromList04,
        ListPanachageVotesFromList05,
        ListPanachageVotesFromList06,
        ListPanachageVotesFromList07,
        ListPanachageVotesFromList08,
        ListPanachageVotesFromList11,
        ListPanachageVotesFromList12,
        ListPanachageVotesFromList13,
        ListPanachageVotesFromList22,
        ListPanachageVotesFromList23,
        ListPanachageVotesFromList33,
        ListPanachageVotesFromList34,
        ListPanachageVotesFromList44,
        ListPanachageVotesFromList55,
        ListPanachageVotesFromList56,
        ListPanachageVotesFromList70,
        ListPanachageVotesFromList77,
        ListPanachageVotesFromList999,
        ListVotes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CandidateElected => "candidate_elected",
                Field::CandidateFamilyName => "candidate_family_name",
                Field::CandidateFirstName => "candidate_first_name",
                Field::CandidateGender => "candidate_gender",
                Field::CandidateId => "candidate_id",
                Field::CandidatePanachageVotesFromList01 => {
                    "candidate_panachage_votes_from_list_01"
                }
                Field::CandidatePanachageVotesFromList02 => {
                    "candidate_panachage_votes_from_list_02"
                }
                Field::CandidatePanachageVotesFromList03 => {
                    "candidate_panachage_votes_from_list_03"
                }
                Field::CandidatePanachageVotesFromList04 => {
                    "candidate_panachage_votes_from_list_04"
                }
                Field::CandidatePanachageVotesFromList05 => {
                    "candidate_panachage_votes_from_list_05"
                }
                Field::CandidatePanachageVotesFromList06 => {
                    "candidate_panachage_votes_from_list_06"
                }
                Field::CandidatePanachageVotesFromList07 => {
                    "candidate_panachage_votes_from_list_07"
                }
                Field::CandidatePanachageVotesFromList08 => {
                    "candidate_panachage_votes_from_list_08"
                }
                Field::CandidatePanachageVotesFromList11 => {
                    "candidate_panachage_votes_from_list_11"
                }
                Field::CandidatePanachageVotesFromList12 => {
                    "candidate_panachage_votes_from_list_12"
                }
                Field::CandidatePanachageVotesFromList13 => {
                    "candidate_panachage_votes_from_list_13"
                }
                Field::CandidatePanachageVotesFromList22 => {
                    "candidate_panachage_votes_from_list_22"
                }
                Field::CandidatePanachageVotesFromList23 => {
                    "candidate_panachage_votes_from_list_23"
                }
                Field::CandidatePanachageVotesFromList33 => {
                    "candidate_panachage_votes_from_list_33"
                }
                Field::CandidatePanachageVotesFromList34 => {
                    "candidate_panachage_votes_from_list_34"
                }
                Field::CandidatePanachageVotesFromList44 => {
                    "candidate_panachage_votes_from_list_44"
                }
                Field::CandidatePanachageVotesFromList55 => {
                    "candidate_panachage_votes_from_list_55"
                }
                Field::CandidatePanachageVotesFromList56 => {
                    "candidate_panachage_votes_from_list_56"
                }
                Field::CandidatePanachageVotesFromList70 => {
                    "candidate_panachage_votes_from_list_70"
                }
                Field::CandidatePanachageVotesFromList77 => {
                    "candidate_panachage_votes_from_list_77"
                }
                Field::CandidatePanachageVotesFromList999 => {
                    "candidate_panachage_votes_from_list_999"
                }
                Field::CandidateParty => "candidate_party",
                Field::CandidateVotes => "candidate_votes",
                Field::CandidateYearOfBirth => "candidate_year_of_birth",
                Field::ElectionDate => "election_date",
                Field::ElectionId => "election_id",
                Field::ElectionMandates => "election_mandates",
                Field::ElectionStatus => "election_status",
                Field::ElectionTitleDeCh => "election_title_de_ch",
                Field::EntityAccountedBallots => "entity_accounted_ballots",
                Field::EntityAccountedVotes => "entity_accounted_votes",
                Field::EntityBlankBallots => "entity_blank_ballots",
                Field::EntityBlankVotes => "entity_blank_votes",
                Field::EntityDistrict => "entity_district",
                Field::EntityEligibleVoters => "entity_eligible_voters",
                Field::EntityId => "entity_id",
                Field::EntityInvalidBallots => "entity_invalid_ballots",
                Field::EntityInvalidVotes => "entity_invalid_votes",
                Field::EntityName => "entity_name",
                Field::EntityReceivedBallots => "entity_received_ballots",
                Field::EntitySuperregion => "entity_superregion",
                Field::EntityUnaccountedBallots => "entity_unaccounted_ballots",
                Field::ListConnection => "list_connection",
                Field::ListConnectionParent => "list_connection_parent",
                Field::ListId => "list_id",
                Field::ListName => "list_name",
                Field::ListNumberOfMandates => "list_number_of_mandates",
                Field::ListPanachageVotesFromList01 => "list_panachage_votes_from_list_01",
                Field::ListPanachageVotesFromList02 => "list_panachage_votes_from_list_02",
                Field::ListPanachageVotesFromList03 => "list_panachage_votes_from_list_03",
                Field::ListPanachageVotesFromList04 => "list_panachage_votes_from_list_04",
                Field::ListPanachageVotesFromList05 => "list_panachage_votes_from_list_05",
                Field::ListPanachageVotesFromList06 => "list_panachage_votes_from_list_06",
                Field::ListPanachageVotesFromList07 => "list_panachage_votes_from_list_07",
                Field::ListPanachageVotesFromList08 => "list_panachage_votes_from_list_08",
                Field::ListPanachageVotesFromList11 => "list_panachage_votes_from_list_11",
                Field::ListPanachageVotesFromList12 => "list_panachage_votes_from_list_12",
                Field::ListPanachageVotesFromList13 => "list_panachage_votes_from_list_13",
                Field::ListPanachageVotesFromList22 => "list_panachage_votes_from_list_22",
                Field::ListPanachageVotesFromList23 => "list_panachage_votes_from_list_23",
                Field::ListPanachageVotesFromList33 => "list_panachage_votes_from_list_33",
                Field::ListPanachageVotesFromList34 => "list_panachage_votes_from_list_34",
                Field::ListPanachageVotesFromList44 => "list_panachage_votes_from_list_44",
                Field::ListPanachageVotesFromList55 => "list_panachage_votes_from_list_55",
                Field::ListPanachageVotesFromList56 => "list_panachage_votes_from_list_56",
                Field::ListPanachageVotesFromList70 => "list_panachage_votes_from_list_70",
                Field::ListPanachageVotesFromList77 => "list_panachage_votes_from_list_77",
                Field::ListPanachageVotesFromList999 => "list_panachage_votes_from_list_999",
                Field::ListVotes => "list_votes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11740/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Leerwohnungsziffer nach Zimmerzahl, Gemeinde und Jahr (seit 2002)
pub mod leerwohnungsziffer_nach_zimmerzahl_gemeinde_und_jahr_seit_2002 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Zimmerzahl
        pub zimmerzahl: Option<String>,
        /// Leerwohnungsziffer
        pub leerwohnungsziffer: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Zimmerzahl,
        Leerwohnungsziffer,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Zimmerzahl => "zimmerzahl",
                Field::Leerwohnungsziffer => "leerwohnungsziffer",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10260/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerungsbestand nach Geschlecht, Alter, Gemeinde und Jahr (seit 2003)
pub mod bevoelkerungsbestand_nach_geschlecht_alter_gemeinde_und_jahr_seit_2003 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub gemeinde_nummer: Option<String>,
        pub gemeinde: Option<String>,
        pub bezirk_nummer: Option<String>,
        pub bezirk: Option<String>,
        pub versorgungsregion_code: Option<i64>,
        pub versorgungsregion: Option<String>,
        pub versorgungsregion_aggregiert_code: Option<i64>,
        pub versorgungsregion_aggregiert: Option<String>,
        pub geschlecht_code: Option<i64>,
        pub geschlecht: Option<String>,
        pub altersjahr_100_plus: Option<i64>,
        pub altersklasse_5_jahre_code: Option<i64>,
        pub altersklasse_5_jahre: Option<String>,
        pub anzahl_personen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        GemeindeNummer,
        Gemeinde,
        BezirkNummer,
        Bezirk,
        VersorgungsregionCode,
        Versorgungsregion,
        VersorgungsregionAggregiertCode,
        VersorgungsregionAggregiert,
        GeschlechtCode,
        Geschlecht,
        Altersjahr100Plus,
        Altersklasse5JahreCode,
        Altersklasse5Jahre,
        AnzahlPersonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::GemeindeNummer => "gemeinde_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::VersorgungsregionCode => "versorgungsregion_code",
                Field::Versorgungsregion => "versorgungsregion",
                Field::VersorgungsregionAggregiertCode => "versorgungsregion_aggregiert_code",
                Field::VersorgungsregionAggregiert => "versorgungsregion_aggregiert",
                Field::GeschlechtCode => "geschlecht_code",
                Field::Geschlecht => "geschlecht",
                Field::Altersjahr100Plus => "altersjahr_100_plus",
                Field::Altersklasse5JahreCode => "altersklasse_5_jahre_code",
                Field::Altersklasse5Jahre => "altersklasse_5_jahre",
                Field::AnzahlPersonen => "anzahl_personen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10010/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Leerwohnungsbestand nach Zimmerzahl, Gemeinde und Jahr (seit 2002)
pub mod leerwohnungsbestand_nach_zimmerzahl_gemeinde_und_jahr_seit_2002 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Zimmerzahl
        pub zimmerzahl: Option<String>,
        /// Leer_stehende_Wohnungen
        pub leer_stehende_wohnungen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        Zimmerzahl,
        LeerStehendeWohnungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::Zimmerzahl => "zimmerzahl",
                Field::LeerStehendeWohnungen => "leer_stehende_wohnungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10250/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Neu erstellte Wohnungen nach Gemeinde und Jahr (seit 1994)
pub mod neu_erstellte_wohnungen_nach_gemeinde_und_jahr_seit_1994 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Neu_erstellte_Wohnungen
        pub neu_erstellte_wohnungen: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Gemeinde,
        NeuErstellteWohnungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::NeuErstellteWohnungen => "neu_erstellte_wohnungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10230/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// CO2-Emissionen nach Energieträger, Gemeinde und Jahr (seit 2018)
pub mod co2_emissionen_nach_energietraeger_gemeinde_und_jahr_seit_2018 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub erhebungsjahr: Option<String>,
        pub bfs_gemeindenummer: Option<String>,
        pub gemeinde: Option<String>,
        pub energietraeger_bezeichnung: Option<String>,
        pub co2_absolut_tonnen: Option<f64>,
        pub co2_kg_pro_person: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Erhebungsjahr,
        BfsGemeindenummer,
        Gemeinde,
        EnergietraegerBezeichnung,
        Co2AbsolutTonnen,
        Co2KgProPerson,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Erhebungsjahr => "erhebungsjahr",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::EnergietraegerBezeichnung => "energietraeger_bezeichnung",
                Field::Co2AbsolutTonnen => "co2_absolut_tonnen",
                Field::Co2KgProPerson => "co2_kg_pro_person",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12020/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Lernende mit Wohnkanton BL an Schulen in der Schweiz nach Schulstufe, Geschlecht, Wohngemeinde und Jahr (seit 2014)
pub mod lernende_mit_wohnkanton_bl_an_schulen_in_der_schweiz_nach_schulstufe_geschlecht_wohngemeinde_und_jahr_seit_2014 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub bfs_nummer: Option<String>,
        pub wohngemeinde: Option<String>,
        pub schulstufe_grob_code: Option<i64>,
        pub schulstufe_grob: Option<String>,
        pub schulstufe_mittel_code: Option<i64>,
        pub schulstufe_mittel: Option<String>,
        pub schulstufe_fein_code: Option<i64>,
        pub schulstufe_fein: Option<String>,
        pub geschlecht_code: Option<i64>,
        pub geschlecht: Option<String>,
        pub indikator: Option<String>,
        pub wert: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        BfsNummer,
        Wohngemeinde,
        SchulstufeGrobCode,
        SchulstufeGrob,
        SchulstufeMittelCode,
        SchulstufeMittel,
        SchulstufeFeinCode,
        SchulstufeFein,
        GeschlechtCode,
        Geschlecht,
        Indikator,
        Wert,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::BfsNummer => "bfs_nummer",
                Field::Wohngemeinde => "wohngemeinde",
                Field::SchulstufeGrobCode => "schulstufe_grob_code",
                Field::SchulstufeGrob => "schulstufe_grob",
                Field::SchulstufeMittelCode => "schulstufe_mittel_code",
                Field::SchulstufeMittel => "schulstufe_mittel",
                Field::SchulstufeFeinCode => "schulstufe_fein_code",
                Field::SchulstufeFein => "schulstufe_fein",
                Field::GeschlechtCode => "geschlecht_code",
                Field::Geschlecht => "geschlecht",
                Field::Indikator => "indikator",
                Field::Wert => "wert",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10420/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nachnamen der ständigen Wohnbevölkerung nach Gemeinde (seit 2022)
pub mod nachnamen_der_staendigen_wohnbevoelkerung_nach_gemeinde_seit_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// TIME_PERIOD
        ///
        /// Jahr
        pub time_period: Option<String>,
        /// LASTNAME
        ///
        /// Nachname
        pub lastname: Option<String>,
        /// GDENR
        ///
        /// BFS-Gemeindenummer
        pub gdenr: Option<String>,
        /// GDENAME
        ///
        /// Gemeinde
        pub gdename: Option<String>,
        /// RANG_GDE
        ///
        /// Rang des Nachnamens in der Gemeinde
        pub rang_gde: Option<i64>,
        /// VALUE
        ///
        /// Anzahl Personen
        pub value: Option<i64>,
        /// PCT_GDE
        ///
        /// Prozentanteil des Nachnamens in der Gemeinde
        pub pct_gde: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TimePeriod,
        Lastname,
        Gdenr,
        Gdename,
        RangGde,
        Value,
        PctGde,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TimePeriod => "time_period",
                Field::Lastname => "lastname",
                Field::Gdenr => "gdenr",
                Field::Gdename => "gdename",
                Field::RangGde => "rang_gde",
                Field::Value => "value",
                Field::PctGde => "pct_gde",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11080/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Einwohnerratswahlen 2024: Kandidierendenresultate
pub mod einwohnerratswahlen_2024_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// Anzahl Sitze
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte
        pub stimmberechtigte: Option<i64>,
        /// Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Ungestempelte Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Partei-ID
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<i64>,
        /// Personen-ID
        pub personen_id: Option<i64>,
        /// Kumulation
        pub kumulation: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Gewählt
        pub gewahlt: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        pub stimmen_unveranderte_wahlzettel: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        pub stimmen_veranderte_wahlzettel: Option<i64>,
        /// Stimmen total
        pub stimmen_total: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        Stimmberechtigte,
        Wahlzettel,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ListenNr,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        PersonenId,
        Kumulation,
        Bisher,
        Gewahlt,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        StimmenUnveranderteWahlzettel,
        StimmenVeranderteWahlzettel,
        StimmenTotal,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::Wahlzettel => "wahlzettel",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ListenNr => "listen_nr",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::StimmenUnveranderteWahlzettel => "stimmen_unveranderte_wahlzettel",
                Field::StimmenVeranderteWahlzettel => "stimmen_veranderte_wahlzettel",
                Field::StimmenTotal => "stimmen_total",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10840/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Drogerien mit Betriebsbewilligung nach Standort (April 2024)
pub mod drogerien_mit_betriebsbewilligung_nach_standort_april_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Drogerie
        pub drogerie: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// Herstellungsbewilligung
        pub herstellungsbewilligung: Option<String>,
        /// Vorname_Name
        pub vorname_name: Option<String>,
        /// GKODE
        pub gkode: Option<f64>,
        /// GKODN
        pub gkodn: Option<f64>,
        /// Koordinaten
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Drogerie,
        Adresse,
        Plz,
        Ort,
        Telefon,
        Herstellungsbewilligung,
        VornameName,
        Gkode,
        Gkodn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Drogerie => "drogerie",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::Herstellungsbewilligung => "herstellungsbewilligung",
                Field::VornameName => "vorname_name",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10400/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Sissach-Bützenen (halbstündliche Messdaten seit Januar 2020)
pub mod luftqualitaet_station_sissach_buetzenen_halbstuendliche_messdaten_seit_januar_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Anfangszeit
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// PM10
        ///
        /// Lungengängiger Feinstaub PM10
        pub pm10: Option<f64>,
        /// PM2.5
        ///
        /// Lungengängiger Feinstaub PM2.5
        pub pm2_5: Option<f64>,
        /// NO2
        ///
        /// Stickstoffdioxid
        pub no2: Option<f64>,
        /// O3
        ///
        /// Ozon
        pub o3: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        Pm10,
        Pm25,
        No2,
        O3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::Pm10 => "pm10",
                Field::Pm25 => "pm2_5",
                Field::No2 => "no2",
                Field::O3 => "o3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12450/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station A2 Hard (halbstündliche Messdaten seit Januar 2020)
pub mod luftqualitaet_station_a2_hard_halbstuendliche_messdaten_seit_januar_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Anfangszeit
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// PM10
        ///
        /// Lungengängiger Feinstaub PM10
        pub pm10: Option<f64>,
        /// PM2.5
        ///
        /// Lungengängiger Feinstaub PM2.5
        pub pm2_5: Option<f64>,
        /// NO2
        ///
        /// Stickstoffdioxid
        pub no2: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        Pm10,
        Pm25,
        No2,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::Pm10 => "pm10",
                Field::Pm25 => "pm2_5",
                Field::No2 => "no2",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12510/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Betriebe mit einer Verkaufsbewilligung für Spirituosen nach Standort (Februar 2024)
pub mod betriebe_mit_einer_verkaufsbewilligung_fuer_spirituosen_nach_standort_februar_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Betriebsnummer
        pub betriebsnummer: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Firma
        pub firma: Option<String>,
        /// Post_Adresse
        pub post_adresse: Option<String>,
        /// PLZ_Ort
        pub plz_ort: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
        /// GWR_Adresse
        pub gwr_adresse: Option<String>,
        pub e_eingangskoordinate: Option<f64>,
        pub n_eingangskoordinate: Option<f64>,
        pub koordinaten: Option<GeoPoint2d>,
        pub egid: Option<i64>,
        pub name_des_gebaeudes: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Betriebsnummer,
        BfsGemeindenummer,
        Gemeinde,
        Firma,
        PostAdresse,
        PlzOrt,
        Bemerkung,
        GwrAdresse,
        EEingangskoordinate,
        NEingangskoordinate,
        Egid,
        NameDesGebaeudes,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Betriebsnummer => "betriebsnummer",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Firma => "firma",
                Field::PostAdresse => "post_adresse",
                Field::PlzOrt => "plz_ort",
                Field::Bemerkung => "bemerkung",
                Field::GwrAdresse => "gwr_adresse",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
                Field::Egid => "egid",
                Field::NameDesGebaeudes => "name_des_gebaeudes",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10960/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Dornach (halbstündliche Messdaten seit Januar 2020)
pub mod luftqualitaet_station_dornach_halbstuendliche_messdaten_seit_januar_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Anfangszeit
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// PM10
        ///
        /// Lungengängiger Feinstaub PM10
        pub pm10: Option<f64>,
        /// PM2.5
        ///
        /// Lungengängiger Feinstaub PM2.5
        pub pm2_5: Option<f64>,
        /// NO2
        ///
        /// Stickstoffdioxid
        pub no2: Option<f64>,
        /// O3
        ///
        /// Ozon
        pub o3: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        Pm10,
        Pm25,
        No2,
        O3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::Pm10 => "pm10",
                Field::Pm25 => "pm2_5",
                Field::No2 => "no2",
                Field::O3 => "o3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12500/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeinderatsnachwahlen 2024: Anzahl Sitze, Wahlberechtigte und Wahlzettel nach Gemeinde
pub mod gemeinderatsnachwahlen_2024_anzahl_sitze_wahlberechtigte_und_wahlzettel_nach_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Wahlverfahren
        pub wahlverfahren: Option<String>,
        /// Stille Wahl
        pub stille_wahl: Option<String>,
        /// Anzahl Sitze
        pub anzahl_sitze: Option<i64>,
        /// Stimmberechtigte
        pub stimmberechtigte: Option<String>,
        /// Abgegebene Wahlzettel
        pub abgegebene_wahlzettel: Option<String>,
        /// Leere Wahlzettel
        pub leere_wahlzettel: Option<String>,
        /// Ungültige Wahlzettel
        pub ungultige_wahlzettel: Option<String>,
        /// Gültige Wahlzettel
        pub gultige_wahlzettel: Option<String>,
        /// Leere Stimmen
        pub leere_stimmen: Option<String>,
        /// Ungültige Stimmen
        pub ungultige_stimmen: Option<String>,
        /// Gültige Stimmen
        pub gultige_stimmen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        Wahlverfahren,
        StilleWahl,
        AnzahlSitze,
        Stimmberechtigte,
        AbgegebeneWahlzettel,
        LeereWahlzettel,
        UngultigeWahlzettel,
        GultigeWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        GultigeStimmen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Wahlverfahren => "wahlverfahren",
                Field::StilleWahl => "stille_wahl",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::AbgegebeneWahlzettel => "abgegebene_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::GultigeWahlzettel => "gultige_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::GultigeStimmen => "gultige_stimmen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12420/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bewilligte Tagesbetreuungseinrichtungen für Kinder nach Standort (Oktober 2024)
pub mod bewilligte_tagesbetreuungseinrichtungen_fuer_kinder_nach_standort_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS
        ///
        /// Gemeindenummer gemäss Bundesamt für Statistik
        pub bfs: Option<String>,
        /// Gemeinde
        ///
        /// Gemeindename
        pub gemeinde: Option<String>,
        /// Institution
        pub institution: Option<String>,
        /// Post_Adresse
        ///
        /// Post-Adresse
        pub post_adresse: Option<String>,
        /// PLZ_Ort
        ///
        /// Postleitzahl und Ort
        pub plz_ort: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// Mail
        ///
        /// E-Mail-Adresse
        pub mail: Option<String>,
        /// URL
        ///
        /// Webpage
        pub url: Option<String>,
        /// Trägerschaft
        pub tragerschaft: Option<String>,
        /// Rechtsform
        pub rechtsform: Option<String>,
        /// Alter
        ///
        /// Betreuungsalter
        pub alter: Option<String>,
        /// Anzahl_Plätze_Tagesbetreuung
        ///
        /// Anzahl Plätze Tagesbetreuung
        pub anzahl_platze_tagesbetreuung: Option<i64>,
        /// Anzahl_Plätze_Mittagstisch
        ///
        /// [...] = Anzahl Plätze für beide Einrichtungen zusammen
        pub anzahl_platze_mittagstisch: Option<i64>,
        /// Anzahl_Plätze_Nachmittagsbetreuung
        ///
        /// [...] = Anzahl Plätze für beide Einrichtungen zusammen
        pub anzahl_platze_nachmittagsbetreuung: Option<i64>,
        /// Wochentage
        ///
        /// Wochentage mit Betreuung
        pub wochentage: Option<String>,
        /// GWR_Adresse
        ///
        /// Gebäudeadresse gemäss kantonalem Gebäude- und Wohnungsregister
        pub gwr_adresse: Option<String>,
        /// GKODE
        ///
        /// Gebäudekoordinate Ost
        pub gkode: Option<f64>,
        /// GKODN
        ///
        /// Gebäudekoordinate Nord
        pub gkodn: Option<f64>,
        /// Koordinaten
        ///
        /// Koordinaten gemäss World Geodetic System 1984 (WGS84)
        pub koordinaten: Option<GeoPoint2d>,
        /// GBEZ
        ///
        /// Gebäudebezeichnung
        pub gbez: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Bfs,
        Gemeinde,
        Institution,
        PostAdresse,
        PlzOrt,
        Telefon,
        Mail,
        Url,
        Tragerschaft,
        Rechtsform,
        Alter,
        AnzahlPlatzeTagesbetreuung,
        AnzahlPlatzeMittagstisch,
        AnzahlPlatzeNachmittagsbetreuung,
        Wochentage,
        GwrAdresse,
        Gkode,
        Gkodn,
        Gbez,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Bfs => "bfs",
                Field::Gemeinde => "gemeinde",
                Field::Institution => "institution",
                Field::PostAdresse => "post_adresse",
                Field::PlzOrt => "plz_ort",
                Field::Telefon => "telefon",
                Field::Mail => "mail",
                Field::Url => "url",
                Field::Tragerschaft => "tragerschaft",
                Field::Rechtsform => "rechtsform",
                Field::Alter => "alter",
                Field::AnzahlPlatzeTagesbetreuung => "anzahl_platze_tagesbetreuung",
                Field::AnzahlPlatzeMittagstisch => "anzahl_platze_mittagstisch",
                Field::AnzahlPlatzeNachmittagsbetreuung => "anzahl_platze_nachmittagsbetreuung",
                Field::Wochentage => "wochentage",
                Field::GwrAdresse => "gwr_adresse",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
                Field::Gbez => "gbez",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10440/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeinderatswahlen 2024: Anzahl Sitze, Wahlberechtigte und Wahlzettel nach Gemeinde
pub mod gemeinderatswahlen_2024_anzahl_sitze_wahlberechtigte_und_wahlzettel_nach_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Wahlverfahren
        pub wahlverfahren: Option<String>,
        /// Stille Wahl
        pub stille_wahl: Option<String>,
        /// Anzahl Sitze
        pub anzahl_sitze: Option<i64>,
        /// Stimmberechtigte
        pub stimmberechtigte: Option<String>,
        /// Abgegebene Wahlzettel
        pub abgegebene_wahlzettel: Option<String>,
        /// Leere Wahlzettel
        pub leere_wahlzettel: Option<String>,
        /// Ungültige Wahlzettel
        pub ungultige_wahlzettel: Option<String>,
        /// Gültige Wahlzettel
        pub gultige_wahlzettel: Option<String>,
        /// Leere Stimmen
        pub leere_stimmen: Option<String>,
        /// Ungültige Stimmen
        pub ungultige_stimmen: Option<String>,
        /// Gültige Stimmen
        pub gultige_stimmen: Option<String>,
        /// Absolutes Mehr
        pub absolutes_mehr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        Wahlverfahren,
        StilleWahl,
        AnzahlSitze,
        Stimmberechtigte,
        AbgegebeneWahlzettel,
        LeereWahlzettel,
        UngultigeWahlzettel,
        GultigeWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        GultigeStimmen,
        AbsolutesMehr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Wahlverfahren => "wahlverfahren",
                Field::StilleWahl => "stille_wahl",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::AbgegebeneWahlzettel => "abgegebene_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::GultigeWahlzettel => "gultige_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::GultigeStimmen => "gultige_stimmen",
                Field::AbsolutesMehr => "absolutes_mehr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10710/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Firmen nach Zweck, Rechtsform, NOGA-Einteilung und Standort
pub mod firmen_nach_zweck_rechtsform_noga_einteilung_und_standort {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub firmensitz_code: Option<String>,
        pub firmensitz: Option<String>,
        pub uid: Option<String>,
        pub firmenname: Option<String>,
        pub zusatz: Option<String>,
        pub strassenbezeichnung: Option<String>,
        pub eingangsnummer_gebaeude: Option<String>,
        pub postleitzahl: Option<String>,
        pub ort: Option<String>,
        pub firmensitz_bezirk_nr: Option<String>,
        pub firmensitz_bezirk: Option<String>,
        pub status: Option<String>,
        pub zweck: Option<String>,
        pub rechtsform_code: Option<String>,
        pub rechtsform: Option<String>,
        pub noga_code: Option<String>,
        pub noga: Option<String>,
        pub noga_abschnitt_code: Option<String>,
        pub noga_abschnitt: Option<String>,
        pub noga_abteilung: Option<String>,
        pub kantonaler_auszug_link: Option<String>,
        pub egid: Option<i64>,
        pub e_eingangskoordinate: Option<f64>,
        pub n_eingangskoordinate: Option<f64>,
        pub koordinaten: Option<GeoPoint2d>,
        pub lokalisierungsmethode: Option<String>,
        pub datum: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        FirmensitzCode,
        Firmensitz,
        Uid,
        Firmenname,
        Zusatz,
        Strassenbezeichnung,
        EingangsnummerGebaeude,
        Postleitzahl,
        Ort,
        FirmensitzBezirkNr,
        FirmensitzBezirk,
        Status,
        Zweck,
        RechtsformCode,
        Rechtsform,
        NogaCode,
        Noga,
        NogaAbschnittCode,
        NogaAbschnitt,
        NogaAbteilung,
        KantonalerAuszugLink,
        Egid,
        EEingangskoordinate,
        NEingangskoordinate,
        Lokalisierungsmethode,
        Datum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::FirmensitzCode => "firmensitz_code",
                Field::Firmensitz => "firmensitz",
                Field::Uid => "uid",
                Field::Firmenname => "firmenname",
                Field::Zusatz => "zusatz",
                Field::Strassenbezeichnung => "strassenbezeichnung",
                Field::EingangsnummerGebaeude => "eingangsnummer_gebaeude",
                Field::Postleitzahl => "postleitzahl",
                Field::Ort => "ort",
                Field::FirmensitzBezirkNr => "firmensitz_bezirk_nr",
                Field::FirmensitzBezirk => "firmensitz_bezirk",
                Field::Status => "status",
                Field::Zweck => "zweck",
                Field::RechtsformCode => "rechtsform_code",
                Field::Rechtsform => "rechtsform",
                Field::NogaCode => "noga_code",
                Field::Noga => "noga",
                Field::NogaAbschnittCode => "noga_abschnitt_code",
                Field::NogaAbschnitt => "noga_abschnitt",
                Field::NogaAbteilung => "noga_abteilung",
                Field::KantonalerAuszugLink => "kantonaler_auszug_link",
                Field::Egid => "egid",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
                Field::Lokalisierungsmethode => "lokalisierungsmethode",
                Field::Datum => "datum",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12480/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeindekennzahlen (2024)
pub mod gemeindekennzahlen_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Nummer
        pub bfs_nummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Bezirk_Nummer
        pub bezirk_nummer: Option<String>,
        /// Bezirk
        pub bezirk: Option<String>,
        /// Höhe_über_Meer
        pub hohe_uber_meer: Option<i64>,
        /// Gesamtfläche_ha_2014_15
        pub gesamtflache_ha_2014_15: Option<i64>,
        /// Siedlungsfläche_Prozent
        pub siedlungsflache_prozent: Option<f64>,
        /// Landwirtschaftsfläche_Prozent
        pub landwirtschaftsflache_prozent: Option<f64>,
        /// Bestockte_Fläche_Wald_Prozent
        pub bestockte_flache_wald_prozent: Option<f64>,
        /// Unproduktive_Fläche_Prozent
        pub unproduktive_flache_prozent: Option<f64>,
        /// Haushalte_2023
        pub haushalte_2023: Option<i64>,
        /// Bevölkerung_2023
        pub bevolkerung_2023: Option<i64>,
        /// 0_bis_14jährige_Prozent
        pub x0_bis_14jahrige_prozent: Option<f64>,
        /// 15_bis_64jährige_Prozent
        pub x15_bis_64jahrige_prozent: Option<f64>,
        /// 65jährige_und_älter_Prozent
        pub x65jahrige_und_alter_prozent: Option<f64>,
        /// Ausländeranteil_2023_Prozent
        pub auslanderanteil_2023_prozent: Option<f64>,
        /// Kinder_öffentliche_Primarstufe_Schulort_2023
        pub kinder_offentliche_primarstufe_schulort_2023: Option<f64>,
        /// Arbeitsstätten_2022
        pub arbeitsstatten_2022: Option<f64>,
        /// Beschäftigte_2022
        pub beschaftigte_2022: Option<f64>,
        /// Beschäftigte_Sektor_1_Prozent
        pub beschaftigte_sektor_1_prozent: Option<f64>,
        /// Beschäftigte_Sektor_2_Prozent
        pub beschaftigte_sektor_2_prozent: Option<f64>,
        /// Beschäftigte_Sektor_3_Prozent
        pub beschaftigte_sektor_3_prozent: Option<f64>,
        /// Wohnungsbestand_2023
        pub wohnungsbestand_2023: Option<f64>,
        /// Einfamilienhäuser_Prozent
        pub einfamilienhauser_prozent: Option<f64>,
        /// Fertigerstellte_Wohnungen_2023
        pub fertigerstellte_wohnungen_2023: Option<f64>,
        /// Leerwohnungsziffer_2024_Prozent
        pub leerwohnungsziffer_2024_prozent: Option<f64>,
        /// Bodenpreis_m2_Wohnbauland_2021_2023_CHF
        pub bodenpreis_m2_wohnbauland_2021_2023_chf: Option<String>,
        /// Steuerertrag_2022_1000_CHF
        pub steuerertrag_2022_1000_chf: Option<i64>,
        /// Steuerfuss_2024
        pub steuerfuss_2024: Option<f64>,
        /// Webseite
        pub webseite: Option<String>,
        /// Geometrie
        pub geometrie: Option<GeoJson>,
        /// Geometrisches_Zentrum
        pub geometrisches_zentrum: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsNummer,
        Gemeinde,
        BezirkNummer,
        Bezirk,
        HoheUberMeer,
        GesamtflacheHa201415,
        SiedlungsflacheProzent,
        LandwirtschaftsflacheProzent,
        BestockteFlacheWaldProzent,
        UnproduktiveFlacheProzent,
        Haushalte2023,
        Bevolkerung2023,
        X0Bis14jahrigeProzent,
        X15Bis64jahrigeProzent,
        X65jahrigeUndAlterProzent,
        Auslanderanteil2023Prozent,
        KinderOffentlichePrimarstufeSchulort2023,
        Arbeitsstatten2022,
        Beschaftigte2022,
        BeschaftigteSektor1Prozent,
        BeschaftigteSektor2Prozent,
        BeschaftigteSektor3Prozent,
        Wohnungsbestand2023,
        EinfamilienhauserProzent,
        FertigerstellteWohnungen2023,
        Leerwohnungsziffer2024Prozent,
        BodenpreisM2Wohnbauland20212023Chf,
        Steuerertrag20221000Chf,
        Steuerfuss2024,
        Webseite,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsNummer => "bfs_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::HoheUberMeer => "hohe_uber_meer",
                Field::GesamtflacheHa201415 => "gesamtflache_ha_2014_15",
                Field::SiedlungsflacheProzent => "siedlungsflache_prozent",
                Field::LandwirtschaftsflacheProzent => "landwirtschaftsflache_prozent",
                Field::BestockteFlacheWaldProzent => "bestockte_flache_wald_prozent",
                Field::UnproduktiveFlacheProzent => "unproduktive_flache_prozent",
                Field::Haushalte2023 => "haushalte_2023",
                Field::Bevolkerung2023 => "bevolkerung_2023",
                Field::X0Bis14jahrigeProzent => "0_bis_14jahrige_prozent",
                Field::X15Bis64jahrigeProzent => "15_bis_64jahrige_prozent",
                Field::X65jahrigeUndAlterProzent => "65jahrige_und_alter_prozent",
                Field::Auslanderanteil2023Prozent => "auslanderanteil_2023_prozent",
                Field::KinderOffentlichePrimarstufeSchulort2023 => {
                    "kinder_offentliche_primarstufe_schulort_2023"
                }
                Field::Arbeitsstatten2022 => "arbeitsstatten_2022",
                Field::Beschaftigte2022 => "beschaftigte_2022",
                Field::BeschaftigteSektor1Prozent => "beschaftigte_sektor_1_prozent",
                Field::BeschaftigteSektor2Prozent => "beschaftigte_sektor_2_prozent",
                Field::BeschaftigteSektor3Prozent => "beschaftigte_sektor_3_prozent",
                Field::Wohnungsbestand2023 => "wohnungsbestand_2023",
                Field::EinfamilienhauserProzent => "einfamilienhauser_prozent",
                Field::FertigerstellteWohnungen2023 => "fertigerstellte_wohnungen_2023",
                Field::Leerwohnungsziffer2024Prozent => "leerwohnungsziffer_2024_prozent",
                Field::BodenpreisM2Wohnbauland20212023Chf => {
                    "bodenpreis_m2_wohnbauland_2021_2023_chf"
                }
                Field::Steuerertrag20221000Chf => "steuerertrag_2022_1000_chf",
                Field::Steuerfuss2024 => "steuerfuss_2024",
                Field::Webseite => "webseite",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10650/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wetterstation Basel / Binningen: Tageswerte Klimamessnetz (seit 1864)
pub mod wetterstation_basel_binningen_tageswerte_klimamessnetz_seit_1864 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// Jahr
        pub jahr: Option<String>,
        /// Globalstrahlung in W/m2
        ///
        /// Tagesmittel
        pub gre000d0: Option<f64>,
        /// Gesamtschneemenge
        ///
        /// Morgenmessung von 6 UTC
        pub hto000d0: Option<f64>,
        /// Gesamtbewölkung
        ///
        /// Tagesmittel
        pub nto000d0: Option<f64>,
        /// Luftdruck in hPa
        ///
        /// Tagesmittel auf Stationshöhe (QFE)
        pub prestad0: Option<f64>,
        /// Niederschlag
        ///
        /// Tagessumme 6 UTC - 6 UTC Folgetag
        pub rre150d0: Option<f64>,
        /// Sonnenscheindauer
        ///
        /// Tagessumme
        pub sre000d0: Option<f64>,
        /// Tagesmittel Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200d0: Option<f64>,
        /// Tagesminimum Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200dn: Option<f64>,
        /// Tagesmaximum Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200dx: Option<f64>,
        /// Relative Luftfeuchtigkeit
        ///
        /// Tagesmittel, 2 m über Boden
        pub ure200d0: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Jahr,
        Gre000d0,
        Hto000d0,
        Nto000d0,
        Prestad0,
        Rre150d0,
        Sre000d0,
        Tre200d0,
        Tre200dn,
        Tre200dx,
        Ure200d0,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Jahr => "jahr",
                Field::Gre000d0 => "gre000d0",
                Field::Hto000d0 => "hto000d0",
                Field::Nto000d0 => "nto000d0",
                Field::Prestad0 => "prestad0",
                Field::Rre150d0 => "rre150d0",
                Field::Sre000d0 => "sre000d0",
                Field::Tre200d0 => "tre200d0",
                Field::Tre200dn => "tre200dn",
                Field::Tre200dx => "tre200dx",
                Field::Ure200d0 => "ure200d0",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12030/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// OGD-Portal: Tägliche Nutzung (seit Januar 2024)
pub mod ogd_portal_taegliche_nutzung_seit_januar_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// Visitors
        ///
        /// Unique IPs
        pub unique_ip_count: Option<i64>,
        /// Interactions
        ///
        /// API calls auf Datensätze
        pub api_calls_count: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        UniqueIpCount,
        ApiCallsCount,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::UniqueIpCount => "unique_ip_count",
                Field::ApiCallsCount => "api_calls_count",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12440/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerungsbilanz nach Gemeinde und Jahr (seit 1980)
pub mod bevoelkerungsbilanz_nach_gemeinde_und_jahr_seit_1980 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub jahr: Option<String>,
        pub gemeinde_nummer: Option<String>,
        pub gemeinde: Option<String>,
        pub bezirk_nummer: Option<String>,
        pub bezirk: Option<String>,
        pub versorgungsregion_code: Option<i64>,
        pub versorgungsregion: Option<String>,
        pub versorgungsregion_aggriegiert_code: Option<i64>,
        pub versorgungsregion_aggriegiert: Option<String>,
        pub anfangsbestand: Option<i64>,
        pub geburten: Option<i64>,
        pub todesfaelle: Option<i64>,
        pub geburtenueberschuss: Option<i64>,
        pub zuzuege: Option<i64>,
        pub wegzuege: Option<i64>,
        pub wanderungssaldo: Option<i64>,
        pub bereinigung_saldo: Option<i64>,
        pub gesamtveraenderung: Option<i64>,
        pub endbestand: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        GemeindeNummer,
        Gemeinde,
        BezirkNummer,
        Bezirk,
        VersorgungsregionCode,
        Versorgungsregion,
        VersorgungsregionAggriegiertCode,
        VersorgungsregionAggriegiert,
        Anfangsbestand,
        Geburten,
        Todesfaelle,
        Geburtenueberschuss,
        Zuzuege,
        Wegzuege,
        Wanderungssaldo,
        BereinigungSaldo,
        Gesamtveraenderung,
        Endbestand,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::GemeindeNummer => "gemeinde_nummer",
                Field::Gemeinde => "gemeinde",
                Field::BezirkNummer => "bezirk_nummer",
                Field::Bezirk => "bezirk",
                Field::VersorgungsregionCode => "versorgungsregion_code",
                Field::Versorgungsregion => "versorgungsregion",
                Field::VersorgungsregionAggriegiertCode => "versorgungsregion_aggriegiert_code",
                Field::VersorgungsregionAggriegiert => "versorgungsregion_aggriegiert",
                Field::Anfangsbestand => "anfangsbestand",
                Field::Geburten => "geburten",
                Field::Todesfaelle => "todesfaelle",
                Field::Geburtenueberschuss => "geburtenueberschuss",
                Field::Zuzuege => "zuzuege",
                Field::Wegzuege => "wegzuege",
                Field::Wanderungssaldo => "wanderungssaldo",
                Field::BereinigungSaldo => "bereinigung_saldo",
                Field::Gesamtveraenderung => "gesamtveraenderung",
                Field::Endbestand => "endbestand",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10040/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahlen Gemeindekommissionen 2024: Anzahl Sitze, Wahlberechtigte und Wahlzettel nach Gemeinde
pub mod wahlen_gemeindekommissionen_2024_anzahl_sitze_wahlberechtigte_und_wahlzettel_nach_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Wahlverfahren
        pub wahlverfahren: Option<String>,
        /// Stille Wahl
        pub stille_wahl: Option<String>,
        /// Anzahl Sitze
        pub anzahl_sitze: Option<i64>,
        /// Stimmberechtigte
        pub stimmberechtigte: Option<i64>,
        /// Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Gültige Wahlzettel
        pub gultige_wahlzettel: Option<i64>,
        /// Ungültige Stimmen
        pub ungultige_stimmen: Option<String>,
        /// Leere Stimmen
        pub leere_stimmen: Option<String>,
        /// Gültige Stimmen
        pub gultige_stimmen: Option<i64>,
        /// Absolutes Mehr
        pub absolutes_mehr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        Wahlverfahren,
        StilleWahl,
        AnzahlSitze,
        Stimmberechtigte,
        Wahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        GultigeWahlzettel,
        UngultigeStimmen,
        LeereStimmen,
        GultigeStimmen,
        AbsolutesMehr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::Wahlverfahren => "wahlverfahren",
                Field::StilleWahl => "stille_wahl",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::Wahlzettel => "wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::GultigeWahlzettel => "gultige_wahlzettel",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::LeereStimmen => "leere_stimmen",
                Field::GultigeStimmen => "gultige_stimmen",
                Field::AbsolutesMehr => "absolutes_mehr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/12370/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Adressen der Sonderschulen und Schulheime (Juni 2024)
pub mod adressen_der_sonderschulen_und_schulheime_juni_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Standortgemeinde
        pub standortgemeinde: Option<String>,
        /// Schule_Code
        pub schule_code: Option<String>,
        /// Schule_Name
        pub schule_name: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// E_Mail
        pub e_mail: Option<String>,
        /// URL
        pub url: Option<String>,
        pub e_eingangskoordinate: Option<i64>,
        pub n_eingangskoordinate: Option<i64>,
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BfsGemeindenummer,
        Standortgemeinde,
        SchuleCode,
        SchuleName,
        Adresse,
        Plz,
        Ort,
        Kategorie,
        Telefon,
        EMail,
        Url,
        EEingangskoordinate,
        NEingangskoordinate,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Standortgemeinde => "standortgemeinde",
                Field::SchuleCode => "schule_code",
                Field::SchuleName => "schule_name",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kategorie => "kategorie",
                Field::Telefon => "telefon",
                Field::EMail => "e_mail",
                Field::Url => "url",
                Field::EEingangskoordinate => "e_eingangskoordinate",
                Field::NEingangskoordinate => "n_eingangskoordinate",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11200/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Datensatz-Katalog
pub mod datensatz_katalog {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub dataset_id: Option<String>,
        pub title: Option<String>,
        pub description: Option<String>,
        pub theme: Option<String>,
        pub keyword: Option<String>,
        pub license: Option<String>,
        #[serde(with = "time::serde::iso8601::option")]
        pub modified: Option<OffsetDateTime>,
        /// Data_processed
        #[serde(with = "time::serde::iso8601::option")]
        pub data_processed: Option<OffsetDateTime>,
        #[serde(with = "time::serde::iso8601::option")]
        pub metadata_processed: Option<OffsetDateTime>,
        pub publisher: Option<String>,
        pub references: Option<String>,
        pub records_count: Option<i64>,
        pub attributions: Option<String>,
        pub contact_email: Option<String>,
        pub accrualperiodicity: Option<String>,
        pub rights: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatasetId,
        Title,
        Description,
        Theme,
        Keyword,
        License,
        Modified,
        DataProcessed,
        MetadataProcessed,
        Publisher,
        References,
        RecordsCount,
        Attributions,
        ContactEmail,
        Accrualperiodicity,
        Rights,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatasetId => "dataset_id",
                Field::Title => "title",
                Field::Description => "description",
                Field::Theme => "theme",
                Field::Keyword => "keyword",
                Field::License => "license",
                Field::Modified => "modified",
                Field::DataProcessed => "data_processed",
                Field::MetadataProcessed => "metadata_processed",
                Field::Publisher => "publisher",
                Field::References => "references",
                Field::RecordsCount => "records_count",
                Field::Attributions => "attributions",
                Field::ContactEmail => "contact_email",
                Field::Accrualperiodicity => "accrualperiodicity",
                Field::Rights => "rights",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10660/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmungsarchiv nach Vorlage und Datum (seit 2003)
pub mod abstimmungsarchiv_nach_vorlage_und_datum_seit_2003 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        pub vote_id: Option<String>,
        /// domain
        ///
        /// Ebene
        pub domain0: Option<String>,
        /// type
        ///
        /// Typ
        pub r#type: Option<String>,
        /// title_de_CH
        ///
        /// Titel
        pub title_de_ch: Option<String>,
        /// Auszuzählende Gemeinden
        pub entities_total: Option<i64>,
        /// Ausgezählte Gemeinden
        pub entities_counted: Option<i64>,
        /// Resultat
        pub answer: Option<String>,
        /// Ja-Anteil
        pub percent_yeas: Option<f64>,
        /// Nein-Anteil
        pub percent_nays: Option<f64>,
        /// Stimmbeteiligung
        pub percent_turnout: Option<f64>,
        /// Stimmberechtigte
        pub eligible_voters: Option<i64>,
        /// Stimmberechtigte Auslandschweizer/innen
        pub expats: Option<i64>,
        /// Leere Stimmen
        pub empty: Option<i64>,
        /// Ungültige Stimmen
        pub invalid: Option<i64>,
        /// Ja-Stimmen
        pub yeas: Option<i64>,
        /// Nein-Stimmen
        pub nays: Option<i64>,
        pub link_to_municipality_results: Option<String>,
        pub url_web: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        VoteId,
        Domain0,
        RType,
        TitleDeCh,
        EntitiesTotal,
        EntitiesCounted,
        Answer,
        PercentYeas,
        PercentNays,
        PercentTurnout,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        LinkToMunicipalityResults,
        UrlWeb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::VoteId => "vote_id",
                Field::Domain0 => "domain0",
                Field::RType => "type",
                Field::TitleDeCh => "title_de_ch",
                Field::EntitiesTotal => "entities_total",
                Field::EntitiesCounted => "entities_counted",
                Field::Answer => "answer",
                Field::PercentYeas => "percent_yeas",
                Field::PercentNays => "percent_nays",
                Field::PercentTurnout => "percent_turnout",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::LinkToMunicipalityResults => "link_to_municipality_results",
                Field::UrlWeb => "url_web",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10500/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmungsarchiv nach Vorlage, Gemeinde und Datum (seit 2003)
pub mod abstimmungsarchiv_nach_vorlage_gemeinde_und_datum_seit_2003 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Abstimmungsdatum
        pub date: Option<Date>,
        /// Gemeindenummer (BFS)
        pub entity_id: Option<String>,
        /// Gemeinde
        pub name: Option<String>,
        /// Bezirk
        pub district: Option<String>,
        pub vote_id: Option<String>,
        /// domain
        ///
        /// Föderale Ebene
        pub domain0: Option<String>,
        /// type
        ///
        /// Typ
        pub r#type: Option<String>,
        /// title_de_CH
        ///
        /// Abstimmungstitel
        pub title_de_ch: Option<String>,
        /// Ausgezählt
        pub counted: Option<String>,
        /// Resultat
        pub answer: Option<String>,
        /// Ja-Stimmen (%)
        pub percent_yeas: Option<f64>,
        /// Nein-Stimmen (%)
        pub percent_nays: Option<f64>,
        /// Wahlbeteiligung
        pub percent_turnout: Option<f64>,
        /// Stimmberechtigte total
        pub eligible_voters: Option<i64>,
        /// davon Stimmberechtigte Auslandschweizer/innen
        pub expats: Option<i64>,
        /// Leere Stimmen
        pub empty: Option<i64>,
        /// Ungültige Stimmen
        pub invalid: Option<i64>,
        /// Ja-Stimmen
        pub yeas: Option<i64>,
        /// Nein-Stimmen
        pub nays: Option<i64>,
        pub link_to_canton_results: Option<String>,
        pub url_web: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        EntityId,
        Name,
        District,
        VoteId,
        Domain0,
        RType,
        TitleDeCh,
        Counted,
        Answer,
        PercentYeas,
        PercentNays,
        PercentTurnout,
        EligibleVoters,
        Expats,
        Empty,
        Invalid,
        Yeas,
        Nays,
        LinkToCantonResults,
        UrlWeb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::EntityId => "entity_id",
                Field::Name => "name",
                Field::District => "district",
                Field::VoteId => "vote_id",
                Field::Domain0 => "domain0",
                Field::RType => "type",
                Field::TitleDeCh => "title_de_ch",
                Field::Counted => "counted",
                Field::Answer => "answer",
                Field::PercentYeas => "percent_yeas",
                Field::PercentNays => "percent_nays",
                Field::PercentTurnout => "percent_turnout",
                Field::EligibleVoters => "eligible_voters",
                Field::Expats => "expats",
                Field::Empty => "empty",
                Field::Invalid => "invalid",
                Field::Yeas => "yeas",
                Field::Nays => "nays",
                Field::LinkToCantonResults => "link_to_canton_results",
                Field::UrlWeb => "url_web",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/11990/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeinderatswahlen 2024: Kandidierendenresultate
pub mod gemeinderatswahlen_2024_kandidierendenresultate {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        pub wahlbezeichnung: Option<String>,
        /// BFS_Gemeindenummer
        pub bfs_gemeindenummer: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Anzahl Stimmen
        pub anzahl_stimmen: Option<String>,
        /// Gewählt
        pub gewahlt: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        BfsGemeindenummer,
        Gemeinde,
        KandidatenNr,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Bisher,
        AnzahlStimmen,
        Gewahlt,
        Parteibezeichnung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::BfsGemeindenummer => "bfs_gemeindenummer",
                Field::Gemeinde => "gemeinde",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Bisher => "bisher",
                Field::AnzahlStimmen => "anzahl_stimmen",
                Field::Gewahlt => "gewahlt",
                Field::Parteibezeichnung => "parteibezeichnung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bl.ch/api/explore/v2.1/catalog/datasets/10700/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}
