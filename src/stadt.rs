use geojson::GeoJson;
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;

#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub struct GeoPoint2d {
    pub lat: f64,
    pub lon: f64,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct File {
    pub url: String,
    pub width: u16,
    pub height: u16,
}

pub type Date = String;

fn escape(value: &str) -> String {
    value.replace('\\', "\\\\").replace('"', "\\\"")
}

/// Wahl von sieben Präsidentinnen oder Präsidenten des Strafgerichts
pub mod wahl_von_sieben_praesidentinnen_oder_praesidenten_des_strafgerichts {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<i64>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub resultats_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anz_sitze: Option<i64>,
        /// Kandidaten-Nr
        pub kandidat_nr: Option<i64>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub name_ganz: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewaehlt: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Wahlzettel
        ///
        /// Anzahl eingelegte Wahlzettel
        pub eingelegte: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leere Wahlzettel
        pub leere: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültige Wahlzettel
        pub ungueltige: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub gueltige: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub anz_briefliche: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total
        pub stimmber_total: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmber_maen: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmber_fraue: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Stimmen + leere Stimmen)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub ant_brieflich: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ResultatsTyp,
        Datum,
        AnzSitze,
        KandidatNr,
        NameGanz,
        Name,
        Vorname,
        Gemeinde,
        Stimmen,
        Vereinzelte,
        Gewaehlt,
        Stimmrechtsausweise,
        Eingelegte,
        Leere,
        Ungueltige,
        Gueltige,
        AnzBriefliche,
        StimmberTotal,
        StimmberMaen,
        StimmberFraue,
        AbsolutesMehr,
        Stimmbeteiligung,
        AntBrieflich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ResultatsTyp => "resultats_typ",
                Field::Datum => "datum",
                Field::AnzSitze => "anz_sitze",
                Field::KandidatNr => "kandidat_nr",
                Field::NameGanz => "name_ganz",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Vereinzelte => "vereinzelte",
                Field::Gewaehlt => "gewaehlt",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Eingelegte => "eingelegte",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::AnzBriefliche => "anz_briefliche",
                Field::StimmberTotal => "stimmber_total",
                Field::StimmberMaen => "stimmber_maen",
                Field::StimmberFraue => "stimmber_fraue",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AntBrieflich => "ant_brieflich",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100133/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Massentests an Schulen
pub mod coronavirus_covid_19_massentests_an_schulen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<i64>,
        /// Resultat
        ///
        /// Resultat der Tests (negativ oder positiv)
        pub result: Option<String>,
        /// Pos./neg. getestete Personen pro Woche
        ///
        /// Anzahl positiv resp. negativ getesteter Personen pro Woche
        pub count: Option<i64>,
        /// Getestete Personen pro Woche
        ///
        /// Anzahl total getesteter Schülerinnen, Schüler oder Lehrpersonen pro Woche
        pub counttotal: Option<i64>,
        /// Positivitätsrate
        ///
        /// Anteil der positiven Tests an der Gesamtzahl der Tests der betreffenden Woche
        pub positivityratepercent: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100183/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Parkplatz-Zonen
pub mod smarte_strasse_parkplatz_zonen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<f64>,
        /// Breitengrad
        pub lat: Option<f64>,
        /// Längengrad
        pub lon: Option<f64>,
        /// Koordinaten
        pub coord: Option<GeoPoint2d>,
        /// Adresse
        pub adresse: Option<String>,
        /// Typ
        ///
        /// Parkplatztyp
        pub typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Lat,
        Lon,
        Adresse,
        Typ,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::Adresse => "adresse",
                Field::Typ => "typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100176/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte Mess-Stationen Smart Climate Schallpegelmessungen
pub mod standorte_mess_stationen_smart_climate_schallpegelmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station
        ///
        /// Name der Station
        pub station_id: Option<String>,
        /// EUI
        ///
        /// ID der Mess-Station
        pub eui: Option<String>,
        /// Geopunkt
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geographische Breite
        pub latitude: Option<f64>,
        /// Geographische Länge
        pub longitude: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        StationId,
        Eui,
        Latitude,
        Longitude,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::Eui => "eui",
                Field::Latitude => "latitude",
                Field::Longitude => "longitude",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100090/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 27. November 2022
pub mod kennzahlen_der_abstimmung_vom_27_november_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Gegenvorschlag
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Stichfrage
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag am Total der Stimmen mit gültiger Antwort
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100240/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Staatsarchiv: Neuzugänge im öffentlichen Archivkatalog
pub mod staatsarchiv_neuzugaenge_im_oeffentlichen_archivkatalog {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr, in dem die Aktenerschliessung stattgefunden hat.
        pub jahr: Option<String>,
        /// Abteilung
        ///
        /// Oberste Ebene (Abteilung) im Archivplan, unter welcher die Unterlagen eingeordnet sind
        pub abteilung: Option<String>,
        /// Unterabteilung / Subtyp
        ///
        /// Für Unterabteilung zweite Ebene im Archivplan, unter welcher die Unterlagen zu finden sind. Subtypen («Zuwachs zu bestehenden Privatarchiven» und «Neue Privatarchive») zeigen für Privatarchive einen neuen oder bestehenden Bestand an.
        pub unterabteilung_subtyp: Option<String>,
        /// Signatur
        ///
        /// Signatur, unter welcher die Neuzugänge im Archivkatalog zu finden sind.
        pub signatur: Option<String>,
        /// Abliefernde Stelle
        ///
        /// Stelle, welche die Unterlagen abgeliefert und in der Regel auch erstellt hat. Kann ein kantonales Amt, eine öffentlich-rechtliche oder private Organisation oder auch eine Privatperson oder Familie sein.
        pub abliefernde_stelle: Option<String>,
        /// Beschreibung
        ///
        /// Eine stichwortartige Beschreibung des Inhalts der Unterlagen
        pub betreff_beschreibung: Option<String>,
        /// Zeitraum
        ///
        /// Der Zeitraum, in dem die Unterlagen erstellt worden sind.
        pub zeitraum: Option<String>,
        /// Umfang (Lfm)
        ///
        /// Umfang der verzeichneten Unterlagen in Laufmeter. Standardeinheit für physische Unterlagen (primär Papier)
        pub umfang_lfm: Option<f64>,
        /// Umfang (Band)
        ///
        /// Umfang in Bänden. Selten bei Büchern verwendet
        pub umfang_band: Option<f64>,
        /// Umfang (Stück)
        ///
        /// Umfang in Stück. Selten bei unterschiedlichen Objekten verwendet
        pub umfang_stuck: Option<f64>,
        /// Umfang (MB)
        ///
        /// Umfang der verzeichneten Unterlagen in Megabyte. Bei digitalen Unterlagen verwendet
        pub umfang_mb: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Abteilung,
        UnterabteilungSubtyp,
        Signatur,
        AblieferndeStelle,
        BetreffBeschreibung,
        Zeitraum,
        UmfangLfm,
        UmfangBand,
        UmfangStuck,
        UmfangMb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Abteilung => "abteilung",
                Field::UnterabteilungSubtyp => "unterabteilung_subtyp",
                Field::Signatur => "signatur",
                Field::AblieferndeStelle => "abliefernde_stelle",
                Field::BetreffBeschreibung => "betreff_beschreibung",
                Field::Zeitraum => "zeitraum",
                Field::UmfangLfm => "umfang_lfm",
                Field::UmfangBand => "umfang_band",
                Field::UmfangStuck => "umfang_stuck",
                Field::UmfangMb => "umfang_mb",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100365/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Nationalratswahlen 2023 (aggregierte Daten)
pub mod resultate_der_nationalratswahlen_2023_aggregierte_daten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listen-Nr
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// HLV-Nr
        ///
        /// Nummer der Hauptlistenverbindung
        pub hlv_nr: Option<String>,
        /// HLV-Bezeichnung
        ///
        /// Name der Hauptlistenverbindung
        pub hlv_bezeichnung: Option<String>,
        /// ULV-Nr
        ///
        /// Nummer der Unterlistenverbindung
        pub ulv_nr: Option<String>,
        /// ULV-Bezeichnung
        ///
        /// Name der Unterlistenverbindung
        pub ulv_bezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen
        ///
        /// Anzahl Stimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub kandidatenstimmen: Option<i64>,
        /// Zusatzstimmen
        ///
        /// Anzahl Zusatzstimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub zusatzstimmen: Option<i64>,
        /// Parteistimmen
        pub parteistimmen: Option<i64>,
        /// Anteil an Summe in %
        pub anteil_an_summe_in: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ListenNr,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        HlvNr,
        HlvBezeichnung,
        UlvNr,
        UlvBezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        Kandidatenstimmen,
        Zusatzstimmen,
        Parteistimmen,
        AnteilAnSummeIn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ListenNr => "listen_nr",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::HlvNr => "hlv_nr",
                Field::HlvBezeichnung => "hlv_bezeichnung",
                Field::UlvNr => "ulv_nr",
                Field::UlvBezeichnung => "ulv_bezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::Kandidatenstimmen => "kandidatenstimmen",
                Field::Zusatzstimmen => "zusatzstimmen",
                Field::Parteistimmen => "parteistimmen",
                Field::AnteilAnSummeIn => "anteil_an_summe_in",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100297/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Einzelmessungen der Smiley-Geschwindigkeitsanzeigen
pub mod einzelmessungen_der_smiley_geschwindigkeitsanzeigen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zyklus
        ///
        /// Messzyklus (1, 2 oder 3)
        pub zyklus: Option<String>,
        /// Phase
        ///
        /// Phase der Messung (Vormessung, Betrieb, Nachmessung oder nach Ende)
        pub phase: Option<String>,
        /// ID Standort
        ///
        /// Eindeutige Standortkennung
        pub id_standort: Option<String>,
        /// Strassenname
        pub strassenname: Option<String>,
        /// Ort
        ///
        /// Ortsname
        pub ort: Option<String>,
        /// Ort Abkürzung
        pub ort_abkuerzung: Option<String>,
        /// Zeitpunkt Messung
        ///
        /// Zeitpunkt der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub messung_timestamp: Option<OffsetDateTime>,
        /// Messung Datum
        ///
        /// Datum der Messung
        pub messung_datum: Option<Date>,
        /// Messung Zeit
        ///
        /// Zeit der Messung
        pub messung_zeit: Option<String>,
        /// Einfahrtstempo
        ///
        /// Geschwindigkeit bei Einfahrt
        pub v_einfahrt: Option<i64>,
        /// Ausfahrtstempo
        ///
        /// Geschwindigkeit bei Ausfahrt
        pub v_ausfahrt: Option<i64>,
        /// Differenztempo
        ///
        /// Geschwindigkeitsdifferenz (Einfahrt minus Ausfahrt)
        pub v_delta: Option<i64>,
        /// Tempolimit
        ///
        /// Maximale erlaubte Geschwindigkeit
        pub geschwindigkeit: Option<i64>,
        /// Halterung
        ///
        /// Art der Befestigung (permanent oder mobil)
        pub halterung: Option<String>,
        /// Start Vormessung
        ///
        /// Beginn der Vormessung (mit ausgeschalteter Anzeige)
        #[serde(with = "time::serde::iso8601::option")]
        pub start_vormessung: Option<OffsetDateTime>,
        /// Start Betrieb
        ///
        /// Beginn des aktiven Betriebs
        #[serde(with = "time::serde::iso8601::option")]
        pub start_betrieb: Option<OffsetDateTime>,
        /// Start Nachmessung
        ///
        /// Beginn der Nachmessung (mit ausgeschalteter Anzeige)
        #[serde(with = "time::serde::iso8601::option")]
        pub start_nachmessung: Option<OffsetDateTime>,
        /// Ende
        ///
        /// Ende des Messzyklus am Standort
        #[serde(with = "time::serde::iso8601::option")]
        pub ende: Option<OffsetDateTime>,
        /// Messung Jahr
        ///
        /// Jahr der Messung
        pub messung_jahr: Option<String>,
        /// Geopunkt
        ///
        /// Geografische Koordinaten der Smiley-Geschwindigkeitsanzeige
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Zyklus,
        Phase,
        IdStandort,
        Strassenname,
        Ort,
        OrtAbkuerzung,
        MessungTimestamp,
        MessungDatum,
        MessungZeit,
        VEinfahrt,
        VAusfahrt,
        VDelta,
        Geschwindigkeit,
        Halterung,
        StartVormessung,
        StartBetrieb,
        StartNachmessung,
        Ende,
        MessungJahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zyklus => "zyklus",
                Field::Phase => "phase",
                Field::IdStandort => "id_standort",
                Field::Strassenname => "strassenname",
                Field::Ort => "ort",
                Field::OrtAbkuerzung => "ort_abkuerzung",
                Field::MessungTimestamp => "messung_timestamp",
                Field::MessungDatum => "messung_datum",
                Field::MessungZeit => "messung_zeit",
                Field::VEinfahrt => "v_einfahrt",
                Field::VAusfahrt => "v_ausfahrt",
                Field::VDelta => "v_delta",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Halterung => "halterung",
                Field::StartVormessung => "start_vormessung",
                Field::StartBetrieb => "start_betrieb",
                Field::StartNachmessung => "start_nachmessung",
                Field::Ende => "ende",
                Field::MessungJahr => "messung_jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100268/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom  28. November 2021
pub mod kennzahlen_der_abstimmung_vom_28_november_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100163/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom  26. September 2021
pub mod kennzahlen_der_abstimmung_vom_26_september_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100155/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 15. Mai 2022
pub mod kennzahlen_der_abstimmung_vom_15_mai_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100195/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 25. September 2022
pub mod kennzahlen_der_abstimmung_vom_25_september_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100207/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 26. November 2023 Details
pub mod abstimmung_vom_26_november_2023_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100327/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 25. September 2022 Details
pub mod abstimmung_vom_25_september_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100206/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 18. Juni 2023
pub mod kennzahlen_der_abstimmung_vom_18_juni_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100299/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 18. Juni 2023 Details
pub mod abstimmung_vom_18_juni_2023_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100298/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung 13. Juni 2021 Details
pub mod abstimmung_13_juni_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Gegenvorschlag Stimmen ohne gültige Antwort
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stichfrage Stimmen ohne gültige Antwort
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100144/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ordnungsbussen
pub mod ordnungsbussen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Laufnummer
        ///
        ///
        pub laufnummer: Option<i64>,
        /// Kategorie Bezeichnung
        ///
        /// Fahrzeugkategorie; enthält auch Fussgänger und Beifahrer;
        pub kategorie_bezeichnung: Option<String>,
        /// Wochentag
        ///
        /// Nummer und Bezeichnung des Wochentags, an welchem die Übertretung stattgefunden hat
        pub wochentag: Option<String>,
        /// Übertretungs-Wochentagnummer
        ///
        /// Nummer des Wochentags, an welchem die Übertretung stattgefunden hat (1 = Sonntag, 2 = Montag, etc.)
        pub ubertretungswochentagnummer: Option<i64>,
        /// Übertretungs-Wochentag
        ///
        /// Wochentag, an welchem die Übertretung stattgefunden hat
        pub ubertretungswochentag: Option<String>,
        /// Übertretungsmonat
        ///
        /// Monat, in welchem die Übertretung stattgefunden hat
        pub ubertretungsmonat: Option<i64>,
        /// Übertretungsjahr
        ///
        /// Jahr, in welchem die Übertretung stattgefunden hat
        pub ubertretungsjahr: Option<String>,
        /// Geschwindigkeitslimite
        ///
        /// Erlaubte Höchstgeschwindigkeit am Ort der Übertretung
        pub gk_limite: Option<f64>,
        /// Übertretungs-PLZ
        ///
        /// Postleitzahl des Ortes, an dem eine Übertretung stattgefunden hat
        pub u_ort_plz: Option<String>,
        /// Übertretungsort
        ///
        /// Gemeinde, in welcher eine Übertretung stattgefunden hat
        pub u_ort_ort: Option<String>,
        /// Bussenbetrag
        ///
        /// Höhe der Busse in Franken
        pub bussen_betrag: Option<i64>,
        /// Bussenziffer
        ///
        /// Ziffer aus der eidg. Ordnungsbussenverordnung
        pub buzi: Option<String>,
        /// Bussenziffer Zusatz
        ///
        /// Zusatz zur Ziffer aus der eidg. Ordnungsbussenverordnung
        pub buzi_zus: Option<String>,
        /// Bussenziffer Text
        ///
        /// Beschreibender Text zur Art der Übertretung gemäss eidg. Ordnungsbussenverordnung und Zusatz zur Ziffer aus der OBV
        pub buzi_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Laufnummer,
        KategorieBezeichnung,
        Wochentag,
        Ubertretungswochentagnummer,
        Ubertretungswochentag,
        Ubertretungsmonat,
        Ubertretungsjahr,
        GkLimite,
        UOrtPlz,
        UOrtOrt,
        BussenBetrag,
        Buzi,
        BuziZus,
        BuziText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Laufnummer => "laufnummer",
                Field::KategorieBezeichnung => "kategorie_bezeichnung",
                Field::Wochentag => "wochentag",
                Field::Ubertretungswochentagnummer => "ubertretungswochentagnummer",
                Field::Ubertretungswochentag => "ubertretungswochentag",
                Field::Ubertretungsmonat => "ubertretungsmonat",
                Field::Ubertretungsjahr => "ubertretungsjahr",
                Field::GkLimite => "gk_limite",
                Field::UOrtPlz => "u_ort_plz",
                Field::UOrtOrt => "u_ort_ort",
                Field::BussenBetrag => "bussen_betrag",
                Field::Buzi => "buzi",
                Field::BuziZus => "buzi_zus",
                Field::BuziText => "buzi_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100058/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Ersatzwahl Regierungspräsidium 3. März 2024
pub mod resultate_der_ersatzwahl_regierungspraesidium_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100338/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Ersatzwahl Regierungsrat 7. April 2024 (2. Wahlgang)
pub mod resultate_der_ersatzwahl_regierungsrat_7_april_2024_2_wahlgang {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1). Für zweiten Wahlgang nicht vorhanden.
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        ///
        /// Spalte, damit bei Grafik "Vereinzelte" abgebildet werden kann
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100360/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Regierungsrats- und Regierungspräsidiumswahl 2020
pub mod regierungsrats_und_regierungspraesidiumswahl_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<String>,
        /// Art der Wahl
        ///
        /// Gesamterneuerungswahl oder Ersatzwahl
        pub art_der_wahl: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anzahl_sitze: Option<i64>,
        /// Listen-Nr.
        pub listen_nr: Option<i64>,
        /// Liste
        ///
        /// Kürzel der unterstützenden Parteien
        pub liste: Option<String>,
        /// Kandidaten-Nr.
        pub kandidaten_nr: Option<i64>,
        /// Bisher
        ///
        /// Angabe ob, eine Regierungsrätin oder ein Regierungsrat in der abgelaufenen Legislatur Mitglied des Regierungsrats war
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Alter am Jahresende 2020
        ///
        /// Alter, berechnet mit der Formel "2020 minus Jahrgang"
        pub alter: Option<i64>,
        /// Partei
        ///
        /// Kürzel der Partei
        pub partei: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewahlt: Option<String>,
        /// Wahlzettel
        ///
        /// Anzahl eingelegter Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_stimmzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_stimmzettel: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültiger Wahlzettel
        pub gultige_stimmzettel: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte_stimmen: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: Ganzzahl((gültige Stimmen + leere Stimmen)/2) + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Stimmen Regierungspräsidium
        ///
        /// Anzahl Stimmen für das Regierungspräsidium
        pub stimmen_prasidium: Option<i64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_stimmende: Option<f64>,
        /// Regierungspräsidium
        ///
        /// 1 = Kandidiert für das Regierungspräsidium
        pub prasidium: Option<i64>,
        /// Kandidaten-Nr. Regierungspräsidium
        ///
        /// Kandidaten-Nr. für die Wahl ins Regierungspräsidium
        pub kandidaten_nr_praidium: Option<i64>,
        /// Bisher Regierungspräsidium
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der vorherigen Legislatur das Regierungspräsidium innehatte
        pub bisher_prasidium: Option<String>,
        /// Gewählt Regierungspräsidium
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat für das Regierungspräsidium gewählt ist
        pub gewahlt_prasidium: Option<String>,
        /// Wahlzettel Regierungspräsidium
        ///
        /// Anzahl eingelegte Wahlzettel für das Regierungspräsidium
        pub wahlzettel_prasidium: Option<i64>,
        /// Briefliche Stimmabgaben Präsidium
        ///
        /// Anzahl brieflich eingelegte Wahlzettel für das Regierungspräsidium
        pub briefliche_stimmabgaben_prasidium: Option<i64>,
        /// Leere Wahlzettel Regierungspräsidium
        ///
        /// Anzahl leer eingelegter Wahlzettel für das Regierungspräsidium
        pub leere_stimmzettel_prasidium: Option<i64>,
        /// Ungültige Wahlzettel Regierungspräsidium
        ///
        /// Anzahl ungültiger Wahlzettel für das Regierungspräsidium
        pub ungultige_stimmzettel_prasidium: Option<i64>,
        /// Gültige Wahlzettel Regierungspräsidium
        ///
        /// Anzahl gültiger Wahlzettel für das Regierungspräsidium
        pub gultige_stimmzettel_prasidium: Option<i64>,
        /// Vereinzelte Stimmen Regierungspräsidium
        ///
        /// Anzahl Stimmen, welche für nicht für das Regierungspräsidium kandidierende Personen eingegangen sind
        pub vereinzelte_stimmen_prasidium: Option<i64>,
        /// Absolutes Mehr Regierungspräsidium
        ///
        /// berechnet nach der Formel: Ganzzahl((gültige Stimmen + leere Stimmen)/2) + 1)
        pub absolutes_mehr_prasidium: Option<i64>,
        /// Stimmbeteiligung Regierungspräsidium
        ///
        /// Anteil eingelegter Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung_prasidium: Option<f64>,
        /// Anteil brieflich Wählender Regierungspräsidium
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_stimmende_prasidium: Option<f64>,
        /// Gemeinde-ID
        pub gemeinde_id: Option<String>,
        /// Stimmberechtigte
        ///
        /// Total der Stimmberechtigten
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Jahrgang numerisch
        ///
        /// Jahrgang formatiert als ganze Zahl
        pub jahrgang_num: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ArtDerWahl,
        Datum,
        AnzahlSitze,
        ListenNr,
        Liste,
        KandidatenNr,
        Bisher,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Alter,
        Partei,
        Beruf,
        Gemeinde,
        Stimmen,
        Gewahlt,
        Wahlzettel,
        BrieflicheStimmabgaben,
        LeereStimmzettel,
        UngultigeStimmzettel,
        GultigeStimmzettel,
        VereinzelteStimmen,
        AbsolutesMehr,
        Stimmbeteiligung,
        StimmenPrasidium,
        AnteilBrieflichStimmende,
        Prasidium,
        KandidatenNrPraidium,
        BisherPrasidium,
        GewahltPrasidium,
        WahlzettelPrasidium,
        BrieflicheStimmabgabenPrasidium,
        LeereStimmzettelPrasidium,
        UngultigeStimmzettelPrasidium,
        GultigeStimmzettelPrasidium,
        VereinzelteStimmenPrasidium,
        AbsolutesMehrPrasidium,
        StimmbeteiligungPrasidium,
        AnteilBrieflichStimmendePrasidium,
        GemeindeId,
        Stimmberechtigte,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmrechtsausweise,
        JahrgangNum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ArtDerWahl => "art_der_wahl",
                Field::Datum => "datum",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::ListenNr => "listen_nr",
                Field::Liste => "liste",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Bisher => "bisher",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Alter => "alter",
                Field::Partei => "partei",
                Field::Beruf => "beruf",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Gewahlt => "gewahlt",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::LeereStimmzettel => "leere_stimmzettel",
                Field::UngultigeStimmzettel => "ungultige_stimmzettel",
                Field::GultigeStimmzettel => "gultige_stimmzettel",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::StimmenPrasidium => "stimmen_prasidium",
                Field::AnteilBrieflichStimmende => "anteil_brieflich_stimmende",
                Field::Prasidium => "prasidium",
                Field::KandidatenNrPraidium => "kandidaten_nr_praidium",
                Field::BisherPrasidium => "bisher_prasidium",
                Field::GewahltPrasidium => "gewahlt_prasidium",
                Field::WahlzettelPrasidium => "wahlzettel_prasidium",
                Field::BrieflicheStimmabgabenPrasidium => "briefliche_stimmabgaben_prasidium",
                Field::LeereStimmzettelPrasidium => "leere_stimmzettel_prasidium",
                Field::UngultigeStimmzettelPrasidium => "ungultige_stimmzettel_prasidium",
                Field::GultigeStimmzettelPrasidium => "gultige_stimmzettel_prasidium",
                Field::VereinzelteStimmenPrasidium => "vereinzelte_stimmen_prasidium",
                Field::AbsolutesMehrPrasidium => "absolutes_mehr_prasidium",
                Field::StimmbeteiligungPrasidium => "stimmbeteiligung_prasidium",
                Field::AnteilBrieflichStimmendePrasidium => "anteil_brieflich_stimmende_prasidium",
                Field::GemeindeId => "gemeinde_id",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::JahrgangNum => "jahrgang_num",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100102/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Zuordnung von Parzellen auf Statistische Raumeinheiten
pub mod zuordnung_von_parzellen_auf_statistische_raumeinheiten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Parzellennummer
        pub r1_nummer: Option<i64>,
        /// EGRID
        ///
        /// Eidgenössischer Grundstücksidentifikator
        pub r1_egris_e: Option<String>,
        /// Code Art Liegenschaft
        ///
        /// Code zur Art der Liegenschaft
        pub r1_art: Option<i64>,
        /// Name Art Liegenschaft
        ///
        /// Text zur Art der Liegenschaft
        pub r1_art_txt: Option<String>,
        /// Sektion
        ///
        /// Sektion des Grundbuchkreises
        pub r1_sektion: Option<String>,
        /// Bezirks-ID
        ///
        /// ID des Bezirks
        pub bez_id: Option<String>,
        /// Bezirksname
        ///
        /// Name des Bezirks
        pub bez_name: Option<String>,
        /// Wohnviertel-ID
        ///
        /// ID des Wohnviertels
        pub wov_id: Option<String>,
        /// Wohnviertelname
        ///
        /// Name des Wohnviertels
        pub wov_name: Option<String>,
        /// Block-ID
        ///
        /// ID des Blocks
        pub blo_id: Option<String>,
        /// Blockname
        ///
        /// Name des Blocks
        pub blo_label: Option<String>,
        /// Gemeindename
        ///
        /// Name der Gemeinde
        pub gemeinde_name: Option<String>,
        /// Objekt-Identifikator
        ///
        /// Eine eindeutige Identifizierungsnummer
        pub oid: Option<String>,
        /// X-Koordinate
        ///
        /// Geographische Länge in Projektion WGS 84
        pub point_x: Option<f64>,
        /// Y-Koordinate
        ///
        /// Geographische Breite in Projektion WGS 84
        pub point_y: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        R1Nummer,
        R1EgrisE,
        R1Art,
        R1ArtTxt,
        R1Sektion,
        BezId,
        BezName,
        WovId,
        WovName,
        BloId,
        BloLabel,
        GemeindeName,
        Oid,
        PointX,
        PointY,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::R1Nummer => "r1_nummer",
                Field::R1EgrisE => "r1_egris_e",
                Field::R1Art => "r1_art",
                Field::R1ArtTxt => "r1_art_txt",
                Field::R1Sektion => "r1_sektion",
                Field::BezId => "bez_id",
                Field::BezName => "bez_name",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::BloId => "blo_id",
                Field::BloLabel => "blo_label",
                Field::GemeindeName => "gemeinde_name",
                Field::Oid => "oid",
                Field::PointX => "point_x",
                Field::PointY => "point_y",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100202/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 29. November 2020
pub mod kennzahlen_der_abstimmung_vom_29_november_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100104/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schülerprognose Riehen und Bettingen
pub mod schuelerprognose_riehen_und_bettingen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Schuljahr
        ///
        /// Schuljahr August - Juli, Stichtag jeweils zu Schuljahresbeginn im September.
        pub schuljahr: Option<String>,
        /// Perimeter ID
        pub nummer: Option<i64>,
        /// Perimeter
        ///
        /// Einteilung der beiden Gemeinden in 13 Planungsperimeter. Die Schülerinnen und Schüler werden nach ihrer Wohnadresse den Perimetern zugeordnet.
        pub perimeter: Option<String>,
        /// Schulstufe
        ///
        /// Einteilung gemäss HarmoS-Schulstufen. Schulstufen 1 und 2 bezeichnen die beiden Jahre im Kindergarten, die Schulstufen 3-6 die umgangssprachlich als Primarschuljahre 1-6 bezeichneten Schulstufen.
        pub schulstufe: Option<i64>,
        /// Schülerinnen und Schüler
        ///
        /// Schülerinnen und Schüler in öffentlichen Schulen von Riehen oder Bettingen, die in einem der Perimeter in  Riehen oder Bettingen wohnhaft sind. Prognosejahre erkennt man am beistehenden Prognoseintervall. In den Prognosen nicht berücksichtigt sind künftige Arealentwicklungen.
        pub sus: Option<i64>,
        /// Unteres Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das untere Prognoseintervall bezeichnet die untere Grenze dieser Bandbreite.
        pub unteres_prognoseintervall: Option<String>,
        /// Oberes Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das obere Prognoseintervall bezeichnet die obere Grenze dieser Bandbreite.
        pub oberes_prognoseintervall: Option<String>,
        /// Typ
        ///
        /// Ist-Wert oder Resultat der Prognose
        pub typ: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Schuljahr,
        Nummer,
        Perimeter,
        Schulstufe,
        Sus,
        UnteresPrognoseintervall,
        OberesPrognoseintervall,
        Typ,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schuljahr => "schuljahr",
                Field::Nummer => "nummer",
                Field::Perimeter => "perimeter",
                Field::Schulstufe => "schulstufe",
                Field::Sus => "sus",
                Field::UnteresPrognoseintervall => "unteres_prognoseintervall",
                Field::OberesPrognoseintervall => "oberes_prognoseintervall",
                Field::Typ => "typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100122/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 13. Juni 2021
pub mod kennzahlen_der_abstimmung_vom_13_juni_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Gegenvorschlag
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Stichfrage
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag am Total der Stimmen mit gültiger Antwort
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100143/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonale Abstimmungen
pub mod kantonale_abstimmungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BS-ID
        ///
        /// Eindeutige Identifikationsnummer einer Vorlage. Sie setzt sich zusammen aus dem vierstelligen Abstimmungsjahr, der zweistelligen Laufnummer des Abstimmungstermins, und der zweistelligen Laufnummer der Vorlage.
        pub bs_id: Option<String>,
        /// Jahr
        ///
        /// Jahr der Abstimmung
        pub jahr: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub datum: Option<Date>,
        /// Laufnummer des Abstimmungstermins
        ///
        /// Laufnummer des Abstimmungstermins. Auch Termine ohne kantonale Abstimmung sind bei der chronologischen Vergabe der Laufnummer pro Kalenderjahr berücksichtigt.
        pub abstimmungstermin_nr: Option<i64>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage. Finden gleichzeitig eidgenössische Abstimmungen statt, setzen die kantonalen Vorlagen die Nummerierung fort.
        pub vorlagen_id: Option<i64>,
        /// Titel der Vorlage
        ///
        /// Offizieller Wortlaut der Vorlage gemäss Abstimmungsunterlagen.
        pub titel: Option<String>,
        /// Kurztitel
        ///
        /// Kurzform des offiziellen Wortlauts der Vorlage.
        pub kurztitel: Option<String>,
        /// Thema
        ///
        /// Betroffener Politikbereich. Klassifikation nach dem Codebook von swissvotes. Zuordnung durch das Statistische Amt Basel-Stadt.
        pub thema: Option<String>,
        /// Unterthema
        ///
        /// Betroffener Politik-Detailbereich. Klassifikation nach dem Codebook von swissvotes. Zuordnung durch das Statistische Amt Basel-Stadt.
        pub unterthema: Option<String>,
        /// Vorlagentyp
        ///
        /// Rechtsform der Vorlage. Beim fakultativen Referendum kann vom Stimmvolk mit 2000 Unterschriften (bis 1974 1000) eine Volksabstimmung über Gesetze und Grossratsbeschlüsse erwirkt werden. Bei Initiativen zu Verfassungs- oder Gesetzesvorlagen sind 3000 Unterschriften (bis Juni 1939 1000, danach 2000, von 1975 bis 2005 4000) erforderlich. Der Grosse Rat kann dem Stimmvolk einen Gegenvorschlag zu einer Initiative vorlegen. Verfassungsvorlagen unterliegen einem Abstimmungsobligatorium. Legt der Grosse Rat den Stimmberechtigten freiwillig weitere Vorlagen zur Abstimmung vor, handelt es sich um eine angeordnete Abstimmung.
        pub vorlagentyp: Option<String>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigte
        pub stimmberechtigte: Option<i64>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl abgegebener Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub stimmzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Stimmzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Stimmende
        ///
        /// Anteil der brieflich abgegebenen Stimmzettel am Total der eingelegten Stimmzettel
        pub briefliche: Option<f64>,
        /// Ergebnis
        ///
        /// Abstimmungsergebnis. Beträgt der Anteil Ja-Stimmen über 50%, gilt die Vorlage als angenommen, bei unter 50% als abgelehnt. Bei Referenden bedeutet «Angenommen» eine Bestätigung des Grossratsbeschlusses (Erfolg des Parlaments). Bei einer Ablehnung ist das Referendumskomitee erfolgreich. Bis 1911 kam nicht die Volksinitiative, sondern der Grossratsbeschluss zur Volksinitiative an die Urne. Lautete die Empfehlung des Grossen Rates «Nein», bedeutete eine Nein-Mehrheit Annahme der Initiative.
        pub ergebnis: Option<String>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leere: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub ungueltige: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub gueltige: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_stimmen: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_stimmen: Option<i64>,
        /// Ja-Anteil
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub ja_anteil: Option<f64>,
        /// Datum Grossratsbeschluss
        ///
        /// Datum des Grossratsbeschlusses
        pub grossratsbeschlussdatum: Option<Date>,
        /// Stichfragenannahmen
        ///
        /// Anzahl Stimmberechtigte, die sich bei der Stichfrage für die jeweilige Vorlage aussprechen
        pub stichfragenannahmen: Option<i64>,
        /// Stichfragenauslassung
        ///
        /// Anzahl Stimmberechtigte, die beim Stichentscheid keine gültige Antwort abgeben
        pub stichfragenauslassung: Option<i64>,
        /// Unterschriften
        ///
        /// Anzahl eingereichter Unterschriften, um Initiativen und Referenden dem Volk zur Abstimmung vorzulegen
        pub unterschriften: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BsId,
        Jahr,
        Datum,
        AbstimmungsterminNr,
        VorlagenId,
        Titel,
        Kurztitel,
        Thema,
        Unterthema,
        Vorlagentyp,
        Stimmberechtigte,
        Stimmrechtsausweise,
        Stimmzettel,
        Stimmbeteiligung,
        Briefliche,
        Ergebnis,
        Leere,
        Ungueltige,
        Gueltige,
        JaStimmen,
        NeinStimmen,
        JaAnteil,
        Grossratsbeschlussdatum,
        Stichfragenannahmen,
        Stichfragenauslassung,
        Unterschriften,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BsId => "bs_id",
                Field::Jahr => "jahr",
                Field::Datum => "datum",
                Field::AbstimmungsterminNr => "abstimmungstermin_nr",
                Field::VorlagenId => "vorlagen_id",
                Field::Titel => "titel",
                Field::Kurztitel => "kurztitel",
                Field::Thema => "thema",
                Field::Unterthema => "unterthema",
                Field::Vorlagentyp => "vorlagentyp",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Stimmzettel => "stimmzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::Briefliche => "briefliche",
                Field::Ergebnis => "ergebnis",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::JaStimmen => "ja_stimmen",
                Field::NeinStimmen => "nein_stimmen",
                Field::JaAnteil => "ja_anteil",
                Field::Grossratsbeschlussdatum => "grossratsbeschlussdatum",
                Field::Stichfragenannahmen => "stichfragenannahmen",
                Field::Stichfragenauslassung => "stichfragenauslassung",
                Field::Unterschriften => "unterschriften",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100229/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung 29. November 2020 Details
pub mod abstimmung_29_november_2020_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        WahllokId,
        GemeinId,
        GemeinName,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100103/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Monatliche Ankünfte und Logiernächte
pub mod monatliche_ankuenfte_und_logiernaechte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub datum: Option<Date>,
        /// Herkunftsland
        ///
        /// Herkunftsland des Gastes
        pub herkunftsland: Option<String>,
        /// Anzahl Ankünfte
        ///
        /// Anzahl in baselstädtischen Hotels angekommene Gäste
        pub anzankuenfte: Option<i64>,
        /// Anzahl Logiernächte
        ///
        /// Anzahl Übernachtungen in baselstädtischen Hotels
        pub anzlogiernaechte: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
        /// Monat
        pub monat: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Herkunftsland,
        Anzankuenfte,
        Anzlogiernaechte,
        Jahr,
        Monat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Herkunftsland => "herkunftsland",
                Field::Anzankuenfte => "anzankuenfte",
                Field::Anzlogiernaechte => "anzlogiernaechte",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100107/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): Ergänzte Fallzahlen ganze Schweiz
pub mod coronavirus_covid_19_ergaenzte_fallzahlen_ganze_schweiz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// Kanton
        pub abbreviation_canton_and_fl: Option<String>,
        /// Anzahl Fälle kumuliert
        ///
        /// Anzahl bestätigte Infektionen mit dem SARS-CoV-2 Virus
        pub ncumul_conf: Option<i64>,
        /// Anzahl Fälle im Spital
        ///
        /// Anzahl Personen mit COVID-19 Erkrankung, welche in einem Spital behandelt werden
        pub current_hosp: Option<i64>,
        /// Anzahl Fälle auf Intensivstation
        ///
        /// Anzahl Personen mit COVID-19 Erkrankung, welche in der Intensivstation eines Spitals behandelt werden
        pub current_icu: Option<i64>,
        /// Anzahl Genesene
        ///
        /// Anzahl Personen, die eine COVID-19-Erkrankung überstanden haben insgesamt (kumuliert)
        pub ncumul_released: Option<i64>,
        /// Anzahl Verstorbene
        ///
        /// Anzahl mit SARS-CoV-2 infizierte Verstorbene
        pub ncumul_deceased: Option<i64>,
        /// Isolierte
        ///
        /// Mit dem neuen Coronavirus infizierte Personen, welche ausserhalb des Spitals isoliert sind
        pub current_isolated: Option<i64>,
        /// Kontaktpersonen in Quarantäne
        ///
        /// Personen, welche in engem Kontakt zu einem Infizierten Fall waren und sich deshalb in Quarantäne befinden
        pub current_quarantined: Option<i64>,
        pub current_quarantined_riskareatravel: Option<i64>,
        /// Differenz Anzahl Fälle
        ///
        /// Neu gemeldete Fälle gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_conf: Option<i64>,
        /// Differenz Anzahl Genesene
        ///
        /// Neu gemeldete Genesene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_released: Option<i64>,
        /// Differenz Anzahl Verstorbene
        ///
        /// Neu gemeldete Gestorbene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_deceased: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        AbbreviationCantonAndFl,
        NcumulConf,
        CurrentHosp,
        CurrentIcu,
        NcumulReleased,
        NcumulDeceased,
        CurrentIsolated,
        CurrentQuarantined,
        CurrentQuarantinedRiskareatravel,
        NdiffConf,
        NdiffReleased,
        NdiffDeceased,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::AbbreviationCantonAndFl => "abbreviation_canton_and_fl",
                Field::NcumulConf => "ncumul_conf",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentIcu => "current_icu",
                Field::NcumulReleased => "ncumul_released",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::CurrentIsolated => "current_isolated",
                Field::CurrentQuarantined => "current_quarantined",
                Field::CurrentQuarantinedRiskareatravel => "current_quarantined_riskareatravel",
                Field::NdiffConf => "ndiff_conf",
                Field::NdiffReleased => "ndiff_released",
                Field::NdiffDeceased => "ndiff_deceased",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100085/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 9. Juni 2024
pub mod kennzahlen_der_abstimmung_vom_9_juni_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100370/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 27. September 2020
pub mod kennzahlen_der_abstimmung_vom_27_september_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100072/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Ersatzwahl Regierungspräsidium 3. März 2024
pub mod kandidierende_der_ersatzwahl_regierungspraesidium_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100334/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Bürgergemeinderatswahlen 2023
pub mod resultate_der_buergergemeinderatswahlen_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze Wahlkreis
        ///
        /// Anzahl Sitze, die für einen Wahlkreis zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aller Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Kumulation
        ///
        /// K: eine Kandidatin oder ein Kandidat auf einem unveränderten Wahlzettel ist mehrfach aufgeführt.
        pub kumulation: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Rangfolge
        ///
        /// Rangfolge innerhalb einer Liste gemäss Anzahl Stimmen (bei Stimmengleichheit entscheidet das Los).
        pub rangfolge: Option<i64>,
        /// 00 OHNE
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer Liste ohne Bezeichnung
        pub x00_ohne: Option<i64>,
        /// 01 FDP
        ///
        /// FDP. Die Liberalen Basel-Stadt und Jungfreisinnige; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x01_fdp: Option<i64>,
        /// 03 LDP
        ///
        /// LDP Liberal-Demokratische Partei Basel-Stadt und Jungliberale; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x03_ldp: Option<i64>,
        /// 04 EVP
        ///
        /// Evangelische Volkspartei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x04_evp: Option<i64>,
        /// 05 SP
        ///
        /// Sozialdemokratische Partei Basel-Stadt (SP) und JUSO; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x05_sp: Option<i64>,
        /// 07 MITTE
        ///
        /// Die Mitte Basel-Stadt (MITTE); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x07_mitte: Option<i64>,
        /// 10 GLP
        ///
        /// Grünliberale Partei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x10_glp: Option<i64>,
        /// 12 SVP
        ///
        /// Schweizerische Volkspartei Basel-Stadt (SVP); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x12_svp: Option<i64>,
        /// 17 GP
        ///
        /// Grüne Partei (GP); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x17_gp: Option<i64>,
        /// 27 BastA!
        ///
        /// Basels starke Alternative (BastA!); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x27_basta: Option<i64>,
        /// 30 Unabh.
        ///
        /// Unabhängige (Unabh.); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x30_unabh: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus unveränderten Wahlzetteln
        pub stimmen_unveranderte_wahlzettel: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus veränderten Wahlzetteln
        pub stimmen_veranderte_wahlzettel: Option<i64>,
        /// Stimmen Total aus Wahlzettel
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten
        pub stimmen_total_aus_wahlzettel: Option<i64>,
        /// Total der gültigen Wahlzettel
        pub total_der_gultigen_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Stimmbeteiligung: Berechnet als Anzahl Wahlzettel geteilt durch das Total der Stimmberechtigten
        pub stimmbeteiligung: Option<GeoPoint2d>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil brieflich Wählende: Berechnet als Anzahl Briefliche Stimmabgaben geteilt durch das Anzahl Wahlzettel.
        pub anteil_brieflich_wahlende: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        Kumulation,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Rangfolge,
        X00Ohne,
        X01Fdp,
        X03Ldp,
        X04Evp,
        X05Sp,
        X07Mitte,
        X10Glp,
        X12Svp,
        X17Gp,
        X27Basta,
        X30Unabh,
        UngestempelteWahlzettel,
        ListenNr,
        StimmenUnveranderteWahlzettel,
        StimmenVeranderteWahlzettel,
        StimmenTotalAusWahlzettel,
        TotalDerGultigenWahlzettel,
        AnteilBrieflichWahlende,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Rangfolge => "rangfolge",
                Field::X00Ohne => "00_ohne",
                Field::X01Fdp => "01_fdp",
                Field::X03Ldp => "03_ldp",
                Field::X04Evp => "04_evp",
                Field::X05Sp => "05_sp",
                Field::X07Mitte => "07_mitte",
                Field::X10Glp => "10_glp",
                Field::X12Svp => "12_svp",
                Field::X17Gp => "17_gp",
                Field::X27Basta => "27_basta",
                Field::X30Unabh => "30_unabh",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::ListenNr => "listen_nr",
                Field::StimmenUnveranderteWahlzettel => "stimmen_unveranderte_wahlzettel",
                Field::StimmenVeranderteWahlzettel => "stimmen_veranderte_wahlzettel",
                Field::StimmenTotalAusWahlzettel => "stimmen_total_aus_wahlzettel",
                Field::TotalDerGultigenWahlzettel => "total_der_gultigen_wahlzettel",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100300/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Ersatzwahl Regierungspräsidium 7. April 2024 (2. Wahlgang)
pub mod resultate_der_ersatzwahl_regierungspraesidium_7_april_2024_2_wahlgang {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1). Für zweiten Wahlgang nicht vorhanden.
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100361/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Studierende der Universität Basel nach Geschlecht und Fakultät
pub mod studierende_der_universitaet_basel_nach_geschlecht_und_fakultaet {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Das Jahr bezeichnet das Wintersemster (bis 2006) oder das Herbstsemester (seit 2007) des gegeben Jahres. Stichtag für das Wintersemester ist der 15. Dezember, für das Herbstsemester der 15. November.
        pub jahr: Option<String>,
        /// Internationale Studenten
        ///
        /// Studenten, welche vor Studienbeginn einen Wohnort im Ausland hatten.
        pub internationale_studenten: Option<i64>,
        /// Schweizer Studenten
        ///
        /// Studenten, welche vor Studienbeginn einen Wohnort in der Schweiz hatten.
        pub schweizer_studenten: Option<i64>,
        /// Studenten_total
        ///
        /// Gesamtanzahl Studenten an der Universität Basel.
        pub studenten_total: Option<i64>,
        /// Internationale Studentinnen
        ///
        /// Studentinnen, welche vor Studienbeginn einen Wohnort  im Ausland hatten.
        pub internationale_studentinnen: Option<i64>,
        /// Schweizer Studentinnen
        ///
        /// Studentinnen, welche vor Studienbeginn einen Wohnort in der Schweiz hatten.
        pub schweizer_studentinnen: Option<i64>,
        /// Studentinnen_total
        ///
        /// Gesamtanzahl Studentinnen an der Universität Basel.
        pub studentinnen_total: Option<i64>,
        /// Studierende_total
        ///
        /// Gesamtanzahl Studierende an der Universität Basel.
        pub studierende_total: Option<i64>,
        /// Theologie_m
        ///
        /// Studenten an der Theologischen Fakultät.
        pub theologie_m: Option<i64>,
        /// Theologie_f
        ///
        /// Studentinnen an der Theologischen Fakultät.
        pub theologie_f: Option<i64>,
        /// Theologie_total
        ///
        /// Gesamtanzahl Studierende an der Theologischen Fakultät.
        pub theologie_total: Option<i64>,
        /// Jurisprudenz_m
        ///
        /// Studenten an der Juristischen Fakultät.
        pub jurisprudenz_m: Option<i64>,
        /// Jurisprudenz_f
        ///
        /// Studentinnen an der Juristischen Fakultät.
        pub jurisprudenz_f: Option<i64>,
        /// Jurisprudenz_total
        ///
        /// Gesamtanzahl Studierende an der Juristischen Fakultät.
        pub jurisprudenz_total: Option<i64>,
        /// Medizin_m
        ///
        /// Studenten an der Medizinischen Fakultät.
        pub medizin_m: Option<i64>,
        /// Medizin_f
        ///
        /// Studentinnen an der Medizinischen Fakultät.
        pub medizin_f: Option<i64>,
        /// Medizin_total
        ///
        /// Gesamtanzahl Studierende an der Medizinischen Fakultät.
        pub medizin_total: Option<i64>,
        /// Philosophie1_m
        ///
        /// Studenten an der Philosophisch-Historischen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie1_m: Option<i64>,
        /// Philosophie1_f
        ///
        /// Studentinnen an der Philosophisch-Historischen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie1_f: Option<i64>,
        /// Philosophie1_total
        ///
        /// Gesamtanzahl Studierende an der Philosophisch-Historischen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie1_total: Option<i64>,
        /// Psychologie_m
        ///
        /// Studenten an der Psychologischen Fakultät (seit 2003 wird der Fachbereich Psychologie in einer eigenen Fakultät geführt und ist damit nicht mehr Teil der Philosophisch-Historischen Fakultät).
        pub psychologie_m: Option<i64>,
        /// Psychologie_f
        ///
        /// Studentinnen an der Psychologischen Fakultät (seit 2003 wird der Fachbereich Psychologie in einer eigenen Fakultät geführt und ist damit nicht mehr Teil der Philosophisch-Historischen Fakultät).
        pub psychologie_f: Option<i64>,
        /// Psychologie_total
        ///
        /// Gesamtanzahl Studierende an der Psychologischen Fakultät (seit 2003 wird der Fachbereich Psychologie in einer eigenen Fakultät geführt und ist damit nicht mehr Teil der Philosophisch-Historischen Fakultät).
        pub psychologie_total: Option<i64>,
        /// Wirtschaft_m
        ///
        /// Studenten an der Wirtschaftlichen Fakultät (seit 1995 wird der Fachbereich Wirtschaft in einer eigenen Fakultät der Wirtschaftswissenschaften geführt, davor wurde das Fach Ökonomie in der Philosophisch-Historischen Fakultät Philosophie geführt
        ///).
        pub wirtschaft_m: Option<i64>,
        /// Wirtschaft_f
        ///
        /// Studentinnen an der Wirtschaftlichen Fakultät (seit 1995 wird der Fachbereich Wirtschaft in einer eigenen Fakultät der Wirtschaftswissenschaften geführt, davor wurde das Fach Ökonomie in der Philosophisch-Historischen Fakultät Philosophie geführt).
        pub wirtschaft_f: Option<i64>,
        /// Wirtschaft_total
        ///
        /// Gesamtanzahl Studierende an der Wirtschaftlichen Fakultät (seit 1995 wird der Fachbereich Wirtschaft in einer eigenen Fakultät der Wirtschaftswissenschaften geführt, davor wurde das Fach Ökonomie in der Philosophisch-Historischen Fakultät Philosophie geführt).
        pub wirtschaft_total: Option<i64>,
        /// Philosophie2_m
        ///
        /// Studenten an der Philosophisch-Naturwissenschaftlichen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie2_m: Option<i64>,
        /// Philosophie2_f
        ///
        /// Studentinnen an derPhilosophisch-Naturwissenschaftlichen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie2_f: Option<i64>,
        /// Philosophie2_total
        ///
        /// Gesamtanzahl Studierende an der Philosophisch-Naturwissenschaftlichen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie2_total: Option<i64>,
        /// UniversitätBasel_m
        ///
        /// Studenten mit einem Studienfach, welches von mehreren Fakultäten gemeinsam angeboten wird (seit 2005 werden die Studierenden separat ausgewiesen).
        pub universitaetbasel_m: Option<i64>,
        /// UniversitätBasel_f
        ///
        /// Studentinnen mit einem Studienfach, welches von mehreren Fakultäten gemeinsam angeboten wird (seit 2005 werden die Studierenden separat ausgewiesen).
        pub universitaetbasel_f: Option<i64>,
        /// UniversitätBasel_total
        ///
        /// Gesamtanzahl Studierende mit einem Studienfach, welches von mehreren Fakultäten gemeinsam angeboten wird (seit 2005 werden die Studierenden separat ausgewiesen).
        pub universitaetbasel_total: Option<i64>,
        /// Lehrerausbildung_m
        ///
        /// Studenten in der Lehrerausbildung (Lehramtsstudierende werden von 1966 bis 2012 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub lehrerausbildung_m: Option<i64>,
        /// Lehrerausbildung_f
        ///
        /// Studentinnen in der Lehrerausbildung (Lehramtsstudierende werden von 1966 bis 2012 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden
        ///).
        pub lehrerausbildung_f: Option<i64>,
        /// Lehrerausbildung_total
        ///
        /// Gesamtanzahl Studierende in der Lehrerausbildung (Lehramtsstudierende werden von 1966 bis 2012 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub lehrerausbildung_total: Option<i64>,
        /// AdvancedStudies_m
        ///
        /// Studenten im Advanced Studies Programm der Universität Basel (seit 2004).
        pub advancedstudies_m: Option<i64>,
        /// AdvancedStudies_f
        ///
        /// Studentinnen im Advanced Studies Programm der Universität Basel (seit 2004).
        pub advancedstudies_f: Option<i64>,
        /// AdvancedStudies_total
        ///
        /// Gesamtanzahl Studierende im Advanced Studies Programm der Universität Basel (seit 2004).
        pub advancedstudies_total: Option<i64>,
        /// Bildungswissenschaften_m
        ///
        /// Studenten in der Fachrichtung Bildungswissenschaften (Studierende der Bildungswissenschaften werden seit 2016 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub bildungswissenschaften_m: Option<i64>,
        /// Bildungswissenschaften_f
        ///
        /// Studentinnen in der Fachrichtung Bildungswissenschaften (Studierende der Bildungswissenschaften werden seit 2016 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub bildungswissenschaften_f: Option<i64>,
        /// Bildungswissenschaften_total
        ///
        /// Gesamtanzahl Studierende in der Fachrichtung Bildungswissenschaften (Studierende der Bildungswissenschaften werden seit 2016 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub bildungswissenschaften_total: Option<i64>,
        /// Philosophie_m
        ///
        /// Studenten in der Philosophischen Fakultät (seit 1937 gibt es die Philosophisch-Naturwissenschaftliche Fakultät und die Philosophisch-Historische Fakultät, welche durch eine Aufspaltung der Philosophischen Fakultät entstanden sind).
        pub philosophie_m: Option<i64>,
        /// Philosophie_f
        ///
        /// Studentinnen in der Philosophischen Fakultät (seit 1937 gibt es die Philosophisch-Naturwissenschaftliche Fakultät und die Philosophisch-Historische Fakultät, welche durch eine Aufspaltung der Philosophischen Fakultät entstanden sind).
        pub philosophie_f: Option<i64>,
        /// Philosophie_total
        ///
        /// Gesamtanzahl Studierende in der Philosophischen Fakultät (seit 1937 gibt es die Philosophisch-Naturwissenschaftliche Fakultät und die Philosophisch-Historische Fakultät, welche durch eine Aufspaltung der Philosophischen Fakultät entstanden sind).
        pub philosophie_total: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        InternationaleStudenten,
        SchweizerStudenten,
        StudentenTotal,
        InternationaleStudentinnen,
        SchweizerStudentinnen,
        StudentinnenTotal,
        StudierendeTotal,
        TheologieM,
        TheologieF,
        TheologieTotal,
        JurisprudenzM,
        JurisprudenzF,
        JurisprudenzTotal,
        MedizinM,
        MedizinF,
        MedizinTotal,
        Philosophie1M,
        Philosophie1F,
        Philosophie1Total,
        PsychologieM,
        PsychologieF,
        PsychologieTotal,
        WirtschaftM,
        WirtschaftF,
        WirtschaftTotal,
        Philosophie2M,
        Philosophie2F,
        Philosophie2Total,
        UniversitaetbaselM,
        UniversitaetbaselF,
        UniversitaetbaselTotal,
        LehrerausbildungM,
        LehrerausbildungF,
        LehrerausbildungTotal,
        AdvancedstudiesM,
        AdvancedstudiesF,
        AdvancedstudiesTotal,
        BildungswissenschaftenM,
        BildungswissenschaftenF,
        BildungswissenschaftenTotal,
        PhilosophieM,
        PhilosophieF,
        PhilosophieTotal,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::InternationaleStudenten => "internationale_studenten",
                Field::SchweizerStudenten => "schweizer_studenten",
                Field::StudentenTotal => "studenten_total",
                Field::InternationaleStudentinnen => "internationale_studentinnen",
                Field::SchweizerStudentinnen => "schweizer_studentinnen",
                Field::StudentinnenTotal => "studentinnen_total",
                Field::StudierendeTotal => "studierende_total",
                Field::TheologieM => "theologie_m",
                Field::TheologieF => "theologie_f",
                Field::TheologieTotal => "theologie_total",
                Field::JurisprudenzM => "jurisprudenz_m",
                Field::JurisprudenzF => "jurisprudenz_f",
                Field::JurisprudenzTotal => "jurisprudenz_total",
                Field::MedizinM => "medizin_m",
                Field::MedizinF => "medizin_f",
                Field::MedizinTotal => "medizin_total",
                Field::Philosophie1M => "philosophie1_m",
                Field::Philosophie1F => "philosophie1_f",
                Field::Philosophie1Total => "philosophie1_total",
                Field::PsychologieM => "psychologie_m",
                Field::PsychologieF => "psychologie_f",
                Field::PsychologieTotal => "psychologie_total",
                Field::WirtschaftM => "wirtschaft_m",
                Field::WirtschaftF => "wirtschaft_f",
                Field::WirtschaftTotal => "wirtschaft_total",
                Field::Philosophie2M => "philosophie2_m",
                Field::Philosophie2F => "philosophie2_f",
                Field::Philosophie2Total => "philosophie2_total",
                Field::UniversitaetbaselM => "universitaetbasel_m",
                Field::UniversitaetbaselF => "universitaetbasel_f",
                Field::UniversitaetbaselTotal => "universitaetbasel_total",
                Field::LehrerausbildungM => "lehrerausbildung_m",
                Field::LehrerausbildungF => "lehrerausbildung_f",
                Field::LehrerausbildungTotal => "lehrerausbildung_total",
                Field::AdvancedstudiesM => "advancedstudies_m",
                Field::AdvancedstudiesF => "advancedstudies_f",
                Field::AdvancedstudiesTotal => "advancedstudies_total",
                Field::BildungswissenschaftenM => "bildungswissenschaften_m",
                Field::BildungswissenschaftenF => "bildungswissenschaften_f",
                Field::BildungswissenschaftenTotal => "bildungswissenschaften_total",
                Field::PhilosophieM => "philosophie_m",
                Field::PhilosophieF => "philosophie_f",
                Field::PhilosophieTotal => "philosophie_total",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100191/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Für Impfung angemeldete Personen nach Altersklasse
pub mod coronavirus_covid_19_fuer_impfung_angemeldete_personen_nach_altersklasse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Zeitstand
        pub date: Option<Date>,
        /// Altersklasse
        ///
        /// Altersklasse der Personen, welche sich für eine Impfung gegen SARS-CoV-2 angemeldet haben
        pub age_group: Option<String>,
        /// Termin ja/nein
        ///
        /// Angabe, ob eine angemeldete Person bereits einen Termin hat (Yes), nicht (No), oder auf Grund fehlender historischer Daten unbekannt (Unknown)
        pub has_appointments: Option<String>,
        /// Anzahl Personen
        ///
        /// Anzahl Personen in der jeweiligen Gruppe
        pub count: Option<i64>,
        /// Woche
        ///
        /// Wochennummer
        pub week: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        AgeGroup,
        HasAppointments,
        Count,
        Week,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::AgeGroup => "age_group",
                Field::HasAppointments => "has_appointments",
                Field::Count => "count",
                Field::Week => "week",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100136/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Massentests in Betrieben
pub mod coronavirus_covid_19_massentests_in_betrieben {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<i64>,
        /// Resultat
        ///
        /// Zeigt an, ob eine SARS-CoV-2-Test positiv oder negativ ausgefallen ist
        pub result: Option<String>,
        /// Pos./neg. getestete MA pro Woche
        ///
        /// Anzahl positiv resp. negativ getesteter Mitarbeiter pro Woche
        pub count: Option<i64>,
        /// Getestete MA pro Woche
        ///
        /// Anzahl getesteter Mitarbeiter pro Woche
        pub counttotal: Option<i64>,
        /// Positivitätsrate
        ///
        /// Zeigt den Prozentsatz der Tests, die positiv auf SARS-CoV-2 getestet wurden
        pub positivityratepercent: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100146/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen zu den Basler Wohnvierteln und Landgemeinden - langer Datensatz
pub mod kennzahlen_zu_den_basler_wohnvierteln_und_landgemeinden_langer_datensatz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationsjahr
        ///
        /// Jahr, in dem der Wert publiziert wurde
        pub publikationsjahr: Option<String>,
        /// Indikator_Nr
        pub indikator_nr: Option<i64>,
        /// Datenjahr
        ///
        /// Jahr, aus dem die Daten stammen
        pub datenjahr: Option<String>,
        /// Wert
        ///
        /// Wert des Indikators
        pub wert: Option<f64>,
        /// Definition des Indikators
        ///
        /// Definition des Indikators, Berechnungsgrundlage
        pub indikator_label: Option<String>,
        /// Indikator
        ///
        /// Kurzform des Indikators
        pub indikator_name: Option<String>,
        /// Wohnviertel ID
        ///
        /// Nummer des Wohnviertels (1-19) bzw. der Landgemeinde (20 und 30)
        pub wohnviertel_id: Option<i64>,
        /// Name des Wohnviertels
        ///
        /// Offizielle Bezeichnungen der 19 Basler Wohnviertel und 2 Landgemeinden
        pub wohnviertel: Option<String>,
        /// Rang
        pub rang: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Publikationsjahr,
        IndikatorNr,
        Datenjahr,
        Wert,
        IndikatorLabel,
        IndikatorName,
        WohnviertelId,
        Wohnviertel,
        Rang,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Publikationsjahr => "publikationsjahr",
                Field::IndikatorNr => "indikator_nr",
                Field::Datenjahr => "datenjahr",
                Field::Wert => "wert",
                Field::IndikatorLabel => "indikator_label",
                Field::IndikatorName => "indikator_name",
                Field::WohnviertelId => "wohnviertel_id",
                Field::Wohnviertel => "wohnviertel",
                Field::Rang => "rang",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100226/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wasserstand Grundwasser
pub mod wasserstand_grundwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Value
        ///
        /// Messwert: Grundwasserstand [m ü. M]
        pub value: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// Status
        ///
        /// Rohadaten/ungeprüfte Daten (raw)
        ///bereinigte/geprüfte Daten (cleansed)
        pub status: Option<String>,
        /// on/offline
        pub on_offline: Option<String>,
        /// Date
        ///
        /// Datum in mitteleuropäischer Winterzeit (UTC+1)
        pub date: Option<String>,
        /// Time
        ///
        /// Zeit in mitteleuropäischer Winterzeit (UTC+1)
        pub time: Option<String>,
        /// Zeitstempel in mitteleuropäischer Winterzeit (UTC+1)
        pub timestamp_text: Option<String>,
        /// StationId
        ///
        /// Katasternummer gemäss Bohrkataster
        pub stationid: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Stationnr,
        Stationname,
        Sensornr,
        Sensname,
        Value,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        Status,
        OnOffline,
        Date,
        Time,
        TimestampText,
        Stationid,
        Lat,
        Lon,
        BohrkatasterLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Stationnr => "stationnr",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Value => "value",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::Status => "status",
                Field::OnOffline => "on_offline",
                Field::Date => "date",
                Field::Time => "time",
                Field::TimestampText => "timestamp_text",
                Field::Stationid => "stationid",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::BohrkatasterLink => "bohrkataster_link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100164/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 26. September 2021 Details
pub mod abstimmung_vom_26_september_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100154/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrszähldaten Velos und Fussgänger
pub mod verkehrszaehldaten_velos_und_fussgaenger {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ZST_NR
        ///
        /// Zählstellennummer
        pub zst_nr: Option<String>,
        /// SiteCode
        ///
        /// Zählstellencode
        pub sitecode: Option<String>,
        /// SiteName
        ///
        /// Zählstellenname
        pub sitename: Option<String>,
        /// DateTimeFrom
        ///
        /// Datum und Uhrzeit Messbeginn (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimefrom: Option<OffsetDateTime>,
        /// DateTimeTo
        ///
        /// Datum und Uhrzeit Messende (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimeto: Option<OffsetDateTime>,
        /// DirectionName
        ///
        /// Richtung/Strassenseite
        pub directionname: Option<String>,
        /// LaneCode
        ///
        /// Spurnummer
        pub lanecode: Option<i64>,
        /// LaneName
        ///
        /// Spurname
        pub lanename: Option<String>,
        /// ValuesApproved
        ///
        /// Daten validiert (1 ja, 0 nein) [Validierte Verkehrszahlen sind kontrollierte und ergänzte Rohdaten. Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesapproved: Option<i64>,
        /// ValuesEdited
        ///
        /// Ersatzwerte (1 ja, 0 nein) [Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesedited: Option<i64>,
        /// TrafficType
        ///
        /// Verkehrsmittel (MIV = motorisierter Individualverkehr)
        pub traffictype: Option<String>,
        /// Total
        ///
        /// Anzahl Fahrzeuge
        pub total: Option<i64>,
        /// Year
        ///
        /// Jahr
        pub year: Option<String>,
        /// Month
        ///
        /// Monat (1=Januar, 12=Dezember)
        pub month: Option<i64>,
        /// Day
        ///
        /// Tag
        pub day: Option<i64>,
        /// Weekday
        ///
        /// Wochentag (0=Montag, 6=Sonntag)
        pub weekday: Option<i64>,
        /// HourFrom
        ///
        /// Stunde des Messbeginns
        pub hourfrom: Option<i64>,
        /// Date
        ///
        /// Datum der Messung als Text
        pub date: Option<String>,
        /// TimeFrom
        ///
        /// Zeit Messbeginn als Text
        pub timefrom: Option<String>,
        /// TimeTo
        ///
        /// Zeit Messende als Text
        pub timeto: Option<String>,
        /// DayOfYear
        ///
        /// Nummer des Tages innerhalb des aktuellen Jahres
        pub dayofyear: Option<i64>,
        /// Zst_id
        pub zst_id: Option<i64>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ZstNr,
        Sitecode,
        Sitename,
        Datetimefrom,
        Datetimeto,
        Directionname,
        Lanecode,
        Lanename,
        Valuesapproved,
        Valuesedited,
        Traffictype,
        Total,
        Year,
        Month,
        Day,
        Weekday,
        Hourfrom,
        Date,
        Timefrom,
        Timeto,
        Dayofyear,
        ZstId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ZstNr => "zst_nr",
                Field::Sitecode => "sitecode",
                Field::Sitename => "sitename",
                Field::Datetimefrom => "datetimefrom",
                Field::Datetimeto => "datetimeto",
                Field::Directionname => "directionname",
                Field::Lanecode => "lanecode",
                Field::Lanename => "lanename",
                Field::Valuesapproved => "valuesapproved",
                Field::Valuesedited => "valuesedited",
                Field::Traffictype => "traffictype",
                Field::Total => "total",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Hourfrom => "hourfrom",
                Field::Date => "date",
                Field::Timefrom => "timefrom",
                Field::Timeto => "timeto",
                Field::Dayofyear => "dayofyear",
                Field::ZstId => "zst_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100013/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerung nach Geschlecht, Heimat und Altersjahr ab 1945
pub mod bevoelkerung_nach_geschlecht_heimat_und_altersjahr_ab_1945 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Bevölkerungsstands am Ende des Jahres
        pub jahr: Option<String>,
        /// Alter
        ///
        /// Personenalter
        pub pers_alter: Option<i64>,
        /// Geschlecht
        ///
        /// Geschlecht (w: weiblich, m: männlich)
        pub geschlecht: Option<String>,
        /// Heimat
        ///
        /// CH: Bevölkerung mit schweizer Staatsangehörigkeit (Achtung: Alle Personen der Kategorie BS sind auch in der Kategorie CH enthalten.), A: Bevölkerungs mit ausländischer Staatsangehörigkeit, BS: Kantonsbürger des Kantons Basel-Stadt
        pub herkunft: Option<String>,
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        PersAlter,
        Geschlecht,
        Herkunft,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::PersAlter => "pers_alter",
                Field::Geschlecht => "geschlecht",
                Field::Herkunft => "herkunft",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100238/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): Todesfälle Basel-Stadt nach Alter und Geschlecht
pub mod coronavirus_covid_19_todesfaelle_basel_stadt_nach_alter_und_geschlecht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum der Datenveröffentlichung
        pub date: Option<Date>,
        /// Kanton
        pub area: Option<String>,
        /// Alter
        ///
        /// Alter in Jahren; [leer] = nicht veröffentlicht
        pub ageyear: Option<i64>,
        /// Alter numerisch
        ///
        /// Alter in Jahren, falls explizite eindeutige Altersangabe vorhanden
        pub ageyear_numeric: Option<i64>,
        /// Geschlecht
        ///
        /// M = männlich, F = weiblich; [leer] = nicht veröffentlicht
        pub gender: Option<String>,
        /// Anzahl Verstorbene
        ///
        /// Anzahl mit COVID-19-Erkrankung verstorbene Personen mit Wohnsitz in Basel-Stadt
        pub newdeaths: Option<i64>,
        /// Bestehende Vorerkrankung
        ///
        /// Y = bestehende Vorerkrankung, N = keine bestehende Vorerkrankung; [leer] = nicht veröffentlicht
        pub preexistingcond: Option<String>,
        /// Anzahl Verstorbene kumuliert
        ///
        /// Anzahl Verstorbene Personen bis zum aktuellen Datum
        pub ncumul_deceased: Option<i64>,
        /// ID pro Tag
        ///
        /// Eindeutige ID des Todesfalls pro Tag
        pub casenumberperday: Option<i64>,
        /// Quelle
        ///
        /// Datenquelle(n)
        pub source: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Area,
        Ageyear,
        AgeyearNumeric,
        Gender,
        Newdeaths,
        Preexistingcond,
        NcumulDeceased,
        Casenumberperday,
        Source,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Area => "area",
                Field::Ageyear => "ageyear",
                Field::AgeyearNumeric => "ageyear_numeric",
                Field::Gender => "gender",
                Field::Newdeaths => "newdeaths",
                Field::Preexistingcond => "preexistingcond",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::Casenumberperday => "casenumberperday",
                Field::Source => "source",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100076/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Regierungsratswahl 20. Oktober 2024
pub mod kandidierende_der_regierungsratswahl_20_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100386/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Zeitreihe der Belegung der Elektroauto-Ladestationen der IWB
pub mod zeitreihe_der_belegung_der_elektroauto_ladestationen_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Adresse
        ///
        /// Strasse und Hausnummer
        pub address: Option<String>,
        /// Ladeleistung
        pub power: Option<String>,
        /// Parkfeld
        ///
        /// Eine Station kann mehrere Parkfelder mit Lademöglichkeit haben
        pub parkingfield: Option<i64>,
        /// Total Parkfelder
        ///
        /// Anzahl Parkfelder der Ladestation
        pub totalparkings: Option<i64>,
        /// Status
        ///
        /// Available / Occupied (verfügbar / belegt)
        pub status: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Address,
        Power,
        Parkingfield,
        Totalparkings,
        Status,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Address => "address",
                Field::Power => "power",
                Field::Parkingfield => "parkingfield",
                Field::Totalparkings => "totalparkings",
                Field::Status => "status",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100196/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gebäudeeingänge (Gebäude- und Wohnungsregister GWR)
pub mod gebaeudeeingaenge_gebaeude_und_wohnungsregister_gwr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// EGID
        ///
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<i64>,
        /// EDID
        ///
        /// Eidgenössischer Eingangsidentifikator
        pub edid: Option<i64>,
        /// EGAID
        ///
        /// Eidgenössischer Gebäudeadressidentifikator
        pub egaid: Option<i64>,
        /// Eingangsnummer Gebäude
        pub deinr: Option<String>,
        /// ESID
        ///
        /// Eidgenössischer Strassenidentifikator
        pub esid: Option<i64>,
        /// Strassenbezeichnung
        pub strname: Option<String>,
        /// Strassenbezeichnung kurz
        pub strnamk: Option<String>,
        /// Strassenbezeichnung Index
        pub strindx: Option<String>,
        /// Strassenbezeichnung Sprache Code
        pub strsp: Option<i64>,
        /// Strassenbezeichnung Sprache Bezeichnung
        pub strsp_decoded: Option<String>,
        /// Strassenbezeichnung offiziell Code
        pub stroffiziel: Option<i64>,
        /// Strassenbezeichnung offiziell Bezeichnung
        pub stroffiziel_decoded: Option<String>,
        /// Postleitzahl
        pub dplz4: Option<i64>,
        /// Postleitzahl-Zusatzziffer
        pub dplzz: Option<i64>,
        /// Postleitzahl-Name
        pub dplzname: Option<String>,
        /// E-Eingangskoordinate
        pub dkode: Option<f64>,
        /// N-Eingangskoordinate
        pub dkodn: Option<f64>,
        pub eingang_koordinaten: Option<GeoPoint2d>,
        /// Offizielle Adresse Code
        pub doffadr: Option<i64>,
        /// Offizielle Adresse Bezeichnung
        pub doffadr_decoded: Option<String>,
        /// Exportdatum
        pub dexpdat: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Egid,
        Edid,
        Egaid,
        Deinr,
        Esid,
        Strname,
        Strnamk,
        Strindx,
        Strsp,
        StrspDecoded,
        Stroffiziel,
        StroffizielDecoded,
        Dplz4,
        Dplzz,
        Dplzname,
        Dkode,
        Dkodn,
        Doffadr,
        DoffadrDecoded,
        Dexpdat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Edid => "edid",
                Field::Egaid => "egaid",
                Field::Deinr => "deinr",
                Field::Esid => "esid",
                Field::Strname => "strname",
                Field::Strnamk => "strnamk",
                Field::Strindx => "strindx",
                Field::Strsp => "strsp",
                Field::StrspDecoded => "strsp_decoded",
                Field::Stroffiziel => "stroffiziel",
                Field::StroffizielDecoded => "stroffiziel_decoded",
                Field::Dplz4 => "dplz4",
                Field::Dplzz => "dplzz",
                Field::Dplzname => "dplzname",
                Field::Dkode => "dkode",
                Field::Dkodn => "dkodn",
                Field::Doffadr => "doffadr",
                Field::DoffadrDecoded => "doffadr_decoded",
                Field::Dexpdat => "dexpdat",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100231/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Postleitzahl seit 1979
pub mod wohnbevoelkerung_nach_postleitzahl_seit_1979 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Postleitzahl
        ///
        /// Vierstellige Postleitzahl, eingeführt 1964 durch die Schweizerische Post. Die Postleitzahl definiert den Leitweg einer Sendung auf ihrer Reise zum Bestimmungsort. In grossen Städten dient sie zudem der Sortierung nach Zustellgruppen und Filialpoststellen.
        pub postleitzahl: Option<String>,
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Postleitzahl,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Postleitzahl => "postleitzahl",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100197/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Vornamen der baselstädtischen Bevölkerung
pub mod vornamen_der_baselstaedtischen_bevoelkerung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Vorname,
        Geschlecht,
        Anzahl,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100129/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Effektiver und erwarteter täglicher Stromverbrauch
pub mod effektiver_und_erwarteter_taeglicher_stromverbrauch {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub time: Option<Date>,
        /// Stromverbrauch effektiv
        ///
        /// Tägliche Summe des viertelstündlichen Stromverbrauchs
        pub stromverbrauch: Option<f64>,
        /// Stromverbrauch erwartet
        ///
        /// Prognostizierter Wert, abhängig von Kalendertag (z.B. Ferien oder Wochentag) und Witterung
        pub forecast: Option<f64>,
        /// Differenz Stromverbrauch (effektiv-erwartet)
        ///
        /// Differenz Stromverbrauch effektiv abzüglich Stromverbrauch
        pub vgl_real_minus_forecast: Option<f64>,
        /// Prognoseintervall tief
        ///
        /// Untere Grenze des 95%-Prognoseintervalls für täglich erwarteten Stromverbrauch
        pub forecast_lowfi: Option<f64>,
        /// Prognoseintervall hoch
        ///
        /// Obere Grenze des 95%-Prognoseintervalls für täglich erwarteten Stromverbrauch
        pub forecast_highfi: Option<f64>,
        /// data split
        ///
        /// Für die Modellevaluierung wurde der Datensatz in drei Teile unterteilt. Der Trainingsdatensatz dient zum Trainieren (Train) des Modells, der Tesdatensatz (Test) zur Bewertung der Modellleistung. Der Prognosedatensatz (Prognose) enthält neue, unbekannte Daten zur Vorhersage durch das mit Training- und Testdatensatz (Train und Test) trainierte Modell.
        pub trainorforecast: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Time,
        Stromverbrauch,
        Forecast,
        VglRealMinusForecast,
        ForecastLowfi,
        ForecastHighfi,
        Trainorforecast,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Time => "time",
                Field::Stromverbrauch => "stromverbrauch",
                Field::Forecast => "forecast",
                Field::VglRealMinusForecast => "vgl_real_minus_forecast",
                Field::ForecastLowfi => "forecast_lowfi",
                Field::ForecastHighfi => "forecast_highfi",
                Field::Trainorforecast => "trainorforecast",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100245/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gemeinden
pub mod gemeinden {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ENTSTEHUNG
        pub entstehung: Option<String>,
        /// ORTSCHAFT_
        pub ortschaft: Option<String>,
        /// STATUS
        pub status: Option<i64>,
        /// STATUS_TXT
        pub status_txt: Option<String>,
        /// INAENDERUN
        pub inaenderun: Option<i64>,
        /// INAENDERU1
        pub inaenderu1: Option<String>,
        /// R1_OBJID
        pub r1_objid: Option<String>,
        /// R1_NBIDENT
        pub r1_nbident: Option<String>,
        /// R1_IDENTIF
        pub r1_identif: Option<String>,
        /// R1_BESCHRE
        pub r1_beschre: Option<String>,
        /// R1_GUELTIG
        pub r1_gueltig: Option<i64>,
        /// R1_GUELTI1
        pub r1_guelti1: Option<String>,
        /// R1_GUELTI2
        #[serde(with = "time::serde::iso8601::option")]
        pub r1_guelti2: Option<OffsetDateTime>,
        /// Name
        pub name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Entstehung,
        Ortschaft,
        Status,
        StatusTxt,
        Inaenderun,
        Inaenderu1,
        R1Objid,
        R1Nbident,
        R1Identif,
        R1Beschre,
        R1Gueltig,
        R1Guelti1,
        R1Guelti2,
        Name,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Entstehung => "entstehung",
                Field::Ortschaft => "ortschaft",
                Field::Status => "status",
                Field::StatusTxt => "status_txt",
                Field::Inaenderun => "inaenderun",
                Field::Inaenderu1 => "inaenderu1",
                Field::R1Objid => "r1_objid",
                Field::R1Nbident => "r1_nbident",
                Field::R1Identif => "r1_identif",
                Field::R1Beschre => "r1_beschre",
                Field::R1Gueltig => "r1_gueltig",
                Field::R1Guelti1 => "r1_guelti1",
                Field::R1Guelti2 => "r1_guelti2",
                Field::Name => "name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100017/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Postleitzahlenkreise
pub mod postleitzahlenkreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ENTSTEHUNG
        pub entstehung: Option<String>,
        /// PLZ6_VON
        pub plz6_von: Option<String>,
        /// STATUS
        pub status: Option<i64>,
        /// STATUS_TXT
        pub status_txt: Option<String>,
        /// INAENDERUN
        pub inaenderun: Option<i64>,
        /// INAENDERU1
        pub inaenderu1: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ZUSATZZIFF
        pub zusatzziff: Option<i64>,
        /// R1_OBJID
        pub r1_objid: Option<String>,
        /// R1_NBIDENT
        pub r1_nbident: Option<String>,
        /// R1_IDENTIF
        pub r1_identif: Option<String>,
        /// R1_BESCHRE
        pub r1_beschre: Option<String>,
        /// R1_GUELTIG
        pub r1_gueltig: Option<i64>,
        /// R1_GUELTI1
        pub r1_guelti1: Option<String>,
        /// R1_GUELTI2
        #[serde(with = "time::serde::iso8601::option")]
        pub r1_guelti2: Option<OffsetDateTime>,
        /// R2_OBJID
        pub r2_objid: Option<String>,
        /// R2_ENTSTEH
        pub r2_entsteh: Option<String>,
        /// R2_ORTSCHA
        pub r2_ortscha: Option<String>,
        /// R2_STATUS_
        pub r2_status: Option<String>,
        /// R2_INAENDE
        pub r2_inaende: Option<i64>,
        /// R2_INAEND1
        pub r2_inaend1: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Entstehung,
        Plz6Von,
        Status,
        StatusTxt,
        Inaenderun,
        Inaenderu1,
        Plz,
        Zusatzziff,
        R1Objid,
        R1Nbident,
        R1Identif,
        R1Beschre,
        R1Gueltig,
        R1Guelti1,
        R1Guelti2,
        R2Objid,
        R2Entsteh,
        R2Ortscha,
        R2Status,
        R2Inaende,
        R2Inaend1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Entstehung => "entstehung",
                Field::Plz6Von => "plz6_von",
                Field::Status => "status",
                Field::StatusTxt => "status_txt",
                Field::Inaenderun => "inaenderun",
                Field::Inaenderu1 => "inaenderu1",
                Field::Plz => "plz",
                Field::Zusatzziff => "zusatzziff",
                Field::R1Objid => "r1_objid",
                Field::R1Nbident => "r1_nbident",
                Field::R1Identif => "r1_identif",
                Field::R1Beschre => "r1_beschre",
                Field::R1Gueltig => "r1_gueltig",
                Field::R1Guelti1 => "r1_guelti1",
                Field::R1Guelti2 => "r1_guelti2",
                Field::R2Objid => "r2_objid",
                Field::R2Entsteh => "r2_entsteh",
                Field::R2Ortscha => "r2_ortscha",
                Field::R2Status => "r2_status",
                Field::R2Inaende => "r2_inaende",
                Field::R2Inaend1 => "r2_inaend1",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100016/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Invasive Neophyten
pub mod invasive_neophyten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Objekt-ID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// KART_ID
        pub kart_id: Option<String>,
        /// Fläche
        ///
        /// Fläche in m²
        pub flaeche: Option<f64>,
        /// Art
        ///
        /// Name der Art in deutsch und latein (in Klammern)
        pub art: Option<String>,
        /// Deckung
        ///
        /// Deckungsgrad in % gemäss den folgenden Klassen: <1, 1-5, 5-15, 15-25, 25-50, 50-75, 75-100.
        pub deckung: Option<String>,
        /// Abundanz
        ///
        /// Individuenzahl gemäss den folgenden Klassen: 1-10, 11-100, 101-1000, >1000.
        pub abundanz: Option<String>,
        /// Jahr
        ///
        /// Kartierungsjahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        KartId,
        Flaeche,
        Art,
        Deckung,
        Abundanz,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::KartId => "kart_id",
                Field::Flaeche => "flaeche",
                Field::Art => "art",
                Field::Deckung => "deckung",
                Field::Abundanz => "abundanz",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100043/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Handelsregister: Firmen mit Rechtsform und Standort
pub mod handelsregister_firmen_mit_rechtsform_und_standort {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Rechtsform
        ///
        /// Rechtsform der Firma
        pub company_type_de: Option<String>,
        /// Firmenname
        ///
        /// Rechtlicher Name der Firma wie im Handelsregister hinterlegt
        pub company_legal_name: Option<String>,
        /// Firma UID
        ///
        /// Unternehmens-Identifikationsnummer
        pub company_uid: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinde, in der die Firma im Handelsregister eingetragen ist. Offizieller Sitz der Firma gemäss Handelsregister.
        pub municipality: Option<String>,
        /// Adresse
        pub street: Option<String>,
        /// Zusatz
        ///
        /// Zusatz zur Adresse
        pub zusatz: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Betriebsgemeinde
        ///
        /// Physische Adresse der Firma. Es kann sich von der im Handelsregister eingetragenen Gemeinde unterscheiden.
        pub locality: Option<String>,
        /// Adresse
        ///
        /// Adresse mit der, mithilfe von einem Georeferenzierungstool, nach den Koordinaten gesucht wurde.
        pub address: Option<String>,
        /// Koordinaten
        pub coordinates: Option<GeoPoint2d>,
        /// URL Kantonaler Auszug
        ///
        /// URL zum Eintrag der Firma im kantonalen Register
        pub url_cantonal_register: Option<String>,
        /// Rechtsform URI
        ///
        /// URI (Uniform Resource Identifier) in ld.admin.ch der Rechtsform
        pub type_id: Option<String>,
        /// Firma URI
        ///
        /// URI (Uniform Resource Identifier) in ld.admin.ch/zefix des Unternehmens
        pub company_uri: Option<String>,
        /// Gemeinde URI
        ///
        /// URI (Uniform Resource Identifier) in ld.admin.ch der Gemeinde
        pub muni_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        CompanyTypeDe,
        CompanyLegalName,
        CompanyUid,
        Municipality,
        Street,
        Zusatz,
        Plz,
        Locality,
        Address,
        UrlCantonalRegister,
        TypeId,
        CompanyUri,
        MuniId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CompanyTypeDe => "company_type_de",
                Field::CompanyLegalName => "company_legal_name",
                Field::CompanyUid => "company_uid",
                Field::Municipality => "municipality",
                Field::Street => "street",
                Field::Zusatz => "zusatz",
                Field::Plz => "plz",
                Field::Locality => "locality",
                Field::Address => "address",
                Field::UrlCantonalRegister => "url_cantonal_register",
                Field::TypeId => "type_id",
                Field::CompanyUri => "company_uri",
                Field::MuniId => "muni_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100330/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Velo-Einbahnstrassen und -Gefahrenstellen
pub mod velo_einbahnstrassen_und_gefahrenstellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// RECNUM
        pub recnum: Option<i64>,
        /// ART
        pub art: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Recnum,
        Art,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Recnum => "recnum",
                Field::Art => "art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100036/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Recyclingstationen
pub mod recyclingstationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_RS
        pub id_rs: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// STATUS
        pub status: Option<i64>,
        /// ADRESSE
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<i64>,
        /// ORT
        pub ort: Option<String>,
        /// WEBSEITE
        pub webseite: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdRs,
        Name,
        Status,
        Adresse,
        Plz,
        Ort,
        Webseite,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdRs => "id_rs",
                Field::Name => "name",
                Field::Status => "status",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Webseite => "webseite",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100027/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Sauberkeitsindex pro Quartal und Wohnviertel
pub mod sauberkeitsindex_pro_quartal_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// SKI
        pub ski: Option<f64>,
        /// Quartal
        pub quartal: Option<String>,
        /// Jahr
        pub jahr: Option<String>,
        /// Quartalsnummer
        pub quartalsnummer: Option<String>,
        /// Beginn Quartal
        pub quartal_beginn: Option<Date>,
        /// Ende Quartal
        pub quartal_ende: Option<Date>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wohnviertel,
        Ski,
        Quartal,
        Jahr,
        Quartalsnummer,
        QuartalBeginn,
        QuartalEnde,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wohnviertel => "wohnviertel",
                Field::Ski => "ski",
                Field::Quartal => "quartal",
                Field::Jahr => "jahr",
                Field::Quartalsnummer => "quartalsnummer",
                Field::QuartalBeginn => "quartal_beginn",
                Field::QuartalEnde => "quartal_ende",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100362/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrsreiche Strassen (50 km/h oder mehr)
pub mod verkehrsreiche_strassen_50_km_h_oder_mehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ATTRIBUTE1
        pub attribute1: Option<i64>,
        /// VELOPLAN_T
        pub veloplan_t: Option<String>,
        /// STR_NAME
        pub str_name: Option<String>,
        /// GEMEINDE
        pub gemeinde: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Attribute1,
        VeloplanT,
        StrName,
        Gemeinde,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Attribute1 => "attribute1",
                Field::VeloplanT => "veloplan_t",
                Field::StrName => "str_name",
                Field::Gemeinde => "gemeinde",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100034/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Steile Velo-Strecken
pub mod steile_velo_strecken {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID Steigung
        ///
        /// Identifikator Steigung
        pub id_steig: Option<i64>,
        /// Steigung
        ///
        /// Kategorisierung der Steigungsstärke von 1 bis 3
        pub steigung: Option<i64>,
        /// Winkel
        ///
        /// Winkel der Steigungsgeometrie (Darstellungswinkel des Symbols auf map.geo.bs.ch)
        pub winkel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdSteig,
        Steigung,
        Winkel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdSteig => "id_steig",
                Field::Steigung => "steigung",
                Field::Winkel => "winkel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100037/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Empfohlene Schwimmbereiche im Rhein
pub mod empfohlene_schwimmbereiche_im_rhein {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {}

    impl Field {
        fn name(self) -> &'static str {
            match self {}
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100270/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Quartiertreffpunkte
pub mod quartiertreffpunkte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// QT_ID
        pub qt_id: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// STRASSE_NR
        pub strasse_nr: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ORT
        pub ort: Option<String>,
        /// KANTON
        pub kanton: Option<String>,
        /// TELEFON
        pub telefon: Option<String>,
        /// LINK
        pub link: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        QtId,
        Name,
        StrasseNr,
        Plz,
        Ort,
        Kanton,
        Telefon,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::QtId => "qt_id",
                Field::Name => "name",
                Field::StrasseNr => "strasse_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Telefon => "telefon",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100026/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baustellen in Gewässernähe
pub mod baustellen_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// IDUnique
        pub idunique: Option<String>,
        /// Sichtbar_von
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        pub sichtbar_bis: Option<Date>,
        /// Status
        pub status: Option<String>,
        /// Datum_von
        ///
        /// Datum Beginn der Baustelle
        pub datum_von: Option<Date>,
        /// Datum_bis
        ///
        /// Wenn bekannt, geplantes Ende der Baustelle. Sonst bis 31.12.2099
        pub datum_bis: Option<Date>,
        /// Titel
        ///
        /// Ort der Baustelle
        pub titel: Option<String>,
        /// Untertitel
        ///
        /// Beschreibung der Baustelle
        pub untertitel: Option<String>,
        /// Text
        ///
        /// Grund der Baustelle
        pub text: Option<String>,
        /// Image
        ///
        /// Bild
        pub image: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idunique,
        SichtbarVon,
        SichtbarBis,
        Status,
        DatumVon,
        DatumBis,
        Titel,
        Untertitel,
        Text,
        Image,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idunique => "idunique",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Status => "status",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Text => "text",
                Field::Image => "image",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100287/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Basler Index der Konsumentenpreise
pub mod basler_index_der_konsumentenpreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Erhebungsdatum
        ///
        /// Erhebungsmonat und -jahr
        pub date: Option<Date>,
        /// Erhebungsjahr
        ///
        /// Jahr des Erhebungsdatums
        pub year: Option<String>,
        /// Erhebungsmonat
        ///
        /// Monat des Erhebungsdatums
        pub month: Option<i64>,
        /// PosNo
        ///
        /// Positionsnummer; der Identifikator des BFS für die Warenposition
        pub bfsid: Option<i64>,
        /// Warenkorb-Hierarchie
        ///
        /// Aneinanderreihung der Felder Hauptgruppe bis Ebene8
        pub warenkorb_hierarchie: Option<String>,
        /// Warenkorbposition
        ///
        /// Bezeichnung der Warenkorbposition
        pub name: Option<String>,
        /// Total
        ///
        /// Erste und oberste Ebene der hierarchischen Struktur des Warenkorbs
        pub name1: Option<String>,
        /// Hauptgruppe
        ///
        /// 2. Ebene der hierarchischen Struktur des Warenkorbs
        pub name2: Option<String>,
        /// Warengruppe
        ///
        /// 3. Ebene der hierarchischen Struktur des Warenkorbs
        pub name3: Option<String>,
        /// Ebene 4
        ///
        /// 4. Ebene der hierarchischen Struktur des Warenkorbs
        pub name4: Option<String>,
        /// Ebene 5
        ///
        /// 5. Ebene der hierarchischen Struktur des Warenkorbs
        pub name5: Option<String>,
        /// Ebene 6
        ///
        /// 6. Ebene der hierarchischen Struktur des Warenkorbs
        pub name6: Option<String>,
        /// Ebene 7
        ///
        /// 7. Ebene der hierarchischen Struktur des Warenkorbs
        pub name7: Option<String>,
        /// Ebene 8
        ///
        /// 8. Ebene der hierarchischen Struktur des Warenkorbs
        pub name8: Option<String>,
        /// Historisches Gewicht
        ///
        /// Das zum Erhebungsdatum gültige Gewicht der Warenkorbposition
        pub weight: Option<f64>,
        /// Historische Tiefe der Warenkorb-Hierarchie
        ///
        /// Die zum Erhebungsdatum gültige hierarchische Tiefe der Warenkorbposition in der Warenkorb-Hierarchie
        pub depth: Option<i64>,
        /// Sortierreihenfolge
        ///
        /// Die Sortier-Reihenfolge gemäss BFS in der aktuellen Erhebung
        pub currentsortorder: Option<i64>,
        /// Position
        ///
        /// Bezeichnung der Warenkorbposition in der aktuellen Erhebung
        pub currentname: Option<String>,
        /// Gewicht aktuell
        ///
        /// Gewicht in der aktuellen Erhebung
        pub currentweight: Option<f64>,
        /// Tiefencode
        ///
        /// Tiefe der Warenkorb-Hierarchie
        pub currentdepth: Option<i64>,
        /// Indexbasis Publikationsdatum
        ///
        /// Das Datum der Revision, die zum Zeitpunkt der Erhebung dieses Indexeintrags gültig war
        pub revisiondate: Option<Date>,
        /// Indexbasis aktuell
        ///
        /// Das Datum der Revision, in der dieser Eintrag skaliert ist
        pub viewrevisiondate: Option<Date>,
        /// Indexwert
        ///
        /// Basler Index aktuell, gerundet auf 4 Nachkommastellen
        ///Indexwert x(p) für die Warenposition p in der Erhebung t.
        pub currentvalue: Option<f64>,
        /// Indexwert Vormonat
        ///
        /// Basler Index Vormonat, gerundet auf 4 Nachkommastellen
        ///Indexwert x(p, t-1) im Vormonat für eine Warenposition p in der Erhebung t.
        pub lastmonthvalue: Option<f64>,
        /// Indexwert Vorjahr
        ///
        /// Basler Index Vorjahr, gerundet auf 4 Nachkommastellen
        ///Indexwert x(p, t-12) des gleichen Monats im Vorjahr für eine Warenposition p in der Erhebung t.
        pub lastyearvalue: Option<f64>,
        /// Monatsteuerung
        ///
        /// Monatsteuerung (in %), gerundet auf 4 Nachkommastellen
        pub monthpriceincrease: Option<f64>,
        /// Jahresteuerung
        ///
        /// Jahresteuerung (in %), gerundet auf 4 Nachkommastellen
        pub yearpriceincrease: Option<f64>,
        /// relWeight
        pub relweight: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Year,
        Month,
        Bfsid,
        WarenkorbHierarchie,
        Name,
        Name1,
        Name2,
        Name3,
        Name4,
        Name5,
        Name6,
        Name7,
        Name8,
        Weight,
        Depth,
        Currentsortorder,
        Currentname,
        Currentweight,
        Currentdepth,
        Revisiondate,
        Viewrevisiondate,
        Currentvalue,
        Lastmonthvalue,
        Lastyearvalue,
        Monthpriceincrease,
        Yearpriceincrease,
        Relweight,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Year => "year",
                Field::Month => "month",
                Field::Bfsid => "bfsid",
                Field::WarenkorbHierarchie => "warenkorb_hierarchie",
                Field::Name => "name",
                Field::Name1 => "name1",
                Field::Name2 => "name2",
                Field::Name3 => "name3",
                Field::Name4 => "name4",
                Field::Name5 => "name5",
                Field::Name6 => "name6",
                Field::Name7 => "name7",
                Field::Name8 => "name8",
                Field::Weight => "weight",
                Field::Depth => "depth",
                Field::Currentsortorder => "currentsortorder",
                Field::Currentname => "currentname",
                Field::Currentweight => "currentweight",
                Field::Currentdepth => "currentdepth",
                Field::Revisiondate => "revisiondate",
                Field::Viewrevisiondate => "viewrevisiondate",
                Field::Currentvalue => "currentvalue",
                Field::Lastmonthvalue => "lastmonthvalue",
                Field::Lastyearvalue => "lastyearvalue",
                Field::Monthpriceincrease => "monthpriceincrease",
                Field::Yearpriceincrease => "yearpriceincrease",
                Field::Relweight => "relweight",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100003/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Defibrillatoren
pub mod defibrillatoren {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_DF
        pub id_df: Option<i64>,
        /// STANDORT
        pub standort: Option<String>,
        /// STRASSE
        pub strasse: Option<String>,
        /// HAUSNUMMER
        pub hausnummer: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ORT
        pub ort: Option<String>,
        /// KANTON
        pub kanton: Option<String>,
        /// VERFUEGBAR
        pub verfuegbar: Option<String>,
        /// BEMERKUNG
        pub bemerkung: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdDf,
        Standort,
        Strasse,
        Hausnummer,
        Plz,
        Ort,
        Kanton,
        Verfuegbar,
        Bemerkung,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdDf => "id_df",
                Field::Standort => "standort",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Verfuegbar => "verfuegbar",
                Field::Bemerkung => "bemerkung",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100019/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Politische Wahlkreise
pub mod politische_wahlkreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_WAHLKRE
        pub objid: Option<i64>,
        /// KUERZEL
        pub text: Option<String>,
        /// WAHLKREIS
        pub wahlkreis: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Text,
        Wahlkreis,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Text => "text",
                Field::Wahlkreis => "wahlkreis",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100025/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Politische Vorstösse
pub mod grosser_rat_politische_vorstoesse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Signatur
        ///
        /// Laufnummer eines Vorstosses
        pub signatur: Option<String>,
        /// Geschäftstyp
        ///
        /// Art des Vorstosses
        pub geschaftstyp: Option<String>,
        /// Partei
        ///
        /// Partei, welcher der Urheber oder die Urheberin eines politischen Vorstosses aktuell angehört.
        pub partei: Option<String>,
        /// Urheber/in
        ///
        /// Urheberin oder Urheber des politischen Vorstosses
        pub urheber: Option<String>,
        /// Titel
        ///
        /// Titel des Vorstosses
        pub titel: Option<String>,
        /// Beginn-Datum
        ///
        /// Datum, an welchem ein Vorstoss an den Regierungsrat überwiesen wurde.
        pub beginn_datum: Option<Date>,
        /// Ende
        ///
        /// Datum, an welchem ein Geschäft den Status abgeschlossen erhält.
        pub ende: Option<Date>,
        /// Thema 1
        ///
        /// Unterthema des Themenbereichs 1
        pub thema_1: Option<String>,
        /// Thema 2
        ///
        /// Unterthema des Themenbereichs 2
        pub thema_2: Option<String>,
        /// Schwerpunkt
        ///
        /// Thematischer Schwerpunkt aus Sicht der Kantons- und Stadtentwicklung
        pub schwerpunkt: Option<String>,
        /// Geschäft
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub geschaft: Option<String>,
        /// Status
        ///
        /// A = Abgeschlossen; B = in Bearbeitung
        pub status: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Signatur,
        Geschaftstyp,
        Partei,
        Urheber,
        Titel,
        BeginnDatum,
        Ende,
        Thema1,
        Thema2,
        Schwerpunkt,
        Geschaft,
        Status,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Signatur => "signatur",
                Field::Geschaftstyp => "geschaftstyp",
                Field::Partei => "partei",
                Field::Urheber => "urheber",
                Field::Titel => "titel",
                Field::BeginnDatum => "beginn_datum",
                Field::Ende => "ende",
                Field::Thema1 => "thema_1",
                Field::Thema2 => "thema_2",
                Field::Schwerpunkt => "schwerpunkt",
                Field::Geschaft => "geschaft",
                Field::Status => "status",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100086/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Touristische Velorouten
pub mod touristische_velorouten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// OBJECTID
        pub objectid: Option<i64>,
        /// INFORMATIO
        pub informatio: Option<String>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// ROUTENBEZ
        pub routenbez: Option<String>,
        /// RBESCHREIB
        pub rbeschreib: Option<String>,
        /// RICHTUNG
        pub richtung: Option<String>,
        /// SHAPE_LENG
        pub shape_leng: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Objectid,
        Informatio,
        Kategorie,
        Routenbez,
        Rbeschreib,
        Richtung,
        ShapeLeng,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Objectid => "objectid",
                Field::Informatio => "informatio",
                Field::Kategorie => "kategorie",
                Field::Routenbez => "routenbez",
                Field::Rbeschreib => "rbeschreib",
                Field::Richtung => "richtung",
                Field::ShapeLeng => "shape_leng",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100033/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Alltagsvelorouten
pub mod alltagsvelorouten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// OBJECTID
        pub objectid: Option<i64>,
        /// INFORMATIO
        pub informatio: Option<String>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// ROUTENBEZ
        pub routenbez: Option<String>,
        /// RBESCHREIB
        pub rbeschreib: Option<String>,
        /// RICHTUNG
        pub richtung: Option<String>,
        /// SHAPE_LENG
        pub shape_leng: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Objectid,
        Informatio,
        Kategorie,
        Routenbez,
        Rbeschreib,
        Richtung,
        ShapeLeng,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Objectid => "objectid",
                Field::Informatio => "informatio",
                Field::Kategorie => "kategorie",
                Field::Routenbez => "routenbez",
                Field::Rbeschreib => "rbeschreib",
                Field::Richtung => "richtung",
                Field::ShapeLeng => "shape_leng",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100032/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bio-Klappen
pub mod bio_klappen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_BK
        pub id_bk: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// PLZ
        pub plz: Option<i64>,
        /// ORT
        pub ort: Option<String>,
        /// WEBSEITE
        pub webseite: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdBk,
        Name,
        Plz,
        Ort,
        Webseite,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdBk => "id_bk",
                Field::Name => "name",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Webseite => "webseite",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100028/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Statistische Raumeinheiten: Blöcke
pub mod statistische_raumeinheiten_bloecke {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BLO_ID
        pub blo_id: Option<String>,
        /// BLO_LABEL
        pub blo_label: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// BEZ_ID
        pub bez_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BloId,
        BloLabel,
        WovId,
        BezId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BloId => "blo_id",
                Field::BloLabel => "blo_label",
                Field::WovId => "wov_id",
                Field::BezId => "bez_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100040/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung 27. September 2020 Details
pub mod abstimmung_27_september_2020_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100071/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonaler Stromverbrauch
pub mod kantonaler_stromverbrauch {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start der Messung
        ///
        /// Startzeitpunkt der Messperiode
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp_interval_start: Option<OffsetDateTime>,
        /// Start der Messung (Text)
        pub timestamp_interval_start_text: Option<String>,
        /// Stromverbrauch
        ///
        /// Stromverbrauch innerhalb des Viertelstundenintervalls
        pub stromverbrauch_kwh: Option<f64>,
        /// Grundversorgte Kunden
        ///
        /// Stromverbrauch durch Kunden in der Grundversorgung
        pub grundversorgte_kunden_kwh: Option<f64>,
        /// Freie Kunden
        ///
        /// Stromverbrauch durch Kunden, welche Strom im freien Markt beziehen
        pub freie_kunden_kwh: Option<f64>,
        /// Jahr
        ///
        /// Jahr als Text
        pub year: Option<String>,
        /// Monat
        ///
        /// Monat (1 = Januar, etc.)
        pub month: Option<i64>,
        /// Tag
        pub day: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag als Zahl (0 = Montag, 1 = Dienstag, etc.)
        pub weekday: Option<i64>,
        /// Tag des Jahres
        ///
        /// Tag innerhalb des Jahres (1. Januar = 1, etc.)
        pub dayofyear: Option<i64>,
        /// Quartal
        ///
        /// Quartal des Jahres (1, 2, 3, 4)
        pub quarter: Option<i64>,
        /// Woche des Jahres
        ///
        /// Woche (1, 2, 3, etc.)
        pub weekofyear: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TimestampIntervalStart,
        TimestampIntervalStartText,
        StromverbrauchKwh,
        GrundversorgteKundenKwh,
        FreieKundenKwh,
        Year,
        Month,
        Day,
        Weekday,
        Dayofyear,
        Quarter,
        Weekofyear,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TimestampIntervalStart => "timestamp_interval_start",
                Field::TimestampIntervalStartText => "timestamp_interval_start_text",
                Field::StromverbrauchKwh => "stromverbrauch_kwh",
                Field::GrundversorgteKundenKwh => "grundversorgte_kunden_kwh",
                Field::FreieKundenKwh => "freie_kunden_kwh",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Dayofyear => "dayofyear",
                Field::Quarter => "quarter",
                Field::Weekofyear => "weekofyear",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100233/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// BachApp: Infos - Allgemein
pub mod bachapp_infos_allgemein {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        pub sichtbar_bis: Option<Date>,
        /// Titel
        ///
        /// Informationstext
        pub titel: Option<String>,
        /// Untertitel
        ///
        /// Informationstext
        pub untertitel: Option<String>,
        /// Text
        ///
        /// Ausführlicher Informationstext
        pub text: Option<String>,
        /// Image_Top
        pub image_top: Option<String>,
        /// Fischli_Anrede
        pub fischli_anrede: Option<String>,
        /// Fischli_Kurztext
        pub fischli_kurztext: Option<String>,
        /// Fischli_Onboarding
        pub fischli_onboarding: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Titel,
        Untertitel,
        Text,
        ImageTop,
        FischliAnrede,
        FischliKurztext,
        FischliOnboarding,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Text => "text",
                Field::ImageTop => "image_top",
                Field::FischliAnrede => "fischli_anrede",
                Field::FischliKurztext => "fischli_kurztext",
                Field::FischliOnboarding => "fischli_onboarding",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100246/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schulwegsicherheit: Strassenquerungen
pub mod schulwegsicherheit_strassenquerungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// ID
        ///
        /// Laufnummer
        pub id: Option<i64>,
        /// Strassenkategorie
        ///
        /// Schulwegrelevante Strassenkategorie
        pub strkat: Option<String>,
        /// Bewertung
        ///
        /// Bewertung der Strassenquerung bezgl. Sicherheit
        pub bewertung: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
        /// Tram
        ///
        /// Tramverkehr vorhanden
        pub tram: Option<String>,
        /// Konfliktgrün
        ///
        /// Konfliktgrün besteht dann, wenn eine Strasse und die Fussgänger über die Querstrasse (also parallel zur Grünrichtung) gleichzeitig grün haben.
        pub konfliktgr: Option<String>,
        /// Lichtsignalanlage
        ///
        /// Verkehrsregelungsanlage VRA ("Ampel") vorhanden
        pub vra: Option<String>,
        /// Vortritt-Typ
        ///
        /// Art / Grund des Fussgänger-Vortritts
        pub vortrtyp: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Id,
        Strkat,
        Bewertung,
        Bemerkung,
        Tram,
        Konfliktgr,
        Vra,
        Vortrtyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Id => "id",
                Field::Strkat => "strkat",
                Field::Bewertung => "bewertung",
                Field::Bemerkung => "bemerkung",
                Field::Tram => "tram",
                Field::Konfliktgr => "konfliktgr",
                Field::Vra => "vra",
                Field::Vortrtyp => "vortrtyp",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100053/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schulwegsicherheit: Fusswege
pub mod schulwegsicherheit_fusswege {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// ID
        ///
        /// Laufnummer
        pub id: Option<i64>,
        /// Fusswegtyp
        ///
        /// Schulwegrelevante Strassenkategorie. Begriffserklärung:
        ///ÖV-Station: Verkehrsinsel für ÖV-Haltestelle; Platz: meist ohne eindeutige Achsführung; Trottoirallee: mind. 2 Grünrabatten mit unterschiedlichen Troittoirspuren
        pub typ: Option<String>,
        /// Strassenkategorie
        ///
        /// Schulwegrelevante Strassenkategorie
        pub strkat: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Id,
        Typ,
        Strkat,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Id => "id",
                Field::Typ => "typ",
                Field::Strkat => "strkat",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100056/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Statistische Raumeinheiten: Blockseiten
pub mod statistische_raumeinheiten_blockseiten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BLS_ID
        pub bls_id: Option<String>,
        /// BLS_LABEL
        pub bls_label: Option<String>,
        /// BLS_NAME
        pub bls_name: Option<String>,
        /// STR_CODE
        pub str_code: Option<i64>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// BEZ_ID
        pub bez_id: Option<String>,
        /// BLO_ID
        pub blo_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BlsId,
        BlsLabel,
        BlsName,
        StrCode,
        WovId,
        BezId,
        BloId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BlsId => "bls_id",
                Field::BlsLabel => "bls_label",
                Field::BlsName => "bls_name",
                Field::StrCode => "str_code",
                Field::WovId => "wov_id",
                Field::BezId => "bez_id",
                Field::BloId => "blo_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100041/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rheinüberwachungsstation: Umweltanalyse Schwebstoffe
pub mod rheinueberwachungsstation_umweltanalyse_schwebstoffe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in WPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in WPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme. Dauer codiert nach Konvention der Internationalen Kommission zum Schutz des Rheins (IKSR) 1M =24h; 14M=336h; 28M=672; 1M14 24h Mischprobe alle 14Tage; Sammelprobe=Dauer variabel abhängig von Schwebstoffanteil. MS steht für Mischung Stahl, MK für Mischung Kunststoff. E steht für Einzelmessung, M für Mischprobenentnahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probeentnahme.
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100068/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Grossratswahlen nach Alter, Geschlecht und Liste seit 2020
pub mod kandidierende_der_grossratswahlen_nach_alter_geschlecht_und_liste_seit_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Altersgruppe
        ///
        /// Altersgruppe Ende Wahljahr (berechnet als Wahljahr - Jahrgang)
        pub altersgruppe: Option<String>,
        /// Listenkurzbezeichnung
        ///
        /// Abkürzung der Liste
        pub listenkurzbezeichnung: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kandidierende
        pub anzahl: Option<i64>,
        /// Anteil
        ///
        /// Anteil im Wahljahr in %
        pub anteil: Option<f64>,
        /// Anteil in Altersgruppe
        ///
        /// Anteil im Wahljahr und in Altersgruppe in %
        pub anteil_altersgruppe: Option<f64>,
        /// Anteil in Liste
        ///
        /// Anteil im Wahljahr und in Liste in %
        pub anteil_liste: Option<f64>,
        /// Listen nach Frauenanteil
        pub frauenanteil_liste: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Altersgruppe,
        Listenkurzbezeichnung,
        Geschlecht,
        Anzahl,
        Anteil,
        AnteilAltersgruppe,
        AnteilListe,
        FrauenanteilListe,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Altersgruppe => "altersgruppe",
                Field::Listenkurzbezeichnung => "listenkurzbezeichnung",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
                Field::Anteil => "anteil",
                Field::AnteilAltersgruppe => "anteil_altersgruppe",
                Field::AnteilListe => "anteil_liste",
                Field::FrauenanteilListe => "frauenanteil_liste",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100392/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Grossratswahlen nach Geschlecht seit 1968
pub mod kandidierende_der_grossratswahlen_nach_geschlecht_seit_1968 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Total
        ///
        /// Total Kandidierende
        pub total: Option<f64>,
        /// Frauen
        ///
        /// Anzahl weibliche Kandidierende
        pub frauen: Option<f64>,
        /// Männer
        ///
        /// Anzahl männliche Kandidierende
        pub manner: Option<f64>,
        /// Frauenanteil Kandidierende
        ///
        /// Anzahl Kandidatinnen / Total Kandidierende
        pub frauenanteil_kand: Option<f64>,
        /// Frauenanteil Gewählte
        ///
        /// Anzahl weibliche Gewählte / Anzahl Sitze im Grossen Rat (aktuell 100)
        pub frauenanteil_gew: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Total,
        Frauen,
        Manner,
        FrauenanteilKand,
        FrauenanteilGew,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Total => "total",
                Field::Frauen => "frauen",
                Field::Manner => "manner",
                Field::FrauenanteilKand => "frauenanteil_kand",
                Field::FrauenanteilGew => "frauenanteil_gew",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100391/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Teilhaltestellen des öffentlichen Verkehrs
pub mod teilhaltestellen_des_oeffentlichen_verkehrs {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_Teilhaltestelle
        ///
        /// Eindeutiger Identifikator der Teilhaltestellen
        pub thst_nr: Option<String>,
        /// Haltestellen-Nr
        ///
        /// Nummer der Haltestelle nach BAV
        pub hst_nr: Option<String>,
        /// Haltestellen_Name
        ///
        /// Name der Haltestelle
        pub haltestl: Option<String>,
        /// Gebiet
        ///
        /// Gebiet. Wertebereich: Aargau (AG), Basel-Landschaft (BL), Basel-Stadt (BS), Deutschland (D), Frankreich (F), Jura (JU), Solothurn (SO).
        pub kt: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Haltestellenart
        ///
        /// Art der Haltestelle
        pub art: Option<String>,
        /// Haltestellentyp
        ///
        /// Typ der Haltestelle
        pub typ: Option<String>,
        /// Tramlinien
        ///
        /// Tramlinien, welche eine Teilhaltestelle bedienen
        pub tramlinien: Option<String>,
        /// Buslinien
        ///
        /// Buslinien, welche eine Teilhaltestelle bedienen
        pub buslinien: Option<String>,
        /// Fahrplan
        ///
        /// Link zum Fahrplan
        pub fahrplan: Option<String>,
        /// Nachtlinien
        ///
        /// Nachtlinien, welche eine Teilhaltestelle bedienen
        pub nachtlin: Option<String>,
        /// Tramzugang
        ///
        /// Zugangsmöglichkeit für Elektrorollstühle bei Tramhaltestellen; ja = hohe Kante (27 cm)
        pub tramzugang: Option<String>,
        /// Buszugang
        ///
        /// Zugangsmöglichkeit für Elektrorollstühle bei Bushaltestellen; ja = hohe Kante (22 cm)
        pub buszugang: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ThstNr,
        HstNr,
        Haltestl,
        Kt,
        Richtung,
        Art,
        Typ,
        Tramlinien,
        Buslinien,
        Fahrplan,
        Nachtlin,
        Tramzugang,
        Buszugang,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ThstNr => "thst_nr",
                Field::HstNr => "hst_nr",
                Field::Haltestl => "haltestl",
                Field::Kt => "kt",
                Field::Richtung => "richtung",
                Field::Art => "art",
                Field::Typ => "typ",
                Field::Tramlinien => "tramlinien",
                Field::Buslinien => "buslinien",
                Field::Fahrplan => "fahrplan",
                Field::Nachtlin => "nachtlin",
                Field::Tramzugang => "tramzugang",
                Field::Buszugang => "buszugang",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100065/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Liniennetz des öffentlichen Verkehrs
pub mod liniennetz_des_oeffentlichen_verkehrs {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_Linie
        ///
        /// Eindeutiger Identifikator der Linien
        pub l_nr: Option<String>,
        /// Liniennummer
        pub liniennmr: Option<String>,
        /// Strecke
        pub strecke: Option<String>,
        /// Hin_Rueckweg
        ///
        /// Hin- und Rückweg
        pub hinrueck: Option<String>,
        /// Fahrzeug
        ///
        /// Transportmittel
        pub fahrzeug: Option<String>,
        /// Angebot
        ///
        /// Zeitraum, in welchem das Angebot besteht
        pub angebot: Option<String>,
        /// Transportunternehmen
        ///
        /// Name des Transportunternehmens
        pub tu: Option<String>,
        /// Shape_Length
        ///
        /// Liniengeometrie
        pub shp_length: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        LNr,
        Liniennmr,
        Strecke,
        Hinrueck,
        Fahrzeug,
        Angebot,
        Tu,
        ShpLength,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::LNr => "l_nr",
                Field::Liniennmr => "liniennmr",
                Field::Strecke => "strecke",
                Field::Hinrueck => "hinrueck",
                Field::Fahrzeug => "fahrzeug",
                Field::Angebot => "angebot",
                Field::Tu => "tu",
                Field::ShpLength => "shp_length",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100064/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Haltestellen des öffentlichen Verkehrs
pub mod haltestellen_des_oeffentlichen_verkehrs {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Haltestellennummer
        ///
        /// Eindeutiger Identifikator der Haltestellen nach BAV
        pub hst_nr: Option<String>,
        /// Haltestellenname
        ///
        /// Haltestellenname nach BAV
        pub name: Option<String>,
        /// Angezeigter_Name
        ///
        /// Angezeigter Name der Haltestelle
        pub angezname: Option<String>,
        /// Transportunternehmen_Nummer
        ///
        /// Nummer des Transportunternehmens nach BAV
        pub tu_nr: Option<String>,
        /// Transportunternehmen_Name
        ///
        /// Name des Transportunternehmens
        pub tu: Option<String>,
        /// Gemeindenummer
        ///
        /// Gemeindenummer nach BFS
        pub gde_nr: Option<i64>,
        /// Gemeinde_Name
        ///
        /// Gemeinde
        pub gde: Option<String>,
        /// Gebiet
        ///
        /// Gebiet. Wertebereich: Aargau (AG), Basel-Landschaft (BL), Basel-Stadt (BS), Deutschland (D), Frankreich (F), Jura (JU), Solothurn (SO).
        pub kt: Option<String>,
        /// Höhe
        ///
        /// Höhe in m ü. M. (Angabe nach BAV)
        pub hoehe: Option<i64>,
        /// Haltestellenart
        ///
        /// Art der Haltestelle
        pub hstart: Option<String>,
        /// Haltestellentyp
        ///
        /// Typ der Haltestelle
        pub art: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        HstNr,
        Name,
        Angezname,
        TuNr,
        Tu,
        GdeNr,
        Gde,
        Kt,
        Hoehe,
        Hstart,
        Art,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::HstNr => "hst_nr",
                Field::Name => "name",
                Field::Angezname => "angezname",
                Field::TuNr => "tu_nr",
                Field::Tu => "tu",
                Field::GdeNr => "gde_nr",
                Field::Gde => "gde",
                Field::Kt => "kt",
                Field::Hoehe => "hoehe",
                Field::Hstart => "hstart",
                Field::Art => "art",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100063/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Eheschliessungen nach Trauungsdatum
pub mod eheschliessungen_nach_trauungsdatum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Trauungsdatum
        ///
        /// Datum der Trauung
        pub trauungsdat: Option<Date>,
        /// Jahr
        ///
        /// Jahr der Trauung
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat der Trauung
        pub monat: Option<i64>,
        /// Woche
        ///
        /// Woche im Jahr in welcher die Trauung stattfand
        pub woche_in_jahr: Option<i64>,
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche in welcher die Trauung stattfand
        pub datum_wochenstart_trauungsdatum: Option<Date>,
        /// Tag im Jahr
        ///
        /// Tag im Jahr an welchem die Trauung stattfand
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag an welchem die Trauung stattfand
        pub wochentag: Option<String>,
        /// Alter der Frau
        ///
        /// Alter der Frau bei der Trauung
        pub persalter_frau_vollendet: Option<i64>,
        /// Alter des Mannes
        ///
        /// Alter des Mannes bei der Trauung
        pub persalter_mann_vollendet: Option<i64>,
        /// Namenswahl der Frau
        pub namenswahl_frau: Option<String>,
        /// Namenswahl des Mannes
        pub namenswahl_mann: Option<String>,
        /// Staatsangehörigkeit der Frau
        pub nationalitat_frau: Option<String>,
        /// Staatsangehörigkeit des Mannes
        pub nationalitat_mann: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Trauungen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Trauungsdat,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartTrauungsdatum,
        TagInJahr,
        Wochentag,
        PersalterFrauVollendet,
        PersalterMannVollendet,
        NamenswahlFrau,
        NamenswahlMann,
        NationalitatFrau,
        NationalitatMann,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Trauungsdat => "trauungsdat",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartTrauungsdatum => "datum_wochenstart_trauungsdatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::PersalterFrauVollendet => "persalter_frau_vollendet",
                Field::PersalterMannVollendet => "persalter_mann_vollendet",
                Field::NamenswahlFrau => "namenswahl_frau",
                Field::NamenswahlMann => "namenswahl_mann",
                Field::NationalitatFrau => "nationalitat_frau",
                Field::NationalitatMann => "nationalitat_mann",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100156/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Umweltanalyse Grundwasser
pub mod umweltanalyse_grundwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Geo Point
        ///
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probenahme.
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100067/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Vornamen der Neugeborenen nach Geschlecht
pub mod vornamen_der_neugeborenen_nach_geschlecht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Geburtsjahr, in dem das Kind den Vornamen erhalten hat
        pub jahr: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht des Kindes (m oder w)
        pub geschlecht: Option<String>,
        /// Vorname
        ///
        /// Erster Vorname des Kindes
        pub vorname: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kinder, die diesen spezifischen Vornamen in einem bestimmten Jahr tragen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Geschlecht,
        Vorname,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Geschlecht => "geschlecht",
                Field::Vorname => "vorname",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100192/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gasverbrauch im Versorgungsgebiet der IWB
pub mod gasverbrauch_im_versorgungsgebiet_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start der Messung
        ///
        /// Startzeitpunkt der Messperiode
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Gasverbrauch
        ///
        /// Gasverbrauch innerhalb des Stundenintervalls
        pub value: Option<f64>,
        /// Datum
        ///
        /// Tag der Messung
        pub date: Option<Date>,
        /// Zeit
        ///
        /// Startuhrzeit der Messung
        pub time: Option<String>,
        /// Jahr
        ///
        /// Jahr als Text
        pub year: Option<String>,
        /// Monat
        ///
        /// Monat (1 = Januar, etc.)
        pub month: Option<i64>,
        /// Tag
        pub day: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag als Zahl (0 = Montag, 1 = Dienstag, etc.)
        pub weekday: Option<i64>,
        /// Tag des Jahres
        ///
        /// Tag innerhalb des Jahres (1. Januar = 1, etc.)
        pub dayofyear: Option<i64>,
        /// Quartal
        ///
        /// Quartal des Jahres (1, 2, 3, 4)
        pub quarter: Option<i64>,
        /// Woche des Jahres
        ///
        /// Woche (1, 2, 3, etc.)
        pub weekofyear: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Value,
        Date,
        Time,
        Year,
        Month,
        Day,
        Weekday,
        Dayofyear,
        Quarter,
        Weekofyear,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Value => "value",
                Field::Date => "date",
                Field::Time => "time",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Dayofyear => "dayofyear",
                Field::Quarter => "quarter",
                Field::Weekofyear => "weekofyear",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100304/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Umweltanalyse Oberflächengewässer
pub mod umweltanalyse_oberflaechengewaesser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Geo Point
        ///
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme. Dauer codiert nach Konvention der Internationalen Kommission zum Schutz des Rheins (IKSR) 1M =24h; 14M=336h; 28M=672; 1M14 24h Mischprobe alle 14Tage; Sammelprobe=Dauer variabel abhängig von Schwebstoffanteil. MS steht für Mischung Stahl, MK für Mischung Kunststoff. E steht für Einzelmessung, M für Mischprobenentnahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probenahme.
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100066/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Vorgänge von Geschäften
pub mod grosser_rat_vorgaenge_von_geschaeften {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Beschlussnummer
        ///
        /// Nummer des Beschlusses des Vorgangs
        pub beschlnr: Option<String>,
        /// Vorgangsnummer
        ///
        /// Nummer des Vorgangs
        pub nummer: Option<String>,
        /// Vermerk
        ///
        /// Vermerk zum Vorgang
        pub vermerk: Option<String>,
        /// Sitzungsnummer
        ///
        /// Nummer der Sitzung, an der der Vorgang bearbeitet wurde
        pub siz_nr: Option<String>,
        /// Sitzungsdatum
        ///
        /// Datum der Sitzung, an der der Vorgang behandelt wurde
        pub siz_datum: Option<Date>,
        /// Laufnummer Geschäft
        ///
        /// Laufnummer des Geschäfts zum zugehörigen Vorgang
        pub laufnr_ges: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Geschäfts zum zugehörigen Vorgang
        pub signatur_ges: Option<String>,
        /// Status Geschäft
        ///
        /// Status des Geschäfts zum zugehörigen Vorgang (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Geschäfts zum zugehörigen Vorgang
        pub titel_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Geschäfts zum zugehörigen Vorgang
        pub ga_rr_gr: Option<String>,
        /// Geschäft grosserrat.bs.ch
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach aktuellem Geschäft.
        pub url_geschaeft_ods: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Beschlnr,
        Nummer,
        Vermerk,
        SizNr,
        SizDatum,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        GaRrGr,
        UrlGes,
        UrlGeschaeftOds,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Beschlnr => "beschlnr",
                Field::Nummer => "nummer",
                Field::Vermerk => "vermerk",
                Field::SizNr => "siz_nr",
                Field::SizDatum => "siz_datum",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100314/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Hospitalisierte in baselstädtischen Spitälern
pub mod coronavirus_covid_19_hospitalisierte_in_baselstaedtischen_spitaelern {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// Hospitalisierte total
        ///
        /// Anzahl in baselstädtischen Spitälern hospitalisierte Personen mit positivem Testresultat auf SARS-CoV-2.
        pub current_hosp: Option<i64>,
        /// Hospitalisierte mit Wohnsitz in Basel-Stadt
        ///
        /// Anzahl in baselstädtischen Spitälern hospitalisierte Personen mit Wohnsitz im Kanton Basel-Stadt und positivem Testresultat auf SARS-CoV-2.
        pub current_hosp_resident: Option<i64>,
        /// Hospitalisierte ausserkantonal und international
        ///
        /// Anzahl in baselstädtischen Spitälern hospitalisierte Personen mit ausserkantonalem oder internationalem Wohnsitz und positivem Testresultat auf SARS-CoV-2.
        pub current_hosp_non_resident: Option<i64>,
        /// Intensivstationäre Patienten
        ///
        /// Anzahl auf Intensivpflegestationen in baselstädtischen Spitälern hospitalisierten Personen mit positivem Testresultat auf SARS-CoV-2.
        pub current_icu: Option<i64>,
        /// Hospitalisierte auf intermediate care-Station
        ///
        /// Anzahl auf intermediate care-Stationen in baselstädtischen Spitälern hospitalisierte Personen mit positivem Testresultat auf SARS-CoV-2.
        pub imcu: Option<f64>,
        /// Hospitalisierte auf Normalstation
        ///
        /// Anzahl auf Normalstationen in baselstädtischen Spitälern hospitalisierte Personen mit positivem Testresultat auf SARS-CoV-2.
        pub normalstation: Option<f64>,
        /// Daten komplett
        ///
        /// True: Daten aller Spitäler sind für den entsprechenden Tag erfasst. False: Daten mindestens eines Spitals fehlen für den entsprechenden Tag.
        pub data_from_all_hosp: Option<String>,
        /// Daten plausibel
        ///
        /// True: Analyse der Daten hat keine Auffälligkeiten ergeben. False: Daten auffällig, sollten genau kontrolliert werden vor dem Gebrauch.
        pub data_plausible: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        CurrentHosp,
        CurrentHospResident,
        CurrentHospNonResident,
        CurrentIcu,
        Imcu,
        Normalstation,
        DataFromAllHosp,
        DataPlausible,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentHospResident => "current_hosp_resident",
                Field::CurrentHospNonResident => "current_hosp_non_resident",
                Field::CurrentIcu => "current_icu",
                Field::Imcu => "imcu",
                Field::Normalstation => "normalstation",
                Field::DataFromAllHosp => "data_from_all_hosp",
                Field::DataPlausible => "data_plausible",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100109/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Interessensbindungen Ratsmitglieder
pub mod grosser_rat_interessensbindungen_ratsmitglieder {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Rubrik
        ///
        /// Rubrik der Interessensbindung (Führung und Aufsicht oder staatliche Kommission)
        pub rubrik: Option<String>,
        /// Interessensbindung
        ///
        /// Name der zugehörigen Interessensbindung
        pub intr_bind: Option<String>,
        /// Funktion Ratsmitglied
        ///
        /// Funktion des Grossratsmitglieds in der Interessensbindung
        pub funktion: Option<String>,
        /// Interessensbindung und Funktion
        ///
        /// Name der zugehörigen Interessensbindung und Funktion des Grossratsmitglied
        pub text: Option<String>,
        /// Anrede
        ///
        /// Anrede des Grossratsmitglieds nach amtlichem Geschlecht
        pub anrede: Option<String>,
        /// Name Ratsmitglied
        ///
        /// Nachname des Grossratsmitglieds
        pub name: Option<String>,
        /// Vorname Ratsmiglied
        ///
        /// Vorname des Grossratsmitglieds
        pub vorname: Option<String>,
        /// Name, Vorname
        ///
        /// Name und Vorname des Grossratsmitglieds
        pub name_vorname: Option<String>,
        /// Partei abgekürzt
        ///
        /// Abkürzung der Parteizugehörigkeit des Grossratsmitglied (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei_kname: Option<String>,
        /// Ratsmitglied grosserrat.bs.ch
        ///
        /// Link zum Grossratsmitglied auf der Webseite des Grossen Rates
        pub url_adr: Option<String>,
        /// ID Ratsmitglied
        ///
        /// Individuelle Identifikationsnummer des Grossratsmitglieds innerhalb der Datenbank des Grossen Rates
        pub uni_nr: Option<String>,
        /// Grossratsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach aktueller Interessensbindung.
        pub url_ratsmitgliedschaften: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Rubrik,
        IntrBind,
        Funktion,
        Text,
        Anrede,
        Name,
        Vorname,
        NameVorname,
        ParteiKname,
        UrlAdr,
        UniNr,
        UrlRatsmitgliedschaften,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Rubrik => "rubrik",
                Field::IntrBind => "intr_bind",
                Field::Funktion => "funktion",
                Field::Text => "text",
                Field::Anrede => "anrede",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::NameVorname => "name_vorname",
                Field::ParteiKname => "partei_kname",
                Field::UrlAdr => "url_adr",
                Field::UniNr => "uni_nr",
                Field::UrlRatsmitgliedschaften => "url_ratsmitgliedschaften",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100309/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Events in Gewässernähe
pub mod events_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// IDUnique
        ///
        /// ID
        pub idunique: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        pub sichtbar_bis: Option<Date>,
        /// Status
        pub status: Option<String>,
        /// Datum_von
        ///
        /// Beginn des Events
        pub datum_von: Option<Date>,
        /// Datum_bis
        ///
        /// Ende des Events
        pub datum_bis: Option<Date>,
        /// Eventname
        ///
        /// Name des Events
        pub titel: Option<String>,
        /// Motto
        ///
        /// Motto des Events
        pub untertitel: Option<String>,
        /// Information
        ///
        /// Beschreibung des Events
        pub text: Option<String>,
        /// Image
        pub image: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idunique,
        SichtbarVon,
        SichtbarBis,
        Status,
        DatumVon,
        DatumBis,
        Titel,
        Untertitel,
        Text,
        Image,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idunique => "idunique",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Status => "status",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Text => "text",
                Field::Image => "image",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100247/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Feuerstellen in Gewässernähe
pub mod feuerstellen_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Bezeichnung
        pub bezeichnung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Bezeichnung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Bezeichnung => "bezeichnung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100276/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Teststellen
pub mod coronavirus_covid_19_teststellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_ts: Option<i64>,
        /// Teststelle
        ///
        /// Name der Teststelle
        pub institut: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
        /// Hausnummer
        pub hausnummer: Option<i64>,
        /// PLZ
        ///
        /// 4-stellige Postleitzahl
        pub plz: Option<String>,
        /// Ort
        ///
        /// Gemeinde
        pub ort: Option<String>,
        /// Telefonnummer
        ///
        /// Telefonnummer der Teststelle
        pub telefon: Option<String>,
        /// Nur bestehende Patienten
        ///
        /// Werden nur bestehende Patienten getestet
        pub bestehend: Option<String>,
        /// Terminvereinbarung
        ///
        /// Sind Terminvereinbarungen notwendig
        pub termin: Option<String>,
        /// Online-Anmeldung
        ///
        /// URL für Online Anmeldung
        pub online: Option<String>,
        /// Bemerkungen
        ///
        /// Bemerkungen zur Teststelle
        pub bemerkung: Option<String>,
        /// Öffnungszeiten Werktags
        ///
        /// Öffnungszeiten unter der Woche
        pub oeff_wt: Option<String>,
        /// Öffnungszeiten Wochenende
        ///
        /// Öffnungszeiten am Wochenende
        pub oeff_we: Option<String>,
        /// Schnelltest
        ///
        /// Verfügbarkeit von Schnelltests
        pub schnellte: Option<String>,
        /// Kinder
        ///
        /// Testet diese Teststelle auch Kinder?
        pub kinder: Option<String>,
        /// Kinder: Mindestalter
        ///
        /// Mindestalter für Tests. Teststellen, welche Personen erst ab einem bestimmten Mindestalter testen, sind spezialisiert auf Corona-Tests bei Kindern.
        pub alter: Option<String>,
        /// Kinder: Zusätzliche Testarten
        ///
        /// Art der durchführenden Tests
        pub testart: Option<String>,
        /// Kinder: Nur symptomatische
        ///
        /// Müssen Kinder COVID-19 Symptome haben, um durch diese Teststelle getestet zu werden?
        pub symptom: Option<String>,
        /// Kinder: Bemerkungen
        ///
        /// Bemerkungen zu Teststellen für Kinder
        pub kommentar: Option<String>,
        /// ADRESSID
        pub adressid: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdTs,
        Institut,
        Strasse,
        Hausnummer,
        Plz,
        Ort,
        Telefon,
        Bestehend,
        Termin,
        Online,
        Bemerkung,
        OeffWt,
        OeffWe,
        Schnellte,
        Kinder,
        Alter,
        Testart,
        Symptom,
        Kommentar,
        Adressid,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdTs => "id_ts",
                Field::Institut => "institut",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::Bestehend => "bestehend",
                Field::Termin => "termin",
                Field::Online => "online",
                Field::Bemerkung => "bemerkung",
                Field::OeffWt => "oeff_wt",
                Field::OeffWe => "oeff_we",
                Field::Schnellte => "schnellte",
                Field::Kinder => "kinder",
                Field::Alter => "alter",
                Field::Testart => "testart",
                Field::Symptom => "symptom",
                Field::Kommentar => "kommentar",
                Field::Adressid => "adressid",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100134/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Sport- und Bewegungsanlagen
pub mod sport_und_bewegungsanlagen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID der Angebote
        ///
        /// Eindeutiger Identifikator
        pub id_angebot: Option<i64>,
        /// Name
        ///
        /// Name des Sportangebots
        pub name: Option<String>,
        /// Kategorie
        ///
        /// Kategorien unterschiedlicher Sport- und Bewegungsanlagen
        pub kategorie: Option<String>,
        /// Beschreibung
        ///
        /// Beschreibung des Sportangebots
        pub beschreibu: Option<String>,
        /// Strassennummer
        ///
        /// Strassenname und Hausnummer
        pub strassenr: Option<String>,
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Link
        ///
        /// Weitere Informationen
        pub link: Option<String>,
        /// Zustaendigkeit
        ///
        /// Zuständigkeit für das Sportangebot
        pub zustaendig: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
        /// Baselinfo
        ///
        /// Gibt Relevanz für das Fussgängerorientierungssystem Basel Info an
        pub baselinfo: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdAngebot,
        Name,
        Kategorie,
        Beschreibu,
        Strassenr,
        Plz,
        Ort,
        Link,
        Zustaendig,
        Bemerkung,
        Baselinfo,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdAngebot => "id_angebot",
                Field::Name => "name",
                Field::Kategorie => "kategorie",
                Field::Beschreibu => "beschreibu",
                Field::Strassenr => "strassenr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Link => "link",
                Field::Zustaendig => "zustaendig",
                Field::Bemerkung => "bemerkung",
                Field::Baselinfo => "baselinfo",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100151/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte der IWB Ladestationen für Elektroautos
pub mod standorte_der_iwb_ladestationen_fuer_elektroautos {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// Description
        pub description: Option<String>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        /// Beschreibung
        pub beschreibung: Option<String>,
        /// Art
        pub art: Option<String>,
        /// Ort
        pub ort: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
        Description,
        Beschreibung,
        Art,
        Ort,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Description => "description",
                Field::Beschreibung => "beschreibung",
                Field::Art => "art",
                Field::Ort => "ort",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100005/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gebäude (Gebäude- und Wohnungsregister GWR)
pub mod gebaeude_gebaeude_und_wohnungsregister_gwr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// EGID
        ///
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<i64>,
        /// Kanton
        ///
        /// Abkürzung Kanton
        pub gdekt: Option<String>,
        /// Gemeindenummer
        pub ggdenr: Option<i64>,
        /// Gemeindename
        pub ggdename: Option<String>,
        /// EGRID
        ///
        /// Eidgenössischer Grundstücksidentifikator
        pub egrid: Option<String>,
        /// Grundbuchkreisnummer
        ///
        /// Sektion
        pub lgbkr: Option<i64>,
        /// Grundstücksnummer
        ///
        /// Parzellennummer - nn(F) bedeutet, dass sich das Grundstück in Frankreich befindet.
        pub lparz: Option<String>,
        /// Suffix der Grundstücksnummer
        ///
        /// Suffix der Parzellennummer
        pub lparzsx: Option<String>,
        /// Typ des Grundstücks
        pub ltyp: Option<String>,
        /// Gebäudenummer
        pub gebnr: Option<i64>,
        /// Gebäudebezeichnung
        pub gbez: Option<String>,
        /// E-Gebäudekoordinate
        pub gkode: Option<f64>,
        /// N-Gebäudekoordinate
        pub gkodn: Option<f64>,
        /// Koordinatenherkunft Code
        pub gksce: Option<i64>,
        /// Koordinatenherkunft Bezeichnung
        pub gksce_decoded: Option<String>,
        /// Gebäudestatus Code
        pub gstat: Option<i64>,
        /// Gebäudestatus Bezeichnung
        pub gstat_decoded: Option<String>,
        /// Gebäudekategorie Code
        pub gkat: Option<i64>,
        /// Gebäudekategorie Bezeichnung
        pub gkat_decoded: Option<String>,
        /// Gebäudeklasse Code
        pub gklas: Option<i64>,
        /// Gebäudeklasse Bezeichnung
        pub gklas_decoded: Option<String>,
        /// Baujahr des Gebäudes
        pub gbauj: Option<i64>,
        /// Baumonat des Gebäudes
        pub gbaum: Option<i64>,
        /// Bauperiode Code
        pub gbaup: Option<i64>,
        /// Bauperiode Bezeichnung
        pub gbaup_decoded: Option<String>,
        /// Abbruchjahr des Gebäudes
        pub gabbj: Option<String>,
        /// Gebäudefläche (in m2)
        pub garea: Option<i64>,
        /// Gebäudevolumen (in m3)
        pub gvol: Option<i64>,
        /// Norm des Gebäudevolumens Code
        pub gvolnorm: Option<i64>,
        /// Norm des Gebäudevolumens Bezeichnung
        pub gvolnorm_decoded: Option<String>,
        /// Informationsquelle zum Gebäudevolumen Code
        pub gvolsce: Option<i64>,
        /// Informationsquelle zum Gebäudevolumen Bezeichnung
        pub gvolsce_decoded: Option<String>,
        /// Anzahl Geschosse
        ///
        /// Anzhl Geschosse
        pub gastw: Option<i64>,
        /// Anzahl Wohnungen
        ///
        /// Anzahl Wohnugnen
        pub ganzwhg: Option<i64>,
        /// Anzahl separate Wohnräume
        pub gazzi: Option<i64>,
        /// Zivilschutzraum Code
        pub gschutzr: Option<i64>,
        /// Zivilschutzraum Bezeichnung
        pub gschutzr_decoded: Option<String>,
        /// Energiebezugsfläche
        pub gebf: Option<i64>,
        /// Primärer Wärmeerzeuger der Heizung Code
        pub gwaerzh1: Option<i64>,
        /// Primärer Wärmeerzeuger der Heizung Bezeichnung
        pub gwaerzh1_decoded: Option<String>,
        /// Primäre Energiequelle der Heizung Code
        pub genh1: Option<i64>,
        /// Primäre Energiequelle der Heizung Bezeichnung
        pub genh1_decoded: Option<String>,
        /// Informationsquelle primäre Heizung Code
        pub gwaersceh1: Option<i64>,
        /// Informationsquelle primäre Heizung Bezeichnung
        pub gwaersceh1_decoded: Option<String>,
        /// Aktualisierungsdatum primäre Heizung
        ///
        /// Informationsquelle primäre Heizung
        pub gwaerdath1: Option<Date>,
        /// Sekundärer Wärmeerzeuger der Heizung Code
        pub gwaerzh2: Option<i64>,
        /// Sekundärer Wärmeerzeuger der Heizung Bezeichnung
        pub gwaerzh2_decoded: Option<String>,
        /// Sekundäre Energiequelle der Heizung Code
        pub genh2: Option<i64>,
        /// Sekundäre Energiequelle der Heizung Bezeichnung
        pub genh2_decoded: Option<String>,
        /// Informationsquelle sekundäre Heizung Code
        pub gwaersceh2: Option<i64>,
        /// Informationsquelle sekundäre Heizung Bezeichnung
        pub gwaersceh2_decoded: Option<String>,
        /// Aktualisierungsdatum sekundäre Heizung
        pub gwaerdath2: Option<Date>,
        /// Primärer Wärmeerzeuger Warmwasser Code
        pub gwaerzw1: Option<i64>,
        /// Primärer Wärmeerzeuger Warmwasser Bezeichnung
        pub gwaerzw1_decoded: Option<String>,
        /// Primäre Energiequelle Warmwasser Code
        pub genw1: Option<i64>,
        /// Primäre Energiequelle Warmwasser Bezeichnung
        pub genw1_decoded: Option<String>,
        /// Informationsquelle primäre Wasseraufbereitung Code
        pub gwaerscew1: Option<i64>,
        /// Informationsquelle primäre Wasseraufbereitung Bezeichnung
        pub gwaerscew1_decoded: Option<String>,
        /// Aktualisierungsdatum primäre Warmwasseraufbereitung
        pub gwaerdatw1: Option<Date>,
        /// Sekundärer Wärmeerzeuger Warmwasser Code
        pub gwaerzw2: Option<i64>,
        /// Sekundärer Wärmeerzeuger Warmwasser Bezeichnung
        pub gwaerzw2_decoded: Option<String>,
        /// Sekundäre Energiequelle Warmwasser Code
        pub genw2: Option<i64>,
        /// Sekundäre Energiequelle Warmwasser Bezeichnung
        pub genw2_decoded: Option<String>,
        /// Informationsquelle sekundäre Warmwasseraufbereitung Code
        pub gwaerscew2: Option<i64>,
        /// Informationsquelle sekundäre Warmwasseraufbereitung Bezeichnung
        pub gwaerscew2_decoded: Option<String>,
        /// Aktualisierungsdatum sekundäre Warmwasseraufbereitung
        pub gwaerdatw2: Option<Date>,
        /// Exportdatum
        pub gexpdat: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Egid,
        Gdekt,
        Ggdenr,
        Ggdename,
        Egrid,
        Lgbkr,
        Lparz,
        Lparzsx,
        Ltyp,
        Gebnr,
        Gbez,
        Gkode,
        Gkodn,
        Gksce,
        GksceDecoded,
        Gstat,
        GstatDecoded,
        Gkat,
        GkatDecoded,
        Gklas,
        GklasDecoded,
        Gbauj,
        Gbaum,
        Gbaup,
        GbaupDecoded,
        Gabbj,
        Garea,
        Gvol,
        Gvolnorm,
        GvolnormDecoded,
        Gvolsce,
        GvolsceDecoded,
        Gastw,
        Ganzwhg,
        Gazzi,
        Gschutzr,
        GschutzrDecoded,
        Gebf,
        Gwaerzh1,
        Gwaerzh1Decoded,
        Genh1,
        Genh1Decoded,
        Gwaersceh1,
        Gwaersceh1Decoded,
        Gwaerdath1,
        Gwaerzh2,
        Gwaerzh2Decoded,
        Genh2,
        Genh2Decoded,
        Gwaersceh2,
        Gwaersceh2Decoded,
        Gwaerdath2,
        Gwaerzw1,
        Gwaerzw1Decoded,
        Genw1,
        Genw1Decoded,
        Gwaerscew1,
        Gwaerscew1Decoded,
        Gwaerdatw1,
        Gwaerzw2,
        Gwaerzw2Decoded,
        Genw2,
        Genw2Decoded,
        Gwaerscew2,
        Gwaerscew2Decoded,
        Gwaerdatw2,
        Gexpdat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Gdekt => "gdekt",
                Field::Ggdenr => "ggdenr",
                Field::Ggdename => "ggdename",
                Field::Egrid => "egrid",
                Field::Lgbkr => "lgbkr",
                Field::Lparz => "lparz",
                Field::Lparzsx => "lparzsx",
                Field::Ltyp => "ltyp",
                Field::Gebnr => "gebnr",
                Field::Gbez => "gbez",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
                Field::Gksce => "gksce",
                Field::GksceDecoded => "gksce_decoded",
                Field::Gstat => "gstat",
                Field::GstatDecoded => "gstat_decoded",
                Field::Gkat => "gkat",
                Field::GkatDecoded => "gkat_decoded",
                Field::Gklas => "gklas",
                Field::GklasDecoded => "gklas_decoded",
                Field::Gbauj => "gbauj",
                Field::Gbaum => "gbaum",
                Field::Gbaup => "gbaup",
                Field::GbaupDecoded => "gbaup_decoded",
                Field::Gabbj => "gabbj",
                Field::Garea => "garea",
                Field::Gvol => "gvol",
                Field::Gvolnorm => "gvolnorm",
                Field::GvolnormDecoded => "gvolnorm_decoded",
                Field::Gvolsce => "gvolsce",
                Field::GvolsceDecoded => "gvolsce_decoded",
                Field::Gastw => "gastw",
                Field::Ganzwhg => "ganzwhg",
                Field::Gazzi => "gazzi",
                Field::Gschutzr => "gschutzr",
                Field::GschutzrDecoded => "gschutzr_decoded",
                Field::Gebf => "gebf",
                Field::Gwaerzh1 => "gwaerzh1",
                Field::Gwaerzh1Decoded => "gwaerzh1_decoded",
                Field::Genh1 => "genh1",
                Field::Genh1Decoded => "genh1_decoded",
                Field::Gwaersceh1 => "gwaersceh1",
                Field::Gwaersceh1Decoded => "gwaersceh1_decoded",
                Field::Gwaerdath1 => "gwaerdath1",
                Field::Gwaerzh2 => "gwaerzh2",
                Field::Gwaerzh2Decoded => "gwaerzh2_decoded",
                Field::Genh2 => "genh2",
                Field::Genh2Decoded => "genh2_decoded",
                Field::Gwaersceh2 => "gwaersceh2",
                Field::Gwaersceh2Decoded => "gwaersceh2_decoded",
                Field::Gwaerdath2 => "gwaerdath2",
                Field::Gwaerzw1 => "gwaerzw1",
                Field::Gwaerzw1Decoded => "gwaerzw1_decoded",
                Field::Genw1 => "genw1",
                Field::Genw1Decoded => "genw1_decoded",
                Field::Gwaerscew1 => "gwaerscew1",
                Field::Gwaerscew1Decoded => "gwaerscew1_decoded",
                Field::Gwaerdatw1 => "gwaerdatw1",
                Field::Gwaerzw2 => "gwaerzw2",
                Field::Gwaerzw2Decoded => "gwaerzw2_decoded",
                Field::Genw2 => "genw2",
                Field::Genw2Decoded => "genw2_decoded",
                Field::Gwaerscew2 => "gwaerscew2",
                Field::Gwaerscew2Decoded => "gwaerscew2_decoded",
                Field::Gwaerdatw2 => "gwaerdatw2",
                Field::Gexpdat => "gexpdat",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100230/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Grossratswahl 20. Oktober 2024
pub mod kandidierende_der_grossratswahl_20_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlkreis
        pub wahlkreis: Option<String>,
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenkurzbezeichnung
        ///
        /// Abkürzung der Liste
        pub listenkurzbezeichnung: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Kandidierenden-Nr.
        ///
        /// Nummer der Kandidatur
        pub kand_nr: Option<String>,
        /// Bisher
        ///
        /// War die kandidierende Person bisher im Grossen Rat?
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// Amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
        /// Altersgruppe
        pub altersgruppe: Option<String>,
        /// Alter Ende 2024
        pub alter: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlkreis,
        ListenNr,
        Listenkurzbezeichnung,
        Listenbezeichnung,
        KandNr,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
        Altersgruppe,
        Alter,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlkreis => "wahlkreis",
                Field::ListenNr => "listen_nr",
                Field::Listenkurzbezeichnung => "listenkurzbezeichnung",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::KandNr => "kand_nr",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
                Field::Altersgruppe => "altersgruppe",
                Field::Alter => "alter",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100385/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Basel-Binningen
pub mod luftqualitaet_station_basel_binningen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        ///
        /// Zeitstempel in UTC
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        /// Zeitstempel als Text in Mitteleuropäischer Zeit ("Winterzeit")
        pub timestamp_text: Option<String>,
        /// O3 [ug/m3]
        ///
        /// Ozon
        pub o3_ug_m3: Option<f64>,
        /// NO2 [ug/m3]
        ///
        /// Stickstoffdioxid
        pub no2_ug_m3: Option<f64>,
        /// PM10 [ug/m3]
        ///
        /// Feinstaub mit Partikelgrösse < 10 tausendstel Millimeter
        pub pm10_ug_m3: Option<f64>,
        /// PM2.5 [ug/m3]
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm2_5_ug_m3: Option<f64>,
        /// CPC [1/cm3]
        ///
        /// Partikelanzahlkonzentration
        pub cpc_1_cm3: Option<f64>,
        /// EC [ug/m3]
        ///
        /// Russ (EC in PM2.5)
        pub ec_ug_m3: Option<f64>,
        /// PREC [mm]
        ///
        /// Niederschlag
        pub prec_mm: Option<f64>,
        /// RAD [W/m2]
        ///
        /// Globalstrahlung
        pub rad_w_m2: Option<f64>,
        /// SO2 [ug/m3]
        ///
        /// Schwefeldioxid
        pub so2_ug_m3: Option<f64>,
        /// NOX [ug/m3 eq. NO2]
        pub nox_ug_m3_eq_no2: Option<f64>,
        /// TEMP [C]
        pub temp_c: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        O3UgM3,
        No2UgM3,
        Pm10UgM3,
        Pm25UgM3,
        Cpc1Cm3,
        EcUgM3,
        PrecMm,
        RadWM2,
        So2UgM3,
        NoxUgM3EqNo2,
        TempC,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::O3UgM3 => "o3_ug_m3",
                Field::No2UgM3 => "no2_ug_m3",
                Field::Pm10UgM3 => "pm10_ug_m3",
                Field::Pm25UgM3 => "pm2_5_ug_m3",
                Field::Cpc1Cm3 => "cpc_1_cm3",
                Field::EcUgM3 => "ec_ug_m3",
                Field::PrecMm => "prec_mm",
                Field::RadWM2 => "rad_w_m2",
                Field::So2UgM3 => "so2_ug_m3",
                Field::NoxUgM3EqNo2 => "nox_ug_m3_eq_no2",
                Field::TempC => "temp_c",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100051/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gesundheitsversorgung (GSV): Spitalkennzahlen
pub mod gesundheitsversorgung_gsv_spitalkennzahlen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<Date>,
        /// Spital/Klinik
        ///
        /// Name des Spitals oder Klinik
        pub spital: Option<String>,
        /// Akutsomatik
        ///
        /// Klinik bietet akutsomatische Behandlungen an.
        pub angebot_akutsomatik: Option<String>,
        /// Psychiatrie
        ///
        /// Klinik bietet psychiatrische Behandlungen an.
        pub angebot_psychiatrie: Option<String>,
        /// Rehabilitation
        ///
        /// Klinik bietet Rehabilitationsbehandlungen an.
        pub angebot_rehabilitation: Option<String>,
        /// Betriebsertrag (in Mio. CHF)
        ///
        /// Totaler Betriebsertrag des jeweiligen Spitals eines Jahres. Angabe in Millionen CHF.
        pub total_betriebsertrag: Option<f64>,
        /// Betriebsertrag (in 1000 CHF)
        ///
        /// Totaler Betriebsertrag des jeweiligen Spitals eines Jahres. Angabe in 1'000 CHF.
        pub total_betriebsertrag_1000: Option<i64>,
        /// Ertrag Leistungserstellung (in 1000 CHF)
        ///
        /// Totaler Ertrag aus Leistungenerstellug des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_ertrag_leistung: Option<i64>,
        /// Ertrag Leistungserstellung (in Mio. CHF)
        pub ertrag_leistungserstellung_in_mio_chf: Option<f64>,
        /// Übriger Betriebsertrag (in Mio. CHF)
        pub ubriger_betriebsertrag_in_mio_chf: Option<f64>,
        /// Betriebsaufwand (in 1000 CHF)
        ///
        /// Totaler Betriebsaufwand des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_betriebsaufwand: Option<i64>,
        /// Betriebsaufwand (in Mio. CHF)
        pub betriebsaufwand_in_mio_chf: Option<f64>,
        /// Personalkosten (in 1000 CHF)
        ///
        /// Totaler Aufwand für Personalkosten des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_kosten_personal: Option<i64>,
        /// Personalkosten (in Mio. CHF)
        pub personalkosten_in_mio_chf: Option<f64>,
        /// Medizinischer Bedarf (in 1000 CHF)
        ///
        /// Totaler Aufwand für medizinischen Bedarf des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_bedarf_medizinisch: Option<i64>,
        /// Medizinischer Bedarf (in Mio. CHF)
        pub medizinischer_bedarf_in_mio_chf: Option<f64>,
        /// Übriger Aufwand (in Mio. CHF)
        pub ubriger_aufwand_in_mio_chf: Option<f64>,
        /// Mitarbeitende (in 100% Stellen)
        ///
        /// Anzahl der Mitarbeitenden in Vollzeitäquivalenten, bzw. in 100%-Stellen im Jahresdurchschnitt.
        pub fte: Option<i64>,
        /// Anzahl Mitarbeitende (Personen)
        ///
        /// Anzahl der Mitarbeitenden in Personen im Jahrestotal.
        pub anz_ma: Option<i64>,
        /// Bettenbetriebstage
        ///
        /// Anzahl der Bettenbetriebstage. Ein Tag, an welchem ein Spitalbett zur Bewirtschaftung zur Verfügung steht, entspricht einem Bettenbetriebstag.
        pub bettenbetriebstage: Option<i64>,
        /// Case-Mix
        ///
        /// Der Case-Mix (CM) beschreibt in der Akutsomatik den (ökonomischen) Schweregrad eines abgerechneten Falles.
        pub case_mix: Option<i64>,
        /// Fälle
        ///
        /// Totale Anzahl aller Fälle des jeweiligen Spitals
        pub anz_faelle_alle: Option<i64>,
        /// Pflegetage
        ///
        /// Total der effektiven Pflegetage, bzw. Dauer des tatsächlichen Aufenthaltes in Tagen.
        pub pflegetage: Option<i64>,
        /// Langzeitpflegefälle
        ///
        /// Anzahl der Langzeitpflegefälle. Langzeitpflege bezeichnet die Pflege und Betreuung von Menschen mit Unterstützungsbedarf über einen längeren Zeitraum.
        pub anz_lzpf: Option<i64>,
        /// Fälle Allgemeine Abteilung
        ///
        /// Anzahl der Fälle, die auf der allgemeinen Abteilung behandelt wurden.
        pub anz_allgemein: Option<i64>,
        /// Allgemeine KVG-Fälle
        ///
        /// Anzahl der Fälle, welche nach dem Krankenversicherungsgesetz (KVG) abgerechnet und auf der allgemeinen Abteilung behandelt wurden.
        pub anz_kvg_allgklasse: Option<i64>,
        /// SwissDRG-Fälle
        ///
        /// Anzahl der Fälle, welche mit SwissDRG-Fallpauschalen abgegolten wurden.
        pub drg_faelle: Option<i64>,
        /// KVG-Fälle
        ///
        /// Anzahl der Fälle, welche nach dem Krankenversicherungsgesetz (KVG) abgerechnet wurden.
        pub anz_kvg_faelle: Option<i64>,
        /// Fälle UV, IV, MV
        ///
        /// Anzahl der Fälle, welche über die Unfall-, Invaliden- oder Militärversicherung abgerechnet wurden.
        pub anz_uvg_iv_faelle: Option<i64>,
        /// Fälle mit Wohnort BS
        ///
        /// Anzahl der Fälle, welche im Kanton Basel-Stadt wohnen.
        pub bs: Option<i64>,
        /// Fälle mit Wohnort BL
        ///
        /// Anzahl der Fälle, welche im Kanton Baselland wohnen.
        pub bl: Option<i64>,
        /// Fälle mit Wohnort AG/SO
        ///
        /// Anzahl der Fälle, welche im Kanton Aargau oder Solothurn wohnen.
        pub ag_so: Option<i64>,
        /// Fälle aus der Restschweiz
        ///
        /// Anzahl der Fälle in einem anderen Kanton als BS, BL, AG oder SO wohnen.
        pub restschweiz: Option<i64>,
        /// Fälle aus dem Ausland
        ///
        /// Anzahl der Fälle, welche im Ausland wohnen.
        pub ausland: Option<i64>,
        /// Männliche Fälle
        ///
        /// Anzahl der männlichen Fälle
        pub maennlich: Option<i64>,
        /// Weibliche Fälle
        ///
        /// Anzahl der weiblichen Fälle
        pub weiblich: Option<i64>,
        /// Alter 0-20 J
        ///
        /// Anzahl der Fälle zwischen 0 und 20 Jahren
        pub jahre_0_20: Option<i64>,
        /// Alter 21-40 J
        ///
        /// Anzahl der Fälle zwischen 21 und 40 Jahren
        pub jahre_21_40: Option<i64>,
        /// Alter 41-60 J
        ///
        /// Anzahl der Fälle zwischen 41 und 60 Jahren
        pub jahre_41_60: Option<i64>,
        /// Alter 61-80 J
        ///
        /// Anzahl der Fälle zwischen 61 und 80 Jahren
        pub jahre_61_80: Option<i64>,
        /// Alter >81 J
        ///
        /// Anzahl der Fälle über 80 Jahren
        pub jahre_ueber80: Option<i64>,
        /// Fälle Akutsomatik
        ///
        /// Gesamtzahl der stationär behandelten Fälle in der Akutsomatik
        pub total_akutsomatik: Option<i64>,
        /// Basispaket
        ///
        /// Anzahl der Fälle im Leistungsbereich Basispaket Chirurgie und innere Medizin oder Basispaket elektiv
        pub basispaket: Option<i64>,
        /// Gastroenterologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Gastroenterologie
        pub gastroenterologie: Option<i64>,
        /// Geburtshilfe
        ///
        /// Anzahl der Fälle des Leistungsbereichs Geburtshilfe
        pub geburtshilfe: Option<i64>,
        /// Gefässe
        ///
        /// Anzahl der Fälle des Leistungsbereichs Gefässe
        pub gefaesse: Option<i64>,
        /// Gynäkologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Gynäkologie
        pub gynaekologie: Option<i64>,
        /// Hals-Nasen-Ohren
        ///
        /// Anzahl der Fälle des Leistungsbereichs Hals-Nasen-Ohren
        pub hno: Option<i64>,
        /// Hämatologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Hämatologie
        pub haematologie: Option<i64>,
        /// Herz
        ///
        /// Anzahl der Fälle des Leistungsbereichs Herz
        pub herz: Option<i64>,
        /// Neugeborene
        ///
        /// Anzahl der Fälle des Leistungsbereichs Neugeborene
        pub neugeborene: Option<i64>,
        /// Neurologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Neurologie
        pub neurologie: Option<i64>,
        /// Orthopädie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Orthopädie
        pub orthopaedie: Option<i64>,
        /// (Radio-) Onkologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs (Radio-) Onkologie
        pub radio_onkologie: Option<i64>,
        /// Pneumologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Pneumologie
        pub pneumologie: Option<i64>,
        /// Urologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Urologie
        pub urologie: Option<i64>,
        /// Viszeralchirurgie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Viszeralchirurgie
        pub viszeralchirurgie: Option<i64>,
        /// Übrige Akutsomatik
        ///
        /// Anzahl der Fälle der übrigen Leistungsbereiche der Akutsomatik
        pub uebrige: Option<i64>,
        /// Fälle Psychiatrie
        ///
        /// Gesamtzahl der stationär behandelten psychiatrischen Fälle
        pub total_psych: Option<i64>,
        /// Affektive Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit einer affektiven Störung als Hauptdiagnose
        pub psych_affektiv: Option<i64>,
        /// Neurotische Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit neurotischer, Belastungs- oder somatoformer Störung als Hauptdiagnose
        pub psych_neurotisch: Option<i64>,
        /// Organische psychische Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit organischer oder symptomatischer psychischer Störung als Hauptdiagnose
        pub psych_organisch: Option<i64>,
        /// Verhaltensstörungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit psychischer oder Verhaltensstörung durch psychotrope Substanzen als Hauptdiagnose
        pub psych_psychisch: Option<i64>,
        /// Psychotische Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit Schizophrenie, schizotyper oder wahnhafter Störung als Hauptdiagnose
        pub psych_schizophren: Option<i64>,
        /// Übrige Psychiatrie
        ///
        /// Anzahl der Psychiatrie-Fälle mit einer anderen psychiatrischen Diagnose
        pub psych_uebrige: Option<i64>,
        /// Fälle Rehabilitation
        ///
        /// Gesamtzahl der stationär durchgeführten Rehabilitationsbehandlungen
        pub total_reha: Option<i64>,
        /// Bewegungsapparat
        ///
        /// Anzahl der Reha-Fälle bei Krankheiten des Muskel-Skelett-Systems und des Bindegewebes
        pub reha_muskelskelett: Option<i64>,
        /// Unfälle
        ///
        /// Anzahl der Reha-Fälle nach Verletzung, Vergiftung oder bestimmten anderen Folgen äusserer Ursachen
        pub reha_verletzung: Option<i64>,
        /// Herz-Kreislaufsystem
        ///
        /// Anzahl der Reha-Fälle bei Krankheit des Herz-Kreislaufsystems
        pub reha_kreislauf: Option<i64>,
        /// Andere Symptome
        ///
        /// Anzahl der Reha-Fälle bei anderen Symptomen oder abnormen klinischen (Labor-)Befunden (wie neurologische)
        pub reha_labor: Option<i64>,
        /// Neubildungen
        ///
        /// Anzahl der onkologisch-internistischen Reha-Fälle
        pub reha_neubildungen: Option<i64>,
        /// Übrige Rehabilitation
        ///
        /// Anzahl der Reha-Fälle aus anderen Gründen
        pub reha_uebrige: Option<i64>,
        /// Geopunkt
        ///
        /// Standort des Spitals
        pub geopunkt: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Spital,
        AngebotAkutsomatik,
        AngebotPsychiatrie,
        AngebotRehabilitation,
        TotalBetriebsertrag,
        TotalBetriebsertrag1000,
        TotalErtragLeistung,
        ErtragLeistungserstellungInMioChf,
        UbrigerBetriebsertragInMioChf,
        TotalBetriebsaufwand,
        BetriebsaufwandInMioChf,
        TotalKostenPersonal,
        PersonalkostenInMioChf,
        TotalBedarfMedizinisch,
        MedizinischerBedarfInMioChf,
        UbrigerAufwandInMioChf,
        Fte,
        AnzMa,
        Bettenbetriebstage,
        CaseMix,
        AnzFaelleAlle,
        Pflegetage,
        AnzLzpf,
        AnzAllgemein,
        AnzKvgAllgklasse,
        DrgFaelle,
        AnzKvgFaelle,
        AnzUvgIvFaelle,
        Bs,
        Bl,
        AgSo,
        Restschweiz,
        Ausland,
        Maennlich,
        Weiblich,
        Jahre020,
        Jahre2140,
        Jahre4160,
        Jahre6180,
        JahreUeber80,
        TotalAkutsomatik,
        Basispaket,
        Gastroenterologie,
        Geburtshilfe,
        Gefaesse,
        Gynaekologie,
        Hno,
        Haematologie,
        Herz,
        Neugeborene,
        Neurologie,
        Orthopaedie,
        RadioOnkologie,
        Pneumologie,
        Urologie,
        Viszeralchirurgie,
        Uebrige,
        TotalPsych,
        PsychAffektiv,
        PsychNeurotisch,
        PsychOrganisch,
        PsychPsychisch,
        PsychSchizophren,
        PsychUebrige,
        TotalReha,
        RehaMuskelskelett,
        RehaVerletzung,
        RehaKreislauf,
        RehaLabor,
        RehaNeubildungen,
        RehaUebrige,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Spital => "spital",
                Field::AngebotAkutsomatik => "angebot_akutsomatik",
                Field::AngebotPsychiatrie => "angebot_psychiatrie",
                Field::AngebotRehabilitation => "angebot_rehabilitation",
                Field::TotalBetriebsertrag => "total_betriebsertrag",
                Field::TotalBetriebsertrag1000 => "total_betriebsertrag_1000",
                Field::TotalErtragLeistung => "total_ertrag_leistung",
                Field::ErtragLeistungserstellungInMioChf => "ertrag_leistungserstellung_in_mio_chf",
                Field::UbrigerBetriebsertragInMioChf => "ubriger_betriebsertrag_in_mio_chf",
                Field::TotalBetriebsaufwand => "total_betriebsaufwand",
                Field::BetriebsaufwandInMioChf => "betriebsaufwand_in_mio_chf",
                Field::TotalKostenPersonal => "total_kosten_personal",
                Field::PersonalkostenInMioChf => "personalkosten_in_mio_chf",
                Field::TotalBedarfMedizinisch => "total_bedarf_medizinisch",
                Field::MedizinischerBedarfInMioChf => "medizinischer_bedarf_in_mio_chf",
                Field::UbrigerAufwandInMioChf => "ubriger_aufwand_in_mio_chf",
                Field::Fte => "fte",
                Field::AnzMa => "anz_ma",
                Field::Bettenbetriebstage => "bettenbetriebstage",
                Field::CaseMix => "case_mix",
                Field::AnzFaelleAlle => "anz_faelle_alle",
                Field::Pflegetage => "pflegetage",
                Field::AnzLzpf => "anz_lzpf",
                Field::AnzAllgemein => "anz_allgemein",
                Field::AnzKvgAllgklasse => "anz_kvg_allgklasse",
                Field::DrgFaelle => "drg_faelle",
                Field::AnzKvgFaelle => "anz_kvg_faelle",
                Field::AnzUvgIvFaelle => "anz_uvg_iv_faelle",
                Field::Bs => "bs",
                Field::Bl => "bl",
                Field::AgSo => "ag_so",
                Field::Restschweiz => "restschweiz",
                Field::Ausland => "ausland",
                Field::Maennlich => "maennlich",
                Field::Weiblich => "weiblich",
                Field::Jahre020 => "jahre_0_20",
                Field::Jahre2140 => "jahre_21_40",
                Field::Jahre4160 => "jahre_41_60",
                Field::Jahre6180 => "jahre_61_80",
                Field::JahreUeber80 => "jahre_ueber80",
                Field::TotalAkutsomatik => "total_akutsomatik",
                Field::Basispaket => "basispaket",
                Field::Gastroenterologie => "gastroenterologie",
                Field::Geburtshilfe => "geburtshilfe",
                Field::Gefaesse => "gefaesse",
                Field::Gynaekologie => "gynaekologie",
                Field::Hno => "hno",
                Field::Haematologie => "haematologie",
                Field::Herz => "herz",
                Field::Neugeborene => "neugeborene",
                Field::Neurologie => "neurologie",
                Field::Orthopaedie => "orthopaedie",
                Field::RadioOnkologie => "radio_onkologie",
                Field::Pneumologie => "pneumologie",
                Field::Urologie => "urologie",
                Field::Viszeralchirurgie => "viszeralchirurgie",
                Field::Uebrige => "uebrige",
                Field::TotalPsych => "total_psych",
                Field::PsychAffektiv => "psych_affektiv",
                Field::PsychNeurotisch => "psych_neurotisch",
                Field::PsychOrganisch => "psych_organisch",
                Field::PsychPsychisch => "psych_psychisch",
                Field::PsychSchizophren => "psych_schizophren",
                Field::PsychUebrige => "psych_uebrige",
                Field::TotalReha => "total_reha",
                Field::RehaMuskelskelett => "reha_muskelskelett",
                Field::RehaVerletzung => "reha_verletzung",
                Field::RehaKreislauf => "reha_kreislauf",
                Field::RehaLabor => "reha_labor",
                Field::RehaNeubildungen => "reha_neubildungen",
                Field::RehaUebrige => "reha_uebrige",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100320/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grillstellen in Gewässernähe
pub mod grillstellen_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        pub sichtbar_bis: Option<Date>,
        /// Name
        ///
        /// Name der Grillstelle
        pub name: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Name,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Name => "name",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100284/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Strassennamen
pub mod strassennamen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id Strasse
        ///
        /// Eindeutiger Identifikator
        pub strassenid: Option<i64>,
        /// Strassenname
        ///
        /// Name der Strasse in Langschreibweise (z.B. Strasse statt Str.)
        pub strname: Option<String>,
        /// Erklärung erste Zeile
        ///
        /// Erklärung der ersten Zeile des Strassenschildes
        pub kurzek_ez: Option<String>,
        /// Erklärung zweite Zeile
        ///
        /// Erklärung der zweiten Zeile des Strassenschildes
        pub kurzek_zz: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Erstmals erwähnt
        ///
        /// Jahr der ersten Erwähnung des Strassennamens
        pub erst_erwae: Option<String>,
        /// Amtlich benannt
        ///
        /// Jahr der amtlichen Benennung der Strasse
        pub amtlich_be: Option<String>,
        /// Indextext
        ///
        /// Kurzschreibweise des Strassennamens (z.B. Str. statt Strasse)
        pub indextext: Option<String>,
        /// Kurztext
        ///
        /// Indextext der Strasse
        pub kurztext: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Strassenid,
        Strname,
        KurzekEz,
        KurzekZz,
        ErstErwae,
        AmtlichBe,
        Indextext,
        Kurztext,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Strassenid => "strassenid",
                Field::Strname => "strname",
                Field::KurzekEz => "kurzek_ez",
                Field::KurzekZz => "kurzek_zz",
                Field::ErstErwae => "erst_erwae",
                Field::AmtlichBe => "amtlich_be",
                Field::Indextext => "indextext",
                Field::Kurztext => "kurztext",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100189/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Sanitäre Anlagen
pub mod sanitaere_anlagen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Bezeichnung
        pub bezeichnug: Option<String>,
        /// Strasse
        ///
        /// Adresse
        pub strasse: Option<String>,
        /// Eurokey-Schloss
        ///
        /// Eurokey ist ein Schlüsselsystem für Menschen mit Behinderung. Dieser Universalschlüssel öffnet den Zugang zu Aufzügen, Toiletten, Umkleideräumen und anderen Anlagen, die für Menschen mit Behinderung eingerichtet sind.
        pub eurokey: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        pub www_link: Option<String>,
        /// Gebühr
        pub gebuehr: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Typ
        pub typ: Option<String>,
        /// Zusatz
        pub zusatz: Option<String>,
        /// Status
        pub status: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Bezeichnug,
        Strasse,
        Eurokey,
        Plz,
        Ort,
        WwwLink,
        Gebuehr,
        Kategorie,
        Typ,
        Zusatz,
        Status,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Bezeichnug => "bezeichnug",
                Field::Strasse => "strasse",
                Field::Eurokey => "eurokey",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::WwwLink => "www_link",
                Field::Gebuehr => "gebuehr",
                Field::Kategorie => "kategorie",
                Field::Typ => "typ",
                Field::Zusatz => "zusatz",
                Field::Status => "status",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100031/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Tägliche Klimadaten der NBCN-Station Basel-Binningen
pub mod taegliche_klimadaten_der_nbcn_station_basel_binningen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// Jahr
        pub jahr: Option<String>,
        /// Globalstrahlung in W/m2
        ///
        /// Tagesmittel
        pub gre000d0: Option<f64>,
        /// Gesamtschneemenge
        ///
        /// Morgenmessung von 6 UTC
        pub hto000d0: Option<f64>,
        /// Gesamtbewölkung
        ///
        /// Tagesmittel
        pub nto000d0: Option<f64>,
        /// Luftdruck in hPa
        ///
        /// Tagesmittel auf Stationshöhe (QFE)
        pub prestad0: Option<f64>,
        /// Niederschlag
        ///
        /// Tagessumme 6 UTC - 6 UTC Folgetag
        pub rre150d0: Option<f64>,
        /// Sonnenscheindauer
        ///
        /// Tagessumme
        pub sre000d0: Option<f64>,
        /// Tagesmittel Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200d0: Option<f64>,
        /// Tagesminimum Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200dn: Option<f64>,
        /// Tagesmaximum Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200dx: Option<f64>,
        /// Relative Luftfeuchtigkeit
        ///
        /// Tagesmittel, 2 m über Boden
        pub ure200d0: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Jahr,
        Gre000d0,
        Hto000d0,
        Nto000d0,
        Prestad0,
        Rre150d0,
        Sre000d0,
        Tre200d0,
        Tre200dn,
        Tre200dx,
        Ure200d0,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Jahr => "jahr",
                Field::Gre000d0 => "gre000d0",
                Field::Hto000d0 => "hto000d0",
                Field::Nto000d0 => "nto000d0",
                Field::Prestad0 => "prestad0",
                Field::Rre150d0 => "rre150d0",
                Field::Sre000d0 => "sre000d0",
                Field::Tre200d0 => "tre200d0",
                Field::Tre200dn => "tre200dn",
                Field::Tre200dx => "tre200dx",
                Field::Ure200d0 => "ure200d0",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100254/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahl der 100 Mitglieder des Grossen Rates vom 25.10.2020
pub mod wahl_der_100_mitglieder_des_grossen_rates_vom_25_10_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        ///
        /// Jahr, in dem die Wahl stattgefunden hat
        pub wahljahr: Option<String>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub status: Option<String>,
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze Wahlkreis
        ///
        /// Anzahl Sitze, die für einen Wahlkreis zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listennummer
        ///
        /// Nummer der Liste
        pub listennummer: Option<String>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<String>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<i64>,
        /// Kumulation
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat auf einem unveränderten Wahlzettel mehrfach aufgeführt ist
        pub kumulation: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Alter am Jahresende 2020
        ///
        /// Alter, berechnet nach der Formel "2020 minus Jahrgang"
        pub alter: Option<i64>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus unveränderten Wahlzetteln
        pub stimmen_uvwz: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus veränderten Wahlzetteln
        pub stimmen_vwz: Option<i64>,
        /// Stimmen Total
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten. Die Summe dieser Stimmen über eine Partei ergibt nicht das Total der Parteistimmen, weil so die leeren Linien auf Parteilisten nicht mitgezählt werden.
        pub stimmen_total: Option<i64>,
        /// Rangfolge
        ///
        /// Rangfolge innerhalb einer Liste gemäss Anzahl Stimmen (bei Stimmengleichheit entscheidet das Los).
        pub rangfolge: Option<i64>,
        /// 00 Ohne
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer Liste ohne Bezeichnung
        pub x00_ohne: Option<i64>,
        /// 01 FDP
        ///
        /// FDP. Die Liberalen Basel-Stadt und Jungfreisinnige; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x01_fdp: Option<i64>,
        /// 02 PP
        ///
        /// PIRATEN - Piratenpartei beider Basel; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x02_pp: Option<i64>,
        /// 03 LDP
        ///
        /// LDP Liberal-Demokratische Partei Basel-Stadt und Jungliberale; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x03_ldp: Option<i64>,
        /// 04 EVP
        ///
        /// Evangelische Volkspartei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x04_evp: Option<i64>,
        /// 05 SP
        ///
        /// Sozialdemokratische Partei Basel-Stadt (SP) und JUSO; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x05_sp: Option<i64>,
        /// 07 CVP
        ///
        /// CVP Basel-Stadt und Junge CVP Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x07_cvp: Option<i64>,
        /// 08 GB
        ///
        /// Bündnis Grüne, BastA!, junges grünes bündnis; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x08_gb: Option<i64>,
        /// 10 GLP
        ///
        /// Grünliberale Partei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x10_glp: Option<i64>,
        /// 12 SVP
        ///
        /// Schweizerische Volkspartei Basel-Stadt (SVP); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x12_svp: Option<i64>,
        /// 13 FUK
        ///
        /// freistaat unteres kleinbasel f-u-k.ch; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x13_fuk: Option<i64>,
        /// 14 VA
        ///
        /// Volks-Aktion gegen zuviele Ausländer und Asylanten in unserer Heimat (VA) - Liste Ausländerstopp; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x14_va: Option<i64>,
        /// 16 AB
        ///
        /// Aktives Bettingen; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x16_ab: Option<String>,
        /// 19 BDV
        ///
        /// Bettinger Dorfvereinigung - BDV; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x19_bdv: Option<String>,
        /// 28 PB
        ///
        /// Parteiloser Bürger für eine Untersuchung der Coronamassnahmen; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x28_pb: Option<i64>,
        /// 29 KL
        ///
        /// Kommunistische Liste - Partei der Arbeit Schweiz; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x29_kl: Option<i64>,
        /// Laufnummer
        ///
        /// Kandidaten-Laufnummer
        pub laufnummer: Option<i64>,
        /// Jahrgang numerisch
        ///
        /// Jahrgang in numerischem Format
        pub jahrgang_num: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Status,
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        Listennummer,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        PersonenId,
        Kumulation,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Alter,
        Anrede,
        Beruf,
        StimmenUvwz,
        StimmenVwz,
        StimmenTotal,
        Rangfolge,
        X00Ohne,
        X01Fdp,
        X02Pp,
        X03Ldp,
        X04Evp,
        X05Sp,
        X07Cvp,
        X08Gb,
        X10Glp,
        X12Svp,
        X13Fuk,
        X14Va,
        X16Ab,
        X19Bdv,
        X28Pb,
        X29Kl,
        Laufnummer,
        JahrgangNum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Status => "status",
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::Listennummer => "listennummer",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Alter => "alter",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::StimmenUvwz => "stimmen_uvwz",
                Field::StimmenVwz => "stimmen_vwz",
                Field::StimmenTotal => "stimmen_total",
                Field::Rangfolge => "rangfolge",
                Field::X00Ohne => "00_ohne",
                Field::X01Fdp => "01_fdp",
                Field::X02Pp => "02_pp",
                Field::X03Ldp => "03_ldp",
                Field::X04Evp => "04_evp",
                Field::X05Sp => "05_sp",
                Field::X07Cvp => "07_cvp",
                Field::X08Gb => "08_gb",
                Field::X10Glp => "10_glp",
                Field::X12Svp => "12_svp",
                Field::X13Fuk => "13_fuk",
                Field::X14Va => "14_va",
                Field::X16Ab => "16_ab",
                Field::X19Bdv => "19_bdv",
                Field::X28Pb => "28_pb",
                Field::X29Kl => "29_kl",
                Field::Laufnummer => "laufnummer",
                Field::JahrgangNum => "jahrgang_num",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100101/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Geschäfte
pub mod grosser_rat_geschaefte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Beginn Geschäft
        ///
        /// Datum, an dem des Geschäft zum ersten mal traktandiert ist.
        pub beginn_ges: Option<Date>,
        /// Ende Geschäft
        ///
        /// Abschlussdatum des Geschäfts
        pub ende_ges: Option<Date>,
        /// Laufnummer
        ///
        /// Laufnummer des Geschäfts
        pub laufnr_ges: Option<String>,
        /// Signatur
        ///
        /// Signatur des Geschäfts
        pub signatur_ges: Option<String>,
        /// Status
        ///
        /// Status des Geschäfts (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Geschäfts
        pub titel_ges: Option<String>,
        /// Department
        ///
        /// Falls der Urheber des Geschäfts der Regierungsrat ist, wird erfasst, welches Departement das Geschäft erfasst hat.
        pub departement_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Geschäfts
        pub ga_rr_gr: Option<String>,
        /// Link Geschäft
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Link Zuweisungen
        ///
        /// Link zum Datensatz "Grosser Rat: Zuweisungen". Gefiltert nach aktuellem Geschäft.
        pub url_zuweisungen: Option<String>,
        /// Link Dokumente
        ///
        /// Link zum Datensatz "Grosser Rat: Dokumente". Gefiltert nach aktuellem Geschäft.
        pub url_dokumente: Option<String>,
        /// Link Vorgänge
        ///
        /// Link zum Datensatz "Grosser Rat: Vorgänge von Geschäften". Gefiltert nach aktuellem Geschäft.
        pub url_vorgaenge: Option<String>,
        /// Anrede Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier die Anrede nach amtlichen Geschlecht festgehalten.
        pub anrede_urheber: Option<String>,
        /// Gremientyp Urheber
        ///
        /// Wenn Urheber ein Gremium ist, dann wird hier der Typ des Gremiums festgehalten (Kommission oder Regierungsrat).
        pub gremientyp_urheber: Option<String>,
        /// Name Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Nachname der Person festgehalten. Ansonsten der Name des Gremiums.
        pub name_urheber: Option<String>,
        /// Vorname/Gremienkurzname Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Vorname der Person festgehalten. Ansonsten der Kurzname des Gremiums.
        pub vorname_urheber: Option<String>,
        /// Name, Vorname Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Ganze Name der Person festgehalten.
        pub name_vorname_urheber: Option<String>,
        /// Partei Urheber abgekürzt
        ///
        /// Wenn Urheber eine Person und noch aktuell Grossratsmitglied ist, dann wird hier die Abkürzung der Parteizugehörigkeit festgehalten.
        pub partei_kname_urheber: Option<String>,
        /// Urheber grosserrat.bs.ch
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Link zum Grossratsmitglied auf der Webseite des Grossen Rates festgehalten.
        pub url_urheber: Option<String>,
        /// ID Urheber
        ///
        /// Individuelle Identifikationsnummer des Urhebers innerhalb der Datenbank des Grossen Rates.
        pub nr_urheber: Option<String>,
        /// Urheber data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach dem aktuellen Urheber.
        pub url_urheber_ratsmitgl: Option<String>,
        /// Anrede Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier die Anrede nach amtlichen Geschlecht festgehalten.
        pub anrede_miturheber: Option<String>,
        /// Gremientyp Miturheber
        ///
        /// Wenn Miturheber ein Gremium ist, dann wird hier der Typ des Gremiums festgehalten (Kommission oder Regierungsrat).
        pub gremientyp_miturheber: Option<String>,
        /// Name Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier der Nachname der Person festgehalten. Ansonsten der Name des Gremiums.
        pub name_miturheber: Option<String>,
        /// Vorname/Gremienkurzname Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier der Vorname der Person festgehalten. Ansonsten der Kurzname des Gremiums.
        pub vorname_miturheber: Option<String>,
        /// Name, Vorname Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier der Ganze Name der Person festgehalten.
        pub name_vorname_miturheber: Option<String>,
        /// Partei Miturheber abgekürzt
        ///
        /// Wenn Miturheber eine Person und noch aktuell Grossratsmitglied ist, dann wird hier die Abkürzung der Parteizugehörigkeit festgehalten.
        pub partei_kname_miturheber: Option<String>,
        /// Miturheber grosserrat.bs.ch
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Link zum Grossratsmitglied auf der Webseite des Grossen Rates festgehalten.
        pub url_miturheber: Option<String>,
        /// ID Miturheber
        ///
        /// Individuelle Identifikationsnummer des Miturhebers innerhalb der Datenbank des Grossen Rates.
        pub nr_miturheber: Option<String>,
        /// Miturheber data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach dem aktuellen Miturheber.
        pub url_miturheber_ratsmitgl: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BeginnGes,
        EndeGes,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        DepartementGes,
        GaRrGr,
        UrlGes,
        UrlZuweisungen,
        UrlDokumente,
        UrlVorgaenge,
        AnredeUrheber,
        GremientypUrheber,
        NameUrheber,
        VornameUrheber,
        NameVornameUrheber,
        ParteiKnameUrheber,
        UrlUrheber,
        NrUrheber,
        UrlUrheberRatsmitgl,
        AnredeMiturheber,
        GremientypMiturheber,
        NameMiturheber,
        VornameMiturheber,
        NameVornameMiturheber,
        ParteiKnameMiturheber,
        UrlMiturheber,
        NrMiturheber,
        UrlMiturheberRatsmitgl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BeginnGes => "beginn_ges",
                Field::EndeGes => "ende_ges",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::DepartementGes => "departement_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlZuweisungen => "url_zuweisungen",
                Field::UrlDokumente => "url_dokumente",
                Field::UrlVorgaenge => "url_vorgaenge",
                Field::AnredeUrheber => "anrede_urheber",
                Field::GremientypUrheber => "gremientyp_urheber",
                Field::NameUrheber => "name_urheber",
                Field::VornameUrheber => "vorname_urheber",
                Field::NameVornameUrheber => "name_vorname_urheber",
                Field::ParteiKnameUrheber => "partei_kname_urheber",
                Field::UrlUrheber => "url_urheber",
                Field::NrUrheber => "nr_urheber",
                Field::UrlUrheberRatsmitgl => "url_urheber_ratsmitgl",
                Field::AnredeMiturheber => "anrede_miturheber",
                Field::GremientypMiturheber => "gremientyp_miturheber",
                Field::NameMiturheber => "name_miturheber",
                Field::VornameMiturheber => "vorname_miturheber",
                Field::NameVornameMiturheber => "name_vorname_miturheber",
                Field::ParteiKnameMiturheber => "partei_kname_miturheber",
                Field::UrlMiturheber => "url_miturheber",
                Field::NrMiturheber => "nr_miturheber",
                Field::UrlMiturheberRatsmitgl => "url_miturheber_ratsmitgl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100311/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): Tests Basel-Stadt
pub mod coronavirus_covid_19_tests_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Falldatum, entspricht in der Regel dem Datum der Probeentnahme
        pub datum: Option<Date>,
        /// Negative Tests
        ///
        /// Anzahl negative Tests. Eine Person kann mehrfach negativ getestet werden.
        pub negative_tests: Option<i64>,
        /// Positive Tests
        ///
        /// Anzahl positive Tests. Eine Person kann mehrfach positiv getestet werden.
        pub positive_tests: Option<i64>,
        /// Total Tests
        ///
        /// Anzahl durchgeführte Tests total. Eine Person kann mehrfach getestet werden.
        pub total_tests: Option<i64>,
        /// Anteil positive Tests in Prozent
        ///
        /// Anteil Tests mit einem positiven Ergebnis am Total der Tests in Prozent.
        pub positivity_rate_percent: Option<f64>,
        /// Anteil positive Tests
        ///
        /// Anteil Tests mit einem positiven Ergebnis am Total der Tests.
        pub positivity_rate: Option<f64>,
        /// Wochentag
        ///
        /// Wochentag des Falldatums. Mo=1, Di=2, Mi=3, Do=4, Fr = 5, Sa = 6, So = 7
        pub dayofweek: Option<i64>,
        /// Wochentag Nummer
        ///
        /// Nummer des Wochentags (Montag=0, Sonntag=6)
        pub weekday_nr: Option<i64>,
        /// Woche
        ///
        /// Wochennummer
        pub woche: Option<i64>,
        /// Total Antigen Schnelltests
        ///
        /// Anzahl durchgeführte Antigen Schnelltests total. Eine Person kann mehrfach getestet werden.
        pub entries_antigen_schnelltest: Option<i64>,
        /// Total PCR Tests
        ///
        /// Anzahl durchgeführte PCR Tests total. Eine Person kann mehrfach getestet werden.
        pub entries_pcr: Option<i64>,
        /// Negative Antigen Schnelltests
        ///
        /// Anzahl negative Antigen Schnelltests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_neg_antigen_schnelltest: Option<i64>,
        /// Negative PCR Tests
        ///
        /// Anzahl negative PCR Tests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_neg_pcr: Option<i64>,
        /// Positive Antigen Schnelltests
        ///
        /// Anzahl positive Antigen Schnelltests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_pos_antigen_schnelltest: Option<i64>,
        /// Positive PCR Tests
        ///
        /// Anzahl positive PCR Tests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_pos_pcr: Option<i64>,
        /// Anteil positive Antigen Schnelltests
        ///
        /// Anteil Antigen Schnelltests mit einem positiven Ergebnis am Total der Antigen Schnelltests.
        pub positivity_rate_antigen_schnelltest: Option<f64>,
        /// Anteil positive PCR Tests
        ///
        /// Anteil PCR Tests mit einem positiven Ergebnis am Total der PCR Tests.
        pub positivity_rate_pcr: Option<f64>,
        /// Anteil positive Antigen Schnelltests in Prozent
        ///
        /// Anteil Antigen Schnelltests mit einem positiven Ergebnis am Total der Antigen Schnelltests.
        pub positivity_rate_percent_antigen_schnelltest: Option<f64>,
        /// Anteil positive PCR Tests in Prozent
        ///
        /// Anteil PCR Tests mit einem positiven Ergebnis am Total der PCR Tests.
        pub positivity_rate_percent_pcr: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        NegativeTests,
        PositiveTests,
        TotalTests,
        PositivityRatePercent,
        PositivityRate,
        Dayofweek,
        WeekdayNr,
        Woche,
        EntriesAntigenSchnelltest,
        EntriesPcr,
        EntriesNegAntigenSchnelltest,
        EntriesNegPcr,
        EntriesPosAntigenSchnelltest,
        EntriesPosPcr,
        PositivityRateAntigenSchnelltest,
        PositivityRatePcr,
        PositivityRatePercentAntigenSchnelltest,
        PositivityRatePercentPcr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::NegativeTests => "negative_tests",
                Field::PositiveTests => "positive_tests",
                Field::TotalTests => "total_tests",
                Field::PositivityRatePercent => "positivity_rate_percent",
                Field::PositivityRate => "positivity_rate",
                Field::Dayofweek => "dayofweek",
                Field::WeekdayNr => "weekday_nr",
                Field::Woche => "woche",
                Field::EntriesAntigenSchnelltest => "entries_antigen_schnelltest",
                Field::EntriesPcr => "entries_pcr",
                Field::EntriesNegAntigenSchnelltest => "entries_neg_antigen_schnelltest",
                Field::EntriesNegPcr => "entries_neg_pcr",
                Field::EntriesPosAntigenSchnelltest => "entries_pos_antigen_schnelltest",
                Field::EntriesPosPcr => "entries_pos_pcr",
                Field::PositivityRateAntigenSchnelltest => "positivity_rate_antigen_schnelltest",
                Field::PositivityRatePcr => "positivity_rate_pcr",
                Field::PositivityRatePercentAntigenSchnelltest => {
                    "positivity_rate_percent_antigen_schnelltest"
                }
                Field::PositivityRatePercentPcr => "positivity_rate_percent_pcr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100094/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Veloabstellplätze
pub mod veloabstellplaetze {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Veloabstellplatz
        ///
        /// Eindeutiger Identifikator
        pub id_platz: Option<i64>,
        /// Typ
        ///
        /// Art des Abstellplatzes
        pub typ: Option<String>,
        /// Strasse
        ///
        /// Strassenname des Standort
        pub strasse: Option<String>,
        /// Tarif
        ///
        /// Tarif für Benutzung des Abstellplatzes
        pub tarif: Option<String>,
        /// Anzahl Velos
        ///
        /// Anzahl Stellplätze für Velos/Motorräder
        pub anzvelos: Option<i64>,
        /// Anschliessbar
        ///
        /// Vorrichtung für Anschliessung vorhanden
        pub anschliess: Option<String>,
        /// Gedeckt
        ///
        /// Dach vorhanden
        pub gedeckt: Option<String>,
        /// Zugänglichkeit
        pub zugang: Option<String>,
        /// Infos
        ///
        /// Internetadresse
        pub infos: Option<String>,
        /// Platz Cargovelos
        ///
        /// Gibt es Platz für Cargovelos
        pub cargovelo: Option<String>,
        /// Bike Ride
        ///
        /// Bike + Ride
        pub bikeride: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdPlatz,
        Typ,
        Strasse,
        Tarif,
        Anzvelos,
        Anschliess,
        Gedeckt,
        Zugang,
        Infos,
        Cargovelo,
        Bikeride,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdPlatz => "id_platz",
                Field::Typ => "typ",
                Field::Strasse => "strasse",
                Field::Tarif => "tarif",
                Field::Anzvelos => "anzvelos",
                Field::Anschliess => "anschliess",
                Field::Gedeckt => "gedeckt",
                Field::Zugang => "zugang",
                Field::Infos => "infos",
                Field::Cargovelo => "cargovelo",
                Field::Bikeride => "bikeride",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100241/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Velopumpen
pub mod velopumpen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Velopumpe
        ///
        /// Eindeutiger Identifikator der Velopumpe
        pub id_pumpe: Option<i64>,
        /// Händler
        ///
        /// Händlername
        pub haendler: Option<String>,
        /// Strasse
        ///
        /// Strasse und Hausnummer
        pub strasse: Option<String>,
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Pumpentyp
        ///
        /// Kategorien unterschiedlicher Pumpentypen
        pub pumpe: Option<String>,
        /// Verfügbarkeit
        ///
        /// Kategorien unterschiedlicher Verfügbarkeit. Der Wert „7/24“ in den Daten entspricht im Modell dem wert „jederzeit“.
        pub verfuegbar: Option<String>,
        /// Link
        ///
        /// Webseite
        pub link: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdPumpe,
        Haendler,
        Strasse,
        Plz,
        Ort,
        Pumpe,
        Verfuegbar,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdPumpe => "id_pumpe",
                Field::Haendler => "haendler",
                Field::Strasse => "strasse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Pumpe => "pumpe",
                Field::Verfuegbar => "verfuegbar",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100213/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrsberuhigte Zonen: Kernzone Verkehrskonzept Innenstadt
pub mod verkehrsberuhigte_zonen_kernzone_verkehrskonzept_innenstadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Objekt-ID
        ///
        /// Identifikationsnummer (für kantonsinterne Zwecke verwendet)
        pub objid: Option<String>,
        /// Objekt-ID
        ///
        /// Identifikationsnummer (für kantonsinterne Zwecke verwendet)
        pub objectid: Option<i64>,
        /// Name
        pub name: Option<String>,
        /// Infos
        pub infos: Option<String>,
        /// Zufahrt
        pub zufahrt: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Objectid,
        Name,
        Infos,
        Zufahrt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Objectid => "objectid",
                Field::Name => "name",
                Field::Infos => "infos",
                Field::Zufahrt => "zufahrt",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100253/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Strassen und Wege: Kantonsstrassen Riehen und Bettingen
pub mod strassen_und_wege_kantonsstrassen_riehen_und_bettingen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_KS_Riehen_Bettingen
        ///
        /// Eindeutiger Identifikator der Kantonsstrassen in Riehen und Bettingen
        pub id_ksrb: Option<i64>,
        /// Gemeinde
        ///
        /// Gemeinden (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub gemeinde: Option<String>,
        /// Eigentum
        ///
        /// Eigentümer
        pub eigentum: Option<String>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdKsrb,
        Gemeinde,
        Eigentum,
        Strasse,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdKsrb => "id_ksrb",
                Field::Gemeinde => "gemeinde",
                Field::Eigentum => "eigentum",
                Field::Strasse => "strasse",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100249/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nutzungsplan - Zonenplan Riehen:  Überlagernde Festlegungen
pub mod nutzungsplan_zonenplan_riehen_ueberlagernde_festlegungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Überlagende_Festlegung
        ///
        /// Eindeutiger Identifikator
        pub idueberfes: Option<String>,
        /// Festlegung Abk.
        ///
        /// Kürzel der Art der Festlegung
        pub festueber: Option<String>,
        /// Festlegung
        ///
        /// Art der Festlegung
        pub festuebtxt: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Verbindlichkeit
        pub verbindli: Option<String>,
        /// Schutzzweck
        ///
        /// Schutzzweck von Natur- und Landschaftsschutzzonen
        pub schutzzwec: Option<String>,
        /// rekurshängig
        ///
        /// 1 (bzw. true) wenn ein Rekurs vorhanden ist. Wenn ein Rekurs hängig ist, enthält das Objekt die neue, geplante Ausprägung, entgegen dem Geschäftsstatus ist diese jedoch noch nicht in Kraft.
        pub rekurshaen: Option<String>,
        /// Bezeichnung
        ///
        /// Bezeichnung der Festlegung
        pub bezeichnng: Option<String>,
        /// Id_Geschäft
        ///
        /// Eindeutiger Identifikator
        pub idgeschae: Option<String>,
        /// Geschäftsstatus
        pub geschaesta: Option<String>,
        /// Datum Status
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        pub geolink: Option<String>,
        /// Geschäftsbezeichnung
        pub geschaebez: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idueberfes,
        Festueber,
        Festuebtxt,
        Verbindli,
        Schutzzwec,
        Rekurshaen,
        Bezeichnng,
        Idgeschae,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idueberfes => "idueberfes",
                Field::Festueber => "festueber",
                Field::Festuebtxt => "festuebtxt",
                Field::Verbindli => "verbindli",
                Field::Schutzzwec => "schutzzwec",
                Field::Rekurshaen => "rekurshaen",
                Field::Bezeichnng => "bezeichnng",
                Field::Idgeschae => "idgeschae",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100256/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nutzungsplan - Zonenplan Bettingen:  Überlagernde Festlegungen
pub mod nutzungsplan_zonenplan_bettingen_ueberlagernde_festlegungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Überlagende_Festlegung
        ///
        /// Eindeutiger Identifikator
        pub idueberfes: Option<String>,
        /// Festlegung überlagernd
        ///
        /// Art der Festlegung
        pub festueber: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Verbindlichkeit
        pub verbindli: Option<String>,
        /// rekurshängig
        ///
        /// 1 (bzw. true) wenn ein Rekurs vorhanden ist. Wenn ein Rekurs hängig ist, enthält das Objekt die neue, geplante Ausprägung, entgegen dem Geschäftsstatus ist diese jedoch noch nicht in Kraft.
        pub rekurshaen: Option<String>,
        /// Bezeichnung
        ///
        /// Bezeichnung der Festlegung
        pub bezeichnng: Option<String>,
        /// Id_Geschäft
        ///
        /// Eindeutiger Identifikator
        pub idgeschae: Option<String>,
        /// Geschäftsstatus
        pub geschaesta: Option<String>,
        /// Datum Status
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        pub geolink: Option<String>,
        /// Geschäftsbezeichnung
        pub geschaebez: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idueberfes,
        Festueber,
        Verbindli,
        Rekurshaen,
        Bezeichnng,
        Idgeschae,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idueberfes => "idueberfes",
                Field::Festueber => "festueber",
                Field::Verbindli => "verbindli",
                Field::Rekurshaen => "rekurshaen",
                Field::Bezeichnng => "bezeichnng",
                Field::Idgeschae => "idgeschae",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100257/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrsberuhigte Zonen: Fussgängerzone
pub mod verkehrsberuhigte_zonen_fussgaengerzone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Fussgängerzone
        ///
        /// Eindeutiger Identifikator der Fussgängerzonen
        pub id_fussgae: Option<String>,
        /// Regime
        ///
        /// Regime der Zone
        pub regime: Option<String>,
        /// Regimenummer
        ///
        /// Nummer des Regimes
        pub regimenr: Option<String>,
        /// Name
        ///
        /// Name des Regimes
        pub name: Option<String>,
        /// Umsetzungsdatum
        ///
        /// Datum der Umsetzung
        pub umdatum: Option<String>,
        /// Umsetzungsjahr
        ///
        /// Jahr der Umsetzung
        pub umjahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdFussgae,
        Regime,
        Regimenr,
        Name,
        Umdatum,
        Umjahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdFussgae => "id_fussgae",
                Field::Regime => "regime",
                Field::Regimenr => "regimenr",
                Field::Name => "name",
                Field::Umdatum => "umdatum",
                Field::Umjahr => "umjahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100251/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte der Smiley-Geschwindigkeitsanzeigen
pub mod standorte_der_smiley_geschwindigkeitsanzeigen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Smiley
        ///
        /// Eindeutiger Identifikator (ID)
        pub id_smiley: Option<i64>,
        /// Id_Standort
        ///
        /// Identifikator des Standorts
        pub idstandort: Option<i64>,
        /// Strassennamen
        ///
        /// Strassenname des Standorts, an dem Smiley-Geschwindigkeitsanzeige platziert wird
        pub strname: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer des Standorts, an dem Smiley-Geschwindigkeitsanzeige aufgestellt wird, falls keine vorhanden Detailangabe zu Standort in Attribut «Hinweis»
        pub hausnr: Option<String>,
        /// Geschwindigkeit
        ///
        /// Signalisierte Geschwindigkeit (20 km/h, 30 km/h, 40 km/h, 50 km/h, 60 km/h, 80 km/h)
        pub geschwind: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung in Form des Strassenamens der anzufahrenden Strasse
        pub richtung: Option<String>,
        /// Hinweis
        ///
        /// Detailangaben zum Standort
        pub hinweis: Option<String>,
        /// Status
        pub status: Option<String>,
        /// Messbeginn
        ///
        /// Datum des Beginn Smiley-Geschwindigkeitsanzeigen-Betriebs
        pub messbegin: Option<Date>,
        /// Messende
        ///
        /// Datum des Ende Smiley-Geschwindigkeitsanzeigen-Betriebs
        pub messende: Option<Date>,
        /// OGD-Link-Einzelmessung
        ///
        /// Link zur Einzelmessung auf OGD
        pub ogdeinzel: Option<String>,
        /// OGD-Link-Analyse
        ///
        /// Link zur Analyse auf OGD
        pub odganalyse: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdSmiley,
        Idstandort,
        Strname,
        Hausnr,
        Geschwind,
        Richtung,
        Hinweis,
        Status,
        Messbegin,
        Messende,
        Ogdeinzel,
        Odganalyse,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdSmiley => "id_smiley",
                Field::Idstandort => "idstandort",
                Field::Strname => "strname",
                Field::Hausnr => "hausnr",
                Field::Geschwind => "geschwind",
                Field::Richtung => "richtung",
                Field::Hinweis => "hinweis",
                Field::Status => "status",
                Field::Messbegin => "messbegin",
                Field::Messende => "messende",
                Field::Ogdeinzel => "ogdeinzel",
                Field::Odganalyse => "odganalyse",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100286/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Strassen und Wege: Strassentypen und Wege
pub mod strassen_und_wege_strassentypen_und_wege {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Strassentyp/Weg
        ///
        /// Eindeutiger Identifikator der Strasse/Weg
        pub id_strweg: Option<i64>,
        /// Strassenname
        pub strname: Option<String>,
        /// Strassennetzhierarchie
        ///
        /// Kategorien unterschiedlicher Strassennetzhierarchien (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub snh: Option<String>,
        /// Strassennetzhierarchien Beschreibung
        pub strassennetzhierarchien_beschreibung: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinden (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub gemeinde: Option<String>,
        /// Kategorie
        ///
        /// Kategorien (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub kategorie: Option<String>,
        /// Weg
        ///
        /// Wege
        pub weg: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdStrweg,
        Strname,
        Snh,
        StrassennetzhierarchienBeschreibung,
        Gemeinde,
        Kategorie,
        Weg,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdStrweg => "id_strweg",
                Field::Strname => "strname",
                Field::Snh => "snh",
                Field::StrassennetzhierarchienBeschreibung => {
                    "strassennetzhierarchien_beschreibung"
                }
                Field::Gemeinde => "gemeinde",
                Field::Kategorie => "kategorie",
                Field::Weg => "weg",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100250/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rheinüberwachungsstation: Umweltanalyse Wasserphase
pub mod rheinueberwachungsstation_umweltanalyse_wasserphase {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Geo Point
        ///
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme. Dauer codiert nach Konvention der Internationalen Kommission zum Schutz des Rheins (IKSR) 1M =24h; 14M=336h; 28M=672; 1M14 24h Mischprobe alle 14Tage; Sammelprobe=Dauer variabel abhängig von Schwebstoffanteil. MS steht für Mischung Stahl, MK für Mischung Kunststoff. E steht für Einzelmessung, M für Mischprobenentnahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht. Automatische Auswertung heisst, dass die Integration des Peaks von einem Algorhytmus erledigt wurde und nur bei ausserordentlich hohen Werten manuell nachkontrolliert wird.
        ///Sofern für einen Parameter zwei Resultate (einmal mit automatische Auswertung TRUE und einmal mit FALSE) angegeben sind, ist dasjenige mit automatische Auswertung TRUE vorzuziehen.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probenahme.
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100069/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Transformation Areal Rosental: Gemessene Überschreitungen der Interventionswerte
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_gemessene_ueberschreitungen_der_interventionswerte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<String>,
        /// Standort
        pub standort: Option<String>,
        /// Parameter
        pub parameter: Option<String>,
        /// Messwert [µg/m3]
        pub messwert_ug_m3: Option<f64>,
        /// Interventionswert [µg/m3]
        pub interventionswert_ug_m3: Option<f64>,
        /// Info / Massnahmen
        pub info_massnahmen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Standort,
        Parameter,
        MesswertUgM3,
        InterventionswertUgM3,
        InfoMassnahmen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::MesswertUgM3 => "messwert_ug_m3",
                Field::InterventionswertUgM3 => "interventionswert_ug_m3",
                Field::InfoMassnahmen => "info_massnahmen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100295/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schulstandorte (Gemeinde Basel)
pub mod schulstandorte_gemeinde_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Schulstandort
        ///
        /// Bezeichnung des Schulstandorts
        pub schulstand: Option<String>,
        /// Schultyp
        ///
        /// Art des Schulhauses
        pub schultyp: Option<String>,
        /// Adresse
        pub name: Option<String>,
        /// Funktion
        ///
        /// Funktion der Schule
        pub funktion: Option<String>,
        /// Strasse
        ///
        /// Strassenname des Schulhauses
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer des Schulhauses
        pub hausnummer: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl des Schulhauses
        pub plz: Option<String>,
        /// Ortschaft
        ///
        /// Ortschaftsname des Schulhauses
        pub ortschaft: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// Fax
        pub fax: Option<String>,
        /// Link
        ///
        /// Internetadresse des Schulhauses
        pub link: Option<String>,
        /// PDF-Report
        ///
        /// PDF-Report des Schulhauses
        pub pdf_report: Option<String>,
        /// Geometrie
        ///
        /// Punktgeometrie
        pub geometrie: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Schulstand,
        Schultyp,
        Name,
        Funktion,
        Strasse,
        Hausnummer,
        Plz,
        Ortschaft,
        Telefon,
        Fax,
        Link,
        PdfReport,
        Geometrie,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schulstand => "schulstand",
                Field::Schultyp => "schultyp",
                Field::Name => "name",
                Field::Funktion => "funktion",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ortschaft => "ortschaft",
                Field::Telefon => "telefon",
                Field::Fax => "fax",
                Field::Link => "link",
                Field::PdfReport => "pdf_report",
                Field::Geometrie => "geometrie",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100029/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gewässerschutzkarte: Gewässerschutzbereiche
pub mod gewaesserschutzkarte_gewaesserschutzbereiche {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_GSBereich
        ///
        /// Eindeutiger Identifikator des ÖREB Fachsystems
        pub idgbereich: Option<String>,
        /// Typ
        ///
        /// Typ des Gewässerschutzbereichs (siehe 9.9 Wertebereich in der Modellbeschreibung)
        pub typ: Option<String>,
        /// Kantonale-Typ-Bezeichnung
        pub kantypbez: Option<String>,
        /// Typ-Beschreibung
        pub typ_beschreibung: Option<String>,
        /// Rechtsdokumente
        ///
        /// Link zu den Rechtsdokumenten
        pub geolink: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idgbereich,
        Typ,
        Kantypbez,
        TypBeschreibung,
        Geolink,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idgbereich => "idgbereich",
                Field::Typ => "typ",
                Field::Kantypbez => "kantypbez",
                Field::TypBeschreibung => "typ_beschreibung",
                Field::Geolink => "geolink",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100291/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schulstandorte (Gemeinden Riehen und Bettingen)
pub mod schulstandorte_gemeinden_riehen_und_bettingen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_SCHULE
        pub id_schule: Option<i64>,
        /// Schulstandort
        pub standort: Option<String>,
        /// Schultyp
        pub typ: Option<String>,
        /// Name der Schule
        pub name: Option<String>,
        /// Telefon Kontaktperson 1
        pub telefon1: Option<String>,
        /// Telefon Kontaktperson 2
        pub telefon2: Option<String>,
        /// Strasse
        pub strasse: Option<String>,
        /// Hausnummer
        pub hausnummer: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ortschaft
        pub ort: Option<String>,
        /// Fax
        pub fax: Option<String>,
        /// Link
        pub link: Option<String>,
        /// Geometrie
        pub geometrie: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdSchule,
        Standort,
        Typ,
        Name,
        Telefon1,
        Telefon2,
        Strasse,
        Hausnummer,
        Plz,
        Ort,
        Fax,
        Link,
        Geometrie,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdSchule => "id_schule",
                Field::Standort => "standort",
                Field::Typ => "typ",
                Field::Name => "name",
                Field::Telefon1 => "telefon1",
                Field::Telefon2 => "telefon2",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Fax => "fax",
                Field::Link => "link",
                Field::Geometrie => "geometrie",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100030/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): Fallzahlen Basel-Stadt
pub mod coronavirus_covid_19_fallzahlen_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datenstand
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Kanton
        pub abbreviation_canton_and_fl: Option<String>,
        /// Aktive Fälle (ehemals Isolierte)
        ///
        /// Ab dem 1.4.22 gelten Personen bis zum 5. Tag nach dem Tag des positiven Tests als "aktive Fälle". Frühere Definition: Mit dem neuen Coronavirus infizierte Personen, welche isoliert sind
        pub current_isolated: Option<i64>,
        /// Kontaktpersonen in Quarantäne
        ///
        /// Personen, welche sich in Quarantäne befinden, weil sie in engem Kontakt zu einem Infizierten Fall waren
        pub current_quarantined: Option<i64>,
        /// Reiserückkehrer in Quarantäne
        ///
        /// Personen, welche sich aufgrund einer Einreise aus einem Gebiet mit erhöhtem Ansteckungsrisiko gemäss BAG in Quarantäne befinden
        pub current_quarantined_riskareatravel: Option<i64>,
        /// In Quarantäne total
        ///
        /// Total der Personen in Quarantäne.
        pub current_quarantined_total: Option<i64>,
        /// Fälle mit Wohnsitz BS
        ///
        /// Anzahl in Basel-Stadt auf das neue Coronavirus positiv getestete Personen mit Wohnsitz in Basel-Stadt (kumuliert)
        pub ncumul_conf: Option<f64>,
        /// Fälle mit Wohnsitz ausserhalb BS
        ///
        /// Anzahl in Basel-Stadt auf Coronavirus positiv getestete Personen mit Wohnsitz ausserhalb Basel-Stadt insgesamt (kumuliert)
        pub ncumul_confirmed_non_resident: Option<i64>,
        /// Differenz Fälle mit Wohnsitz BS
        ///
        /// Neu gemeldete Fälle mit Wohnsitz in Basel-Stadt gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_conf: Option<i64>,
        /// Differenz Fälle mit Wohnsitz ausserhalb BS
        ///
        /// Neu gemeldete Fälle mit Wohnsitz ausserhalb des Kantons Basel-Stadt gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_confirmed_non_resident: Option<i64>,
        /// Hospitalisierte
        ///
        /// In Basel-Stadt hospitalisierte Personen mit COVID-19 Erkrankung (inkl. Fälle auf Intensivstationen)
        pub current_hosp: Option<i64>,
        /// Hospitalisierte mit Wohnsitz BS
        ///
        /// Anzahl zum aktuellen Zeitpunkt an COVID-19 erkrankte in Basel-Stadt hospitalisierte Personen mit Wohnsitz in Basel-Stadt (inkl. Fälle auf Intensivstationen)
        pub current_hosp_resident: Option<i64>,
        /// Hospitalisierte mit Wohnsitz ausserhalb BS
        ///
        /// Anzahl zum aktuellen Zeitpunkt an COVID-19 erkrankte in Basel-Stadt hospitalisierte Personen mit Wohnsitz ausserhalb Basel-Stadt (inkl. Fälle auf Intensivstationen)
        pub current_hosp_non_resident: Option<i64>,
        /// Neu Hospitalisierte
        ///
        /// Seit letzter Meldung neu hinzugekommene COVID-19 Fälle im Spital
        pub new_hosp: Option<i64>,
        /// Fälle auf Intensivstation
        ///
        /// An COVID-19 Erkrankte in Intensivstationen Basel-Städtischer Spitäler
        pub current_icu: Option<i64>,
        /// Intubierte
        ///
        /// Anzahl aktuell intubierte COVID-19 Fälle in Spitälern Basel-Stadt
        pub current_vent: Option<i64>,
        /// Genesene
        ///
        /// Anzahl genesene Personen mit Wohnsitz im Kanton Basel-Stadt insgesamt (kumuliert). Definition ab dem 1.4.22: Personen gelten ab dem 6. Tag nach positivem Testresultat als genesen. Ursprüngliche Definition: Als genesen gilt, wer 10 Tage nach einem positiven Covid-19-Test resp. 10 Tage nach den ersten Symptomen mindestens 48 Stunden symptomfrei war.
        pub ncumul_released: Option<i64>,
        /// Differenz Genesene
        ///
        /// Neu gemeldete Genesene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_released: Option<i64>,
        /// Verstorbene
        ///
        /// Anzahl mit COVID-19 Erkrankung verstorbene Personen mit Wohnsitz in Basel-Stadt, kumuliert
        pub ncumul_deceased: Option<i64>,
        /// Differenz Verstorbene
        ///
        /// Neu gemeldete Gestorbene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_deceased: Option<i64>,
        /// Quelle
        ///
        /// Datenquelle(n)
        pub source: Option<String>,
        /// Datum
        ///
        /// Datum der Datenveröffentlichung
        pub date: Option<Date>,
        /// Zeit
        ///
        /// Zeit der Datenveröffentlichung
        pub time: Option<String>,
        /// Woche
        ///
        /// Nummer der Kalenderwoche
        pub week: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        AbbreviationCantonAndFl,
        CurrentIsolated,
        CurrentQuarantined,
        CurrentQuarantinedRiskareatravel,
        CurrentQuarantinedTotal,
        NcumulConf,
        NcumulConfirmedNonResident,
        NdiffConf,
        NdiffConfirmedNonResident,
        CurrentHosp,
        CurrentHospResident,
        CurrentHospNonResident,
        NewHosp,
        CurrentIcu,
        CurrentVent,
        NcumulReleased,
        NdiffReleased,
        NcumulDeceased,
        NdiffDeceased,
        Source,
        Date,
        Time,
        Week,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::AbbreviationCantonAndFl => "abbreviation_canton_and_fl",
                Field::CurrentIsolated => "current_isolated",
                Field::CurrentQuarantined => "current_quarantined",
                Field::CurrentQuarantinedRiskareatravel => "current_quarantined_riskareatravel",
                Field::CurrentQuarantinedTotal => "current_quarantined_total",
                Field::NcumulConf => "ncumul_conf",
                Field::NcumulConfirmedNonResident => "ncumul_confirmed_non_resident",
                Field::NdiffConf => "ndiff_conf",
                Field::NdiffConfirmedNonResident => "ndiff_confirmed_non_resident",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentHospResident => "current_hosp_resident",
                Field::CurrentHospNonResident => "current_hosp_non_resident",
                Field::NewHosp => "new_hosp",
                Field::CurrentIcu => "current_icu",
                Field::CurrentVent => "current_vent",
                Field::NcumulReleased => "ncumul_released",
                Field::NdiffReleased => "ndiff_released",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::NdiffDeceased => "ndiff_deceased",
                Field::Source => "source",
                Field::Date => "date",
                Field::Time => "time",
                Field::Week => "week",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100073/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gewässerschutzkarte: Grundwasserschutzzonen
pub mod gewaesserschutzkarte_grundwasserschutzzonen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_GWSZone
        ///
        /// Eindeutiger Identifikator des ÖREB Fachsystems
        pub idgwszone: Option<String>,
        /// Typ
        ///
        /// Typ der Schutzzone (siehe 9.9 Wertebereich in der Modellbeschreibung)
        pub typ: Option<String>,
        /// Kantonale-Typ-Bezeichnung
        pub kantypbez: Option<String>,
        /// Typ-Beschreibung
        pub typ_beschreibung: Option<String>,
        /// Ist altrechtlich
        ///
        /// Angabe aus dem Bundesmodells, informiert ob rechtsgültige Objekte nicht mehr den heutigen gesetzl. Anforderungen entsprechen
        pub altrecht: Option<String>,
        /// Bemerkungen
        pub bemerkung: Option<String>,
        /// Id_Geschaeft
        ///
        /// Eindeutiger Identifikator des ÖREB Fachsystems
        pub idgeschaef: Option<String>,
        /// Geschäftsstatus
        ///
        /// Der Geschäftsstatus gibt den letzten publizierten Status eines Geschäfts wieder (siehe 9.9 Wertebereich in der Modellbeschreibung)
        pub geschaesta: Option<String>,
        /// Datum_Status
        ///
        /// Datum des Statuswechsels
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        ///
        /// Eindeutige Verbindung zur Rechtsvorschrift
        pub geolink: Option<String>,
        /// Geschaeftsbezeichnung
        ///
        /// Bezeichnung des Geschäfts
        pub geschaebez: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idgwszone,
        Typ,
        Kantypbez,
        TypBeschreibung,
        Altrecht,
        Bemerkung,
        Idgeschaef,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idgwszone => "idgwszone",
                Field::Typ => "typ",
                Field::Kantypbez => "kantypbez",
                Field::TypBeschreibung => "typ_beschreibung",
                Field::Altrecht => "altrecht",
                Field::Bemerkung => "bemerkung",
                Field::Idgeschaef => "idgeschaef",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100292/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abfuhrzonen (Gemeinde Basel)
pub mod abfuhrzonen_gemeinde_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ZONE
        pub zone: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Zone,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zone => "zone",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100095/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verbotszonen geteilte Mikromobilität: Sperr- und Parkverbotszonen
pub mod verbotszonen_geteilte_mikromobilitaet_sperr_und_parkverbotszonen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Verbotszone
        ///
        /// Eindeutiger Identifikator der Verbotszone
        pub id_verbot: Option<i64>,
        /// Name
        ///
        /// Bezeichnung der Verbotszone
        pub name: Option<String>,
        /// Regulierungsart
        ///
        /// Art der Verbotszone
        pub regart: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdVerbot,
        Name,
        Regart,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdVerbot => "id_verbot",
                Field::Name => "name",
                Field::Regart => "regart",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100332/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Feinstaubmessungen Naturhistorisches Museum Basel
pub mod feinstaubmessungen_naturhistorisches_museum_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel des Messbeginns
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm25: Option<f64>,
        /// Zeitstempel als String
        pub zeitstempel_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        Pm25,
        ZeitstempelText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::Pm25 => "pm25",
                Field::ZeitstempelText => "zeitstempel_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100100/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Tigermückenbekämpfung: Bekämpfungszone
pub mod tigermueckenbekaempfung_bekaempfungszone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID Bekämpfungszone
        ///
        /// Eindeutiger Identifikator
        pub id_bekam: Option<i64>,
        /// URL
        ///
        /// URL zur Infoseite
        pub url: Option<String>,
        /// Merkblatt
        ///
        /// URL zum Merkblatt
        pub merkblatt: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdBekam,
        Url,
        Merkblatt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdBekam => "id_bekam",
                Field::Url => "url",
                Field::Merkblatt => "merkblatt",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100305/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Secondhand-Angebote / Wiederverwendungsstellen
pub mod secondhand_angebote_wiederverwendungsstellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_wiederv: Option<i64>,
        /// Kategorie
        ///
        /// Kategorie der Wiederverwendungsstelle
        pub kategorie: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Beschreibung
        pub beschreibu: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Gemeinde
        pub ortschaft: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// Link
        pub link: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdWiederv,
        Kategorie,
        Name,
        Beschreibu,
        Adresse,
        Plz,
        Ortschaft,
        Telefon,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdWiederv => "id_wiederv",
                Field::Kategorie => "kategorie",
                Field::Name => "name",
                Field::Beschreibu => "beschreibu",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ortschaft => "ortschaft",
                Field::Telefon => "telefon",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100363/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kitas und Tagesheime
pub mod kitas_und_tagesheime {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_tk: Option<i64>,
        /// Standortname
        ///
        /// Bezeichnung des Standortes
        pub std_name: Option<String>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
        /// Hausnummer
        pub haus_nr: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        ///
        /// Gemeinde
        pub ort: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// Homepage
        ///
        /// Internetadresse
        pub homepage: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdTk,
        StdName,
        Strasse,
        HausNr,
        Plz,
        Ort,
        Telefon,
        Homepage,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdTk => "id_tk",
                Field::StdName => "std_name",
                Field::Strasse => "strasse",
                Field::HausNr => "haus_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::Homepage => "homepage",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100341/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Live-Abstimmungsergebnisse
pub mod grosser_rat_live_abstimmungsergebnisse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Zeit
        ///
        /// Uhrzeit
        pub zeit: Option<String>,
        /// Traktandum
        ///
        /// Nummer des Traktandums, falls vorhanden, gemäss Tagesordnung (Traktandenliste)
        pub traktandum: Option<i64>,
        /// Subtraktandum
        ///
        /// Nummer des Subtraktandums, falls vorhanden,  gemäss Tagesordnung (Traktandenliste)
        pub subtraktandum: Option<i64>,
        /// Geschäft
        ///
        /// Titel des Geschäfts
        pub geschaeft: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Geschäfts
        pub signatur_ges: Option<String>,
        /// Geschäft auf grosserrat.bs.ch
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach dem Geschäft.
        pub url_geschaeft_ods: Option<String>,
        /// Signatur Dokument
        ///
        /// Signatur des Dokuments
        pub signatur_dok: Option<String>,
        /// Abstimmungsnummer
        ///
        /// Laufende Nummerierung der Abstimmungen an einem Sitzungstag
        pub abst_nr: Option<String>,
        /// Typ
        ///
        /// Abstimmungstyp (ab September 2023 gibt es neue Typen)
        pub typ: Option<String>,
        /// Ja-Stimmen
        ///
        /// Anzahl Grossratsmitglieder, welche mit "Ja" abgestimmt haben
        pub anz_j: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Grossratsmitglieder, welche mit "Nein" abgestimmt haben
        pub anz_n: Option<i64>,
        /// Enthaltungen
        ///
        /// Anzahl Grossratsmitglieder, welche sich der Stimme enthalten haben
        pub anz_e: Option<i64>,
        /// Abwesende
        ///
        /// Anzahl Grossratsmitglieder, welche bei der Abstimmung nicht anwesend waren
        pub anz_a: Option<i64>,
        /// Präsidiumsstimmen
        ///
        /// Anzahl Stimmen der Ratspräsidentin oder des Ratspräsidenten (= maximal 1)
        pub anz_p: Option<i64>,
        /// Sitz Nr.
        ///
        /// Nummer des Sitzes des Grossratsmitglieds
        pub sitz_nr: Option<i64>,
        /// Anrede
        ///
        /// Anrede des Grossratsmitglieds
        pub mitglied_anrede: Option<String>,
        /// Nachname
        ///
        /// Nachname des Grossratsmitglieds
        pub mitglied_nachname: Option<String>,
        /// Vorname
        ///
        /// Vorname des Grossratsmitglieds
        pub mitglied_vorname: Option<String>,
        /// Name
        ///
        /// Vor- und Nachname des Grossratsmitglieds
        pub mitglied_name: Option<String>,
        /// Fraktion
        ///
        /// Fraktion des Grossratsmitglieds
        pub fraktion: Option<String>,
        /// Name und Fraktion
        ///
        /// Name und Fraktionszugehörigkeit des Grossratsmitglieds
        pub mitglied_name_fraktion: Option<String>,
        /// Funktion
        ///
        /// Funktion des Grossratsmitglieds (Mitglied, Präsident/in, Statthalter/in)
        pub mitglied_funktion: Option<String>,
        /// Entscheid Mitglied
        ///
        /// Stimmverhalten des Grossratsmitglieds (Ja, Nein, Enthaltung, Abwesend, Präsidium)
        pub entscheid_mitglied: Option<String>,
        /// ID Ratsmitglied
        ///
        /// Individuelle Identifikationsnummer des Grossratsmitglied innerhalb der Datenbank des Grossen Rates.
        pub gr_uni_nr: Option<String>,
        /// Ratsmitglied auf grosserrat.bs.ch
        ///
        /// Link zum Grossratsmitglied auf der Webseite des Grossen Rates
        pub gr_url: Option<String>,
        /// Ratsmitglied auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach Grossratsmitglied.
        pub gr_url_ods: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitstempel_text: Option<OffsetDateTime>,
        /// Datenstand
        ///
        /// Datum und Uhrzeit des Datenexports
        #[serde(with = "time::serde::iso8601::option")]
        pub datenstand_text: Option<OffsetDateTime>,
        /// Erweiterte Abstimmungsnummer
        ///
        /// Besteht aus [Abstimmungsnummer]-[Datum]-[Uhrzeit]
        pub anr: Option<String>,
        /// Abstimmungsdokument auf grosserrat.bs.ch
        ///
        /// Link zum Dokument der Abstimmung auf der Webseite des Grossen Rates
        pub url_abstimmung_dok: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Zeit,
        Traktandum,
        Subtraktandum,
        Geschaeft,
        SignaturGes,
        UrlGes,
        UrlGeschaeftOds,
        SignaturDok,
        AbstNr,
        Typ,
        AnzJ,
        AnzN,
        AnzE,
        AnzA,
        AnzP,
        SitzNr,
        MitgliedAnrede,
        MitgliedNachname,
        MitgliedVorname,
        MitgliedName,
        Fraktion,
        MitgliedNameFraktion,
        MitgliedFunktion,
        EntscheidMitglied,
        GrUniNr,
        GrUrl,
        GrUrlOds,
        ZeitstempelText,
        DatenstandText,
        Anr,
        UrlAbstimmungDok,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Zeit => "zeit",
                Field::Traktandum => "traktandum",
                Field::Subtraktandum => "subtraktandum",
                Field::Geschaeft => "geschaeft",
                Field::SignaturGes => "signatur_ges",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
                Field::SignaturDok => "signatur_dok",
                Field::AbstNr => "abst_nr",
                Field::Typ => "typ",
                Field::AnzJ => "anz_j",
                Field::AnzN => "anz_n",
                Field::AnzE => "anz_e",
                Field::AnzA => "anz_a",
                Field::AnzP => "anz_p",
                Field::SitzNr => "sitz_nr",
                Field::MitgliedAnrede => "mitglied_anrede",
                Field::MitgliedNachname => "mitglied_nachname",
                Field::MitgliedVorname => "mitglied_vorname",
                Field::MitgliedName => "mitglied_name",
                Field::Fraktion => "fraktion",
                Field::MitgliedNameFraktion => "mitglied_name_fraktion",
                Field::MitgliedFunktion => "mitglied_funktion",
                Field::EntscheidMitglied => "entscheid_mitglied",
                Field::GrUniNr => "gr_uni_nr",
                Field::GrUrl => "gr_url",
                Field::GrUrlOds => "gr_url_ods",
                Field::ZeitstempelText => "zeitstempel_text",
                Field::DatenstandText => "datenstand_text",
                Field::Anr => "anr",
                Field::UrlAbstimmungDok => "url_abstimmung_dok",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100186/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Vorhersagen Rhein: Wasserstand und Abfluss
pub mod vorhersagen_rhein_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wasserstand
        ///
        /// Pegelstand in Meter über Meer. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub wasserstand: Option<f64>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmeter pro Sekunde. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub abfluss: Option<f64>,
        /// Methode
        ///
        /// Das verwendete Meteo-Modell
        pub methode: Option<String>,
        /// Zeitstempel Ausgabe
        ///
        /// Datum und Uhrzeit der Veröffentlichung
        #[serde(with = "time::serde::iso8601::option")]
        pub ausgegeben_an: Option<OffsetDateTime>,
        /// Zeitstempel Meteolauf
        ///
        /// Datum und Uhrzeit des Meteo-Laufs (der Zeitpunkt, zu dem die meteorologischen Vorhersagen erstellt wurden, die dann als Grundlage für das Modell zur Berechnung der hydrologischen Vorhersagen verwendet wird)
        #[serde(with = "time::serde::iso8601::option")]
        pub meteolauf: Option<OffsetDateTime>,
        /// Zeitstempel Gemessene Werte
        ///
        /// Datum und Uhrzeit, bis zu dem die Werte gemessen wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub gemessene_werten_bis: Option<OffsetDateTime>,
        /// Wasserstand Minimum
        ///
        /// Minimum (0%-Quantil) des Pegelstands in Meter über Meer
        pub h_min: Option<f64>,
        /// Wasserstand 25%-Quantil
        ///
        /// 25%-Quantil des Pegelstands in Meter über Meer
        pub h_p25: Option<f64>,
        /// Wasserstand Median
        ///
        /// Median (50%-Quantil) des Pegelstands in Meter über Meer
        pub h_p50: Option<f64>,
        /// Wasserstand 75%-Quantil
        ///
        /// 75%-Quantil des Pegelstands in Meter über Meer
        pub h_p75: Option<f64>,
        /// Wasserstand Maximum
        ///
        /// Maximum (100%-Quantil) des Pegelstands in Meter über Meer
        pub h_max: Option<f64>,
        /// Abflussmenge Minimum
        ///
        /// Minimum (0%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_min: Option<f64>,
        /// Abflussmenge 25%-Quantil
        ///
        /// 25%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p25: Option<f64>,
        /// Abflussmenge Median
        ///
        /// Median (50%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p50: Option<f64>,
        /// Abflussmenge 75%-Quantil
        ///
        /// 75%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p75: Option<f64>,
        /// Abflussmenge Maximum
        ///
        /// Maximum (100%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_max: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Wasserstand,
        Abfluss,
        Methode,
        AusgegebenAn,
        Meteolauf,
        GemesseneWertenBis,
        HMin,
        HP25,
        HP50,
        HP75,
        HMax,
        QMin,
        QP25,
        QP50,
        QP75,
        QMax,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Wasserstand => "wasserstand",
                Field::Abfluss => "abfluss",
                Field::Methode => "methode",
                Field::AusgegebenAn => "ausgegeben_an",
                Field::Meteolauf => "meteolauf",
                Field::GemesseneWertenBis => "gemessene_werten_bis",
                Field::HMin => "h_min",
                Field::HP25 => "h_p25",
                Field::HP50 => "h_p50",
                Field::HP75 => "h_p75",
                Field::HMax => "h_max",
                Field::QMin => "q_min",
                Field::QP25 => "q_p25",
                Field::QP50 => "q_p50",
                Field::QP75 => "q_p75",
                Field::QMax => "q_max",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100271/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Transformation Areal Rosental: Flüchtige Schadstoffe
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_fluechtige_schadstoffe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messbeginn
        ///
        /// Beginn der Messung
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Ende der Messung
        pub messende: Option<Date>,
        /// Standort
        ///
        /// Name des Standorts
        pub standort: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff
        pub parameter: Option<String>,
        /// Messwert
        ///
        /// Gemessener Wert
        pub messwert: Option<f64>,
        /// Messwert 3 Dezimalstellen
        pub messwert_3_dezimalstellen: Option<f64>,
        /// Interventionswert
        pub interventionswert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub interventionswert_3_dez: Option<f64>,
        /// Warnwert
        pub warnwert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub warnwert_3_dez: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird
        pub einheit: Option<String>,
        /// Messmethode
        pub messmethode: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Messbeginn,
        Messende,
        Standort,
        Parameter,
        Messwert,
        Messwert3Dezimalstellen,
        Interventionswert,
        Interventionswert3Dez,
        Warnwert,
        Warnwert3Dez,
        Einheit,
        Messmethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::Messwert => "messwert",
                Field::Messwert3Dezimalstellen => "messwert_3_dezimalstellen",
                Field::Interventionswert => "interventionswert",
                Field::Interventionswert3Dez => "interventionswert_3_dez",
                Field::Warnwert => "warnwert",
                Field::Warnwert3Dez => "warnwert_3_dez",
                Field::Einheit => "einheit",
                Field::Messmethode => "messmethode",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100273/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Birs Temperatur, Wasserstand und Abfluss
pub mod birs_temperatur_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmetern pro Sekunde
        pub abfluss: Option<f64>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
        /// Temperatur
        ///
        /// Temperatur in Grad Celsius
        pub temperatur: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Abfluss,
        Pegel,
        Temperatur,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Abfluss => "abfluss",
                Field::Pegel => "pegel",
                Field::Temperatur => "temperatur",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100236/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smart Climate Feinstaubmessungen
pub mod smart_climate_feinstaubmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitstempel: Option<OffsetDateTime>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm_2_5: Option<f64>,
        /// Station Name
        pub name: Option<String>,
        /// Station Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Station ID
        pub id: Option<String>,
        pub station: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Zeitstempel,
        Pm25,
        Name,
        Id,
        Station,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zeitstempel => "zeitstempel",
                Field::Pm25 => "pm_2_5",
                Field::Name => "name",
                Field::Id => "id",
                Field::Station => "station",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100081/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smart Climate Schallpegelmessungen
pub mod smart_climate_schallpegelmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station
        ///
        /// Name der Station
        pub station_id: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wert
        ///
        /// Gemessene Lautstärke in Dezibel
        pub value: Option<f64>,
        /// Geopunkt
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geographische Breite
        pub latitude: Option<f64>,
        /// Geographische Länge
        pub longitude: Option<f64>,
        /// EUI
        ///
        /// ID der Mess-Station
        pub eui: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        StationId,
        Timestamp,
        Value,
        Latitude,
        Longitude,
        Eui,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::Timestamp => "timestamp",
                Field::Value => "value",
                Field::Latitude => "latitude",
                Field::Longitude => "longitude",
                Field::Eui => "eui",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100087/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rhein Wasserstand Klingentalfähre
pub mod rhein_wasserstand_klingentalfaehre {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Pegel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Pegel => "pegel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100243/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Strassenverkehrsunfälle
pub mod strassenverkehrsunfaelle {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Eindeutiger Identifikator des Unfalls
        ///
        /// Eindeutiger Identifikator des Unfalls aus der MISTRA-Applikation Verkehrsunfälle.
        pub id_unfall: Option<i64>,
        /// Beschreibung zum Unfalltyp
        ///
        /// Der Unfalltyp bezeichnet den Verkehrsvorgang bzw. die Konfliktsituation, welche massgebend für die Entstehung des Unfalls ist.
        pub typ: Option<String>,
        /// Beschreibung der Unfallschwerekategorie
        ///
        /// Beschreibung der Unfallschwerekategorie.
        pub schwere: Option<String>,
        /// Unfalljahr
        ///
        /// Unfalljahr in dem sich der Unfall ereignet hat.
        pub jahr: Option<Date>,
        /// Unfallmonat
        ///
        /// Unfallmonat in dem sich der Unfall ereignet hat.
        pub monat: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag an dem sich der Unfall ereignet hat.
        pub wochentag: Option<String>,
        /// Unfallstunde
        ///
        /// Beschreibung der Unfallstunde, in der sich der Unfall ereignet hat.
        pub stunde: Option<i64>,
        /// Strassenart
        ///
        /// Art der Strasse auf der sich der Unfall ereignet hat.
        pub strasseart: Option<String>,
        /// Fussgängerbeteiligung
        ///
        /// War ein Fussgänger am Unfall beteiligt
        pub fussgg_bet: Option<String>,
        /// Fahrradbeteiligung
        ///
        /// War ein Fahrrad am Unfall beteiligt
        pub fahrrd_bet: Option<String>,
        /// Motorradbeteiligung
        ///
        /// War ein Motorrad am Unfall beteiligt
        pub motord_bet: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdUnfall,
        Typ,
        Schwere,
        Jahr,
        Monat,
        Wochentag,
        Stunde,
        Strasseart,
        FussggBet,
        FahrrdBet,
        MotordBet,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdUnfall => "id_unfall",
                Field::Typ => "typ",
                Field::Schwere => "schwere",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Wochentag => "wochentag",
                Field::Stunde => "stunde",
                Field::Strasseart => "strasseart",
                Field::FussggBet => "fussgg_bet",
                Field::FahrrdBet => "fahrrd_bet",
                Field::MotordBet => "motord_bet",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100120/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rheinmesswerte kontinuierlich
pub mod rheinmesswerte_kontinuierlich {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Startzeitpunkt
        ///
        /// Start der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub startzeitpunkt: Option<OffsetDateTime>,
        /// Start_text
        ///
        /// Start der Messung
        pub start_text: Option<String>,
        /// Endezeitpunkt
        ///
        /// Ende der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub endezeitpunkt: Option<OffsetDateTime>,
        /// Ende_text
        ///
        /// Ende der Messung
        pub ende_text: Option<String>,
        /// Elektrische Leitfähigkeit [µS/cm]
        ///
        /// Elektrische Leitfähigkeit Strang S3 in µS/cm, Koordinaten 611740 / 272310
        pub rus_w_o_s3_lf: Option<f64>,
        /// Sauerstoffgehalt [mg/L]
        ///
        /// Sauerstoffgehalt Strang S3 in mg/L
        pub rus_w_o_s3_o2: Option<f64>,
        /// pH-Wert
        ///
        /// pH-Wert Strang S3
        pub rus_w_o_s3_ph: Option<f64>,
        /// Temperatur [°C]
        ///
        /// Temperatur Strang S3 in °C
        pub rus_w_o_s3_te: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Startzeitpunkt,
        StartText,
        Endezeitpunkt,
        EndeText,
        RusWOS3Lf,
        RusWOS3O2,
        RusWOS3Ph,
        RusWOS3Te,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Startzeitpunkt => "startzeitpunkt",
                Field::StartText => "start_text",
                Field::Endezeitpunkt => "endezeitpunkt",
                Field::EndeText => "ende_text",
                Field::RusWOS3Lf => "rus_w_o_s3_lf",
                Field::RusWOS3O2 => "rus_w_o_s3_o2",
                Field::RusWOS3Ph => "rus_w_o_s3_ph",
                Field::RusWOS3Te => "rus_w_o_s3_te",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100046/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Solarkataster: Dachkanten
pub mod solarkataster_dachkanten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Dachkante
        ///
        /// Identifikator der Dachkante
        pub id_dkante: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdDkante,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdDkante => "id_dkante",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100383/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Luftqualität des Vortages
pub mod smarte_strasse_luftqualitaet_des_vortages {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel = Anfangszeit des 30 minütigen Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// G107 NO2
        ///
        /// Tagesmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_no2: Option<f64>,
        /// G107 O3
        ///
        /// Tageshöchstwert O3 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_03: Option<f64>,
        /// G107 PM2.5
        ///
        /// Tagesmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_pm25: Option<f64>,
        /// G125 NO2
        ///
        /// Tagesmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_no2: Option<f64>,
        /// G125 O3
        ///
        /// Tageshöchstwert O3 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_o3: Option<f64>,
        /// G125 PM2.5
        ///
        /// Tagesmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_pm25: Option<f64>,
        /// G131 NO2
        ///
        /// Tagesmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_no2: Option<f64>,
        /// G131 O3
        ///
        /// Tageshöchstwert O3 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_o3: Option<f64>,
        /// G131 PM2.5
        ///
        /// Tagesmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_pm25: Option<f64>,
        pub timestamp_text: Option<String>,
        /// Anfangszeit
        pub anfangszeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        G107No2,
        G10703,
        G107Pm25,
        G125No2,
        G125O3,
        G125Pm25,
        G131No2,
        G131O3,
        G131Pm25,
        TimestampText,
        Anfangszeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::G107No2 => "g107_no2",
                Field::G10703 => "g107_03",
                Field::G107Pm25 => "g107_pm25",
                Field::G125No2 => "g125_no2",
                Field::G125O3 => "g125_o3",
                Field::G125Pm25 => "g125_pm25",
                Field::G131No2 => "g131_no2",
                Field::G131O3 => "g131_o3",
                Field::G131Pm25 => "g131_pm25",
                Field::TimestampText => "timestamp_text",
                Field::Anfangszeit => "anfangszeit",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100174/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Reproduktionszahl (Re)
pub mod coronavirus_covid_19_reproduktionszahl_re {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Land
        ///
        /// Das Land, für welches die Werte geschätzt wurden
        pub country: Option<String>,
        /// Region
        ///
        /// Das Land, die Grossregion bzw. der Kanton, für welche/n die Werte geschätzt wurden
        pub region: Option<String>,
        /// Datenquelle
        ///
        /// Quelle aus der die verwendeten Daten stammen
        pub source: Option<String>,
        /// Datentyp
        ///
        /// Art der für die Schätzung verwendeten Daten
        pub data_type: Option<String>,
        /// Schätzmethode
        ///
        /// Die bei der Schätzung verwendete Methodik
        pub estimate_type: Option<String>,
        /// Datum
        ///
        /// Datum, für welches die effektive Reproduktionszahl berechnet wurde. Da sich die effektive Reproduktionszahl erst mit zeitlichem Verzug berechnen lässt, liegt der letzte verfügbare Schätzwert in der Vergangenheit
        pub date: Option<Date>,
        /// Mittlere effektive Reproduktionszahl
        ///
        /// Die mittlere geschätzte effektive Reproduktionszahl
        pub median_r_mean: Option<f64>,
        /// Obere Grenze der effektiven Reproduktionszahl
        ///
        /// Die obere Grenze des 95%-Vertrauensintervalls der mittleren geschätzten effektiven Reproduktionszahl
        pub median_r_highhpd: Option<f64>,
        /// Untere Grenze der effektiven Reproduktionszahl
        ///
        /// Die untere Grenze des 95%-Vertrauensintervalls der mittleren geschätzten effektiven Reproduktionszahl
        pub median_r_lowhpd: Option<f64>,
        /// Land (Iso Code)
        ///
        /// Iso Code des Landes, für welches die Werte geschätzt wurden
        pub countryiso3: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Country,
        Region,
        Source,
        DataType,
        EstimateType,
        Date,
        MedianRMean,
        MedianRHighhpd,
        MedianRLowhpd,
        Countryiso3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Country => "country",
                Field::Region => "region",
                Field::Source => "source",
                Field::DataType => "data_type",
                Field::EstimateType => "estimate_type",
                Field::Date => "date",
                Field::MedianRMean => "median_r_mean",
                Field::MedianRHighhpd => "median_r_highhpd",
                Field::MedianRLowhpd => "median_r_lowhpd",
                Field::Countryiso3 => "countryiso3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100110/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Zu- und Wegfahrten, Parkplatzauslastung
pub mod smarte_strasse_zu_und_wegfahrten_parkplatzauslastung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// von
        ///
        /// Start der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub from: Option<OffsetDateTime>,
        /// bis
        ///
        /// Ende der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub to: Option<OffsetDateTime>,
        /// Typ
        ///
        /// Parklatztyp
        pub r#type: Option<String>,
        /// Summe Zufahrten
        pub sum_inflow: Option<f64>,
        /// Summe Wegfahrten
        pub sum_outflow: Option<f64>,
        /// Auslastung (Mittelwert in %)
        ///
        /// Durchschnittliche Auslastung
        pub avg_occupancy_abs: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        From,
        To,
        RType,
        SumInflow,
        SumOutflow,
        AvgOccupancyAbs,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::From => "from",
                Field::To => "to",
                Field::RType => "type",
                Field::SumInflow => "sum_inflow",
                Field::SumOutflow => "sum_outflow",
                Field::AvgOccupancyAbs => "avg_occupancy_abs",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100171/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Aktuelle Temperaturen der Gartenbäder
pub mod aktuelle_temperaturen_der_gartenbaeder {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        ///
        /// Name des Bads
        pub name: Option<String>,
        /// Temperatur
        ///
        /// Temperatur des Wassers
        pub temperatur: Option<i64>,
        /// Zeit
        ///
        /// Zeitpunkt, an dem die Daten gescraped wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitpunkt_job: Option<OffsetDateTime>,
        /// Koordinaten
        ///
        /// Punktkoordinate des Bads
        pub koordinaten: Option<GeoPoint2d>,
        /// URL Sportanlage
        ///
        /// Link zum Datensatz "Sport- und Bewegungsanlagen"
        pub url_sportanlage: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
        Temperatur,
        ZeitpunktJob,
        UrlSportanlage,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Temperatur => "temperatur",
                Field::ZeitpunktJob => "zeitpunkt_job",
                Field::UrlSportanlage => "url_sportanlage",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100388/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station St. Johannplatz
pub mod luftqualitaet_station_st_johannplatz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        pub timestamp_text: Option<String>,
        /// PM10 (Stundenmittelwerte)
        pub pm10_stundenmittelwerte_ug_m3: Option<f64>,
        /// PM2.5 (Stundenmittelwerte)
        pub pm2_5_stundenmittelwerte_ug_m3: Option<f64>,
        /// O3 (Stundenmittelwerte)
        pub o3_stundenmittelwerte_ug_m3: Option<f64>,
        /// NO2 (Stundenmittelwerte)
        pub no2_stundenmittelwerte_ug_m3: Option<f64>,
        /// Standort
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        Pm10StundenmittelwerteUgM3,
        Pm25StundenmittelwerteUgM3,
        O3StundenmittelwerteUgM3,
        No2StundenmittelwerteUgM3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::Pm10StundenmittelwerteUgM3 => "pm10_stundenmittelwerte_ug_m3",
                Field::Pm25StundenmittelwerteUgM3 => "pm2_5_stundenmittelwerte_ug_m3",
                Field::O3StundenmittelwerteUgM3 => "o3_stundenmittelwerte_ug_m3",
                Field::No2StundenmittelwerteUgM3 => "no2_stundenmittelwerte_ug_m3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100049/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Briefliche Stimmbeteiligung
pub mod briefliche_stimmbeteiligung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Tag
        ///
        /// Wochentag an dem die Stimmbeteiligung erhoben wurde
        pub tag: Option<String>,
        /// Datum
        ///
        /// Datum an dem die Stimmbeteiligung erhoben wurde.
        pub datum: Option<Date>,
        /// Eingang pro Tag
        ///
        /// Erhaltene Briefeingänge an diesem Tag
        pub eingang_pro_tag: Option<i64>,
        /// Eingang kumuliert
        ///
        /// Total erhaltene Briefeingänge bis zu diesem Datum
        pub eingang_kumuliert: Option<i64>,
        /// Stimmbeteiligung (%)
        ///
        /// Prozentualer Anteil der von Stimmberechtigten bereits abgegebenen Stimmzettel
        pub stimmbeteiligung: Option<f64>,
        /// Datum Urnengang
        ///
        /// Datum des Urnengangs
        pub datum_urnengang: Option<Date>,
        /// Tage bis Urnengang
        ///
        /// Verbleibende Tage bis zum Urnengang
        pub tage_bis_urnengang: Option<i64>,
        /// Abstimmungen
        ///
        /// Ja: Urnengang mit Abstimmung; Nein: Urnengang ohne Abstimmung
        pub abstimmungen: Option<String>,
        /// Wahlen
        ///
        /// Ja: Urnengang mit Wahlen; Nein: Urnengang ohne Wahlen
        pub wahlen: Option<String>,
        /// Art der Wahl(-en)
        pub wahlen_typ: Option<String>,
        /// Datum Urnengang (Rohtext)
        ///
        /// Datum des Urnengangs in YYYY-MM-DD-Format
        pub datum_urnengang_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Tag,
        Datum,
        EingangProTag,
        EingangKumuliert,
        Stimmbeteiligung,
        DatumUrnengang,
        TageBisUrnengang,
        Abstimmungen,
        Wahlen,
        WahlenTyp,
        DatumUrnengangText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Tag => "tag",
                Field::Datum => "datum",
                Field::EingangProTag => "eingang_pro_tag",
                Field::EingangKumuliert => "eingang_kumuliert",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::DatumUrnengang => "datum_urnengang",
                Field::TageBisUrnengang => "tage_bis_urnengang",
                Field::Abstimmungen => "abstimmungen",
                Field::Wahlen => "wahlen",
                Field::WahlenTyp => "wahlen_typ",
                Field::DatumUrnengangText => "datum_urnengang_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100223/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Luftqualität
pub mod smarte_strasse_luftqualitaet {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel = Anfangszeit des 30 minütigen Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// G107 NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_no2: Option<f64>,
        /// G107 O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_03: Option<f64>,
        /// G107 PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_pm25: Option<f64>,
        /// G125 NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_no2: Option<f64>,
        /// G125 O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_o3: Option<f64>,
        /// G125 PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_pm25: Option<f64>,
        /// G131 NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_no2: Option<f64>,
        /// G131 O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_o3: Option<f64>,
        /// G131 PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_pm25: Option<f64>,
        pub timestamp_text: Option<String>,
        /// Anfangszeit
        pub anfangszeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        G107No2,
        G10703,
        G107Pm25,
        G125No2,
        G125O3,
        G125Pm25,
        G131No2,
        G131O3,
        G131Pm25,
        TimestampText,
        Anfangszeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::G107No2 => "g107_no2",
                Field::G10703 => "g107_03",
                Field::G107Pm25 => "g107_pm25",
                Field::G125No2 => "g125_no2",
                Field::G125O3 => "g125_o3",
                Field::G125Pm25 => "g125_pm25",
                Field::G131No2 => "g131_no2",
                Field::G131O3 => "g131_o3",
                Field::G131Pm25 => "g131_pm25",
                Field::TimestampText => "timestamp_text",
                Field::Anfangszeit => "anfangszeit",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100093/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baustellen
pub mod baustellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Strasse - Projektname
        ///
        /// Das ist die Strasse auf dem das Projekt stattfindet.
        pub projekt_name: Option<String>,
        /// Beschreibung
        pub projekt_beschrieb: Option<String>,
        /// Zusatzinformationen
        pub projekt_info: Option<String>,
        /// Weblink Projekt
        ///
        /// Link zum Projekt
        pub projekt_link: Option<String>,
        /// Baubeginn
        pub datum_von: Option<Date>,
        /// Bauende
        pub datum_bis: Option<Date>,
        /// Dokument 1
        ///
        /// Dokument mit Anwohnerinformationen
        pub dokument1: Option<String>,
        /// Dokument 2
        ///
        /// Dokument mit Anwohnerinformationen
        pub dokument2: Option<String>,
        /// Dokument 3
        ///
        /// Dokument mit Anwohnerinformationen
        pub dokument3: Option<String>,
        /// Fallnummer Allmendbewilligung
        pub id: Option<i64>,
        /// Weblink Allmendbewilligung
        ///
        /// Link zum OGD-Datensatz mit den Allmendbewilligungen
        pub allmendbewilligungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ProjektName,
        ProjektBeschrieb,
        ProjektInfo,
        ProjektLink,
        DatumVon,
        DatumBis,
        Dokument1,
        Dokument2,
        Dokument3,
        Id,
        Allmendbewilligungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ProjektName => "projekt_name",
                Field::ProjektBeschrieb => "projekt_beschrieb",
                Field::ProjektInfo => "projekt_info",
                Field::ProjektLink => "projekt_link",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::Dokument1 => "dokument1",
                Field::Dokument2 => "dokument2",
                Field::Dokument3 => "dokument3",
                Field::Id => "id",
                Field::Allmendbewilligungen => "allmendbewilligungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100335/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Fahrzeugdurchfahrten
pub mod smarte_strasse_fahrzeugdurchfahrten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit bei Durchfahrt
        #[serde(with = "time::serde::iso8601::option")]
        pub localdatetime: Option<OffsetDateTime>,
        /// Fahrzeugklasse
        ///
        /// Klassifizierung des Fahrzeugs bei Durchfahrt
        pub classification: Option<String>,
        pub timestamp_text: Option<String>,
        /// Klassifizierungsindex
        ///
        /// Index für die Fahrzeuge
        pub classificationindex: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Localdatetime,
        Classification,
        TimestampText,
        Classificationindex,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Localdatetime => "localdatetime",
                Field::Classification => "classification",
                Field::TimestampText => "timestamp_text",
                Field::Classificationindex => "classificationindex",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100172/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte der öffentlichen Parkhäuser Basel
pub mod standorte_der_oeffentlichen_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub title: Option<String>,
        pub address: Option<String>,
        pub id: Option<String>,
        pub lot_type: Option<String>,
        /// Name
        ///
        /// Name des Parkhauses
        pub name: Option<String>,
        pub id2: Option<String>,
        pub total: Option<i64>,
        pub link: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
        /// coords.lat
        pub coords_lat: Option<f64>,
        /// coords.lng
        pub coords_lng: Option<f64>,
        #[serde(with = "time::serde::iso8601::option")]
        pub published: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Title,
        Address,
        Id,
        LotType,
        Name,
        Id2,
        Total,
        Link,
        CoordsLat,
        CoordsLng,
        Published,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Title => "title",
                Field::Address => "address",
                Field::Id => "id",
                Field::LotType => "lot_type",
                Field::Name => "name",
                Field::Id2 => "id2",
                Field::Total => "total",
                Field::Link => "link",
                Field::CoordsLat => "coords_lat",
                Field::CoordsLng => "coords_lng",
                Field::Published => "published",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100044/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Feldbergstrasse
pub mod luftqualitaet_station_feldbergstrasse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        pub timestamp_text: Option<String>,
        pub pm10_stundenmittelwerte_ug_m3: Option<f64>,
        pub pm2_5_stundenmittelwerte_ug_m3: Option<f64>,
        pub no2_stundenmittelwerte_ug_m3: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        Pm10StundenmittelwerteUgM3,
        Pm25StundenmittelwerteUgM3,
        No2StundenmittelwerteUgM3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::Pm10StundenmittelwerteUgM3 => "pm10_stundenmittelwerte_ug_m3",
                Field::Pm25StundenmittelwerteUgM3 => "pm2_5_stundenmittelwerte_ug_m3",
                Field::No2StundenmittelwerteUgM3 => "no2_stundenmittelwerte_ug_m3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100050/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Transformation Areal Rosental: Online Sensor Feinstaub
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_online_sensor_feinstaub {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Station Name
        pub station: Option<String>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm_2_5: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Station,
        Pm25,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Station => "station",
                Field::Pm25 => "pm_2_5",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100275/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Zeitreihe der Temperaturen der Gartenbäder
pub mod zeitreihe_der_temperaturen_der_gartenbaeder {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        ///
        /// Name des Bads
        pub name: Option<String>,
        /// Temperatur
        ///
        /// Temperatur des Wassers
        pub temperatur: Option<i64>,
        /// Zeit
        ///
        /// Zeitpunkt, an dem die Daten gescraped wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitpunkt_job: Option<OffsetDateTime>,
        /// Koordinaten
        ///
        /// Punktkoordinate des Bads
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
        Temperatur,
        ZeitpunktJob,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Temperatur => "temperatur",
                Field::ZeitpunktJob => "zeitpunkt_job",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100384/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// OGD Datensätze
pub mod ogd_datensaetze {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Dataset identifier
        pub dataset_identifier: Option<String>,
        /// Federated dataset
        pub federated_dataset: Option<String>,
        /// Title
        pub title: Option<String>,
        /// Description
        pub description: Option<String>,
        /// Themes
        pub themes: Option<String>,
        /// Keywords
        pub keywords: Option<String>,
        /// License
        pub license: Option<String>,
        /// Language
        pub language: Option<String>,
        /// Timezone
        pub timezone: Option<String>,
        /// Modified
        #[serde(with = "time::serde::iso8601::option")]
        pub modified: Option<OffsetDateTime>,
        /// Data processed
        #[serde(with = "time::serde::iso8601::option")]
        pub data_processed: Option<OffsetDateTime>,
        /// Metadata processed
        #[serde(with = "time::serde::iso8601::option")]
        pub metadata_processed: Option<OffsetDateTime>,
        /// Publisher
        pub publisher: Option<String>,
        /// Reference
        pub reference: Option<String>,
        /// Attributions
        pub attributions: Option<String>,
        /// Created
        pub created: Option<Date>,
        /// Issued
        pub issued: Option<Date>,
        /// Creator
        pub creator: Option<String>,
        /// Contributor
        pub contributor: Option<String>,
        /// Contact name
        pub contact_name: Option<String>,
        /// Contact email
        pub contact_email: Option<String>,
        /// Accrual periodicity
        pub accrual_periodicity: Option<String>,
        /// Spatial
        pub spatial: Option<String>,
        /// Temporal
        pub temporal: Option<String>,
        /// Granularity
        pub granularity: Option<String>,
        /// Data quality
        pub data_quality: Option<String>,
        /// Publisher type
        pub publisher_type: Option<String>,
        /// Conforms to
        pub conforms_to: Option<String>,
        /// Temporal coverage start date
        #[serde(with = "time::serde::iso8601::option")]
        pub temporal_coverage_start_date: Option<OffsetDateTime>,
        /// Temporal coverage end date
        #[serde(with = "time::serde::iso8601::option")]
        pub temporal_coverage_end_date: Option<OffsetDateTime>,
        /// Rights
        pub rights: Option<String>,
        /// RML Mapping
        pub rml_mapping: Option<String>,
        /// Publizierende Organisation
        pub publizierende_organisation: Option<String>,
        /// Geodaten Modellbeschreibung
        pub geodaten_modellbeschreibung: Option<String>,
        /// Tags
        pub tags: Option<String>,
        /// Number of records
        pub number_of_records: Option<i64>,
        /// Size of records in the dataset (in bytes)
        pub size_of_records_in_the_dataset_in_bytes: Option<i64>,
        /// Reuse count
        pub reuse_count: Option<i64>,
        /// API call count
        pub api_call_count: Option<i64>,
        /// Download count
        pub download_count: Option<i64>,
        /// Attachments download count
        pub attachments_download_count: Option<i64>,
        /// File fields download count
        pub file_fields_download_count: Option<i64>,
        /// Popularity score
        pub popularity_score: Option<f64>,
        /// Visibility (domain or restricted)
        pub visibility_domain_or_restricted: Option<String>,
        /// Published
        pub published: Option<String>,
        /// Publishing properties
        pub publishing_properties: Option<String>,
        /// Update frequency
        pub update_frequency: Option<String>,
        /// Domain
        pub domain0: Option<String>,
        /// Access Rights
        pub access_rights: Option<String>,
        pub url_dataset: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatasetIdentifier,
        FederatedDataset,
        Title,
        Description,
        Themes,
        Keywords,
        License,
        Language,
        Timezone,
        Modified,
        DataProcessed,
        MetadataProcessed,
        Publisher,
        Reference,
        Attributions,
        Created,
        Issued,
        Creator,
        Contributor,
        ContactName,
        ContactEmail,
        AccrualPeriodicity,
        Spatial,
        Temporal,
        Granularity,
        DataQuality,
        PublisherType,
        ConformsTo,
        TemporalCoverageStartDate,
        TemporalCoverageEndDate,
        Rights,
        RmlMapping,
        PublizierendeOrganisation,
        GeodatenModellbeschreibung,
        Tags,
        NumberOfRecords,
        SizeOfRecordsInTheDatasetInBytes,
        ReuseCount,
        ApiCallCount,
        DownloadCount,
        AttachmentsDownloadCount,
        FileFieldsDownloadCount,
        PopularityScore,
        VisibilityDomainOrRestricted,
        Published,
        PublishingProperties,
        UpdateFrequency,
        Domain0,
        AccessRights,
        UrlDataset,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatasetIdentifier => "dataset_identifier",
                Field::FederatedDataset => "federated_dataset",
                Field::Title => "title",
                Field::Description => "description",
                Field::Themes => "themes",
                Field::Keywords => "keywords",
                Field::License => "license",
                Field::Language => "language",
                Field::Timezone => "timezone",
                Field::Modified => "modified",
                Field::DataProcessed => "data_processed",
                Field::MetadataProcessed => "metadata_processed",
                Field::Publisher => "publisher",
                Field::Reference => "reference",
                Field::Attributions => "attributions",
                Field::Created => "created",
                Field::Issued => "issued",
                Field::Creator => "creator",
                Field::Contributor => "contributor",
                Field::ContactName => "contact_name",
                Field::ContactEmail => "contact_email",
                Field::AccrualPeriodicity => "accrual_periodicity",
                Field::Spatial => "spatial",
                Field::Temporal => "temporal",
                Field::Granularity => "granularity",
                Field::DataQuality => "data_quality",
                Field::PublisherType => "publisher_type",
                Field::ConformsTo => "conforms_to",
                Field::TemporalCoverageStartDate => "temporal_coverage_start_date",
                Field::TemporalCoverageEndDate => "temporal_coverage_end_date",
                Field::Rights => "rights",
                Field::RmlMapping => "rml_mapping",
                Field::PublizierendeOrganisation => "publizierende_organisation",
                Field::GeodatenModellbeschreibung => "geodaten_modellbeschreibung",
                Field::Tags => "tags",
                Field::NumberOfRecords => "number_of_records",
                Field::SizeOfRecordsInTheDatasetInBytes => {
                    "size_of_records_in_the_dataset_in_bytes"
                }
                Field::ReuseCount => "reuse_count",
                Field::ApiCallCount => "api_call_count",
                Field::DownloadCount => "download_count",
                Field::AttachmentsDownloadCount => "attachments_download_count",
                Field::FileFieldsDownloadCount => "file_fields_download_count",
                Field::PopularityScore => "popularity_score",
                Field::VisibilityDomainOrRestricted => "visibility_domain_or_restricted",
                Field::Published => "published",
                Field::PublishingProperties => "publishing_properties",
                Field::UpdateFrequency => "update_frequency",
                Field::Domain0 => "domain0",
                Field::AccessRights => "access_rights",
                Field::UrlDataset => "url_dataset",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100057/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahl eines Mitglieds des Gerichts für fürsorgerische Unterbringungen
pub mod wahl_eines_mitglieds_des_gerichts_fuer_fuersorgerische_unterbringungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<i64>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub resultats_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anz_sitze: Option<i64>,
        /// Kandidaten-Nr
        pub kandidat_nr: Option<i64>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub name_ganz: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewaehlt: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Wahlzettel
        ///
        /// Anzahl eingelegte Wahlzettel
        pub eingelegte: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leere Wahlzettel
        pub leere: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültige Wahlzettel
        pub ungueltige: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub gueltige: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub anz_briefliche: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total
        pub stimmber_total: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmber_maen: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmber_fraue: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Stimmen + leere Stimmen)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub ant_brieflich: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ResultatsTyp,
        Datum,
        AnzSitze,
        KandidatNr,
        NameGanz,
        Name,
        Vorname,
        Gemeinde,
        Stimmen,
        Vereinzelte,
        Gewaehlt,
        Stimmrechtsausweise,
        Eingelegte,
        Leere,
        Ungueltige,
        Gueltige,
        AnzBriefliche,
        StimmberTotal,
        StimmberMaen,
        StimmberFraue,
        AbsolutesMehr,
        Stimmbeteiligung,
        AntBrieflich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ResultatsTyp => "resultats_typ",
                Field::Datum => "datum",
                Field::AnzSitze => "anz_sitze",
                Field::KandidatNr => "kandidat_nr",
                Field::NameGanz => "name_ganz",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Vereinzelte => "vereinzelte",
                Field::Gewaehlt => "gewaehlt",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Eingelegte => "eingelegte",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::AnzBriefliche => "anz_briefliche",
                Field::StimmberTotal => "stimmber_total",
                Field::StimmberMaen => "stimmber_maen",
                Field::StimmberFraue => "stimmber_fraue",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AntBrieflich => "ant_brieflich",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100132/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte Mess-Stationen Smart Climate Feinstaubmessungen
pub mod standorte_mess_stationen_smart_climate_feinstaubmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// ID
        pub id: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
        Id,
        Titel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Id => "id",
                Field::Titel => "titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100084/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahl von fünf Präsidentinnen oder Präsidenten des Appellationsgerichts
pub mod wahl_von_fuenf_praesidentinnen_oder_praesidenten_des_appellationsgerichts {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<i64>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub resultats_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anz_sitze: Option<i64>,
        /// Kandidaten-Nr
        pub kandidat_nr: Option<i64>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub name_ganz: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewaehlt: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Wahlzettel
        ///
        /// Anzahl eingelegte Wahlzettel
        pub eingelegte: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leere Wahlzettel
        pub leere: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültige Wahlzettel
        pub ungueltige: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub gueltige: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub anz_briefliche: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total
        pub stimmber_total: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmber_maen: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmber_fraue: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Stimmen + leere Stimmen)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub ant_brieflich: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ResultatsTyp,
        Datum,
        AnzSitze,
        KandidatNr,
        NameGanz,
        Name,
        Vorname,
        Gemeinde,
        Stimmen,
        Vereinzelte,
        Gewaehlt,
        Stimmrechtsausweise,
        Eingelegte,
        Leere,
        Ungueltige,
        Gueltige,
        AnzBriefliche,
        StimmberTotal,
        StimmberMaen,
        StimmberFraue,
        AbsolutesMehr,
        Stimmbeteiligung,
        AntBrieflich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ResultatsTyp => "resultats_typ",
                Field::Datum => "datum",
                Field::AnzSitze => "anz_sitze",
                Field::KandidatNr => "kandidat_nr",
                Field::NameGanz => "name_ganz",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Vereinzelte => "vereinzelte",
                Field::Gewaehlt => "gewaehlt",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Eingelegte => "eingelegte",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::AnzBriefliche => "anz_briefliche",
                Field::StimmberTotal => "stimmber_total",
                Field::StimmberMaen => "stimmber_maen",
                Field::StimmberFraue => "stimmber_fraue",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AntBrieflich => "ant_brieflich",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100131/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Regierungspräsidiumswahl 20. Oktober 2024
pub mod kandidierende_der_regierungspraesidiumswahl_20_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100387/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Sammlung Europa
pub mod sammlung_europa {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Inventarnummer
        ///
        /// Die Inventarnummer besteht aus einem Präfix und einer Laufnummer. Unterschiedliche Präfixe deuten auf unterschiedliche Unter-Sammlungen hin. Standard ist VI, weil Europa die sechste Abteilung des Museums ist.
        pub inventarnummer: Option<String>,
        /// Einlaufnummer
        ///
        /// Die Einlaufnummer besteht aus Suffix-Underline-Laufnummer. Sie nummeriert jeweils die Gruppe von Objekten, die zusammen ins Museum gekommen sind.
        pub einlaufnummer: Option<String>,
        /// Kurzbezeichnung
        ///
        /// Kurzbezeichnung ist die möglichst allgemeine Bezeichnung des Objekts.
        pub kurzbezeichnung: Option<String>,
        /// Titel
        ///
        /// Der Titel ist eine präzisere Bezeichnung, eine einheimische Bezeichnung oder der Werktitel (kann fehlen).
        pub titel: Option<String>,
        /// Datierung
        ///
        /// Das geschätzte oder dokumentierte Jahr der Herstellung des Objekts (in der Regel sehr ungenau, fehlt häufig)
        pub datierung: Option<String>,
        /// Material & Technik
        ///
        /// Angaben dazu, wie und/oder aus welchem Material das Objekt geschaffen wurde.
        pub material_technik: Option<String>,
        /// Herkunft
        ///
        /// Geografische Herkunft des Objekts (nur eine von möglicherweise mehrfachen Herkunftsangaben)
        pub herkunft: Option<String>,
        /// Einlieferer*in, Erwerbungsart, Jahr der Einlieferung
        ///
        /// Der/die Einlieferer*in brachte die Objekte ins Museum bzw. bezahlte dafür. Erwerbungsart ist in der Regel Kauf (dann bezahlte das Museum und als Einlieferer erscheint der aktuelle Kurator) oder Geschenk, teils auch Legat oder Tausch. Leider teilweise auch «unbekannt, alter Bestand».
        pub einlauf_info: Option<String>,
        /// Masse
        ///
        /// Masse des Objekts
        pub masse: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Inventarnummer,
        Einlaufnummer,
        Kurzbezeichnung,
        Titel,
        Datierung,
        MaterialTechnik,
        Herkunft,
        EinlaufInfo,
        Masse,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Inventarnummer => "inventarnummer",
                Field::Einlaufnummer => "einlaufnummer",
                Field::Kurzbezeichnung => "kurzbezeichnung",
                Field::Titel => "titel",
                Field::Datierung => "datierung",
                Field::MaterialTechnik => "material_technik",
                Field::Herkunft => "herkunft",
                Field::EinlaufInfo => "einlauf_info",
                Field::Masse => "masse",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100148/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 27. November 2022 Details
pub mod abstimmung_vom_27_november_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Gegenvorschlag Stimmen ohne gültige Antwort
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stichfrage Stimmen ohne gültige Antwort
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100239/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidaturen für Gerichtspräsidienwahlen
pub mod kandidaturen_fuer_gerichtspraesidienwahlen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Name der Wahl
        pub titel: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind.
        pub anzahl_sitze: Option<f64>,
        /// Listen-Nr.
        ///
        /// Listennummer
        pub listennr: Option<i64>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Kandidierenden-Nr.
        ///
        /// Kandidierendennummer
        pub zeilennummer: Option<i64>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        pub bisher: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Geburtsjahr der kandidierenden Person
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatzliche_angaben: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Titel,
        Datum,
        AnzahlSitze,
        Listennr,
        Listenbezeichnung,
        Zeilennummer,
        Name,
        Vorname,
        Bisher,
        Geschlecht,
        Jahrgang,
        ZusatzlicheAngaben,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Titel => "titel",
                Field::Datum => "datum",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::Listennr => "listennr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Zeilennummer => "zeilennummer",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Bisher => "bisher",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::ZusatzlicheAngaben => "zusatzliche_angaben",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100379/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Tests nach Nachweismethode
pub mod coronavirus_covid_19_tests_nach_nachweismethode {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Falldatum, entspricht in der Regel dem Datum der Probeentnahme
        pub datum: Option<Date>,
        /// Region
        ///
        /// Wohnkanton, falls unbekannt: Kanton des Testcenters. Zusätzlich sind die aggregierten Einheiten CH, FL und CHFL vorhanden.
        pub georegion: Option<String>,
        /// Tests Total
        ///
        /// Anzahl durchgeführte Tests. Eine Person kann mehrfach getestet werden.
        pub entries: Option<i64>,
        /// Bevölkerungszahl
        ///
        /// Anzahl EinwohnerInnen der vorliegenden Region, wie sie vom BAG zur Inzidenzberechnung verwendet wird.
        pub pop: Option<i64>,
        /// Wochentag ID
        ///
        /// ID des Wochentags. 0 = Montag, 1 = Dienstag, etc.
        pub dayofweek: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag auf Deutsch
        pub wochentag: Option<String>,
        /// Wochennummer
        pub week: Option<i64>,
        pub offset_last7d: Option<i64>,
        pub offset_last14d: Option<i64>,
        pub offset_last28d: Option<i64>,
        pub sumdelta7d: Option<f64>,
        pub inzdelta7d: Option<f64>,
        pub type_variant: Option<String>,
        pub entries_letzter_stand: Option<i64>,
        pub entries_neu_gemeldet: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Georegion,
        Entries,
        Pop,
        Dayofweek,
        Wochentag,
        Week,
        OffsetLast7d,
        OffsetLast14d,
        OffsetLast28d,
        Sumdelta7d,
        Inzdelta7d,
        TypeVariant,
        EntriesLetzterStand,
        EntriesNeuGemeldet,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Georegion => "georegion",
                Field::Entries => "entries",
                Field::Pop => "pop",
                Field::Dayofweek => "dayofweek",
                Field::Wochentag => "wochentag",
                Field::Week => "week",
                Field::OffsetLast7d => "offset_last7d",
                Field::OffsetLast14d => "offset_last14d",
                Field::OffsetLast28d => "offset_last28d",
                Field::Sumdelta7d => "sumdelta7d",
                Field::Inzdelta7d => "inzdelta7d",
                Field::TypeVariant => "type_variant",
                Field::EntriesLetzterStand => "entries_letzter_stand",
                Field::EntriesNeuGemeldet => "entries_neu_gemeldet",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100116/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 28. November 2021 Details
pub mod abstimmung_vom_28_november_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100161/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 15. Mai 2022 Details
pub mod abstimmung_vom_15_mai_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100194/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 3. März 2024
pub mod kennzahlen_der_abstimmung_vom_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100340/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 26. November 2023
pub mod kennzahlen_der_abstimmung_vom_26_november_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100328/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 7. März 2021
pub mod kennzahlen_der_abstimmung_vom_7_maerz_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100118/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 12. März 2023 Details
pub mod abstimmung_vom_12_maerz_2023_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100279/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung 7. März 2021 Details
pub mod abstimmung_7_maerz_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        WahllokId,
        GemeinId,
        GemeinName,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100117/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 3. März 2024 Details
pub mod abstimmung_vom_3_maerz_2024_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100339/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 13. Februar 2022 Details
pub mod abstimmung_vom_13_februar_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100168/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Nationalratswahlen 2023
pub mod resultate_der_nationalratswahlen_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listen-Nr
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// HLV-Nr
        ///
        /// Nummer der Hauptlistenverbindung
        pub hlv_nr: Option<String>,
        /// HLV-Bezeichnung
        ///
        /// Name der Hauptlistenverbindung
        pub hlv_bezeichnung: Option<String>,
        /// ULV-Nr
        ///
        /// Nummer der Unterlistenverbindung
        pub ulv_nr: Option<String>,
        /// ULV-Bezeichnung
        ///
        /// Name der Unterlistenverbindung
        pub ulv_bezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Kumulation
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat auf einem unveränderten Wahlzettel mehrfach aufgeführt ist
        pub kumulation: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus unveränderten Wahlzetteln
        pub stimmen_unveranderte_wahlzettel: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus veränderten Wahlzetteln
        pub stimmen_veranderte_wahlzettel: Option<i64>,
        /// Stimmen Total aus Wahlzettel
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten. Die Summe dieser Stimmen über eine Partei ergibt nicht das Total der Parteistimmen, weil so die leeren Linien auf Parteilisten nicht mitgezählt werden.
        pub stimmen_total_aus_wahlzettel: Option<i64>,
        /// 01 FDP
        pub x01_fdp: Option<i64>,
        /// 03 LDP
        pub x03_ldp: Option<i64>,
        /// 04 EVP
        pub x04_evp: Option<i64>,
        /// 05 SP
        pub x05_sp: Option<i64>,
        /// 09 EDU
        pub x09_edu: Option<i64>,
        /// 10 GLP
        pub x10_glp: Option<i64>,
        /// 12 SVP
        pub x12_svp: Option<i64>,
        /// 14 VA
        pub x14_va: Option<i64>,
        /// 18 JSVP
        pub x18_jsvp: Option<i64>,
        /// 21 jgb
        pub x21_jgb: Option<i64>,
        /// 23 JLB
        pub x23_jlb: Option<i64>,
        /// 25 JGLP
        pub x25_jglp: Option<i64>,
        /// 00 OHNE
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer Liste ohne Bezeichnung
        pub x00_ohne: Option<i64>,
        /// Rangfolge
        ///
        /// Rangfolge innerhalb einer Liste gemäss Anzahl Stimmen (bei Stimmengleichheit entscheidet das Los).
        pub rangfolge: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_der_gultigen_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// 06 JFDP
        pub x06_jfdp: Option<i64>,
        /// 07 Mitte
        pub x07_mitte: Option<i64>,
        /// 08 BGB
        pub x08_bgb: Option<i64>,
        /// 11 PdA
        pub x11_pda: Option<i64>,
        /// 17 Basta-rm
        pub x17_basta_rm: Option<i64>,
        /// 20 JUSO
        pub x20_juso: Option<i64>,
        /// 22 JMITTE
        pub x22_jmitte: Option<i64>,
        /// 24 SP60+
        pub x24_sp60: Option<i64>,
        /// 26 FDP+
        pub x26_fdp: Option<i64>,
        /// 27 BastA-jA
        pub x27_basta_ja: Option<i64>,
        /// 28 MV
        pub x28_mv: Option<i64>,
        /// 30 SVP-Gew
        pub x30_svp_gew: Option<i64>,
        /// 31 SVP60+
        pub x31_svp60: Option<i64>,
        /// 32 GLP-K-U
        pub x32_glp_k_u: Option<i64>,
        /// 33 GLP-B
        pub x33_glp_b: Option<i64>,
        /// 34 LDP-Gew
        pub x34_ldp_gew: Option<i64>,
        /// 35 GLP-R-E
        pub x35_glp_r_e: Option<i64>,
        /// 36 Mitte60+
        pub x36_mitte60: Option<i64>,
        /// 37 GLP-KMU
        pub x37_glp_kmu: Option<i64>,
        /// 38 GLP-I
        pub x38_glp_i: Option<i64>,
        pub jahrgang_num: Option<i64>,
        /// Alter am Jahresende 2023
        ///
        /// Alter, berechnet nach der Formel "2023 minus Jahrgang"
        pub alter_am_jahresende_2023: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ListenNr,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        HlvNr,
        HlvBezeichnung,
        UlvNr,
        UlvBezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        PersonenId,
        Kumulation,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        StimmenUnveranderteWahlzettel,
        StimmenVeranderteWahlzettel,
        StimmenTotalAusWahlzettel,
        X01Fdp,
        X03Ldp,
        X04Evp,
        X05Sp,
        X09Edu,
        X10Glp,
        X12Svp,
        X14Va,
        X18Jsvp,
        X21Jgb,
        X23Jlb,
        X25Jglp,
        X00Ohne,
        Rangfolge,
        TotalDerGultigenWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        X06Jfdp,
        X07Mitte,
        X08Bgb,
        X11Pda,
        X17BastaRm,
        X20Juso,
        X22Jmitte,
        X24Sp60,
        X26Fdp,
        X27BastaJa,
        X28Mv,
        X30SvpGew,
        X31Svp60,
        X32GlpKU,
        X33GlpB,
        X34LdpGew,
        X35GlpRE,
        X36Mitte60,
        X37GlpKmu,
        X38GlpI,
        JahrgangNum,
        AlterAmJahresende2023,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ListenNr => "listen_nr",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::HlvNr => "hlv_nr",
                Field::HlvBezeichnung => "hlv_bezeichnung",
                Field::UlvNr => "ulv_nr",
                Field::UlvBezeichnung => "ulv_bezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::StimmenUnveranderteWahlzettel => "stimmen_unveranderte_wahlzettel",
                Field::StimmenVeranderteWahlzettel => "stimmen_veranderte_wahlzettel",
                Field::StimmenTotalAusWahlzettel => "stimmen_total_aus_wahlzettel",
                Field::X01Fdp => "01_fdp",
                Field::X03Ldp => "03_ldp",
                Field::X04Evp => "04_evp",
                Field::X05Sp => "05_sp",
                Field::X09Edu => "09_edu",
                Field::X10Glp => "10_glp",
                Field::X12Svp => "12_svp",
                Field::X14Va => "14_va",
                Field::X18Jsvp => "18_jsvp",
                Field::X21Jgb => "21_jgb",
                Field::X23Jlb => "23_jlb",
                Field::X25Jglp => "25_jglp",
                Field::X00Ohne => "00_ohne",
                Field::Rangfolge => "rangfolge",
                Field::TotalDerGultigenWahlzettel => "total_der_gultigen_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::X06Jfdp => "06_jfdp",
                Field::X07Mitte => "07_mitte",
                Field::X08Bgb => "08_bgb",
                Field::X11Pda => "11_pda",
                Field::X17BastaRm => "17_basta_rm",
                Field::X20Juso => "20_juso",
                Field::X22Jmitte => "22_jmitte",
                Field::X24Sp60 => "24_sp60",
                Field::X26Fdp => "26_fdp",
                Field::X27BastaJa => "27_basta_ja",
                Field::X28Mv => "28_mv",
                Field::X30SvpGew => "30_svp_gew",
                Field::X31Svp60 => "31_svp60",
                Field::X32GlpKU => "32_glp_k_u",
                Field::X33GlpB => "33_glp_b",
                Field::X34LdpGew => "34_ldp_gew",
                Field::X35GlpRE => "35_glp_r_e",
                Field::X36Mitte60 => "36_mitte60",
                Field::X37GlpKmu => "37_glp_kmu",
                Field::X38GlpI => "38_glp_i",
                Field::JahrgangNum => "jahrgang_num",
                Field::AlterAmJahresende2023 => "alter_am_jahresende_2023",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100281/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Sensoren
pub mod smarte_strasse_sensoren {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Was wird gemessen?
        pub was_wird_gemessen: Option<String>,
        /// Verantwortlich
        pub verantwortlich: Option<String>,
        /// QR-Code-Nr.
        pub qrc_nr: Option<f64>,
        /// Zu den Messwerten
        pub zu_den_messwerten: Option<String>,
        /// Foto
        pub foto: Option<String>,
        /// Geo Point
        pub geo_point: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WasWirdGemessen,
        Verantwortlich,
        QrcNr,
        ZuDenMesswerten,
        Foto,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WasWirdGemessen => "was_wird_gemessen",
                Field::Verantwortlich => "verantwortlich",
                Field::QrcNr => "qrc_nr",
                Field::ZuDenMesswerten => "zu_den_messwerten",
                Field::Foto => "foto",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100114/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Ersatzwahl Regierungsrat 3. März 2024
pub mod resultate_der_ersatzwahl_regierungsrat_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        ///
        /// Spalte, damit bei Grafik "Vereinzelte" abgebildet werden kann
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100337/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Gremien
pub mod grosser_rat_gremien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Aktiv
        ///
        /// Aktives durch den Grossen Rat gewähltes Gremium
        pub ist_aktuelles_gremium: Option<String>,
        /// Kurzname
        ///
        /// Kurzname des Gremiums
        pub kurzname: Option<String>,
        /// Name
        ///
        /// Name des Gremiums
        pub name: Option<String>,
        /// Gremientyp
        ///
        /// Typ des Gremiums (Kommission, Fraktion, Parlament)
        pub gremientyp: Option<String>,
        /// ID Gremium
        ///
        /// Individuelle Identifikationsnummer des Gremiums innerhalb der Datenbank des Grossen Rates.
        pub uni_nr: Option<String>,
        /// Gremiumsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Mitgliedschaften in Gremien". Gefiltert nach aktuellem Gremium.
        pub url_mitgliedschaften: Option<String>,
        /// Urheber von
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach Geschäften, bei denen das aktuelle Gremium als Urheber gilt.
        pub url_urheber: Option<String>,
        /// Zugewiesene Geschäfte data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Zuweisungen". Gefiltert nach Zuweisungen, die an das aktuelle Gremium gemacht wurden.
        pub url_zugew_geschaefte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IstAktuellesGremium,
        Kurzname,
        Name,
        Gremientyp,
        UniNr,
        UrlMitgliedschaften,
        UrlUrheber,
        UrlZugewGeschaefte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IstAktuellesGremium => "ist_aktuelles_gremium",
                Field::Kurzname => "kurzname",
                Field::Name => "name",
                Field::Gremientyp => "gremientyp",
                Field::UniNr => "uni_nr",
                Field::UrlMitgliedschaften => "url_mitgliedschaften",
                Field::UrlUrheber => "url_urheber",
                Field::UrlZugewGeschaefte => "url_zugew_geschaefte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100310/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Ersatzwahl Regierungsrat 3. März 2024
pub mod kandidierende_der_ersatzwahl_regierungsrat_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100333/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ein- und Ausfahrten öffentlicher Parkhäuser Basel
pub mod ein_und_ausfahrten_oeffentlicher_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Start des Messintervalls von 1 h
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Parkhaus
        ///
        /// Name des Parkhauses
        pub title: Option<String>,
        /// Zeitstempel wie vom Quellsystem geliefert in lokaler Zeitzone. Falls leer, so wurde diese Zeile nachträglich hinzugefügt, um Lücken in der Zeitreihe zu vermeiden.
        pub timestamp_text: Option<String>,
        /// Einfahrten
        ///
        /// Anzahl Einfahrten im Messintervall
        pub einfahrten: Option<i64>,
        /// Ausfahrten
        ///
        /// Anzahl Ausfahrten im Messintervall
        pub ausfahrten: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Title,
        TimestampText,
        Einfahrten,
        Ausfahrten,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Title => "title",
                Field::TimestampText => "timestamp_text",
                Field::Einfahrten => "einfahrten",
                Field::Ausfahrten => "ausfahrten",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100198/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmung vom 9. Juni 2024 Details
pub mod abstimmung_vom_9_juni_2024_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100369/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Massentests an Schulen der Sekundarstufe II
pub mod coronavirus_covid_19_massentests_an_schulen_der_sekundarstufe_ii {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<String>,
        /// Resultat
        ///
        /// Zeigt an, ob ein SARS-CoV-2-Test positiv oder negativ ausgefallen ist
        pub result: Option<String>,
        /// Pos./neg. getestete SUS pro Woche
        ///
        /// Anzahl positiv resp. negativ getesteter Schülerinnen, Schüler und Lehrpersonen pro Woche
        pub count: Option<i64>,
        /// Getestete SUS pro Woche
        ///
        /// Anzahl getesteter Schülerinnen, Schüler und Lehrpersonen pro Woche
        pub counttotal: Option<i64>,
        /// Positivitätsrate
        ///
        /// Zeigt den Prozentsatz der Tests, die positiv auf SARS-CoV-2 getestet wurden
        pub positivityratepercent: Option<f64>,
        /// Schulen
        ///
        /// Anzahl Schulen der Sekundarstufe II, deren Schülerinnen, Schüler und Lehrpersonen getestet wurden
        pub schoolcount: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
        Schoolcount,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
                Field::Schoolcount => "schoolcount",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100153/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gesundheitsversorgung (GSV): Pflegeheimbewohnende
pub mod gesundheitsversorgung_gsv_pflegeheimbewohnende {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<f64>,
        /// BewohnerInnen Total
        ///
        /// Anzahl der Pflegeheimbewohnenden
        pub bewohner: Option<i64>,
        /// Anzahl Frauen
        ///
        /// Anzahl Frauen in Pflegeheimen
        pub anzahl_frauen: Option<i64>,
        /// Anteil Frauen
        ///
        /// Anteil der Frauen aller Pflegeheimbewohnenden
        pub anteil_frauen: Option<f64>,
        /// Anzahl Männer
        ///
        /// Anzahl der Männer in Pflegeheimen
        pub anzahl_maenner: Option<i64>,
        /// Anteil Männer
        ///
        /// Anteil der Männer aller Pflegeheimbewohnenden
        pub anteil_maenner: Option<f64>,
        /// Durchschnittsalter PflegeheimbewohnerInnen
        ///
        /// Durchschnittsalter aller Pflegeheimbewohnenden
        pub mean_alter_bewohner: Option<f64>,
        /// Durchschnittsalter Frauen
        ///
        /// Durchschnittsalter aller Pflegeheimbewohnerinnen
        pub mean_alter_frauen: Option<f64>,
        /// Durchschnittsalter Männer
        ///
        /// Durchschnittsalter aller Pflegeheimbewohner
        pub mean_alter_maenner: Option<f64>,
        /// Anzahl verstorbene Pflegeheimbewohnende
        ///
        /// Anzahl der verstorbenen Pflegeheimbewohnenden
        pub verstorben_bewohner: Option<i64>,
        /// Durchschnittliche Aufenthaltsdauer
        ///
        /// Durchschnittliche Aufenthaltsdauer In Jahren aller Bewohnende in Pflegeheimen. Bezieht sich auf die PflegeheimbewohnerInnen, die im jeweiligen Jahr verstorben sind.
        pub alos: Option<f64>,
        /// Durchschnittliche Aufenthaltsdauer Frauen
        ///
        /// Durchschnittliche Aufenthaltsdauer in Jahren der Frauen. Bezieht sich auf die Pflegeheimbewohnerinnen, die im jeweiligen Jahr verstorben sind.
        pub alos_frauen: Option<f64>,
        /// Durchschnittliche Aufenthaltsdauer Männer
        ///
        /// Durchschnittliche Aufenthaltsdauer in Jahren der Männer. Bezieht sich auf die Pflegeheimbewohner, die im jeweiligen Jahr verstorben sind.
        pub alos_maenner: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Id,
        Bewohner,
        AnzahlFrauen,
        AnteilFrauen,
        AnzahlMaenner,
        AnteilMaenner,
        MeanAlterBewohner,
        MeanAlterFrauen,
        MeanAlterMaenner,
        VerstorbenBewohner,
        Alos,
        AlosFrauen,
        AlosMaenner,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Id => "id",
                Field::Bewohner => "bewohner",
                Field::AnzahlFrauen => "anzahl_frauen",
                Field::AnteilFrauen => "anteil_frauen",
                Field::AnzahlMaenner => "anzahl_maenner",
                Field::AnteilMaenner => "anteil_maenner",
                Field::MeanAlterBewohner => "mean_alter_bewohner",
                Field::MeanAlterFrauen => "mean_alter_frauen",
                Field::MeanAlterMaenner => "mean_alter_maenner",
                Field::VerstorbenBewohner => "verstorben_bewohner",
                Field::Alos => "alos",
                Field::AlosFrauen => "alos_frauen",
                Field::AlosMaenner => "alos_maenner",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100319/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen zu den Basler Wohnvierteln und Landgemeinden
pub mod kennzahlen_zu_den_basler_wohnvierteln_und_landgemeinden {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationsjahr
        ///
        /// Jahr, in dem der Wert publiziert wurde
        pub publikationsjahr: Option<String>,
        /// Wohnviertel ID
        ///
        /// Nummer des Wohnviertels (1-19) bzw. der Landgemeinde (20 und 30)
        pub wohnviertel_id: Option<i64>,
        /// Wohnviertel Name
        ///
        /// Name des Wohnviertels bzw. der Landgemeinde
        pub wohnviertel_name: Option<String>,
        /// Altersquotient
        ///
        /// Verhältnis der Anzahl über 64-Jähriger zur Anzahl 20- bis 64-Jähriger (Personen im erwerbsfähigen Alter). Quelle: Kantonale Bevölkerungsstatistik
        pub altersquotient: Option<f64>,
        /// Jugendquotient
        ///
        /// Verhältnis der Anzahl unter 20-Jähriger zur Anzahl 20- bis 64-Jähriger (Personen im erwerbsfähigen Alter). Quelle: Kantonale Bevölkerungsstatistik
        pub jugendquotient: Option<f64>,
        /// Anteil Personen ohne Religionszugehörigkeit
        ///
        /// Anteil Personen ohne Religionszugehörigkeit an der gesamten Wohnbevölkerung des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_personen_ohne_religionszugehoerigkeit: Option<f64>,
        /// Anteil Personen in Einpersonenhaushalten
        ///
        /// Anteil der Personen in Einpersonenhaushalten an der Wohnbevölkerung in Privathaushalten des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_personen_in_einpersonenhaushalten: Option<f64>,
        /// Anteil Sesshafte
        ///
        /// Anteil der seit mindestens 10 Jahren am gleichen Wohnsitz wohnenden Personen des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_sesshafte: Option<f64>,
        /// Baujahr der Wohngebäude
        ///
        /// Mittleres Baujahr der Wohngebäude des Wohnviertels (ungewichtetes arithmetisches Mittel). Quelle: Kantonale Baustatistik
        pub baujahr_der_wohngebaeude: Option<f64>,
        /// Anteil Einfamilienhäuser
        ///
        /// Anteil der Einfamilienhäuser an allen bewohnbaren Gebäuden des Wohnviertels. Quelle: Kantonale Baustatistik
        pub anteil_einfamilienhaeuser: Option<f64>,
        /// Gymnasialquote
        ///
        /// Anteil der Schülerinnen und Schüler der öffentlichen Sekundarschule Basel-Stadt im Leistungszug P mit hohen Anforderungen («Progymnasium») an allen Sek-Lernenden der 10. und 11. Schulstufe. Quelle: Kantonale Bildungsstatistik
        pub gymnasialquote: Option<f64>,
        /// Anteil Sozialhilfeempfänger
        ///
        /// Anteil der im Jahresverlauf unterstützten Sozialhilfeempfänger an der Wohnbevölkerung des Wohnviertels. Quelle: Kantonale Sozialhilfestatistik
        pub anteil_sozialhilfeempfaenger: Option<f64>,
        /// Anteil Ausländer
        ///
        /// Anteil der ausländischen Wohnbevölkerung an der gesamten Wohnbevölkerung des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_auslaender: Option<f64>,
        /// Anteil Grünflächen
        ///
        /// Anteil der Grünfläche an der gesamten Fläche des Wohnviertels. Quelle: Grundbuch- und Vermessungsamt Basel-Stadt
        pub anteil_gruenflaechen: Option<f64>,
        /// Fläche pro Wohnung
        ///
        /// Mittlere Fläche der Wohnungen im Wohnviertel (ungewichtetes arithmetisches Mittel) in m². Quelle: Kantonale Baustatistik
        pub flaeche_pro_wohnung: Option<f64>,
        /// Wohnfläche pro Person
        ///
        /// Mittlere verfügbare Wohnfläche pro Einwohner im Wohnviertel (ungewichtetes arithmetisches Mittel) in m². Quelle: Kantonale Bau- und Bevölkerungsstatistik
        pub wohnflaeche_pro_person: Option<f64>,
        /// Vermögenssteuer pro Veranlagung
        ///
        /// Mittlere Vermögenssteuer der steuerpflichtigen Personen im Wohnviertel (ungewichtetes arithmetisches Mittel der ordentlichen Steuerveranlagungen) in Fr. Quelle: Steuerstatistik Basel-Stadt
        pub vermoegenssteuer_pro_veranlagung: Option<f64>,
        /// Einkommenssteuer pro Veranlagung
        ///
        /// Mittlere Einkommenssteuer der steuerpflichtigen Personen im Wohnviertel (ungewichtetes arithmetisches Mittel der ordentlichen Steuerveranlagungen) in Fr. Quelle: Steuerstatistik Basel-Stadt
        pub einkommenssteuer_pro_veranlagung: Option<f64>,
        /// Erwerbstätigenquote
        ///
        /// Anteil der erwerbstätigen Wohnbevölkerung an der gesamten erwerbsfähigen Wohnbevölkerung (16 bis 64 Jahre). Quelle: Bundesamt für Statistik, Strukturerhebung. Hochrechnungen auf Basis einer Stichprobe von rund 5 000 Personen im Jahr. Aufgrund der Grösse wird Bettingen zusammen mit Riehen ausgewertet, was zum gleichen Rangwert der beiden Gemeinden führt.
        pub erwerbstaetigenquote: Option<f64>,
        /// Arbeitsplätze pro Einwohner
        ///
        /// Anzahl Arbeitsplätze (Beschäftigtenzahl in Vollzeitäquivalenten) an der gesamten Wohnbevölkerung des Wohnviertels. Quelle: Bundesamt für Statistik, STATENT
        pub arbeitsplaetze_pro_einwohner: Option<f64>,
        /// Arbeitslosenquote
        ///
        /// Anteil als arbeitslos gemeldeter Personen am Total der Erwerbspersonen. Quelle: SECO (Anzahl Arbeitslose) und Bundesamt für Statistik, Strukturerhebung (Erwerbspersonen aus den Jahren 2010-2014, Hochrechnungen auf Basis einer Stichprobe von rund 5 000 Personen im Jahr). Aufgrund der Grösse wird Bettingen zusammen mit Riehen ausgewertet, was zum gleichen Rangwert der beiden Gemeinden führt.
        pub arbeitslosenquote: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Publikationsjahr,
        WohnviertelId,
        WohnviertelName,
        Altersquotient,
        Jugendquotient,
        AnteilPersonenOhneReligionszugehoerigkeit,
        AnteilPersonenInEinpersonenhaushalten,
        AnteilSesshafte,
        BaujahrDerWohngebaeude,
        AnteilEinfamilienhaeuser,
        Gymnasialquote,
        AnteilSozialhilfeempfaenger,
        AnteilAuslaender,
        AnteilGruenflaechen,
        FlaecheProWohnung,
        WohnflaecheProPerson,
        VermoegenssteuerProVeranlagung,
        EinkommenssteuerProVeranlagung,
        Erwerbstaetigenquote,
        ArbeitsplaetzeProEinwohner,
        Arbeitslosenquote,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Publikationsjahr => "publikationsjahr",
                Field::WohnviertelId => "wohnviertel_id",
                Field::WohnviertelName => "wohnviertel_name",
                Field::Altersquotient => "altersquotient",
                Field::Jugendquotient => "jugendquotient",
                Field::AnteilPersonenOhneReligionszugehoerigkeit => {
                    "anteil_personen_ohne_religionszugehoerigkeit"
                }
                Field::AnteilPersonenInEinpersonenhaushalten => {
                    "anteil_personen_in_einpersonenhaushalten"
                }
                Field::AnteilSesshafte => "anteil_sesshafte",
                Field::BaujahrDerWohngebaeude => "baujahr_der_wohngebaeude",
                Field::AnteilEinfamilienhaeuser => "anteil_einfamilienhaeuser",
                Field::Gymnasialquote => "gymnasialquote",
                Field::AnteilSozialhilfeempfaenger => "anteil_sozialhilfeempfaenger",
                Field::AnteilAuslaender => "anteil_auslaender",
                Field::AnteilGruenflaechen => "anteil_gruenflaechen",
                Field::FlaecheProWohnung => "flaeche_pro_wohnung",
                Field::WohnflaecheProPerson => "wohnflaeche_pro_person",
                Field::VermoegenssteuerProVeranlagung => "vermoegenssteuer_pro_veranlagung",
                Field::EinkommenssteuerProVeranlagung => "einkommenssteuer_pro_veranlagung",
                Field::Erwerbstaetigenquote => "erwerbstaetigenquote",
                Field::ArbeitsplaetzeProEinwohner => "arbeitsplaetze_pro_einwohner",
                Field::Arbeitslosenquote => "arbeitslosenquote",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100011/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Sitzungskalender
pub mod grosser_rat_sitzungskalender {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Sitzungstyp
        ///
        /// Beschreibung der Sitzung
        pub summary: Option<String>,
        /// Start
        ///
        /// Datum und Uhrzeit, zu der die Sitzung beginnt
        #[serde(with = "time::serde::iso8601::option")]
        pub dtstart: Option<OffsetDateTime>,
        /// Ende
        ///
        /// Datum und Uhrzeit, zu der die Sitzung endet
        #[serde(with = "time::serde::iso8601::option")]
        pub dtend: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Summary,
        Dtstart,
        Dtend,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Summary => "summary",
                Field::Dtstart => "dtstart",
                Field::Dtend => "dtend",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100188/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Positiv getestete Minderjährige in 3-Jahresklassen
pub mod coronavirus_covid_19_positiv_getestete_minderjaehrige_in_3_jahresklassen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Testresultat
        ///
        /// Datum, an dem das Testresultat vorlag
        pub test_datum: Option<Date>,
        /// Altersklasse
        ///
        /// 3-Jahresklassen der Minderjährigen, wobei die erste Klasse (0 bis 3 Jahre) 4 Jahre umfasst
        pub pers_alter: Option<String>,
        /// Anzahl Personen
        ///
        /// Anzahl Personen in der jeweiligen Subgruppe
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TestDatum,
        PersAlter,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TestDatum => "test_datum",
                Field::PersAlter => "pers_alter",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100152/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 12. März 2023
pub mod kennzahlen_der_abstimmung_vom_12_maerz_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100280/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baumkronenbedeckung
pub mod baumkronenbedeckung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// URL Bild
        ///
        /// Downloadlink zum Bild der Baumkronenbedeckung im png-Format.
        pub url_png: Option<String>,
        /// URL Weltdatei
        ///
        /// Downloadlink zur Weltdatei im png-Format. Eine Weltdatei enthält Georeferenzierungsdaten für ein zugehöriges Bild (hier im PNG-Format), um dessen genaue Positionierung auf einer Karte zu ermöglichen.
        pub url_pgw: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        UrlPng,
        UrlPgw,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::UrlPng => "url_png",
                Field::UrlPgw => "url_pgw",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100357/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2023: Veränderte Wahlzettel
pub mod nationalratswahlen_2023_veraenderte_wahlzettel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Column 1
        pub column_1: Option<i64>,
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Wahlkreis
        pub wahlkreis: Option<String>,
        /// Stimmmedium
        ///
        /// Beschreibt, ob der Wahlzettel in physischer oder elektronischer Form abgegeben wurde.
        pub wahlzettel_type: Option<String>,
        /// Listennummer
        pub listen_nr: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// 1. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der ersten Stimme
        pub kandidat_1: Option<String>,
        /// 1. Stimme - Name
        ///
        /// Ganzer Name der ersten Stimme
        pub kandidat_1_name: Option<String>,
        /// 2. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der zweiten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_2: Option<String>,
        /// 2. Stimme - Name
        ///
        /// Ganzer Name der zweiten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_2_name: Option<String>,
        /// 3. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der dritten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_3: Option<String>,
        /// 3. Stimme - Name
        ///
        /// Ganzer Name der dritten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_3_name: Option<String>,
        /// 4. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der vierten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_4: Option<String>,
        /// 4. Stimme - Name
        ///
        /// Ganzer Name der vierten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_4_name: Option<String>,
        /// Veränderungsart
        ///
        /// p = panaschiert; k = kumuliert
        pub wahlzettel_typ: Option<String>,
        /// Listenverbindungen
        pub listenverbindungen: Option<String>,
        /// Unterlistenverbindungen
        pub unterlistenverbindungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Column1,
        Wahljahr,
        Wahlkreis,
        WahlzettelType,
        ListenNr,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        Kandidat1,
        Kandidat1Name,
        Kandidat2,
        Kandidat2Name,
        Kandidat3,
        Kandidat3Name,
        Kandidat4,
        Kandidat4Name,
        WahlzettelTyp,
        Listenverbindungen,
        Unterlistenverbindungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Column1 => "column_1",
                Field::Wahljahr => "wahljahr",
                Field::Wahlkreis => "wahlkreis",
                Field::WahlzettelType => "wahlzettel_type",
                Field::ListenNr => "listen_nr",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::Kandidat1 => "kandidat_1",
                Field::Kandidat1Name => "kandidat_1_name",
                Field::Kandidat2 => "kandidat_2",
                Field::Kandidat2Name => "kandidat_2_name",
                Field::Kandidat3 => "kandidat_3",
                Field::Kandidat3Name => "kandidat_3_name",
                Field::Kandidat4 => "kandidat_4",
                Field::Kandidat4Name => "kandidat_4_name",
                Field::WahlzettelTyp => "wahlzettel_typ",
                Field::Listenverbindungen => "listenverbindungen",
                Field::Unterlistenverbindungen => "unterlistenverbindungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100331/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nationalratswahlen 2023: Kandidierende aus Basel-Stadt
pub mod nationalratswahlen_2023_kandidierende_aus_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenkurzbezeichnung
        ///
        /// Abkürzung der Liste
        pub listenkurzbezeichnung: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Listenverbindungen mit
        ///
        /// Hauptlistenverbindungen
        pub hlv_mit: Option<String>,
        /// Filter nach Listenverbindung
        ///
        /// Mit dem Klick auf den Link wird der Datensatz nach allen Listen gefiltert, die in der gleichen Hauptlistenverbindung sind.
        pub hlv_link: Option<String>,
        /// Unterlistenverbindungen mit
        ///
        /// Unterlistenverbindungen
        pub ulv_mit: Option<String>,
        /// Filter nach Unterlistenverbindung
        ///
        /// Mit dem Klick auf den Link wird der Datensatz nach allen Listen gefiltert, die in der gleichen Unterlistenverbindung sind.
        pub ulv_link: Option<String>,
        /// Kandidierenden-Nr.
        ///
        /// Nummer der Kandidatur
        pub kand_nr: Option<String>,
        /// Bisher
        ///
        /// War die kandidierende Person bisher im Nationalrat?
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub kurzbeschrieb: Option<String>,
        /// Wohnhaft in
        pub wh_in: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenkurzbezeichnung,
        Listenbezeichnung,
        HlvMit,
        HlvLink,
        UlvMit,
        UlvLink,
        KandNr,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Kurzbeschrieb,
        WhIn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenkurzbezeichnung => "listenkurzbezeichnung",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::HlvMit => "hlv_mit",
                Field::HlvLink => "hlv_link",
                Field::UlvMit => "ulv_mit",
                Field::UlvLink => "ulv_link",
                Field::KandNr => "kand_nr",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Kurzbeschrieb => "kurzbeschrieb",
                Field::WhIn => "wh_in",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100316/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Ständeratswahlen 2023: Kandidierende aus Basel-Stadt
pub mod staenderatswahlen_2023_kandidierende_aus_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        ///
        /// War die kandidierende Person bisher im Ständerat?
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e) etc.
        pub kurzbeschrieb: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Kurzbeschrieb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Kurzbeschrieb => "kurzbeschrieb",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100317/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wahllokale Kanton Basel-Stadt
pub mod wahllokale_kanton_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WahllokName,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100098/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Lebendgeborene seit 1901
pub mod lebendgeborene_seit_1901 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// Total
        ///
        /// Total der Lebendgeborenen
        pub total: Option<i64>,
        /// Knaben
        ///
        /// Anzahl Knaben
        pub knaben: Option<i64>,
        /// Mädchen
        ///
        /// Anzahl Mädchen
        pub madchen: Option<i64>,
        /// Mutter verheiratet
        ///
        /// Anzahl der Mütter, die verheiratet sind
        pub mutter_verheiratet: Option<i64>,
        /// Mutter unverheiratet
        ///
        /// Anzahl der Mütter, die unverheiratet sind
        pub mutter_unverheiratet: Option<i64>,
        /// Kantonsbürger
        ///
        /// Anzahl der Lebendgeborenen, die Bürgerinnen und Bürger des Kantons Basel-Stadt sind
        pub kantonsburger: Option<i64>,
        /// Übrige Schweizer
        ///
        /// Anzahl der Lebendgeborenen, die Bürgerinnen und Bürger anderer Schweizer Kantone sind
        pub ubrige_schweiz: Option<i64>,
        /// Schweiz
        ///
        /// Anzahl der Lebendgeborenen mit Schweizer Staatsangehörigkeit
        pub schweiz: Option<i64>,
        /// Ausland
        ///
        /// Anzahl der Lebendgeborenen mit ausländischer Staatsangehörigkeit
        pub ausland: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Total,
        Knaben,
        Madchen,
        MutterVerheiratet,
        MutterUnverheiratet,
        Kantonsburger,
        UbrigeSchweiz,
        Schweiz,
        Ausland,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Total => "total",
                Field::Knaben => "knaben",
                Field::Madchen => "madchen",
                Field::MutterVerheiratet => "mutter_verheiratet",
                Field::MutterUnverheiratet => "mutter_unverheiratet",
                Field::Kantonsburger => "kantonsburger",
                Field::UbrigeSchweiz => "ubrige_schweiz",
                Field::Schweiz => "schweiz",
                Field::Ausland => "ausland",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100326/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Perimeter der Schülerprognosen Basel-Stadt
pub mod perimeter_der_schuelerprognosen_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Perimeter ID
        ///
        /// Laufnummer der Perimeter
        pub nummer: Option<i64>,
        /// Perimeter Name
        ///
        /// Räumliche Einheiten, die zu Planungszwecken vom Erziehungsdepartement Basel-Stadt und von der Gemeinde Riehen verwendet werden. Die Perimeter dienen als Planungsgrundlage und nicht als effektive Einzugsgebiete.
        pub zonen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Nummer,
        Zonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Nummer => "nummer",
                Field::Zonen => "zonen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100124/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geschwindigkeitsklassen motorisierter Individualverkehr
pub mod geschwindigkeitsklassen_motorisierter_individualverkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Standort-ID
        pub zst_id: Option<String>,
        /// Standortname
        ///
        /// Name des Standorts
        pub sitename: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung des Fahrzeugs
        pub directionname: Option<String>,
        /// Spurnummer
        ///
        /// Nummer der Spur
        pub lanecode: Option<String>,
        /// Spurname
        ///
        /// Name der Spur
        pub lanename: Option<String>,
        /// Datum
        pub date: Option<Date>,
        /// Messbeginn Uhrzeit
        pub timefrom: Option<String>,
        /// Messende Uhrzeit
        pub timeto: Option<String>,
        /// Verkehrsart
        pub traffictype: Option<String>,
        /// Total
        pub total: Option<i64>,
        /// <20km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von weniger als 20 km/h fahren.
        pub x20: Option<i64>,
        /// 20-30km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 20-30km/h fahren.
        pub x20_30: Option<i64>,
        /// 30-40km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 30-40km/h fahren.
        pub x30_40: Option<i64>,
        /// 40-50km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 40-50km/h fahren.
        pub x40_50: Option<i64>,
        /// 50-60km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 50-60km/h fahren.
        pub x50_60: Option<i64>,
        /// 60-70km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 60-70km/h fahren.
        pub x60_70: Option<i64>,
        /// 70-80km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 70-80km/h fahren.
        pub x70_80: Option<i64>,
        /// 80-90km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 80-90km/h fahren.
        pub x80_90: Option<i64>,
        /// 90-100km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 90-100km/h fahren.
        pub x90_100: Option<i64>,
        /// 100-110km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 100-110km/h fahren.
        pub x100_110: Option<i64>,
        /// 110-120km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 110-120km/h fahren.
        pub x110_120: Option<i64>,
        /// 120-130km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 120-130km/h fahren.
        pub x120_130: Option<i64>,
        /// >130km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von über 130km/h fahren.
        pub x130: Option<i64>,
        /// Messbeginn Zeitpunkt
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimefrom: Option<OffsetDateTime>,
        /// Messende Zeitpunkt
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimeto: Option<OffsetDateTime>,
        /// Jahr
        pub year: Option<String>,
        /// Monat
        pub month: Option<String>,
        /// Tag
        pub day: Option<String>,
        /// Wochentag
        ///
        /// Die Wochentage sind von 0 bis 6 durchnummeriert mit Montag als Wochenanfang mit der Nummer 0.
        pub weekday: Option<String>,
        /// Stunde
        pub hourfrom: Option<String>,
        /// Tag des Jahres
        pub dayofyear: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ZstId,
        Sitename,
        Directionname,
        Lanecode,
        Lanename,
        Date,
        Timefrom,
        Timeto,
        Traffictype,
        Total,
        X20,
        X2030,
        X3040,
        X4050,
        X5060,
        X6070,
        X7080,
        X8090,
        X90100,
        X100110,
        X110120,
        X120130,
        X130,
        Datetimefrom,
        Datetimeto,
        Year,
        Month,
        Day,
        Weekday,
        Hourfrom,
        Dayofyear,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ZstId => "zst_id",
                Field::Sitename => "sitename",
                Field::Directionname => "directionname",
                Field::Lanecode => "lanecode",
                Field::Lanename => "lanename",
                Field::Date => "date",
                Field::Timefrom => "timefrom",
                Field::Timeto => "timeto",
                Field::Traffictype => "traffictype",
                Field::Total => "total",
                Field::X20 => "20",
                Field::X2030 => "20_30",
                Field::X3040 => "30_40",
                Field::X4050 => "40_50",
                Field::X5060 => "50_60",
                Field::X6070 => "60_70",
                Field::X7080 => "70_80",
                Field::X8090 => "80_90",
                Field::X90100 => "90_100",
                Field::X100110 => "100_110",
                Field::X110120 => "110_120",
                Field::X120130 => "120_130",
                Field::X130 => "130",
                Field::Datetimefrom => "datetimefrom",
                Field::Datetimeto => "datetimeto",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Hourfrom => "hourfrom",
                Field::Dayofyear => "dayofyear",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100356/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Transformation Areal Rosental: Baustellenbereich
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_baustellenbereich {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub n: Option<String>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        N,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::N => "n",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100296/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Steuerstatistik Basel-Stadt: Kennzahlen seit 1991 nach Gemeinde und Wohnviertel
pub mod steuerstatistik_basel_stadt_kennzahlen_seit_1991_nach_gemeinde_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Steuerjahr
        ///
        /// Jahr, auf das sich die Veranlagung bezieht.
        pub steuerjahr: Option<String>,
        /// Wohnviertel
        ///
        /// Umfasst die Wohnviertel der Stadt Basel sowie die beiden Einwohnergemeinden Riehen und Bettingen.
        pub wohnviertel: Option<i64>,
        /// Wohnviertel Name
        pub wohnviertel_name: Option<String>,
        /// Anzahl Veranlagungen
        ///
        /// Ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub n: Option<i64>,
        /// Reineinkommen Mittelwert
        ///
        /// Mittelwert des Reineinkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reineinkommen_mittelwert: Option<i64>,
        /// Reineinkommen Median
        ///
        /// Median des Reineinkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reineinkommen_median: Option<i64>,
        /// Reineinkommen Gini-Koeffizient
        ///
        /// Gini-Koeffizient für das Reineinkommen; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt. Der Gini-Koeffizient ist eine statistische Masszahl zur Messung der Einkommens- oder Vermögensungleichheit in einer Gesellschaft. Er variiert zwischen 0 und 1, wobei 0 für absolute Gleichheit steht und 1 für maximale Ungleichheit.
        pub reineinkommen_ginik: Option<f64>,
        /// Steuerbares Einkommen Mittelwert
        ///
        /// Mittelwert des steuerbaren Einkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbar_mittelwert: Option<i64>,
        /// Steuerbares Einkommen Median
        ///
        /// Median des steuerbaren Einkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbar_median: Option<i64>,
        /// Ertrag Einkommenssteuer Mittelwert
        ///
        /// Mittelwert des Einkommenssteuerertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbetrag_ktgde_mittelwert: Option<i64>,
        /// Ertrag Einkommenssteuer Median
        ///
        /// Median des Einkommenssteuerertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbetrag_ktgde_median: Option<i64>,
        /// Reinvermögen Mittelwert
        ///
        /// Mittelwert des Reinvermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reinvermoegen_mittelwert: Option<i64>,
        /// Reinvermögen Median
        ///
        /// Median des Reinvermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reinvermoegen_median: Option<i64>,
        /// Reinvermögen Gini-Koeffizient
        ///
        /// Gini-Koeffizient für das Reinvermögen; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt. Der Gini-Koeffizient ist eine statistische Masszahl zur Messung der Einkommens- oder Vermögensungleichheit in einer Gesellschaft. Er variiert zwischen 0 und 1, wobei 0 für absolute Gleichheit steht und 1 für maximale Ungleichheit.
        pub reinvermoegen_ginik: Option<f64>,
        /// Steuerbares Vermögen Mittelwert
        ///
        /// Mittelwert des steuerbaren Vermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbar_mittelwert: Option<i64>,
        /// Steuerbares Vermögen Median
        ///
        /// Median des steuerbaren Vermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbar_median: Option<i64>,
        /// Ertrag Vermögenssteuer Mittelwert
        ///
        /// Mittelwert des Vermögenssteuerertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbetrag_ktgde_mittelwert: Option<i64>,
        /// Ertrag Vermögenssteuer Median
        ///
        /// Median des Vermögenssteuertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbetrag_ktgde_median: Option<i64>,
        pub steuerjahr_zahl: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Steuerjahr,
        Wohnviertel,
        WohnviertelName,
        N,
        ReineinkommenMittelwert,
        ReineinkommenMedian,
        ReineinkommenGinik,
        EinkommenSteuerbarMittelwert,
        EinkommenSteuerbarMedian,
        EinkommenSteuerbetragKtgdeMittelwert,
        EinkommenSteuerbetragKtgdeMedian,
        ReinvermoegenMittelwert,
        ReinvermoegenMedian,
        ReinvermoegenGinik,
        VermoegenSteuerbarMittelwert,
        VermoegenSteuerbarMedian,
        VermoegenSteuerbetragKtgdeMittelwert,
        VermoegenSteuerbetragKtgdeMedian,
        SteuerjahrZahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Steuerjahr => "steuerjahr",
                Field::Wohnviertel => "wohnviertel",
                Field::WohnviertelName => "wohnviertel_name",
                Field::N => "n",
                Field::ReineinkommenMittelwert => "reineinkommen_mittelwert",
                Field::ReineinkommenMedian => "reineinkommen_median",
                Field::ReineinkommenGinik => "reineinkommen_ginik",
                Field::EinkommenSteuerbarMittelwert => "einkommen_steuerbar_mittelwert",
                Field::EinkommenSteuerbarMedian => "einkommen_steuerbar_median",
                Field::EinkommenSteuerbetragKtgdeMittelwert => {
                    "einkommen_steuerbetrag_ktgde_mittelwert"
                }
                Field::EinkommenSteuerbetragKtgdeMedian => "einkommen_steuerbetrag_ktgde_median",
                Field::ReinvermoegenMittelwert => "reinvermoegen_mittelwert",
                Field::ReinvermoegenMedian => "reinvermoegen_median",
                Field::ReinvermoegenGinik => "reinvermoegen_ginik",
                Field::VermoegenSteuerbarMittelwert => "vermoegen_steuerbar_mittelwert",
                Field::VermoegenSteuerbarMedian => "vermoegen_steuerbar_median",
                Field::VermoegenSteuerbetragKtgdeMittelwert => {
                    "vermoegen_steuerbetrag_ktgde_mittelwert"
                }
                Field::VermoegenSteuerbetragKtgdeMedian => "vermoegen_steuerbetrag_ktgde_median",
                Field::SteuerjahrZahl => "steuerjahr_zahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100165/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Eingebürgerte Ausländerinnen und Ausländer nach Geschlecht, Alter, Geburtsland und Staatsangehörigkeit bei Gesuchsstellung
pub mod eingebuergerte_auslaenderinnen_und_auslaender_nach_geschlecht_alter_geburtsland_und_staatsangehoerigkeit_bei_gesuchsstellung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Einbürgerungsjahr
        pub jahr: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht der eingebürgerten Person (männlich oder weiblich)
        pub geschlecht: Option<String>,
        /// Alter
        ///
        /// Alter am Ende des Einbürgerungsjahres
        pub alter: Option<String>,
        /// Alter mit Nummerierung
        ///
        /// Alter (mit Nummerierung) am Ende des Einbürgerungsjahres
        pub alter_numm: Option<String>,
        /// Geburtsland
        ///
        /// Geburtsland (Ausland oder Schweiz)
        pub geburtsland: Option<String>,
        /// Staatsangehörigkeit bei Gesuchstellung
        ///
        /// Staatsangehörigkeit bei der Gesuchstellung
        pub ehem_staaatsangehorigkeit: Option<String>,
        /// Anzahl Eingebürgerte
        pub anzahl_eingeburgerte: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Geschlecht,
        Alter,
        AlterNumm,
        Geburtsland,
        EhemStaaatsangehorigkeit,
        AnzahlEingeburgerte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Geschlecht => "geschlecht",
                Field::Alter => "alter",
                Field::AlterNumm => "alter_numm",
                Field::Geburtsland => "geburtsland",
                Field::EhemStaaatsangehorigkeit => "ehem_staaatsangehorigkeit",
                Field::AnzahlEingeburgerte => "anzahl_eingeburgerte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100321/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schutzsuchende im Kanton Basel-Stadt nach Geschlecht, Altersklasse, Staatsangehörigkeit, Zuzugs- und Wegzugsmonat
pub mod schutzsuchende_im_kanton_basel_stadt_nach_geschlecht_altersklasse_staatsangehoerigkeit_zuzugs_und_wegzugsmonat {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Personen-ID
        ///
        /// Personenbezogene Laufnummer
        pub laufnummer: Option<i64>,
        /// Jahr
        ///
        /// Jahr des Bevölkerungsbestand
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat des Bevölkerungsbestand
        pub monat: Option<i64>,
        /// Schutzstatus
        pub schutzstatus: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht der Schutzsuchenden (W: Weiblich, M: Männlich)
        pub geschlecht: Option<String>,
        /// Altersgruppen
        ///
        /// Schutzsuchende nach Altersgruppen
        pub altersgruppen: Option<String>,
        /// Weggezogen
        ///
        /// 0: Schutzsuchende sind noch im Bevölkerungsbestand, 1: Schutzsuchende sind nicht mehr im Bevölkerungsbestand (entweder aufgrund von Wegzug, Wechsel des Status, Todesfall, Registerbereinigung etc.)
        pub weggezogen: Option<i64>,
        /// Wegzugsjahr
        ///
        /// Jahr des Wegzugs (entweder aufgrund von Wegzug, Wechsel des Status, Todesfall, Registerbereinigung etc.)
        pub wegzugsjahr: Option<String>,
        /// Wegzugsmonat
        ///
        /// Monat des Wegzugs (entweder aufgrund von Wegzug, Wechsel des Status, Todesfall, Registerbereinigung etc.)
        pub wegzugsmonat: Option<i64>,
        /// Zuzugsjahr
        ///
        /// Jahr des Zuzugs (aufgrund von Zuzug oder Wechsel des Status)
        pub zuzugsjahr: Option<String>,
        /// Zuzugsmonat
        ///
        /// Monat des Zuzugs (aufgrund von Zuzug oder Wechsel des Status)
        pub zuzugsmonat: Option<i64>,
        /// Value_gender_BFS
        pub value_gender_bfs: Option<i64>,
        /// Name_gender_BFS
        pub name_gender_bfs: Option<String>,
        /// Monat und Jahr
        pub monat_und_jahr: Option<String>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit der Schutzsuchenden
        pub staatsangehoerigkeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Laufnummer,
        Jahr,
        Monat,
        Schutzstatus,
        Geschlecht,
        Altersgruppen,
        Weggezogen,
        Wegzugsjahr,
        Wegzugsmonat,
        Zuzugsjahr,
        Zuzugsmonat,
        ValueGenderBfs,
        NameGenderBfs,
        MonatUndJahr,
        Staatsangehoerigkeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Laufnummer => "laufnummer",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Schutzstatus => "schutzstatus",
                Field::Geschlecht => "geschlecht",
                Field::Altersgruppen => "altersgruppen",
                Field::Weggezogen => "weggezogen",
                Field::Wegzugsjahr => "wegzugsjahr",
                Field::Wegzugsmonat => "wegzugsmonat",
                Field::Zuzugsjahr => "zuzugsjahr",
                Field::Zuzugsmonat => "zuzugsmonat",
                Field::ValueGenderBfs => "value_gender_bfs",
                Field::NameGenderBfs => "name_gender_bfs",
                Field::MonatUndJahr => "monat_und_jahr",
                Field::Staatsangehoerigkeit => "staatsangehoerigkeit",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100225/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Sanierung Areal Walkeweg
pub mod ueberwachung_luftqualitaet_sanierung_areal_walkeweg {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messbeginn
        ///
        /// Beginn der Messung
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Ende der Messung
        pub messende: Option<Date>,
        /// Standort
        ///
        /// Name des Standorts
        pub standort: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff
        pub parameter: Option<String>,
        /// Messwert
        ///
        /// Gemessener Wert
        pub messwert: Option<f64>,
        /// Interventionswert
        pub interventionswert: Option<f64>,
        /// Warnwert
        pub warnwert: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird
        pub einheit: Option<String>,
        /// Messmethode
        pub messmethode: Option<String>,
        /// Koordinaten des Standorts
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Messbeginn,
        Messende,
        Standort,
        Parameter,
        Messwert,
        Interventionswert,
        Warnwert,
        Einheit,
        Messmethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::Messwert => "messwert",
                Field::Interventionswert => "interventionswert",
                Field::Warnwert => "warnwert",
                Field::Einheit => "einheit",
                Field::Messmethode => "messmethode",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100158/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Ständeratswahlen 2023
pub mod resultate_der_staenderatswahlen_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Alter am Jahresende 2023
        ///
        /// Alter, berechnet nach der Formel "2023 minus Jahrgang"
        pub alter_am_jahresende_2023: Option<i64>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1)
        pub column_44: Option<i64>,
        pub jahrgang_num: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        AlterAmJahresende2023,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        Column44,
        JahrgangNum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::AlterAmJahresende2023 => "alter_am_jahresende_2023",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::Column44 => "column_44",
                Field::JahrgangNum => "jahrgang_num",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100282/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Erweiterte Daten zu Impfungen nach Altersgruppe
pub mod coronavirus_covid_19_erweiterte_daten_zu_impfungen_nach_altersgruppe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Impfdatum
        ///
        /// Datum der Impfung
        pub vacc_day: Option<Date>,
        /// Altersgruppe
        ///
        /// Altersgruppe in Jahren. Impfberechtigte Bevölkerung: Personen ab 16 Jahre.
        pub age_group: Option<String>,
        /// Impftyp
        ///
        /// 1: Erste Impfung; 2: Zweite Impfung einer Person; -1: Anzahl ausschliesslich mit erster Dosis geimpfter Personen
        pub vacc_count: Option<i64>,
        /// Impftyp Beschreibung
        ///
        /// Beschreibung des Impftyps in Klartext
        pub vacc_count_description: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Impfungen pro Tag, Altersgruppe und Impftyp
        pub count: Option<i64>,
        /// Anzahl Kumuliert
        ///
        /// Kumulierte Anzahl Impfungen pro Altersgruppe und Impftyp seit Beginn der Impfkampagne
        pub count_cum: Option<i64>,
        /// Bevölkerungzahl der Altersgruppe
        ///
        /// Anzahl Personen wohnhaft in BS der angegebenen Altersgruppe per Ende 2020
        pub total_pop: Option<i64>,
        /// Anteil der Geimpften
        ///
        /// Quotient der kumulierten Anzahl Impfungen durch die Anzahl EinwohnerInnen der angegebenen Altersgruppe in %
        pub count_cum_percentage_of_total_pop: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        VaccDay,
        AgeGroup,
        VaccCount,
        VaccCountDescription,
        Count,
        CountCum,
        TotalPop,
        CountCumPercentageOfTotalPop,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::VaccDay => "vacc_day",
                Field::AgeGroup => "age_group",
                Field::VaccCount => "vacc_count",
                Field::VaccCountDescription => "vacc_count_description",
                Field::Count => "count",
                Field::CountCum => "count_cum",
                Field::TotalPop => "total_pop",
                Field::CountCumPercentageOfTotalPop => "count_cum_percentage_of_total_pop",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100137/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Massentests an Schulen der Primar- und Sekundarstufe I
pub mod coronavirus_covid_19_massentests_an_schulen_der_primar_und_sekundarstufe_i {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<i64>,
        /// Resultat
        ///
        /// Zeigt an, ob ein Pool positiv oder negativ auf SARS-CoV-2 getestet wurde
        pub result: Option<String>,
        /// Klassen pro Woche pos./neg.
        ///
        /// Anzahl positiv resp. negativ getesteter Klassen-Pools in einer Woche
        pub count: Option<i64>,
        /// Klassen pro Woche total
        ///
        /// Anzahl in einer Woche getesteter Klassen-Pools total
        pub counttotal: Option<i64>,
        /// Klassen-Positivitätsrate
        ///
        /// Zeigt den Prozentsatz der positiv auf SARS-CoV-2 getesteten Klassen-Pools
        pub positivityratepercent: Option<f64>,
        /// Getestete SchülerInnen
        ///
        /// Anzahl in den Klassen-Pools einer Woche getesteter Schülerinnen und Schüler
        pub countsamples: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
        Countsamples,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
                Field::Countsamples => "countsamples",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100145/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gefahrenstufen für Hochwasser
pub mod gefahrenstufen_fuer_hochwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id
        pub station_id: Option<String>,
        /// Station
        ///
        ///
        pub station_name: Option<String>,
        /// Gefahrenstufe 1
        ///
        /// Gefahrenstufe 1 (m3/s)
        pub gefahrenstufe_1: Option<String>,
        /// Gefahrenstufe 2
        ///
        /// Gefahrenstufe 2 (m3/s)
        pub gefahrenstufe_2: Option<String>,
        /// Gefahrenstufe 3
        ///
        /// Gefahrenstufe 3 (m3/s)
        pub gefahrenstufe_3: Option<String>,
        /// Gefahrenstufe 4
        ///
        /// Gefahrenstufe 4 (m3/s)
        pub gefahrenstufe_4: Option<String>,
        /// Gefahrenstufe 5
        ///
        /// Gefahrenstufe 5 (m3/s)
        pub gefahrenstufe_5: Option<String>,
        /// Grenze 1
        ///
        /// Obergrenze der Gefahrenstufe 1
        pub wl1: Option<i64>,
        /// Grenze 2
        ///
        /// Obergrenze der Gefahrenstufe 2
        pub wl2: Option<i64>,
        /// Grenze 3
        ///
        /// Obergrenze der Gefahrenstufe 3
        pub wl3: Option<i64>,
        /// Grenze 4
        ///
        /// Obergrenze der Gefahrenstufe 4
        pub wl4: Option<i64>,
        /// Link
        pub link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        StationId,
        StationName,
        Gefahrenstufe1,
        Gefahrenstufe2,
        Gefahrenstufe3,
        Gefahrenstufe4,
        Gefahrenstufe5,
        Wl1,
        Wl2,
        Wl3,
        Wl4,
        Link,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::StationName => "station_name",
                Field::Gefahrenstufe1 => "gefahrenstufe_1",
                Field::Gefahrenstufe2 => "gefahrenstufe_2",
                Field::Gefahrenstufe3 => "gefahrenstufe_3",
                Field::Gefahrenstufe4 => "gefahrenstufe_4",
                Field::Gefahrenstufe5 => "gefahrenstufe_5",
                Field::Wl1 => "wl1",
                Field::Wl2 => "wl2",
                Field::Wl3 => "wl3",
                Field::Wl4 => "wl4",
                Field::Link => "link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100244/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Bürgergemeinderatswahlen 2023 auf Listenebene
pub mod resultate_der_buergergemeinderatswahlen_2023_auf_listenebene {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze Wahlkreis
        ///
        /// Anzahl Sitze, die für einen Wahlkreis zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aller Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<String>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Kandidatenstimmen
        ///
        /// Anzahl Stimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub kandidatenstimmen: Option<i64>,
        /// Zusatzstimmen
        ///
        /// Anzahl Zusatzstimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub zusatzstimmen: Option<String>,
        /// Parteistimmen
        ///
        /// Anzahl Stimmen total für einer Liste
        pub parteistimmen: Option<i64>,
        /// Anteil an Summe in %
        ///
        /// Prozentsatz des Anteils an der Summe der Stimmen für eine Liste
        pub anteil_an_summe_in: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        UngestempelteWahlzettel,
        ListenNr,
        Kandidatenstimmen,
        Zusatzstimmen,
        Parteistimmen,
        AnteilAnSummeIn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::ListenNr => "listen_nr",
                Field::Kandidatenstimmen => "kandidatenstimmen",
                Field::Zusatzstimmen => "zusatzstimmen",
                Field::Parteistimmen => "parteistimmen",
                Field::AnteilAnSummeIn => "anteil_an_summe_in",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100301/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Impfungen nach Altersgruppe
pub mod coronavirus_covid_19_impfungen_nach_altersgruppe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Impfdatum
        ///
        /// Datum der Impfung
        pub vacc_day: Option<Date>,
        /// Altersgruppe
        pub age_group: Option<String>,
        /// Impftyp
        ///
        /// 1: Erste Impfung; 2: Zweite Impfung einer Person
        pub vacc_count: Option<i64>,
        /// Anzahl
        ///
        /// Anzahl Impfungen pro Tag, Altersgruppe und Impftyp
        pub count: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        VaccDay,
        AgeGroup,
        VaccCount,
        Count,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::VaccDay => "vacc_day",
                Field::AgeGroup => "age_group",
                Field::VaccCount => "vacc_count",
                Field::Count => "count",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100135/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Mitgliedschaften in Gremien
pub mod grosser_rat_mitgliedschaften_in_gremien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kurzname Gremium
        ///
        /// Kurzname des zugehörigen Gremiums
        pub kurzname_gre: Option<String>,
        /// Name Gremium
        ///
        /// Name des zugehörigen Gremiums
        pub name_gre: Option<String>,
        /// Gremientyp
        ///
        /// Typ des Gremiums (Kommission, Fraktion, Parlament)
        pub gremientyp: Option<String>,
        /// ID Gremium
        ///
        /// Individuelle Identifikationsnummer des Gremiums innerhalb der Datenbank des Grossen Rates.
        pub uni_nr_gre: Option<String>,
        /// Gremien data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Gremien". Gefiltert nach aktuellem Gremium.
        pub url_gremium: Option<String>,
        /// Beginn Gremiumsmitgliedschaft
        ///
        /// Startdatum der Mitgliedschaft im Gremium
        pub beginn_mit: Option<Date>,
        /// Ende Gremiumsmitgliedschaft
        ///
        /// Enddatum der Mitgliedschaft im Gremium
        pub ende_mit: Option<Date>,
        /// Funktion
        ///
        /// Funktion des Gremiumsmitglieds
        pub funktion_adr: Option<String>,
        /// Anrede
        ///
        /// Anrede des Gremiumsmitglieds nach amtlichem Geschlecht
        pub anrede: Option<String>,
        /// Name Ratsmitglied
        ///
        /// Nachname des Gremiumsmitglieds
        pub name_adr: Option<String>,
        /// Vorname Ratsmitglied
        ///
        /// Vorname des Gremiumsmitglieds
        pub vorname_adr: Option<String>,
        /// Name, Vorname
        ///
        /// Name und Vorname des Gremiumsmitglieds
        pub name_vorname: Option<String>,
        /// Partei abgekürzt
        ///
        /// Abkürzung der Parteizugehörigkeit des Gremiumsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei_kname: Option<String>,
        /// Ratsmitglied grosserrat.bs.ch
        ///
        /// Link zum Gremiumsmitglied auf der Webseite des Grossen Rates
        pub url_adr: Option<String>,
        /// ID Ratsmitglied
        ///
        /// Individuelle Identifikationsnummer des Gremiumsmitglieds innerhalb der Datenbank des Grossen Rates.
        pub uni_nr_adr: Option<String>,
        /// Grossratsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach aktuellem Gremiumsmitglied.
        pub url_ratsmitgliedschaften: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        KurznameGre,
        NameGre,
        Gremientyp,
        UniNrGre,
        UrlGremium,
        BeginnMit,
        EndeMit,
        FunktionAdr,
        Anrede,
        NameAdr,
        VornameAdr,
        NameVorname,
        ParteiKname,
        UrlAdr,
        UniNrAdr,
        UrlRatsmitgliedschaften,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::KurznameGre => "kurzname_gre",
                Field::NameGre => "name_gre",
                Field::Gremientyp => "gremientyp",
                Field::UniNrGre => "uni_nr_gre",
                Field::UrlGremium => "url_gremium",
                Field::BeginnMit => "beginn_mit",
                Field::EndeMit => "ende_mit",
                Field::FunktionAdr => "funktion_adr",
                Field::Anrede => "anrede",
                Field::NameAdr => "name_adr",
                Field::VornameAdr => "vorname_adr",
                Field::NameVorname => "name_vorname",
                Field::ParteiKname => "partei_kname",
                Field::UrlAdr => "url_adr",
                Field::UniNrAdr => "uni_nr_adr",
                Field::UrlRatsmitgliedschaften => "url_ratsmitgliedschaften",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100308/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Entwicklungszusammenarbeit: Unterstützte Projekte
pub mod entwicklungszusammenarbeit_unterstuetzte_projekte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Das Jahr, in dem das Projekt finanziell unterstützt wird.
        pub jahr: Option<Date>,
        /// Projekt-Titel
        ///
        /// Der Name des geförderten Entwicklungsprojekts.
        pub projekt_titel: Option<String>,
        /// Staat
        ///
        /// Das Land, in dem das Projekt durchgeführt wird.
        pub staat: Option<String>,
        /// Organisation
        ///
        /// Die Hilfsorganisation oder Institution, die das Projekt durchführt und um finanzielle Unterstützung bittet.
        pub organisation: Option<String>,
        /// Betrag-Entscheid
        ///
        /// Der finanzielle Beitrag, der von der Kommission für das Projekt genehmigt wurde.
        pub betrag_entscheid: Option<String>,
        /// Projektbeschrieb
        ///
        /// Eine kurze Zusammenfassung der Ziele und Aktivitäten des Projekts.
        pub projektbeschrieb: Option<String>,
        /// Region
        ///
        /// Die spezifische Region innerhalb des Staates, in der das Projekt stattfindet.
        pub region: Option<String>,
        /// Sachgebiet
        ///
        /// Das Hauptthema oder der Schwerpunkt des Projekts (z.B. medizinische Versorgung, Bildung).
        pub sachgebiet: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        ProjektTitel,
        Staat,
        Organisation,
        BetragEntscheid,
        Projektbeschrieb,
        Region,
        Sachgebiet,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::ProjektTitel => "projekt_titel",
                Field::Staat => "staat",
                Field::Organisation => "organisation",
                Field::BetragEntscheid => "betrag_entscheid",
                Field::Projektbeschrieb => "projektbeschrieb",
                Field::Region => "region",
                Field::Sachgebiet => "sachgebiet",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100380/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Resultate der Wahl eines zusätzl. Strafgerichtspräsidiums 18. August 2024
pub mod resultate_der_wahl_eines_zusaetzl_strafgerichtspraesidiums_18_august_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1). Für zweiten Wahlgang nicht vorhanden.
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100381/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Positiv getestete Personen nach Alter und Geschlecht
pub mod coronavirus_covid_19_positiv_getestete_personen_nach_alter_und_geschlecht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Testresultat
        ///
        /// Datum, an dem das Testresultat vorlag
        pub test_datum: Option<Date>,
        /// Altersklasse
        ///
        /// 10-Jahresklassen, wobei die letzte Altersklasse gegen oben offen ist
        pub pers_alter: Option<String>,
        /// Geschlecht
        ///
        /// F = weiblich, M = männlich
        pub geschlecht: Option<String>,
        /// Anzahl Personen
        ///
        /// Anzahl Personen in der jeweilige Subgruppe
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TestDatum,
        PersAlter,
        Geschlecht,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TestDatum => "test_datum",
                Field::PersAlter => "pers_alter",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100105/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geschwindigkeitsmonitoring: Kennzahlen pro Mess-Standort
pub mod geschwindigkeitsmonitoring_kennzahlen_pro_mess_standort {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub id: Option<i64>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        pub messende: Option<Date>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<i64>,
        /// Richtung 1
        ///
        /// Fahrtrichtung 1
        pub richtung_1: Option<String>,
        /// Fahrzeuge Richtung 1
        ///
        /// Anzahl gemessene Fahrzeuge in Richtung 1 während einer Messung
        pub fzg_1: Option<f64>,
        /// V50 Richtung 1
        ///
        /// Höchstgeschwindigkeit in Richtung 1, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50_1: Option<f64>,
        /// V85 Richtung 1
        ///
        /// Höchstgeschwindigkeit in Richtung 1, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85_1: Option<f64>,
        /// Übertretungsquote Richtung 1
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit in Richtung 1 überschritten haben
        pub ue_quote_1: Option<f64>,
        /// Richtung 2
        ///
        /// Fahrtrichtung 2
        pub richtung_2: Option<String>,
        /// Fahrzeuge Richtung 2
        ///
        /// Anzahl gemessene Fahrzeuge in Richtung 2 während einer Messung
        pub fzg_2: Option<f64>,
        /// V50 Richtung 2
        ///
        /// Höchstgeschwindigkeit in Richtung 2, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50_2: Option<f64>,
        /// V85 Richtung 2
        ///
        /// Höchstgeschwindigkeit in Richtung 1, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85_2: Option<f64>,
        /// Übertretungsquote Richtung 2
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit in Richtung 2 überschritten haben
        pub ue_quote_2: Option<f64>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Einzelmessungen
        ///
        /// Link zum Datensatz "Geschwindigkeitsmonitoring: Einzelmessungen"
        pub link_zu_einzelmessungen: Option<String>,
        /// Messbeginn Jahr
        ///
        /// Jahr des Messbeginns
        pub messbeginn_jahr: Option<String>,
        /// Einzelmessungen Datensatz ID
        ///
        /// Datensatz ID, in welchem die Einzelmessungen abgelegt sind
        pub dataset_id: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Messbeginn,
        Messende,
        Strasse,
        StrasseNr,
        Ort,
        Zone,
        Richtung1,
        Fzg1,
        V501,
        V851,
        UeQuote1,
        Richtung2,
        Fzg2,
        V502,
        V852,
        UeQuote2,
        LinkZuEinzelmessungen,
        MessbeginnJahr,
        DatasetId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Ort => "ort",
                Field::Zone => "zone",
                Field::Richtung1 => "richtung_1",
                Field::Fzg1 => "fzg_1",
                Field::V501 => "v50_1",
                Field::V851 => "v85_1",
                Field::UeQuote1 => "ue_quote_1",
                Field::Richtung2 => "richtung_2",
                Field::Fzg2 => "fzg_2",
                Field::V502 => "v50_2",
                Field::V852 => "v85_2",
                Field::UeQuote2 => "ue_quote_2",
                Field::LinkZuEinzelmessungen => "link_zu_einzelmessungen",
                Field::MessbeginnJahr => "messbeginn_jahr",
                Field::DatasetId => "dataset_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100112/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Witterung
pub mod witterung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Monat und Jahr
        ///
        /// Monat und Jahr, in dem der Wert registriert wurde
        pub datum: Option<Date>,
        /// Jahr
        ///
        /// Jahreszahl
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monatsname
        pub monat: Option<String>,
        /// Frosttag
        ///
        /// Anzahl Tage mit Minimaltemperatur unter 0° Celsius
        pub frosttag: Option<i64>,
        /// Eistag
        ///
        /// Anzahl Tage mit Maximaltemperatur unter 0° Celsius
        pub eistag: Option<i64>,
        /// Sommertag
        ///
        /// Anzahl Tage mit Maximaltemperatur über 25° Celsius
        pub sommertag: Option<i64>,
        /// Hitzetag
        ///
        /// Anzahl Tage mit Maximaltemperatur über 30° Celsius
        pub hitzetag: Option<i64>,
        /// Ohne Sonne
        ///
        /// Anzahl Tage mit 0 Sonnenstunden
        pub sonnenlos: Option<i64>,
        /// Regen (0,1 mm)
        ///
        /// Anzahl Tage mit mindestens 0,1 mm Niederschlag
        pub regen1: Option<i64>,
        /// Regen (0,3 mm)
        ///
        /// Anzahl Tage mit mindestens 0,3 mm Niederschlag
        pub regen2: Option<i64>,
        /// Regen (1,0 mm)
        ///
        /// Anzahl Tage mit mindestens 1,0 mm Niederschlag
        pub regen3: Option<i64>,
        /// Schneefall
        ///
        /// Anzahl Tage mit Schneefall
        pub schneefall: Option<i64>,
        /// Schneedecke
        ///
        /// Anzahl Tage mit geschlossener Schneedecke
        pub schneedecke: Option<i64>,
        /// Reif
        ///
        /// Anzahl Tage mit Reif
        pub reif: Option<i64>,
        /// Nebel
        ///
        /// Anzahl Tage mit Nebel
        pub nebel: Option<i64>,
        /// Gewitter
        ///
        /// Anzahl Tage mit Nah- oder Ferngewitter
        pub gewitter1: Option<i64>,
        /// Nahgewitter
        ///
        /// Anzahl Tage mit Nahgewitter (<15 km Entfernung)
        pub gewitter2: Option<f64>,
        /// Hagel
        ///
        /// Anzahl Tage mit Hagel
        pub hagel: Option<i64>,
        /// Heller Tag
        ///
        /// Anzahl Tage mit höchstens 20% Bewölkung
        pub hell: Option<i64>,
        /// Trüber Tag
        ///
        /// Anzahl Tage mit mindestens 80% Bewölkung
        pub trueb: Option<i64>,
        /// Wind (> 15 m/sec)
        ///
        /// Anzahl Tage mit Windgeschwindigkeiten über 15 m/sec
        pub wind1: Option<i64>,
        /// Wind (> 26 m/sec)
        ///
        /// Anzahl Tage mit Windgeschwindigkeiten über 26 m/sec
        pub wind2: Option<i64>,
        /// Heiztage
        ///
        /// Anzahl Tage, an denen die Heizgrenze von 12 °C unterschritten wird.
        pub heiztage: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Jahr,
        Monat,
        Frosttag,
        Eistag,
        Sommertag,
        Hitzetag,
        Sonnenlos,
        Regen1,
        Regen2,
        Regen3,
        Schneefall,
        Schneedecke,
        Reif,
        Nebel,
        Gewitter1,
        Gewitter2,
        Hagel,
        Hell,
        Trueb,
        Wind1,
        Wind2,
        Heiztage,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Frosttag => "frosttag",
                Field::Eistag => "eistag",
                Field::Sommertag => "sommertag",
                Field::Hitzetag => "hitzetag",
                Field::Sonnenlos => "sonnenlos",
                Field::Regen1 => "regen1",
                Field::Regen2 => "regen2",
                Field::Regen3 => "regen3",
                Field::Schneefall => "schneefall",
                Field::Schneedecke => "schneedecke",
                Field::Reif => "reif",
                Field::Nebel => "nebel",
                Field::Gewitter1 => "gewitter1",
                Field::Gewitter2 => "gewitter2",
                Field::Hagel => "hagel",
                Field::Hell => "hell",
                Field::Trueb => "trueb",
                Field::Wind1 => "wind1",
                Field::Wind2 => "wind2",
                Field::Heiztage => "heiztage",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100227/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Aufrufe der Microsites
pub mod smarte_strasse_aufrufe_der_microsites {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Identifikationsnummer
        ///
        /// Willkürliche Identifikationsnummer
        pub id: Option<i64>,
        /// Zeitstempel
        ///
        /// Gibt das Datum der Datenaufzeichnung an.
        pub timestamp: Option<Date>,
        /// Dataset-ID
        ///
        /// Link zu den Daten, die auf der Microsite abgebildet werden.
        pub dataset_id: Option<String>,
        /// API-Suchanfrage
        ///
        /// Abfrage zum Suchen nach den Daten auf der Microsite. Wenn die Microsite aufgerufen wird, dann werden die Daten aus dem Datensatz auf der Microsite abgebildet. Es entsteht eine Datenabfrage. Die Anzahl an Datenabfragen kann man messen.
        pub api: Option<String>,
        /// Anzahl Anfragen
        ///
        /// Anzahl der Suchanfragen auf der Microsite.
        pub nhits: Option<i64>,
        /// Sensor
        pub sensor: Option<String>,
        /// Microsite
        ///
        /// Link zu der Microsite
        pub microsite: Option<String>,
        /// Geo Point des Sensors
        pub geo_point: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Timestamp,
        DatasetId,
        Api,
        Nhits,
        Sensor,
        Microsite,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Timestamp => "timestamp",
                Field::DatasetId => "dataset_id",
                Field::Api => "api",
                Field::Nhits => "nhits",
                Field::Sensor => "sensor",
                Field::Microsite => "microsite",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100306/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geschwindigkeitsmonitoring: Einzelmessungen bis 2020
pub mod geschwindigkeitsmonitoring_einzelmessungen_bis_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Timestamp
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit in km/h
        pub geschwindigkeit: Option<f64>,
        /// Zeit
        ///
        /// Uhrzeit (hh:mm:ss) einer gemessenen Fahrt
        pub zeit: Option<String>,
        /// Datum
        pub datum: Option<String>,
        /// Datum und Zeit
        ///
        /// Datum und Uhrzeit als Text formatiert
        pub datum_zeit: Option<String>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        pub messende: Option<Date>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<f64>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Übertretungsquote
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit überschritten haben
        pub ue_quote: Option<f64>,
        /// Geschwindigkeit V50
        ///
        /// Höchstgeschwindigkeit, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50: Option<f64>,
        /// Geschwindigkeit V85
        ///
        /// Höchstgeschwindigkeit, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85: Option<f64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge während einer Messung
        pub fzg: Option<i64>,
        /// Fahrzeuglänge
        ///
        /// Vom Radar gemessene Fahrzeuglänge
        pub fahrzeuglange: Option<f64>,
        /// Kennzahlen pro Mess-Standort
        ///
        /// Link zum nach der aktuellen Messung gefilterten Datensatz "Kennzahlen pro Mess-Standort"
        pub link_zu_messung: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        MessungId,
        RichtungId,
        Geschwindigkeit,
        Zeit,
        Datum,
        DatumZeit,
        Messbeginn,
        Messende,
        Zone,
        Ort,
        Richtung,
        UeQuote,
        V50,
        V85,
        Strasse,
        StrasseNr,
        Fzg,
        Fahrzeuglange,
        LinkZuMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::MessungId => "messung_id",
                Field::RichtungId => "richtung_id",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Zeit => "zeit",
                Field::Datum => "datum",
                Field::DatumZeit => "datum_zeit",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Zone => "zone",
                Field::Ort => "ort",
                Field::Richtung => "richtung",
                Field::UeQuote => "ue_quote",
                Field::V50 => "v50",
                Field::V85 => "v85",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Fzg => "fzg",
                Field::Fahrzeuglange => "fahrzeuglange",
                Field::LinkZuMessung => "link_zu_messung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100200/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Fahrgastzahlen BVB
pub mod fahrgastzahlen_bvb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Startdatum Kalenderwoche/Monat
        ///
        /// Das Attribut 'Startdatum Kalenderwoche/Monat' gibt den Anfang des Zeitraums an, für den die Fahrgastzahlen erfasst wurden, entweder den ersten Tag der Woche oder den ersten Tag des Monats entsprechend der Granularität.
        pub startdatum_kalenderwoche_monat: Option<Date>,
        /// Fahrgäste (Einsteiger)
        ///
        /// Anzahl Fahrgäste, welche in einer Woche ein Verkehrsmittel der BVB genutzt haben.
        pub fahrgaeste_einsteiger: Option<i64>,
        /// Kalenderwoche
        pub kalenderwoche: Option<i64>,
        /// Granularität
        ///
        /// Das Attribut 'Granularität' bestimmt, ob die Fahrgastdaten auf wöchentlicher oder monatlicher Basis erfasst wurden, um die zeitliche Detailgenauigkeit der Daten zu definieren.
        pub granularitat: Option<String>,
        /// Datum der Monatswerte
        pub datum_der_monatswerte: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        StartdatumKalenderwocheMonat,
        FahrgaesteEinsteiger,
        Kalenderwoche,
        Granularitat,
        DatumDerMonatswerte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StartdatumKalenderwocheMonat => "startdatum_kalenderwoche_monat",
                Field::FahrgaesteEinsteiger => "fahrgaeste_einsteiger",
                Field::Kalenderwoche => "kalenderwoche",
                Field::Granularitat => "granularitat",
                Field::DatumDerMonatswerte => "datum_der_monatswerte",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100075/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bevölkerungsszenarien Basel-Stadt 2024-2045
pub mod bevoelkerungsszenarien_basel_stadt_2024_2045 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Alter
        ///
        /// Für das Jahr 2019 Alter 0= Geburtsjahrgang 2019, usw.
        pub alter: Option<i64>,
        /// Wahlkreis
        ///
        /// Die Stadt Basel hat 3 Wahlkreise, die Landgemeinden bilden eigene Wahlkreise
        pub geo: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht (Mann oder Frau)
        pub geschlecht: Option<String>,
        /// Herkunft
        ///
        /// Schweiz oder Ausland; Doppelbürger unter Schweiz erfasst
        pub herkunft: Option<String>,
        /// Jahr
        ///
        /// Datenjahr
        pub jahr: Option<String>,
        /// Einwohnerzahl
        ///
        /// Anzahl Personen im angegebenen Datenjahr
        pub bestand_hist: Option<i64>,
        /// Einwohnerzahl hoch
        ///
        /// Anzahl Personen im hohen Szenario
        pub bestand_hoch: Option<f64>,
        /// Einwohnerzahl  mittel
        ///
        /// Anzahl Personen im mittleren Szenario
        pub bestand_mittel: Option<f64>,
        /// Einwohnerzahl tief
        ///
        /// Anzahl Personen im tiefen Szenario
        pub bestand_tief: Option<f64>,
        /// Geburtenzahl
        ///
        /// Anzahl Geburten im angegebenen Datenjahr
        pub geb_hist: Option<i64>,
        /// Geburtenzahl hoch
        ///
        /// Anzahl Geburten im hohen Szenario
        pub geb_hoch: Option<f64>,
        /// Geburtenzahl mittel
        ///
        /// Anzahl Geburten im mittleren Szenario
        pub geb_mittel: Option<f64>,
        /// Geburtenzahl tief
        ///
        /// Anzahl Geburten im tiefen Szenario
        pub geb_tief: Option<f64>,
        /// Todesfaelle
        ///
        /// Anzahl Gestorbene im angegebenen Datenjahr
        pub tod_hist: Option<i64>,
        /// Todesfalle hoch
        ///
        /// Anzahl Gestorbene im hohen Szenario
        pub tod_hoch: Option<f64>,
        /// Todesfaelle mittel
        ///
        /// Anzahl Gestorbene im mittleren Szenario
        pub tod_mittel: Option<f64>,
        /// Todesfaelle tief
        ///
        /// Anzahl Gestorbene im tiefen Szenario
        pub tod_tief: Option<f64>,
        /// Saldo
        ///
        /// Differenz
        pub s_geb_tod_hist: Option<i64>,
        /// Geburtensaldo hoch
        ///
        /// Geburtensaldo hohes Szenario
        pub s_geb_tod_hoch: Option<f64>,
        /// Geburtensaldo mittel
        ///
        /// Geburtensaldo mittleres Szenario
        pub s_geb_tod_mittel: Option<f64>,
        /// Geburtensaldo tief
        ///
        /// Geburtensaldo tiefes Szenario
        pub s_geb_tod_tief: Option<f64>,
        /// Zuzüge
        ///
        /// Zuzüge interkantonal historisch
        pub zuz_hist: Option<i64>,
        /// Zuzüge hoch
        ///
        /// Zuzüge interkantonal hohes Szenario
        pub zuz_hoch: Option<f64>,
        /// Zuzüge mittel
        ///
        /// Zuzüge interkantonal mittleres Szenario
        pub zuz_mittel: Option<f64>,
        /// Zuzüge tief
        ///
        /// Zuzüge interkantonal tiefes Szenario
        pub zuz_tief: Option<f64>,
        /// Wegzüge
        ///
        /// Wegzüge interkantonal historisch
        pub wegz_hist: Option<i64>,
        /// Wegzüge hoch
        ///
        /// Wegzüge interkantonal hohes Szenario
        pub wegz_hoch: Option<f64>,
        /// Wegzüge mittel
        ///
        /// Wegzüge interkantonal mittleres Szenario
        pub wegz_mittel: Option<f64>,
        /// Wegzüge tief
        ///
        /// Wegzüge interkantonal tiefes Szenario
        pub wegz_tief: Option<f64>,
        /// Saldo Umzüge national
        ///
        /// Saldo interkantonale Wanderung historisch
        pub s_ink_hist: Option<i64>,
        /// Saldo Umzüge national hoch
        ///
        /// Saldo interkantonale Wanderung hohes Szenario
        pub s_ink_hoch: Option<f64>,
        /// Saldo Umzüge national mittel
        ///
        /// Saldo interkantonale Wanderung mittleres Szenario
        pub s_ink_mittel: Option<f64>,
        /// Saldo Umzüge national tief
        ///
        /// Saldo interkantonale Wanderung tiefes Szenario
        pub s_ink_tief: Option<f64>,
        /// Einwanderung
        ///
        /// Einwanderung international historisch
        pub einw_hist: Option<i64>,
        /// Einwanderung hoch
        ///
        /// Einwanderung international hohes Szenario
        pub einw_hoch: Option<f64>,
        /// Einwanderung  mittel
        ///
        /// Einwanderung international mittleres Szenario
        pub einw_mittel: Option<f64>,
        /// Einwanderung tief
        ///
        /// Einwanderung international tiefes Szenario
        pub einw_tief: Option<f64>,
        /// Auswanderung
        ///
        /// Auswanderung international historisch
        pub ausw_hist: Option<i64>,
        /// Auswanderung hoch
        ///
        /// Auswanderung international hohes Szenario
        pub ausw_hoch: Option<f64>,
        /// Auswanderung mittel
        ///
        /// Auswanderung international mittleres Szenario
        pub ausw_mittel: Option<f64>,
        /// Auswanderung tief
        ///
        /// Auswanderung international tiefes Szenario
        pub ausw_tief: Option<f64>,
        /// Saldo Umzüge international
        ///
        /// Saldo internationale Wanderung historisch
        pub s_int_hist: Option<i64>,
        /// Saldo Umzüge international hoch
        ///
        /// Saldo internationale Wanderung hohes Szenario
        pub s_int_hoch: Option<f64>,
        /// Saldo Umzüge international mittel
        ///
        /// Saldo internationale Wanderung mittleres Szenario
        pub s_int_mittel: Option<f64>,
        /// Saldo Umzüge international tief
        ///
        /// Saldo internationale Wanderung tiefes Szenario
        pub s_int_tief: Option<f64>,
        /// Umzüge total
        ///
        /// Saldo Wanderung total historisch
        pub s_wtotal_hist: Option<i64>,
        /// Umzüge total hoch
        ///
        /// Saldo Wanderung total hohes Szenario
        pub s_wtotal_hoch: Option<f64>,
        /// Umzüge total mittel
        ///
        /// Saldo Wanderung total mittleres Szenario
        pub s_wtotal_mittel: Option<f64>,
        /// Umzüge total tief
        ///
        /// Saldo Wanderung total tiefes Szenario
        pub s_wtotal_tief: Option<f64>,
        /// Kantonale Zuzüge
        ///
        /// Umzüge intrakantonal hin historisch
        pub uhin_hist: Option<i64>,
        /// Kantonale Zuzüge hoch
        ///
        /// Umzüge intrakantonal hin hohes Szenario
        pub uhin_hoch: Option<f64>,
        /// Kantonale Zuzüge mittel
        ///
        /// Umzüge intrakantonal hin mittleres Szenario
        pub uhin_mittel: Option<f64>,
        /// Kantonale Zuzüge tief
        ///
        /// Umzüge intrakantonal hin tiefes Szenario
        pub uhin_tief: Option<f64>,
        /// Kantonale Wegzüge
        ///
        /// Umzüge intrakantonal weg historisch
        pub uweg_hist: Option<i64>,
        /// Kantonale Wegzüge hoch
        ///
        /// Umzüge intrakantonal weg hohes Szenario
        pub uweg_hoch: Option<f64>,
        /// Kantonale Wegzüge mittel
        ///
        /// Umzüge intrakantonal weg mittleres Szenario
        pub uweg_mittel: Option<f64>,
        /// Kantonale Wegzüge tief
        ///
        /// Umzüge intrakantonal weg tiefes Szenario
        pub uweg_tief: Option<f64>,
        /// Saldo kantonale Umzüge
        ///
        /// Saldo Umzüge intrakantonal historisch
        pub s_umz_hist: Option<i64>,
        /// Saldo kantonale Umzüge hoch
        ///
        /// Saldo Umzüge intrakantonal hohes Szenario
        pub s_umz_hoch: Option<f64>,
        /// Saldo kantonale Umzüge mittel
        ///
        /// Saldo Umzüge intrakantonal mittleres Szenario
        pub s_umz_mittel: Option<f64>,
        /// Saldo kantonale Umzüge tief
        ///
        /// Saldo Umzüge intrakantonal tiefes Szenario
        pub s_umz_tief: Option<f64>,
        /// Einbürgerungen
        ///
        /// Einbürgerungen historisch
        pub einb_hist: Option<i64>,
        /// Einbürgerungen hoch
        ///
        /// Einbürgerungen hohes Szenario
        pub einb_hoch: Option<f64>,
        /// Einbürgerungen mittel
        ///
        /// Einbürgerungen mittleres Szenario
        pub einb_mittel: Option<f64>,
        /// Einbürgerungen tief
        ///
        /// Einbürgerungen tiefes Szenario
        pub einb_tief: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Alter,
        Geo,
        Geschlecht,
        Herkunft,
        Jahr,
        BestandHist,
        BestandHoch,
        BestandMittel,
        BestandTief,
        GebHist,
        GebHoch,
        GebMittel,
        GebTief,
        TodHist,
        TodHoch,
        TodMittel,
        TodTief,
        SGebTodHist,
        SGebTodHoch,
        SGebTodMittel,
        SGebTodTief,
        ZuzHist,
        ZuzHoch,
        ZuzMittel,
        ZuzTief,
        WegzHist,
        WegzHoch,
        WegzMittel,
        WegzTief,
        SInkHist,
        SInkHoch,
        SInkMittel,
        SInkTief,
        EinwHist,
        EinwHoch,
        EinwMittel,
        EinwTief,
        AuswHist,
        AuswHoch,
        AuswMittel,
        AuswTief,
        SIntHist,
        SIntHoch,
        SIntMittel,
        SIntTief,
        SWtotalHist,
        SWtotalHoch,
        SWtotalMittel,
        SWtotalTief,
        UhinHist,
        UhinHoch,
        UhinMittel,
        UhinTief,
        UwegHist,
        UwegHoch,
        UwegMittel,
        UwegTief,
        SUmzHist,
        SUmzHoch,
        SUmzMittel,
        SUmzTief,
        EinbHist,
        EinbHoch,
        EinbMittel,
        EinbTief,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Alter => "alter",
                Field::Geo => "geo",
                Field::Geschlecht => "geschlecht",
                Field::Herkunft => "herkunft",
                Field::Jahr => "jahr",
                Field::BestandHist => "bestand_hist",
                Field::BestandHoch => "bestand_hoch",
                Field::BestandMittel => "bestand_mittel",
                Field::BestandTief => "bestand_tief",
                Field::GebHist => "geb_hist",
                Field::GebHoch => "geb_hoch",
                Field::GebMittel => "geb_mittel",
                Field::GebTief => "geb_tief",
                Field::TodHist => "tod_hist",
                Field::TodHoch => "tod_hoch",
                Field::TodMittel => "tod_mittel",
                Field::TodTief => "tod_tief",
                Field::SGebTodHist => "s_geb_tod_hist",
                Field::SGebTodHoch => "s_geb_tod_hoch",
                Field::SGebTodMittel => "s_geb_tod_mittel",
                Field::SGebTodTief => "s_geb_tod_tief",
                Field::ZuzHist => "zuz_hist",
                Field::ZuzHoch => "zuz_hoch",
                Field::ZuzMittel => "zuz_mittel",
                Field::ZuzTief => "zuz_tief",
                Field::WegzHist => "wegz_hist",
                Field::WegzHoch => "wegz_hoch",
                Field::WegzMittel => "wegz_mittel",
                Field::WegzTief => "wegz_tief",
                Field::SInkHist => "s_ink_hist",
                Field::SInkHoch => "s_ink_hoch",
                Field::SInkMittel => "s_ink_mittel",
                Field::SInkTief => "s_ink_tief",
                Field::EinwHist => "einw_hist",
                Field::EinwHoch => "einw_hoch",
                Field::EinwMittel => "einw_mittel",
                Field::EinwTief => "einw_tief",
                Field::AuswHist => "ausw_hist",
                Field::AuswHoch => "ausw_hoch",
                Field::AuswMittel => "ausw_mittel",
                Field::AuswTief => "ausw_tief",
                Field::SIntHist => "s_int_hist",
                Field::SIntHoch => "s_int_hoch",
                Field::SIntMittel => "s_int_mittel",
                Field::SIntTief => "s_int_tief",
                Field::SWtotalHist => "s_wtotal_hist",
                Field::SWtotalHoch => "s_wtotal_hoch",
                Field::SWtotalMittel => "s_wtotal_mittel",
                Field::SWtotalTief => "s_wtotal_tief",
                Field::UhinHist => "uhin_hist",
                Field::UhinHoch => "uhin_hoch",
                Field::UhinMittel => "uhin_mittel",
                Field::UhinTief => "uhin_tief",
                Field::UwegHist => "uweg_hist",
                Field::UwegHoch => "uweg_hoch",
                Field::UwegMittel => "uweg_mittel",
                Field::UwegTief => "uweg_tief",
                Field::SUmzHist => "s_umz_hist",
                Field::SUmzHoch => "s_umz_hoch",
                Field::SUmzMittel => "s_umz_mittel",
                Field::SUmzTief => "s_umz_tief",
                Field::EinbHist => "einb_hist",
                Field::EinbHoch => "einb_hoch",
                Field::EinbMittel => "einb_mittel",
                Field::EinbTief => "einb_tief",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100007/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geborene nach Geschlecht, Staatsangehörigkeit, Wohnviertel und Geburtsdatum
pub mod geborene_nach_geschlecht_staatsangehoerigkeit_wohnviertel_und_geburtsdatum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geburtsdatum
        ///
        /// Tag der Geburt
        pub geburts_datum: Option<Date>,
        /// Jahr
        ///
        /// Geburtsjahr
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Geburtsmonat
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Laufnummer der Woche im Jahr
        pub woche_in_jahr: Option<i64>,
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Geburtswoche
        pub datum_wochenstart_geburtsdatum: Option<Date>,
        /// Tag in Jahr
        ///
        /// Laufnummer des Tages im Jahr
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Geschlecht
        ///
        /// M=männlich, W=weiblich
        pub geschlecht: Option<String>,
        /// Anzahl Kinder
        ///
        /// Anzahl Kinder, welche zusammen geboren wurden (Mehrlingsgeburten)
        pub anzahl_kinder: Option<i64>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit des Neugeborenen (Schweiz/Ausland)
        pub nationalitaet: Option<String>,
        /// Wohnviertel
        pub wohnviertel_name: Option<String>,
        /// Laufnummer
        pub id: Option<String>,
        /// Wohnviertel ID
        pub wohnviertel_id: Option<i64>,
        /// Value_gender_BFS
        pub value_gender_bfs: Option<i64>,
        /// Name_gender_BFS
        pub name_gender_bfs: Option<String>,
        /// Value_citizenship_BFS
        pub value_citizenship_bfs: Option<i64>,
        /// Name_citizenship_BFS
        pub name_citizenship_bfs: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GeburtsDatum,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartGeburtsdatum,
        TagInJahr,
        Wochentag,
        Geschlecht,
        AnzahlKinder,
        Nationalitaet,
        WohnviertelName,
        Id,
        WohnviertelId,
        ValueGenderBfs,
        NameGenderBfs,
        ValueCitizenshipBfs,
        NameCitizenshipBfs,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GeburtsDatum => "geburts_datum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartGeburtsdatum => "datum_wochenstart_geburtsdatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::Geschlecht => "geschlecht",
                Field::AnzahlKinder => "anzahl_kinder",
                Field::Nationalitaet => "nationalitaet",
                Field::WohnviertelName => "wohnviertel_name",
                Field::Id => "id",
                Field::WohnviertelId => "wohnviertel_id",
                Field::ValueGenderBfs => "value_gender_bfs",
                Field::NameGenderBfs => "name_gender_bfs",
                Field::ValueCitizenshipBfs => "value_citizenship_bfs",
                Field::NameCitizenshipBfs => "name_citizenship_bfs",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100092/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnungen (Gebäude- und Wohnungsregister GWR)
pub mod wohnungen_gebaeude_und_wohnungsregister_gwr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// EGID
        ///
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<i64>,
        /// EWID
        ///
        /// Eidgenössischer Wohnungsidentifikator
        pub ewid: Option<i64>,
        /// EDID
        ///
        /// Eidgenössischer Eingangsidentifikator
        pub edid: Option<i64>,
        /// AWN
        ///
        /// Administrative Wohnungsnummer
        pub whgnr: Option<i64>,
        /// Physische Wohnungsnummer
        pub weinr: Option<String>,
        /// Stockwerk Code
        pub wstwk: Option<i64>,
        /// Stockwerk Bezeichnung
        pub wstwk_decoded: Option<String>,
        /// Lage auf dem Stockwerk
        pub wbez: Option<String>,
        /// Mehrgeschossige Wohnung Code
        pub wmehrg: Option<i64>,
        /// Mehrgeschossige Wohnung Bezeichnung
        pub wmehrg_decoded: Option<String>,
        /// Baujahr der Wohnung
        pub wbauj: Option<String>,
        /// Abbruchjahr der Wohnung
        pub wabbj: Option<String>,
        /// Wohnungsstatus Code
        pub wstat: Option<i64>,
        /// Wohnungsstatus Bezeichnung
        pub wstat_decoded: Option<String>,
        /// Wohnungsfläche (in m2)
        pub warea: Option<i64>,
        /// Anzahl Zimmer
        pub wazim: Option<i64>,
        /// Kocheinrichtung Code
        pub wkche: Option<i64>,
        /// Kocheinrichtung Bezeichnung
        pub wkche_decoded: Option<String>,
        /// Exportdatum
        pub wexpdat: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Egid,
        Ewid,
        Edid,
        Whgnr,
        Weinr,
        Wstwk,
        WstwkDecoded,
        Wbez,
        Wmehrg,
        WmehrgDecoded,
        Wbauj,
        Wabbj,
        Wstat,
        WstatDecoded,
        Warea,
        Wazim,
        Wkche,
        WkcheDecoded,
        Wexpdat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Ewid => "ewid",
                Field::Edid => "edid",
                Field::Whgnr => "whgnr",
                Field::Weinr => "weinr",
                Field::Wstwk => "wstwk",
                Field::WstwkDecoded => "wstwk_decoded",
                Field::Wbez => "wbez",
                Field::Wmehrg => "wmehrg",
                Field::WmehrgDecoded => "wmehrg_decoded",
                Field::Wbauj => "wbauj",
                Field::Wabbj => "wabbj",
                Field::Wstat => "wstat",
                Field::WstatDecoded => "wstat_decoded",
                Field::Warea => "warea",
                Field::Wazim => "wazim",
                Field::Wkche => "wkche",
                Field::WkcheDecoded => "wkche_decoded",
                Field::Wexpdat => "wexpdat",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100232/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Statistiken der Smiley-Geschwindigkeitsanzeigen
pub mod statistiken_der_smiley_geschwindigkeitsanzeigen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zyklus
        ///
        /// Messzyklus (1, 2 oder 3)
        pub zyklus: Option<i64>,
        /// Phase
        ///
        /// Phase der Messung (Vormessung, Betrieb, Nachmessung oder Gesamt)
        pub phase: Option<String>,
        /// ID Standort
        ///
        /// Eindeutige Standortkennung
        pub idstandort: Option<i64>,
        /// Strassenname
        pub strassenname: Option<String>,
        /// Start Phase
        ///
        /// Beginn der jeweiligen Phase
        #[serde(with = "time::serde::iso8601::option")]
        pub messbeginn_phase: Option<OffsetDateTime>,
        /// Median-Tempo
        ///
        /// Geschwindigkeit, bei welcher die Hälfte der Fahrzeuge schneller und die andere Hälfte langsamer fährt.
        pub v_50: Option<f64>,
        /// Tempo-85%
        ///
        /// Geschwindigkeitswert, unter dem 85% der Fahrzeuge fahren. Dieser wird oft genutzt zur Bestimmung von Sicherheitsgrenzen.
        pub v_85: Option<f64>,
        /// Tempolimit
        ///
        /// Maximale erlaubte Geschwindigkeit
        pub geschwindigkeit: Option<f64>,
        /// Anzahl Messungen
        ///
        /// Gesamtanzahl der durchgeführten Geschwindigkeitsmessungen.
        pub anzahl_messungen: Option<i64>,
        /// Messdauer
        ///
        /// Die Gesamtdauer der Geschwindigkeitsmessung, angegeben in Stunden.
        pub messdauer_h: Option<f64>,
        /// Durchschnittlicher Tagesverkehr
        ///
        /// Durchschnittliche Anzahl Fahrzeuge, die täglich den Messbereich passieren.
        pub dtv: Option<f64>,
        /// Link Einzelmessungen
        ///
        /// URL zu detaillierten Einzeldaten der Geschwindigkeitsmessungen
        pub link_einzelmessungen: Option<String>,
        /// Geopunkt
        ///
        /// Geografische Koordinaten der Smiley-Geschwindigkeitsanzeige
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Zyklus,
        Phase,
        Idstandort,
        Strassenname,
        MessbeginnPhase,
        V50,
        V85,
        Geschwindigkeit,
        AnzahlMessungen,
        MessdauerH,
        Dtv,
        LinkEinzelmessungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zyklus => "zyklus",
                Field::Phase => "phase",
                Field::Idstandort => "idstandort",
                Field::Strassenname => "strassenname",
                Field::MessbeginnPhase => "messbeginn_phase",
                Field::V50 => "v_50",
                Field::V85 => "v_85",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::AnzahlMessungen => "anzahl_messungen",
                Field::MessdauerH => "messdauer_h",
                Field::Dtv => "dtv",
                Field::LinkEinzelmessungen => "link_einzelmessungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100277/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Vorhersagen Birs: Wasserstand und Abfluss
pub mod vorhersagen_birs_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wasserstand
        ///
        /// Pegelstand in Meter über Meer. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub wasserstand: Option<f64>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmeter pro Sekunde. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub abfluss: Option<f64>,
        /// Methode
        ///
        /// Das verwendete Meteo-Modell
        pub methode: Option<String>,
        /// Zeitstempel Ausgabe
        ///
        /// Datum und Uhrzeit der Veröffentlichung
        #[serde(with = "time::serde::iso8601::option")]
        pub ausgegeben_an: Option<OffsetDateTime>,
        /// Zeitstempel Meteolauf
        ///
        /// Datum und Uhrzeit des Meteo-Laufs (der Zeitpunkt, zu dem die meteorologischen Vorhersagen erstellt wurden, die dann als Grundlage für das Modell zur Berechnung der hydrologischen Vorhersagen verwendet wird)
        #[serde(with = "time::serde::iso8601::option")]
        pub meteolauf: Option<OffsetDateTime>,
        /// Zeitstempel Gemessene Werte
        ///
        /// Datum und Uhrzeit, bis zu dem die Werte gemessen wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub gemessene_werten_bis: Option<OffsetDateTime>,
        /// Wasserstand Minimum
        ///
        /// Minimum (0%-Quantil) des Pegelstands in Meter über Meer
        pub h_min: Option<f64>,
        /// Wasserstand 25%-Quantil
        ///
        /// 25%-Quantil des Pegelstands in Meter über Meer
        pub h_p25: Option<f64>,
        /// Wasserstand Median
        ///
        /// Median (50%-Quantil) des Pegelstands in Meter über Meer
        pub h_p50: Option<f64>,
        /// Wasserstand 75%-Quantil
        ///
        /// 75%-Quantil des Pegelstands in Meter über Meer
        pub h_p75: Option<f64>,
        /// Wasserstand Maximum
        ///
        /// Maximum (100%-Quantil) des Pegelstands in Meter über Meer
        pub h_max: Option<f64>,
        /// Abflussmenge Minimum
        ///
        /// Minimum (0%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_min: Option<f64>,
        /// Abflussmenge 25%-Quantil
        ///
        /// 25%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p25: Option<f64>,
        /// Abflussmenge Median
        ///
        /// Median (50%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p50: Option<f64>,
        /// Abflussmenge 75%-Quantil
        ///
        /// 75%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p75: Option<f64>,
        /// Abflussmenge Maximum
        ///
        /// Maximum (100%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_max: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Wasserstand,
        Abfluss,
        Methode,
        AusgegebenAn,
        Meteolauf,
        GemesseneWertenBis,
        HMin,
        HP25,
        HP50,
        HP75,
        HMax,
        QMin,
        QP25,
        QP50,
        QP75,
        QMax,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Wasserstand => "wasserstand",
                Field::Abfluss => "abfluss",
                Field::Methode => "methode",
                Field::AusgegebenAn => "ausgegeben_an",
                Field::Meteolauf => "meteolauf",
                Field::GemesseneWertenBis => "gemessene_werten_bis",
                Field::HMin => "h_min",
                Field::HP25 => "h_p25",
                Field::HP50 => "h_p50",
                Field::HP75 => "h_p75",
                Field::HMax => "h_max",
                Field::QMin => "q_min",
                Field::QP25 => "q_p25",
                Field::QP50 => "q_p50",
                Field::QP75 => "q_p75",
                Field::QMax => "q_max",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100272/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Effektiver und erwarteter täglicher Gasverbrauch
pub mod effektiver_und_erwarteter_taeglicher_gasverbrauch {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub time: Option<Date>,
        /// Gasverbrauch effektiv
        ///
        /// Tägliche Summe des stündlichen Stromverbrauchs
        pub gasverbrauch: Option<f64>,
        /// Gasverbrauch erwartet
        ///
        /// Prognostizierter Wert, abhängig von Kalendertag (z.B. Ferien oder Wochentag) und Witterung
        pub forecast: Option<f64>,
        /// Differenz Gasverbrauch (effektiv - erwartet)
        ///
        /// Differenz Gasverbrauch effektiv abzüglich erwartet
        pub vgl_real_minus_forecast: Option<f64>,
        /// Prognoseintervall tief
        ///
        /// Untere Grenze des 95%-Prognoseintervalls für täglich erwarteten Gasverbrauch
        pub forecast_lowfi: Option<f64>,
        /// Prognoseintervall hoch
        ///
        /// Obere Grenze des 95%-Prognoseintervalls für täglich erwarteten Gasverbrauch
        pub forecast_highfi: Option<f64>,
        /// data split
        ///
        /// Für die Modellevaluierung wurde der Datensatz in drei Teile unterteilt. Der Trainingsdatensatz dient zum Trainieren (Train) des Modells, der Tesdatensatz (Test) zur Bewertung der Modellleistung. Der Prognosedatensatz (Prognose) enthält neue, unbekannte Daten zur Vorhersage durch das mit Training- und Testdaten (Train und Test) trainierte Modell.
        pub traintestorforecast: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Time,
        Gasverbrauch,
        Forecast,
        VglRealMinusForecast,
        ForecastLowfi,
        ForecastHighfi,
        Traintestorforecast,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Time => "time",
                Field::Gasverbrauch => "gasverbrauch",
                Field::Forecast => "forecast",
                Field::VglRealMinusForecast => "vgl_real_minus_forecast",
                Field::ForecastLowfi => "forecast_lowfi",
                Field::ForecastHighfi => "forecast_highfi",
                Field::Traintestorforecast => "traintestorforecast",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100353/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geborene nach Geschlecht, Staatsangehörigkeit und Geburtsmonat
pub mod geborene_nach_geschlecht_staatsangehoerigkeit_und_geburtsmonat {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Geburtsjahr
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Geburtsmonat
        pub monat: Option<i64>,
        /// Geschlecht
        ///
        /// M=männlich, W=weiblich
        pub geschlecht: Option<String>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit des Neugeborenen (Schweiz/Ausland)
        pub nationalitaet: Option<String>,
        /// Alter der Mutter
        ///
        /// Alter der Mutter bei Geburt des Kindes
        pub alter_mutter: Option<i64>,
        /// Alter des Vaters
        ///
        /// Alter des Vaters bei Geburt des Kindes
        pub alter_vater: Option<i64>,
        /// Staatsangehörigkeit der Mutter
        ///
        /// Staatsangehörigkeit der Mutter bei Geburt des Kindes (Schweiz/Ausland)
        pub nationalitaet_mutter: Option<String>,
        /// Staatsangehörigkeit des Vaters
        ///
        /// Staatsangehörigkeit des Vaters bei Geburt des Kindes (Schweiz/Ausland)
        pub nationalitaet_vater: Option<String>,
        /// Verheiratet
        ///
        /// Gibt an, ob die Eltern bei Geburt des Kindes verheiratet waren
        pub verheiratet: Option<String>,
        /// Geburtenfolge
        ///
        /// Anzahl gemeinsame Kinder des Elternpaares (einschl. des Geborenen und allfälliger gemeinsamer Kinder des Ehepaares vor der Eheschliessung); bei unverheirateten Paaren wird der Wert 0 angegeben.
        pub geburtenfolge: Option<i64>,
        /// Laufnummer
        pub id: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        Geschlecht,
        Nationalitaet,
        AlterMutter,
        AlterVater,
        NationalitaetMutter,
        NationalitaetVater,
        Verheiratet,
        Geburtenfolge,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Geschlecht => "geschlecht",
                Field::Nationalitaet => "nationalitaet",
                Field::AlterMutter => "alter_mutter",
                Field::AlterVater => "alter_vater",
                Field::NationalitaetMutter => "nationalitaet_mutter",
                Field::NationalitaetVater => "nationalitaet_vater",
                Field::Verheiratet => "verheiratet",
                Field::Geburtenfolge => "geburtenfolge",
                Field::Id => "id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100099/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Geschlecht, Alter, Staatsangehörigkeit und Wohnviertel
pub mod wohnbevoelkerung_nach_geschlecht_alter_staatsangehoerigkeit_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Jahr
        pub jahr: Option<String>,
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// Wohnviertel-ID
        pub wohnviertel_id: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Geschlecht
        ///
        /// M=Männlich, W=Weiblich
        pub geschlecht: Option<String>,
        /// Alter
        ///
        /// Die Angabe des Alters beruht auf dem Geburtsjahr.
        pub person_alter: Option<i64>,
        /// Staatsangehoerigkeit
        ///
        /// CH=Schweiz, A=Ausland
        pub staatsangehoerigkeit: Option<String>,
        /// Value_gender_BFS
        pub value_gender_bfs: Option<i64>,
        /// Name_gender_BFS
        pub name_gender_bfs: Option<String>,
        /// Value_citizenship_BFS
        pub value_citizenship_bfs: Option<i64>,
        /// Name_citizenship_BFS
        pub name_citizenship_bfs: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Jahr,
        Wohnviertel,
        WohnviertelId,
        Gemeinde,
        Geschlecht,
        PersonAlter,
        Staatsangehoerigkeit,
        ValueGenderBfs,
        NameGenderBfs,
        ValueCitizenshipBfs,
        NameCitizenshipBfs,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Jahr => "jahr",
                Field::Wohnviertel => "wohnviertel",
                Field::WohnviertelId => "wohnviertel_id",
                Field::Gemeinde => "gemeinde",
                Field::Geschlecht => "geschlecht",
                Field::PersonAlter => "person_alter",
                Field::Staatsangehoerigkeit => "staatsangehoerigkeit",
                Field::ValueGenderBfs => "value_gender_bfs",
                Field::NameGenderBfs => "name_gender_bfs",
                Field::ValueCitizenshipBfs => "value_citizenship_bfs",
                Field::NameCitizenshipBfs => "name_citizenship_bfs",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100128/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Geschlecht und Staatsangehörigkeit
pub mod wohnbevoelkerung_nach_geschlecht_und_staatsangehoerigkeit {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Geschlecht
        ///
        /// M=Männlich, W=Weiblich
        pub geschlecht: Option<String>,
        /// Staatsangehoerigkeit
        pub staatsangehoerigkeit: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Gemeinde,
        Geschlecht,
        Staatsangehoerigkeit,
        Anzahl,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Gemeinde => "gemeinde",
                Field::Geschlecht => "geschlecht",
                Field::Staatsangehoerigkeit => "staatsangehoerigkeit",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100126/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonales Leistungsverzeichnis: Gebühren
pub mod kantonales_leistungsverzeichnis_gebuehren {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Departement
        pub departement: Option<String>,
        /// Dienststelle
        pub diensstelle: Option<String>,
        /// Gegenstand der Gebühr
        ///
        /// Gegenstand/Name der Gebühr
        pub gegenstand_der_gebuhr: Option<String>,
        /// Rechtliche Grundlage
        ///
        /// Referenz auf die Rechtsgrundlagen der Gebühr.
        pub rechtliche_grundlage: Option<String>,
        /// Höhe der Gebühr(en) CHF
        ///
        /// Höhe der Einzelgebühr(en) in Franken oder Referenz zu Gebührenkatalog.
        pub hohe_der_gebuhr_en_chf: Option<String>,
        /// Benchmark
        ///
        /// Benchmark, derselben Gebühr in anderen Kantonen
        pub benchmark: Option<String>,
        /// Leistung
        ///
        /// Zugehörige Leistung
        pub leistung: Option<String>,
        /// Weitere Gliederung OE
        ///
        /// Wenn vorhanden, weitere Aufteilung der Organisationseinheit
        pub weiteregliederungoe: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Departement,
        Diensstelle,
        GegenstandDerGebuhr,
        RechtlicheGrundlage,
        HoheDerGebuhrEnChf,
        Benchmark,
        Leistung,
        Weiteregliederungoe,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Departement => "departement",
                Field::Diensstelle => "diensstelle",
                Field::GegenstandDerGebuhr => "gegenstand_der_gebuhr",
                Field::RechtlicheGrundlage => "rechtliche_grundlage",
                Field::HoheDerGebuhrEnChf => "hohe_der_gebuhr_en_chf",
                Field::Benchmark => "benchmark",
                Field::Leistung => "leistung",
                Field::Weiteregliederungoe => "weiteregliederungoe",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100325/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Treppen und Ausstiegsleitern an Gewässern
pub mod treppen_und_ausstiegsleitern_an_gewaessern {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// TYP_BEZ
        ///
        /// Art des Ausstiegs
        pub typ_bez: Option<String>,
        /// Ausstiegsmöglichkeit
        pub ausstieg_moeglich: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TypBez,
        AusstiegMoeglich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TypBez => "typ_bez",
                Field::AusstiegMoeglich => "ausstieg_moeglich",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100285/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Schülerprognose Basel
pub mod schuelerprognose_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Schuljahr
        ///
        /// Schuljahr August - Juli, Stichtag jeweils zu Schuljahresbeginn im September
        pub schuljahr: Option<String>,
        /// Perimeter ID
        pub nummer: Option<i64>,
        /// Perimeter
        ///
        /// Einteilung des Stadtgebiets in 15 Schulperimeter. Die Schülerinnen und Schüler werden nach ihrer Wohnadresse den Perimetern zugeordnet.
        pub perimeter: Option<String>,
        /// Schulstufe
        ///
        /// Einteilung gemäss HarmoS-Schulstufen. Schulstufen 1 und 2 bezeichnen die beiden Jahre im Kindergarten, die Schulstufen 3-6 die umgangssprachlich als Primarschuljahre 1-6 bezeichneten Schulstufen.
        pub schulstufe: Option<i64>,
        /// Schülerinnen und Schüler
        ///
        /// Schülerinnen und Schüler in öffentlichen Schulen von Basel, die in einem der Perimeter in Basel wohnhaft sind. Prognosejahre erkennt man am beistehenden Prognoseintervall. In den Prognosen nicht berücksichtigt sind künftige Arealentwicklungen.
        pub sus: Option<i64>,
        /// Unteres Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das untere Prognoseintervall bezeichnet die untere Grenze dieser Bandbreite.
        pub unteres_prognoseintervall: Option<String>,
        /// Oberes Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das obere Prognoseintervall bezeichnet die obere Grenze dieser Bandbreite.
        pub oberes_prognoseintervall: Option<String>,
        /// Typ
        ///
        /// Ist-Wert oder Resultat der Prognose
        pub typ: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Perimeter ID
        pub perimeter_id: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Schuljahr,
        Nummer,
        Perimeter,
        Schulstufe,
        Sus,
        UnteresPrognoseintervall,
        OberesPrognoseintervall,
        Typ,
        PerimeterId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schuljahr => "schuljahr",
                Field::Nummer => "nummer",
                Field::Perimeter => "perimeter",
                Field::Schulstufe => "schulstufe",
                Field::Sus => "sus",
                Field::UnteresPrognoseintervall => "unteres_prognoseintervall",
                Field::OberesPrognoseintervall => "oberes_prognoseintervall",
                Field::Typ => "typ",
                Field::PerimeterId => "perimeter_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100121/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Velo-Fahrverbote (allgemein oder temporär)
pub mod velo_fahrverbote_allgemein_oder_temporaer {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ID_VERBOT
        pub id_verbot: Option<i64>,
        /// GEOMETRY1_
        pub geometry1: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        IdVerbot,
        Geometry1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::IdVerbot => "id_verbot",
                Field::Geometry1 => "geometry1",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100035/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Elternberatung
pub mod elternberatung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_el: Option<i64>,
        /// Standortname
        ///
        /// Bezeichnung des Standortes
        pub std_name: Option<String>,
        /// Strasse
        ///
        /// Strassename und Hausnummer
        pub strasse_nr: Option<String>,
        /// Postleitzahl
        ///
        /// 4 bis 5-stellige Postleitzahl
        pub plz: Option<i64>,
        /// Ort
        ///
        /// Gemeinde
        pub ort: Option<String>,
        /// Kanton
        ///
        /// Name des Kanton
        pub kanton: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// Link Homepage
        ///
        /// Adresse der Website
        pub link_hp: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdEl,
        StdName,
        StrasseNr,
        Plz,
        Ort,
        Kanton,
        Telefon,
        LinkHp,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdEl => "id_el",
                Field::StdName => "std_name",
                Field::StrasseNr => "strasse_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Telefon => "telefon",
                Field::LinkHp => "link_hp",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100020/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Temperatur Grundwasser: Langjährige Statistiken
pub mod temperatur_grundwasser_langjaehrige_statistiken {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationId
        ///
        /// Identifikationsnummer
        pub stationid: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// 10YMin
        ///
        /// kleinster Messwert (nach 10 Jahren)
        pub x10ymin: Option<f64>,
        /// 10YMean
        ///
        /// Mittelwert aller Messwerte (nach 10 Jahren)
        pub x10ymean: Option<f64>,
        /// 10YMax
        ///
        /// grösster Messwert (nach 10 Jahren)
        pub x10ymax: Option<f64>,
        /// startStatist
        ///
        /// Start Messung
        pub startstatist: Option<String>,
        /// endStatist
        ///
        /// Ende Messung
        pub endstatist: Option<String>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_start_timestamp: Option<OffsetDateTime>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_end_timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Stationnr,
        Stationid,
        Stationname,
        Sensornr,
        Sensname,
        Lat,
        Lon,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        X10ymin,
        X10ymean,
        X10ymax,
        Startstatist,
        Endstatist,
        BohrkatasterLink,
        StatStartTimestamp,
        StatEndTimestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Stationnr => "stationnr",
                Field::Stationid => "stationid",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::X10ymin => "10ymin",
                Field::X10ymean => "10ymean",
                Field::X10ymax => "10ymax",
                Field::Startstatist => "startstatist",
                Field::Endstatist => "endstatist",
                Field::BohrkatasterLink => "bohrkataster_link",
                Field::StatStartTimestamp => "stat_start_timestamp",
                Field::StatEndTimestamp => "stat_end_timestamp",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100181/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmung vom 13. Februar 2022
pub mod kennzahlen_der_abstimmung_vom_13_februar_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100169/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Entsorgungsstellen
pub mod entsorgungsstellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_ENTSORG
        pub id_entsorg: Option<i64>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// NAME
        pub name: Option<String>,
        /// BESCHREIBU
        pub beschreibu: Option<String>,
        /// ADRESSE
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ORTSCHAFT
        pub ortschaft: Option<String>,
        /// TELEFON
        pub telefon: Option<String>,
        /// OEFFNUNGSZ
        pub oeffnungsz: Option<String>,
        /// LINK
        pub www_link: Option<String>,
        /// ZUSTAENDIG
        pub zustaendig: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdEntsorg,
        Kategorie,
        Name,
        Beschreibu,
        Adresse,
        Plz,
        Ortschaft,
        Telefon,
        Oeffnungsz,
        WwwLink,
        Zustaendig,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdEntsorg => "id_entsorg",
                Field::Kategorie => "kategorie",
                Field::Name => "name",
                Field::Beschreibu => "beschreibu",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ortschaft => "ortschaft",
                Field::Telefon => "telefon",
                Field::Oeffnungsz => "oeffnungsz",
                Field::WwwLink => "www_link",
                Field::Zustaendig => "zustaendig",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100021/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Hundesignalisation: Orte mit Leinenpflicht oder Hundeverbot
pub mod hundesignalisation_orte_mit_leinenpflicht_oder_hundeverbot {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id: Option<i64>,
        /// Einschränkung
        ///
        /// Beschreibung der Einschränkung
        pub einschraen: Option<String>,
        /// Einschränkungsnummer
        ///
        /// Identifikator der Art der Einschränkung
        pub einschrnr: Option<i64>,
        /// Datum von
        ///
        /// Startdatum der Einschränkung
        #[serde(with = "time::serde::iso8601::option")]
        pub datumvon: Option<OffsetDateTime>,
        /// Datum bis
        ///
        /// Enddatum der Einschränkung
        #[serde(with = "time::serde::iso8601::option")]
        pub datumbis: Option<OffsetDateTime>,
        /// Bemerkung
        ///
        /// Bemerkung zur Fläche
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Einschraen,
        Einschrnr,
        Datumvon,
        Datumbis,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Einschraen => "einschraen",
                Field::Einschrnr => "einschrnr",
                Field::Datumvon => "datumvon",
                Field::Datumbis => "datumbis",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100023/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Scheidungen nach Scheidungsdatum, Ehedauer sowie Alter und Staatsangehörigkeit der ehemaligen Ehepartner
pub mod scheidungen_nach_scheidungsdatum_ehedauer_sowie_alter_und_staatsangehoerigkeit_der_ehemaligen_ehepartner {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Scheidungsdatum
        pub scheidungsdatum: Option<Date>,
        /// Jahr
        ///
        /// Scheidungsjahr
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Scheidungsmonat
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Laufnummer der Scheidungswoche im Jahr
        pub woche_in_jahr: Option<i64>,
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Scheidungswoche
        pub datum_wochenstart_scheidungsdatum: Option<Date>,
        /// Tag in Jahr
        ///
        /// Laufnummer des Tages im Jahr
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Alter der Frau
        ///
        /// Alter der Frau in vollendeten Jahren
        pub persalter_frau_vollendet: Option<String>,
        /// Alter des Mannes
        ///
        /// Alter des Mannes in vollendeten Jahren
        pub persalter_mann_vollendet: Option<String>,
        /// Staatsangehörigkeit der Frau
        ///
        /// Staatsangehörigkeit der Frau (Schweiz/Ausland)
        pub nationalitaet_frau: Option<String>,
        /// Staatsangehörigkeit des Mannes
        ///
        /// Staatsangehörigkeit des Mannes (Schweiz/Ausland)
        pub nationalitaet_mann: Option<String>,
        /// Ehedauer
        ///
        /// Ehedauer in vollendeten Jahren
        pub jahreehedauer_vollendet: Option<i64>,
        /// Anzahl
        ///
        /// Anzahl Scheidungen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Scheidungsdatum,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartScheidungsdatum,
        TagInJahr,
        Wochentag,
        PersalterFrauVollendet,
        PersalterMannVollendet,
        NationalitaetFrau,
        NationalitaetMann,
        JahreehedauerVollendet,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Scheidungsdatum => "scheidungsdatum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartScheidungsdatum => "datum_wochenstart_scheidungsdatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::PersalterFrauVollendet => "persalter_frau_vollendet",
                Field::PersalterMannVollendet => "persalter_mann_vollendet",
                Field::NationalitaetFrau => "nationalitaet_frau",
                Field::NationalitaetMann => "nationalitaet_mann",
                Field::JahreehedauerVollendet => "jahreehedauer_vollendet",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100139/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Buvetten in Gewässernähe
pub mod buvetten_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        pub sichtbar_bis: Option<Date>,
        /// Name
        ///
        /// Name der Buvette
        pub name: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Name,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Name => "name",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100283/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kinder- und Jugendangebote
pub mod kinder_und_jugendangebote {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_KJ
        pub id_kj: Option<i64>,
        /// KI_ANGEBOT
        pub ki_angebot: Option<String>,
        /// JU_ANGEBOT
        pub ju_angebot: Option<String>,
        /// TRAEGER
        pub traeger: Option<String>,
        /// ANGEBOT
        pub angebot: Option<String>,
        /// STRASSE_NR
        pub strasse_nr: Option<String>,
        /// PLZ
        pub plz: Option<i64>,
        /// ORT
        pub ort: Option<String>,
        /// KANTON
        pub kanton: Option<String>,
        /// LINK
        pub link: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdKj,
        KiAngebot,
        JuAngebot,
        Traeger,
        Angebot,
        StrasseNr,
        Plz,
        Ort,
        Kanton,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdKj => "id_kj",
                Field::KiAngebot => "ki_angebot",
                Field::JuAngebot => "ju_angebot",
                Field::Traeger => "traeger",
                Field::Angebot => "angebot",
                Field::StrasseNr => "strasse_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100024/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Staatsangehörigkeit und Bezirk
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_bezirk {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BEZ_NAME
        pub bez_name: Option<String>,
        /// Bezirk
        pub bezirk: Option<String>,
        /// BEZ_LABEL
        pub bez_label: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// WOV_NAME
        pub wov_name: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_al: Option<i64>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub gesbev_f: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BezName,
        Bezirk,
        BezLabel,
        WovId,
        WovName,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BezName => "bez_name",
                Field::Bezirk => "bezirk",
                Field::BezLabel => "bez_label",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100061/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): Fallzahlen ganze Schweiz
pub mod coronavirus_covid_19_fallzahlen_ganze_schweiz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Date
        pub date: Option<Date>,
        /// Last update
        ///
        /// the precise update time is not always known
        #[serde(with = "time::serde::iso8601::option")]
        pub update: Option<OffsetDateTime>,
        /// Canton
        pub name: Option<String>,
        /// Cumulative number of tests
        ///
        /// cumulative
        pub ncumul_tested: Option<i64>,
        /// Cumulative number of confirmed cases
        ///
        /// cumulative
        pub ncumul_conf: Option<i64>,
        /// Number of new hospitalisations since last day
        pub new_hosp: Option<i64>,
        /// Current number of hospitalised patients
        ///
        /// at the given date
        pub current_hosp: Option<i64>,
        /// Current number of hospitalised patients in ICUs
        ///
        /// at the given date
        pub current_icu: Option<i64>,
        /// Current number of patients requiring ventilation
        ///
        /// at the given date
        pub current_vent: Option<i64>,
        /// Cumulative number of patients released from hospital or recovered
        ///
        /// cumulative
        pub ncumul_released: Option<i64>,
        /// Cumulative number of deceased
        ///
        /// cumulative
        pub ncumul_deceased: Option<i64>,
        /// Number of hospitalised patients in ICUs
        ///
        /// DUPLICATE FOR COMPATIBILITY
        pub ncumul_icu: Option<i64>,
        /// Number of hospitalised patients
        ///
        /// DUPLICATE FOR COMPATIBILITY
        pub ncumul_hosp: Option<i64>,
        /// Number of patients requiring ventilation
        ///
        /// DUPLICATE FOR COMPATIBILITY
        pub ncumul_vent: Option<i64>,
        /// Current number of isolated persons
        pub current_isolated: Option<i64>,
        /// Current number of quarantined persons
        pub current_quarantined: Option<i64>,
        /// Source
        pub source: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Canton abbreviation
        pub abbreviation_canton_and_fl: Option<String>,
        /// Current number of quarantined persons coming from risk areas
        pub current_quarantined_riskareatravel: Option<i64>,
        /// Current quarantined persons (total)
        pub current_quarantined_total: Option<i64>,
        /// Official code Kanton
        pub kan_code: Option<String>,
        /// Official Name Kanton
        pub kan_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Update,
        Name,
        NcumulTested,
        NcumulConf,
        NewHosp,
        CurrentHosp,
        CurrentIcu,
        CurrentVent,
        NcumulReleased,
        NcumulDeceased,
        NcumulIcu,
        NcumulHosp,
        NcumulVent,
        CurrentIsolated,
        CurrentQuarantined,
        Source,
        AbbreviationCantonAndFl,
        CurrentQuarantinedRiskareatravel,
        CurrentQuarantinedTotal,
        KanCode,
        KanName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Update => "update",
                Field::Name => "name",
                Field::NcumulTested => "ncumul_tested",
                Field::NcumulConf => "ncumul_conf",
                Field::NewHosp => "new_hosp",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentIcu => "current_icu",
                Field::CurrentVent => "current_vent",
                Field::NcumulReleased => "ncumul_released",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::NcumulIcu => "ncumul_icu",
                Field::NcumulHosp => "ncumul_hosp",
                Field::NcumulVent => "ncumul_vent",
                Field::CurrentIsolated => "current_isolated",
                Field::CurrentQuarantined => "current_quarantined",
                Field::Source => "source",
                Field::AbbreviationCantonAndFl => "abbreviation_canton_and_fl",
                Field::CurrentQuarantinedRiskareatravel => "current_quarantined_riskareatravel",
                Field::CurrentQuarantinedTotal => "current_quarantined_total",
                Field::KanCode => "kan_code",
                Field::KanName => "kan_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100077/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Statistische Raumeinheiten: Bezirke
pub mod statistische_raumeinheiten_bezirke {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BEZ_ID
        pub bez_id: Option<String>,
        /// BEZ_LABEL
        pub bez_label: Option<String>,
        /// BEZ_NAME
        pub bez_name: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        BezId,
        BezLabel,
        BezName,
        WovId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BezId => "bez_id",
                Field::BezLabel => "bez_label",
                Field::BezName => "bez_name",
                Field::WovId => "wov_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100039/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geschwindigkeitsmonitoring: Einzelmessungen von 2021 bis 2023
pub mod geschwindigkeitsmonitoring_einzelmessungen_von_2021_bis_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Timestamp
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit in km/h
        pub geschwindigkeit: Option<f64>,
        /// Zeit
        ///
        /// Uhrzeit (hh:mm:ss) einer gemessenen Fahrt
        pub zeit: Option<String>,
        /// Datum
        pub datum: Option<String>,
        /// Datum und Zeit
        ///
        /// Datum und Uhrzeit als Text formatiert
        pub datum_zeit: Option<String>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        pub messende: Option<Date>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<f64>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Übertretungsquote
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit überschritten haben
        pub ue_quote: Option<f64>,
        /// Geschwindigkeit V50
        ///
        /// Höchstgeschwindigkeit, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50: Option<f64>,
        /// Geschwindigkeit V85
        ///
        /// Höchstgeschwindigkeit, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85: Option<f64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge während einer Messung
        pub fzg: Option<i64>,
        /// Fahrzeuglänge
        ///
        /// Vom Radar gemessene Fahrzeuglänge
        pub fahrzeuglange: Option<f64>,
        /// Kennzahlen pro Mess-Standort
        ///
        /// Link zum nach der aktuellen Messung gefilterten Datensatz "Kennzahlen pro Mess-Standort"
        pub link_zu_messung: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        MessungId,
        RichtungId,
        Geschwindigkeit,
        Zeit,
        Datum,
        DatumZeit,
        Messbeginn,
        Messende,
        Zone,
        Ort,
        Richtung,
        UeQuote,
        V50,
        V85,
        Strasse,
        StrasseNr,
        Fzg,
        Fahrzeuglange,
        LinkZuMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::MessungId => "messung_id",
                Field::RichtungId => "richtung_id",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Zeit => "zeit",
                Field::Datum => "datum",
                Field::DatumZeit => "datum_zeit",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Zone => "zone",
                Field::Ort => "ort",
                Field::Richtung => "richtung",
                Field::UeQuote => "ue_quote",
                Field::V50 => "v50",
                Field::V85 => "v85",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Fzg => "fzg",
                Field::Fahrzeuglange => "fahrzeuglange",
                Field::LinkZuMessung => "link_zu_messung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100358/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Fischereistatistik Basel-Stadt
pub mod fischereistatistik_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr des Fangs
        pub jahr: Option<Date>,
        /// Jahr und Monat
        ///
        /// Jahr und Monat des Fangs
        pub monat: Option<Date>,
        /// Fischereikarte
        ///
        /// Fischereikarte: https://www.aue.bs.ch/wasser/fischen-basler-rheinknie/fischereikarten.html
        pub fischereikarte: Option<String>,
        /// Gewässer
        ///
        /// Gewässer, wo der Fisch gefangen worden ist
        pub gewasser: Option<String>,
        /// Fischart
        ///
        /// Art des gefangenen Fisches
        pub fischart: Option<String>,
        /// Länge
        ///
        /// Länge des gefangenen Fisches
        pub lange: Option<f64>,
        /// Kesslergrundel
        ///
        /// Anzahl der gefangenen Kesslergrundeln
        pub kesslergrundel: Option<i64>,
        /// Schwarzmundgrundel
        ///
        /// Anzahl der gefangenen Schwarzmundgrundeln
        pub schwarzmundgrundel: Option<i64>,
        /// Geo Shape Gewässer
        pub geo_shape: Option<GeoJson>,
        /// Laufnummer
        pub laufnummer: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        Fischereikarte,
        Gewasser,
        Fischart,
        Lange,
        Kesslergrundel,
        Schwarzmundgrundel,
        Laufnummer,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Fischereikarte => "fischereikarte",
                Field::Gewasser => "gewasser",
                Field::Fischart => "fischart",
                Field::Lange => "lange",
                Field::Kesslergrundel => "kesslergrundel",
                Field::Schwarzmundgrundel => "schwarzmundgrundel",
                Field::Laufnummer => "laufnummer",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100193/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Staatsangehörigkeit und Block
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_block {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Block
        pub block: Option<String>,
        /// BLO_LABEL
        pub blo_label: Option<String>,
        /// BEZ_ID
        pub bez_id: Option<String>,
        /// BEZ_NAME
        pub bez_name: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// WOV_NAME
        pub wov_name: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anzahl_al: Option<i64>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub gesbev_f: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Block,
        BloLabel,
        BezId,
        BezName,
        WovId,
        WovName,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Block => "block",
                Field::BloLabel => "blo_label",
                Field::BezId => "bez_id",
                Field::BezName => "bez_name",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100062/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kantonsblatt
pub mod kantonsblatt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Rubrik
        pub rubric_de: Option<String>,
        /// Rubrik-Code
        ///
        /// Code der Rubrik
        pub rubric: Option<String>,
        /// Unterrubrik
        pub subrubric_de: Option<String>,
        /// Unterrubrik-Code
        ///
        /// Code der Unterrubrik
        pub subrubric: Option<String>,
        /// Veröffentlichungsdatum
        ///
        /// Datum, an dem die Veröffentlichung im Kantonsblatt für die Öffentlichkeit zugänglich gemacht wurde.
        pub publicationdate: Option<Date>,
        /// Öffentlich einsehbar bis
        ///
        /// Das Dokument kann nur bis zum angegebenen Datum aufgerufen werden.
        pub expirationdate: Option<Date>,
        /// Sprache
        pub language: Option<String>,
        /// Publizierende Stelle
        ///
        /// Name der publizierenden Stelle
        pub registrationofficedisplayname: Option<String>,
        /// ID - Publizierende Stelle
        ///
        /// Identifikationsnummer der publizierenden Stelle
        pub registrationofficeid: Option<String>,
        /// Strasse
        ///
        /// Strasse der publizierenden Stelle
        pub registrationofficestreet: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer der publizierenden Stelle
        pub registrationofficestreetnumber: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl der publizierenden Stelle
        pub registrationofficeswisszipcode: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinde der publizierenden Stelle
        pub registrationofficetown: Option<String>,
        /// Postfachverfügbarkeit
        ///
        /// Hat die publizierende Stelle ein Postfach? "True" bedeutet Ja, "False" bedeutet Nein.
        pub registrationofficecontainspostofficebox: Option<String>,
        /// Postfachnummer
        pub registrationofficepostofficeboxnumber: Option<String>,
        /// Postfach PLZ
        ///
        /// Postfach Postleitzahl
        pub registrationofficepostofficeboxswisszipcode: Option<String>,
        /// Postfach Gemeinde
        pub registrationofficepostofficeboxtown: Option<String>,
        /// Veröffentlichungs-ID
        ///
        /// Eindeutige Identifikationsnummer der Veröffentlichung. Wird im Gegensatz zur Meldungsnummer für API-Aufrufe und URL benötigt
        pub id: Option<String>,
        /// Meldungsnummer
        ///
        /// Nummer zugehörig zur Veröffentlichung
        pub publicationnumber: Option<String>,
        /// Status
        ///
        /// Nur PUBLISHED (veröffentlicht) vorhanden
        pub publicationstate: Option<String>,
        /// primärer Mandant - Code
        ///
        /// Code des primären veröffentlichenden Amtsblattes
        pub primarytenantcode: Option<String>,
        /// primärer Mandant
        ///
        /// primäres veröffentlichendes Amtsblatt
        pub primarytenantname: Option<String>,
        /// Im Auftrag von
        ///
        /// Name des Auftraggebers
        pub onbehalfof: Option<String>,
        /// Rechtliche Hinweise
        pub legalremedy: Option<String>,
        /// Kantone
        ///
        /// Kürzel der beteiligten Kantone
        pub cantons: Option<String>,
        /// Weitere Mandanten - Code
        ///
        /// Code der zusätzlichen Mandanten, getrennt durch Komma
        pub secondarytenantstenantcode: Option<String>,
        /// Weitere Mandanten
        ///
        /// Zusätzliche Mandanten, getrennt durch Komma
        pub secondarytenantstenantname: Option<String>,
        /// Veröffentlichungsdaten weiterer Mandanten
        ///
        /// Das Veröffentlichungsdatum weiterer Mandanten. In der gleichen Reihenfolge wie in der Spalte "Weitere Mandanten" aufgeführt.
        pub secondarytenantspublicationdate: Option<String>,
        /// Mehrfache Veröffentlichungen
        ///
        /// Falls die Veröffentlichung mehrmals getätigt wurde, werden hier die zugehörigen Meldungsnummern aufgeführt.
        pub repeatedpublicationspublicationnumber: Option<String>,
        /// Veröffentlichungsdaten anderer Veröffentlichungen
        ///
        /// Falls die Veröffentlichung mehrmals getätigt wurde, werden hier die anderen Veröffentlichungsdaten aufgeführt. In der gleichen Reihenfolge wie in der Spalte "Mehrfache Veröffentlichungen" aufgeführt.
        pub repeatedpublicationspublicationdate: Option<String>,
        /// Webansicht
        ///
        /// Webansicht der Veröffentlichung auf der Webseite von www.kantonsblatt.ch (generiert mit Veröffentlichungs-ID)
        pub url_kantonsblatt: Option<String>,
        /// PDF-Dokument
        ///
        /// Downloadlink für die Veröffentlichung als PDF (generiert mit Veröffentlichungs-ID)
        pub url_pdf: Option<String>,
        /// XML-Datei
        ///
        /// Downloadlink für die Veröffentlichung als XML-Datei  (generiert mit Veröffentlichungs-ID)
        pub url_xml: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        RubricDe,
        Rubric,
        SubrubricDe,
        Subrubric,
        Publicationdate,
        Expirationdate,
        Language,
        Registrationofficedisplayname,
        Registrationofficeid,
        Registrationofficestreet,
        Registrationofficestreetnumber,
        Registrationofficeswisszipcode,
        Registrationofficetown,
        Registrationofficecontainspostofficebox,
        Registrationofficepostofficeboxnumber,
        Registrationofficepostofficeboxswisszipcode,
        Registrationofficepostofficeboxtown,
        Id,
        Publicationnumber,
        Publicationstate,
        Primarytenantcode,
        Primarytenantname,
        Onbehalfof,
        Legalremedy,
        Cantons,
        Secondarytenantstenantcode,
        Secondarytenantstenantname,
        Secondarytenantspublicationdate,
        Repeatedpublicationspublicationnumber,
        Repeatedpublicationspublicationdate,
        UrlKantonsblatt,
        UrlPdf,
        UrlXml,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::RubricDe => "rubric_de",
                Field::Rubric => "rubric",
                Field::SubrubricDe => "subrubric_de",
                Field::Subrubric => "subrubric",
                Field::Publicationdate => "publicationdate",
                Field::Expirationdate => "expirationdate",
                Field::Language => "language",
                Field::Registrationofficedisplayname => "registrationofficedisplayname",
                Field::Registrationofficeid => "registrationofficeid",
                Field::Registrationofficestreet => "registrationofficestreet",
                Field::Registrationofficestreetnumber => "registrationofficestreetnumber",
                Field::Registrationofficeswisszipcode => "registrationofficeswisszipcode",
                Field::Registrationofficetown => "registrationofficetown",
                Field::Registrationofficecontainspostofficebox => {
                    "registrationofficecontainspostofficebox"
                }
                Field::Registrationofficepostofficeboxnumber => {
                    "registrationofficepostofficeboxnumber"
                }
                Field::Registrationofficepostofficeboxswisszipcode => {
                    "registrationofficepostofficeboxswisszipcode"
                }
                Field::Registrationofficepostofficeboxtown => "registrationofficepostofficeboxtown",
                Field::Id => "id",
                Field::Publicationnumber => "publicationnumber",
                Field::Publicationstate => "publicationstate",
                Field::Primarytenantcode => "primarytenantcode",
                Field::Primarytenantname => "primarytenantname",
                Field::Onbehalfof => "onbehalfof",
                Field::Legalremedy => "legalremedy",
                Field::Cantons => "cantons",
                Field::Secondarytenantstenantcode => "secondarytenantstenantcode",
                Field::Secondarytenantstenantname => "secondarytenantstenantname",
                Field::Secondarytenantspublicationdate => "secondarytenantspublicationdate",
                Field::Repeatedpublicationspublicationnumber => {
                    "repeatedpublicationspublicationnumber"
                }
                Field::Repeatedpublicationspublicationdate => "repeatedpublicationspublicationdate",
                Field::UrlKantonsblatt => "url_kantonsblatt",
                Field::UrlPdf => "url_pdf",
                Field::UrlXml => "url_xml",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100352/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kunst im öffentlichen Raum
pub mod kunst_im_oeffentlichen_raum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Inventar-Nummer
        ///
        /// Eindeutiger Identifikator, Inventar-Nummer
        pub id_invnr: Option<String>,
        /// Gruppe
        ///
        /// Gruppe zur Unterteilung in Kunst und Bau (KuB) und Kunst im öffentlichen Raum (KiöR)
        pub gruppe: Option<String>,
        /// Fotonummer
        ///
        /// Dateiname des Fotos
        pub fotonummer: Option<String>,
        /// Kunstschaffende
        ///
        /// Name der Kunstschaffende
        pub ku_name: Option<String>,
        /// Werktitel
        ///
        /// Titel des Kunstwerks
        pub werktitel: Option<String>,
        /// Datierung
        ///
        /// Datierung des Kunstwerks
        pub datierung: Option<String>,
        /// Standort
        ///
        /// Adresse und genauer Standortbeschrieb des Kunstwerks
        pub standort: Option<String>,
        /// PDF
        ///
        /// Dateiname des PDFs
        pub pdf: Option<String>,
        /// Rückbau
        ///
        /// ist das Werk zurückgebaut
        pub rueckbau: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
        /// Foto-Downloadlink
        ///
        /// Downloadlink
        pub foto_downloadlink: Option<File>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdInvnr,
        Gruppe,
        Fotonummer,
        KuName,
        Werktitel,
        Datierung,
        Standort,
        Pdf,
        Rueckbau,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdInvnr => "id_invnr",
                Field::Gruppe => "gruppe",
                Field::Fotonummer => "fotonummer",
                Field::KuName => "ku_name",
                Field::Werktitel => "werktitel",
                Field::Datierung => "datierung",
                Field::Standort => "standort",
                Field::Pdf => "pdf",
                Field::Rueckbau => "rueckbau",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100214/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Umfrage «digitale Mitwirkung» 2020
pub mod umfrage_digitale_mitwirkung_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Altersgruppe
        ///
        /// Darf ich fragen, wie alt Sie sind?
        pub altersgruppe: Option<String>,
        /// An CH-Wahlen 2019 teilgenommen
        ///
        /// Im Oktober 2019 wurde das Schweizer Parlament neu gewählt: Haben Sie an den Wahlen teilgenommen?
        pub w92a: Option<String>,
        /// Parteibindung
        ///
        /// Welche Liste oder Partei haben Sie gewählt bzw. von welcher Partei haben Sie am meisten Kandidatinnen und Kandidaten unterstützt? Unter «nicht im Grossen Rat vertretene Partei» sind die folgenden Nennungen summiert: CSP, BDP, Alternative Linke, Alternative Liste, PdA, solidarität, EDU.
        pub partei: Option<String>,
        /// Teilnahme an künftigen Abstimmungen über politische Fragen in BS
        ///
        /// Wenn in den nächsten 5 Jahren im Kanton Basel-Stadt insgesamt 10 Mal über politische Fragen abgestimmt würde, an wie vielen dieser Abstimmungen werden Sie vermutlich teilnehmen?
        pub verhal: Option<String>,
        /// Ausbildung
        ///
        /// Welche Schule haben Sie selber zuletzt besucht resp. was für eine Berufsausbildung haben Sie? Obligatorische Schule bzw. Sekundarstufe I enthält die Antworten «keine», «Primar-Real-Sekundarschule». Sekundarstuffe II enthält die Antworten «Berufslehere-Berufsschule-KV-Gewerbeschule», «Maturitätsschule, Gymnasium, LehrerInnenseminar, Berufsmaturität». Tertiärstufe enthält die Antworten «Höhere Fach- oder Berufsausbildung, Kunstgewerbeschule», «Höhere Fachschule (z.B. HTL, HWV)», «Technische Hochschulen (ETH), Fachhochschule (FHS)», «Universität».
        pub bildung: Option<String>,
        /// Gewichtung
        ///
        /// Gewichtung der Antwort
        pub gewdef: Option<f64>,
        /// Geschlecht
        ///
        /// Geschlecht des/der Befragten
        pub s11: Option<String>,
        /// CH Staatsbürgerschaft
        ///
        /// Haben Sie die Schweizer Staatsbürgerschaft?
        pub stimm: Option<String>,
        /// Interesse an politischen Fragen
        ///
        /// Ganz allgemein gesprochen, wie sehr sind Sie an politischen Fragen interessiert? Sind Sie…
        pub bast1: Option<String>,
        /// Interesse an der Auswirkung von technologischen Entwicklungen
        ///
        /// Und wie sehr sind Sie an Fragen zur Auswirkung von technologischen Entwicklungen auf unser Alltagsleben interessiert? Sind Sie…
        pub bast2: Option<String>,
        /// Haltung zur Digitalisierung
        ///
        /// Wie stehen Sie zum Thema Digitalisierung? Fühlen sie sich vom rasanten technischen Wandel und der Digitalisierung überhaupt nicht überfordert, teilweise überfordert oder stark überfordert?
        pub bast3: Option<String>,
        /// Bedeutung Digitalisierung für gesellsch. Austausch
        ///
        /// Die Digitalisierung und das Internet haben grosse Auswirkungen auf die Art und Weise, wie wir zusammenleben. Ich nenne Ihnen nun drei separate Bereiche. Bitte sagen Sie mir jeweils, ob die Digitalisierung für Sie in diesen Bereichen primär eine Chance oder primär ein Risiko darstellt, oder ob weder noch der Fall ist. --- Für den gesellschaftlichen und sozialen Austausch unter den Menschen
        pub bast5_1: Option<String>,
        /// Bedeutung Digitalisierung für polit. Mitbestimmung
        ///
        /// Die Digitalisierung und das Internet haben grosse Auswirkungen auf die Art und Weise, wie wir zusammenleben. Ich nenne Ihnen nun drei separate Bereiche. Bitte sagen Sie mir jeweils, ob die Digitalisierung für Sie in diesen Bereichen primär eine Chance oder primär ein Risiko darstellt, oder ob weder noch der Fall ist. --- Für die politische Mitbestimmung der Bürger und Bürgerinnen
        pub bast5_2: Option<String>,
        /// Bedeutung Digitalisierung für Individuum
        ///
        /// Die Digitalisierung und das Internet haben grosse Auswirkungen auf die Art und Weise, wie wir zusammenleben. Ich nenne Ihnen nun drei separate Bereiche. Bitte sagen Sie mir jeweils, ob die Digitalisierung für Sie in diesen Bereichen primär eine Chance oder primär ein Risiko darstellt, oder ob weder noch der Fall ist. --- Für Sie persönlich als Individuum
        pub bast5_3: Option<String>,
        /// eHealth
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Elektronische Speicherung und Verwaltung von Gesundheits- und Patientendaten (eHealth / elektronisches Patientendossier?)
        pub bast6_1: Option<String>,
        /// e-Banking
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Finanztransaktionen über das Internet (e-Banking)
        pub bast6_2: Option<String>,
        /// Steuererklärung online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Die Steuererklärung online Ausfüllen
        pub bast6_3: Option<String>,
        /// Abstimmen und Wählen online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Abstimmen und Wählen über das Internet
        pub bast6_5: Option<String>,
        /// Dokumente / Ausweise online bestellen
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Dokumente wie Ausweise bei Behörden bestellen und Administratives erledigen
        pub bast6_6: Option<String>,
        /// Referendum / Intitiative online unterschreiben
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Ein Referendum oder eine Volksinitiative im Internet unterschreiben
        pub bast6_7: Option<String>,
        /// Rückmeldung / Vorschäge an Verwaltung online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Über Dialogplattformen im Internet der Politik und der Verwaltung Rückmeldungen geben und Vorschläge einbringen
        pub bast6_8: Option<String>,
        /// Mitsprache in Stadt und Quartier online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Über das Internet neue Möglichkeiten zur Mitsprache in Stadt und Quartier nutzen
        pub bast6_9: Option<String>,
        /// Infos über PolitikerInnen online einholen
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Online Informationen über Politikerinnen und Politiker einholen (Smartvote)
        pub bast6_10: Option<String>,
        /// Politische Disussionen online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Online an politischen Diskussionen teilnehmen und kommentieren
        pub bast6_11: Option<String>,
        /// Wählen / Abstimmen via Handy / Internet
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Wenn ich in Zukunft auch übers Handy oder übers Internet wählen und abstimmen könnte, würde ich öfter an Abstimmungen und Wahlen teilnehmen.
        pub bast7_1: Option<String>,
        /// Kosten sparen mit eVoting
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Indem in Zukunft auch elektronisch gewählt und abgestimmt werden kann, kann der Kanton Kosten sparen und effizienter arbeiten.
        ///3. Der Kanton Basel-Stadt soll in der Schweiz ein Vorreiter
        pub bast7_2: Option<String>,
        /// BS soll Vorreiter sein
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Der Kanton Basel-Stadt soll in der Schweiz ein Vorreiter bei der Nutzung des Internets für die politische Teilnahme sein.
        pub bast7_3: Option<String>,
        /// Informationen über mich
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Durch die Digitalisierung erhält der Staat noch mehr Informationen über mich, die er dann gegen mich verwenden kann.
        pub bast7_5: Option<String>,
        /// Manipulation einfacher
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Wahlen und Abstimmungen, die über das Internet durchgeführt werden, sind fehleranfälliger und einfacher zu manipulieren als Wahlen und Abstimmungen per Brief oder an der Urne.
        pub bast7_6: Option<String>,
        /// Vertrauen Urne
        ///
        /// Bei der politischen Mitbestimmung ist es wichtig, dass man darauf vertrauen kann, dass die eigene Stimme oder Meinung richtig gezählt wird. Wie gross ist Ihr Vertrauen bei den folgenden drei Möglichkeiten der politischen Mitbestimmung? Bitte sagen Sie mir das auf einer Skala von 0 (überhaupt kein Vertrauen) bis 10 (grösstes Vertrauen). --- politische Mitbestimmung an der Urne respektive vor Ort im Wahllokal
        pub bast8_1: Option<String>,
        /// Vertrauen Brief
        ///
        /// Bei der politischen Mitbestimmung ist es wichtig, dass man darauf vertrauen kann, dass die eigene Stimme oder Meinung richtig gezählt wird. Wie gross ist Ihr Vertrauen bei den folgenden drei Möglichkeiten der politischen Mitbestimmung? Bitte sagen Sie mir das auf einer Skala von 0 (überhaupt kein Vertrauen) bis 10 (grösstes Vertrauen). --- politische Mitbestimmung per Brief und Post
        pub bast8_2: Option<String>,
        /// Vertrauen Internet
        ///
        /// Bei der politischen Mitbestimmung ist es wichtig, dass man darauf vertrauen kann, dass die eigene Stimme oder Meinung richtig gezählt wird. Wie gross ist Ihr Vertrauen bei den folgenden drei Möglichkeiten der politischen Mitbestimmung? Bitte sagen Sie mir das auf einer Skala von 0 (überhaupt kein Vertrauen) bis 10 (grösstes Vertrauen). --- politische Mitbestimmung über das Internet
        pub bast8_3: Option<String>,
        /// Einführung eVoting BS
        ///
        /// Gemäss den Informationen, die Sie heute zum Thema haben, sind sehr, eher, eher nicht oder überhaupt nicht für die Einführung von eVoting im Kanton Basel-Stadt?
        pub bast10: Option<String>,
        /// Hauptgrund für eVoting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_01: Option<String>,
        /// Hauptgrund für eVoting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_02: Option<String>,
        /// Hauptgrund für eVoting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_03: Option<String>,
        /// Hauptgrund für eVoting 4
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_04: Option<String>,
        /// Hauptgrund gegen eVoting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_01: Option<String>,
        /// Hauptgrund gegen eVoting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_02: Option<String>,
        /// Hauptgrund gegen eVoting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_03: Option<String>,
        /// Hauptgrund gegen eVoting 4
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_04: Option<String>,
        /// Hauptgrund gegen eVoting 5
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_05: Option<String>,
        /// eCollecting
        ///
        /// Eine weitere Idee, wie das Internet für die Demokratie genutzt werden kann ist eCollecting. Das heisst, dass in Zukunft Unterschriften für Petitionen und Volksinitiativen auch elektronisch abgegeben werden können. Wären Sie damit sehr einverstanden, eher einverstanden, eher nicht einverstanden oder überhaupt nicht einverstanden?
        pub bast13: Option<String>,
        /// Hauptgrund für eCollecting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast14_01: Option<String>,
        /// Hauptgrund für eCollecting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast14_02: Option<String>,
        /// Hauptgrund für eCollecting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast14_03: Option<String>,
        /// Hauptgrund gegen eCollecting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_01: Option<String>,
        /// Hauptgrund gegen eCollecting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_02: Option<String>,
        /// Hauptgrund gegen eCollecting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_03: Option<String>,
        /// Hauptgrund gegen eCollecting 4
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_04: Option<String>,
        /// Prüfung Möglichkeiten Digitalisierung für polit. Mitbestimmung
        ///
        /// Die Behörden des Kantons Basel-Stadt möchten über die nächsten 2 Jahre zusammen mit den Einwohnerinnen und Einwohnern herausfinden, wie sich die Möglichkeiten der Digitalisierung und des Internets für die politische Mitbestimmung nutzen lässt. Finden Sie das eine sehr gute Idee, eine eher gute Idee, eher eine schlechte Idee oder eine sehr schlechte Idee?
        pub bast16: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 1
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_01: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 2
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_02: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 3
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_03: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 4
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_04: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 5
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_05: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Altersgruppe,
        W92a,
        Partei,
        Verhal,
        Bildung,
        Gewdef,
        S11,
        Stimm,
        Bast1,
        Bast2,
        Bast3,
        Bast51,
        Bast52,
        Bast53,
        Bast61,
        Bast62,
        Bast63,
        Bast65,
        Bast66,
        Bast67,
        Bast68,
        Bast69,
        Bast610,
        Bast611,
        Bast71,
        Bast72,
        Bast73,
        Bast75,
        Bast76,
        Bast81,
        Bast82,
        Bast83,
        Bast10,
        Bast1101,
        Bast1102,
        Bast1103,
        Bast1104,
        Bast1201,
        Bast1202,
        Bast1203,
        Bast1204,
        Bast1205,
        Bast13,
        Bast1401,
        Bast1402,
        Bast1403,
        Bast1501,
        Bast1502,
        Bast1503,
        Bast1504,
        Bast16,
        Bast1701,
        Bast1702,
        Bast1703,
        Bast1704,
        Bast1705,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Altersgruppe => "altersgruppe",
                Field::W92a => "w92a",
                Field::Partei => "partei",
                Field::Verhal => "verhal",
                Field::Bildung => "bildung",
                Field::Gewdef => "gewdef",
                Field::S11 => "s11",
                Field::Stimm => "stimm",
                Field::Bast1 => "bast1",
                Field::Bast2 => "bast2",
                Field::Bast3 => "bast3",
                Field::Bast51 => "bast5_1",
                Field::Bast52 => "bast5_2",
                Field::Bast53 => "bast5_3",
                Field::Bast61 => "bast6_1",
                Field::Bast62 => "bast6_2",
                Field::Bast63 => "bast6_3",
                Field::Bast65 => "bast6_5",
                Field::Bast66 => "bast6_6",
                Field::Bast67 => "bast6_7",
                Field::Bast68 => "bast6_8",
                Field::Bast69 => "bast6_9",
                Field::Bast610 => "bast6_10",
                Field::Bast611 => "bast6_11",
                Field::Bast71 => "bast7_1",
                Field::Bast72 => "bast7_2",
                Field::Bast73 => "bast7_3",
                Field::Bast75 => "bast7_5",
                Field::Bast76 => "bast7_6",
                Field::Bast81 => "bast8_1",
                Field::Bast82 => "bast8_2",
                Field::Bast83 => "bast8_3",
                Field::Bast10 => "bast10",
                Field::Bast1101 => "bast11_01",
                Field::Bast1102 => "bast11_02",
                Field::Bast1103 => "bast11_03",
                Field::Bast1104 => "bast11_04",
                Field::Bast1201 => "bast12_01",
                Field::Bast1202 => "bast12_02",
                Field::Bast1203 => "bast12_03",
                Field::Bast1204 => "bast12_04",
                Field::Bast1205 => "bast12_05",
                Field::Bast13 => "bast13",
                Field::Bast1401 => "bast14_01",
                Field::Bast1402 => "bast14_02",
                Field::Bast1403 => "bast14_03",
                Field::Bast1501 => "bast15_01",
                Field::Bast1502 => "bast15_02",
                Field::Bast1503 => "bast15_03",
                Field::Bast1504 => "bast15_04",
                Field::Bast16 => "bast16",
                Field::Bast1701 => "bast17_01",
                Field::Bast1702 => "bast17_02",
                Field::Bast1703 => "bast17_03",
                Field::Bast1704 => "bast17_04",
                Field::Bast1705 => "bast17_05",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100083/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Statistische Raumeinheiten: Wohnviertel
pub mod statistische_raumeinheiten_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// WOV_LABEL
        pub wov_label: Option<String>,
        /// WOV_NAME
        pub wov_name: Option<String>,
        pub gemeinde_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WovId,
        WovLabel,
        WovName,
        GemeindeName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WovId => "wov_id",
                Field::WovLabel => "wov_label",
                Field::WovName => "wov_name",
                Field::GemeindeName => "gemeinde_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100042/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wanderungen (Zuzug, Wegzug und Umzug) Kanton Basel-Stadt
pub mod wanderungen_zuzug_wegzug_und_umzug_kanton_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wanderungstyp
        ///
        /// Typ der Wanderungsbewegung: Zuzug, Wegzug und Umzug
        pub ereignis_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wanderungsbewegung
        pub datum: Option<Date>,
        /// Jahr
        ///
        /// Jahr der Wanderungsbewegung
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat der Wanderungbewegung
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Kalenderwoche der Wanderungsbewegung
        pub woche_in_jahr: Option<i64>,
        /// Startdatum Woche
        ///
        /// Datum des Montags der Woche
        pub datum_wochenstart: Option<Date>,
        /// Tag-Nr.
        ///
        /// Laufnummer des Tages innerhalb eines Jahres
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit der wandernden Person (Schweiz/Ausland)
        pub nationalitaet: Option<String>,
        /// Geschlecht
        ///
        /// M=männlich, W=weiblich
        pub geschlecht: Option<String>,
        /// Alter
        ///
        /// Alter der wandernden Person in vollendeten Jahren
        pub alter: Option<i64>,
        /// Aufenthaltsdauer in Jahren
        ///
        /// Zeitdauer vom letzten Zuzug nach Basel-Stadt bis zum Wegzug. Nur für wegziehende Personen vorhanden.
        pub aufenthaltsdauer_in_jahren: Option<i64>,
        /// Von Kontinent
        ///
        /// Kontinent, in dem die Wanderungsbewegung startet
        pub von_kontinent: Option<String>,
        /// Von Land
        ///
        /// Land, in dem die Wanderungsbewegung startet
        pub von_land: Option<String>,
        /// Von Kanton
        ///
        /// Kanton, in dem die Wanderungsbewegung startet. Nur für Schweiz bekannt.
        pub von_kanton: Option<String>,
        /// Von Gemeinde
        ///
        /// Gemeinde, in der die Wanderungsbewegung startet. Nur für Schweiz bekannt.
        pub von_gemeinde: Option<String>,
        /// Von Wohnviertel
        ///
        /// Wohnviertel, in dem die Wanderungsbewegung startet. Nur für Kanton Basel-Stadt bekannt.
        pub von_wohnviertel: Option<String>,
        /// Nach Kontinent
        ///
        /// Kontinent, in dem die Wanderungsbewegung endet
        pub nach_kontinent: Option<String>,
        /// Nach Land
        ///
        /// Land, in dem die Wanderungsbewegung endet
        pub nach_land: Option<String>,
        /// Nach Kanton
        ///
        /// Kanton, in dem die Wanderungsbewegung endet. Nur für Schweiz bekannt.
        pub nach_kanton: Option<String>,
        /// Nach Gemeinde
        ///
        /// Gemeinde, in der die Wanderungsbewegung endet. Nur für Schweiz bekannt.
        pub nach_gemeinde: Option<String>,
        /// Nach Wohnviertel
        ///
        /// Wohnviertel, in dem die Wanderungsbewegung endet. Nur für Kanton Basel-Stadt bekannt.
        pub nach_wohnviertel: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        EreignisTyp,
        Datum,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstart,
        TagInJahr,
        Wochentag,
        Nationalitaet,
        Geschlecht,
        Alter,
        AufenthaltsdauerInJahren,
        VonKontinent,
        VonLand,
        VonKanton,
        VonGemeinde,
        VonWohnviertel,
        NachKontinent,
        NachLand,
        NachKanton,
        NachGemeinde,
        NachWohnviertel,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::EreignisTyp => "ereignis_typ",
                Field::Datum => "datum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstart => "datum_wochenstart",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::Nationalitaet => "nationalitaet",
                Field::Geschlecht => "geschlecht",
                Field::Alter => "alter",
                Field::AufenthaltsdauerInJahren => "aufenthaltsdauer_in_jahren",
                Field::VonKontinent => "von_kontinent",
                Field::VonLand => "von_land",
                Field::VonKanton => "von_kanton",
                Field::VonGemeinde => "von_gemeinde",
                Field::VonWohnviertel => "von_wohnviertel",
                Field::NachKontinent => "nach_kontinent",
                Field::NachLand => "nach_land",
                Field::NachKanton => "nach_kanton",
                Field::NachGemeinde => "nach_gemeinde",
                Field::NachWohnviertel => "nach_wohnviertel",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100138/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Grossratswahlen nach Berufsgruppe seit 2020
pub mod kandidierende_der_grossratswahlen_nach_berufsgruppe_seit_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Berufsgruppe
        pub berufsgruppe: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kandidierende in Berufsgruppe
        pub anzahl: Option<i64>,
        /// Anteil in %
        ///
        /// Anzahl Kandidierende in Berufsgruppe / Anzahl Kandidierende
        pub anteil: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Berufsgruppe,
        Anzahl,
        Anteil,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Berufsgruppe => "berufsgruppe",
                Field::Anzahl => "anzahl",
                Field::Anteil => "anteil",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100394/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nachnamen der baselstädtischen Bevölkerung
pub mod nachnamen_der_baselstaedtischen_bevoelkerung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Nachname
        pub nachname: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Nachname,
        Anzahl,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Nachname => "nachname",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100127/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baumkataster: Fäll- und Baumersatzliste
pub mod baumkataster_faell_und_baumersatzliste {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// Baumnummer
        ///
        /// Eindeutige Nummer des Baums
        pub baumnr: Option<String>,
        /// Baumart
        ///
        /// Botanische und deutsche Bezeichnung der Baumart
        pub art: Option<String>,
        /// Baumart lateinisch
        ///
        /// Botanische Bezeichnung der Baumart
        pub baumart_lateinisch: Option<String>,
        /// Baumart deutsch
        ///
        /// Deutsche Bezeichnung der Baumart
        pub baumart_deutsch: Option<String>,
        /// ID_Schutzstatus
        ///
        /// ID des Schutzstatus
        pub id_schutzs: Option<i64>,
        /// Schutzstatus
        ///
        /// Beschreibung des Schutzstatus: "Geschützt (Umfang)": Geschützt wegen gemessenem Baumumfang. "Gemäss Baumschutzgesetz (BSchG)": Baumumfang wurde nicht unbedingt aktuell gemessen, Baum wurde trotzdem konservativ als geschützt eingeteilt. "Geschützt (Ersatzpflanzung)": Aktueller Baum ist geschützt, da er einen vormalig geschützten Baum ersetzt.
        pub schutzstat: Option<String>,
        /// Strasse
        ///
        /// Strasse des Baumstandortes
        pub strasse: Option<String>,
        /// Ersatzart
        ///
        /// Baumart des geplanten Ersatzbaums
        pub ersatzart: Option<String>,
        /// Ersatzdatum
        ///
        /// Datum des geplanten Ersatzes
        pub ersatzdatu: Option<String>,
        /// Ersatzort
        ///
        /// Standort des geplanten Ersatzbaums
        pub ersatzort: Option<String>,
        /// Stammumfang
        pub stammumfan: Option<i64>,
        /// Fällgrund
        ///
        /// Grund für die Fällung des Baums
        pub faellgrund: Option<String>,
        /// Fällgrund - weitere Informationen
        ///
        /// Weitergehende Informationen zur Fällung des Baums
        pub faellgrun1: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Baumnr,
        Art,
        BaumartLateinisch,
        BaumartDeutsch,
        IdSchutzs,
        Schutzstat,
        Strasse,
        Ersatzart,
        Ersatzdatu,
        Ersatzort,
        Stammumfan,
        Faellgrund,
        Faellgrun1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Baumnr => "baumnr",
                Field::Art => "art",
                Field::BaumartLateinisch => "baumart_lateinisch",
                Field::BaumartDeutsch => "baumart_deutsch",
                Field::IdSchutzs => "id_schutzs",
                Field::Schutzstat => "schutzstat",
                Field::Strasse => "strasse",
                Field::Ersatzart => "ersatzart",
                Field::Ersatzdatu => "ersatzdatu",
                Field::Ersatzort => "ersatzort",
                Field::Stammumfan => "stammumfan",
                Field::Faellgrund => "faellgrund",
                Field::Faellgrun1 => "faellgrun1",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100054/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Leerstehende Wohnungen
pub mod leerstehende_wohnungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Wohnviertel-ID
        ///
        /// ID des Wohnviertels
        pub wov_id: Option<String>,
        /// Wohnviertel
        ///
        /// Name des Wohnviertels
        pub wov_name: Option<String>,
        /// Bezirk-ID
        ///
        /// ID des Wohnbezirks
        pub wohnbezirk_id: Option<i64>,
        /// Bezirk Label
        ///
        /// Label des Bezirks
        pub bez_label: Option<String>,
        /// Bezirk
        ///
        /// Name des Wohnbezirks
        pub bez_name: Option<String>,
        /// Total Leerstand
        ///
        /// Gesamtzahl leerstehender Wohnungen nach Bezirk und Zimmerzahl
        pub total: Option<i64>,
        /// Anzahl Zimmer
        ///
        /// Zimmerzahl der Wohnung: Halbe Zimmer werden nicht ausgewiesen
        pub zimmerzahl_ganzzahlig: Option<i64>,
        /// Wohnfläche bis 30m2
        ///
        /// Wohnfläche beträgt bis 30 Quadratmeter
        pub wfl_min_30m2: Option<i64>,
        /// Wohnfläche 31 bis 50m2
        ///
        /// Wohnfläche beträgt 31 bis 50 Quadratmeter
        pub wfl_31m2_50m2: Option<i64>,
        /// Wohnfläche 51 bis 70m2
        ///
        /// Wohnfläche beträgt 51 bis 70 Quadratmeter
        pub wfl_51m2_70m2: Option<i64>,
        /// Wohnfläche 71 bis 90m2
        ///
        /// Wohnfläche beträgt 71 bis 90 Quadratmeter
        pub wfl_71m2_90m2: Option<i64>,
        /// Wohnfläche 91 bis 110m2
        ///
        /// Wohnfläche beträgt 91 bis 110 Quadratmeter
        pub wfl_91m2_110m2: Option<i64>,
        /// Wohnfläche 111 bis 130m2
        ///
        /// Wohnfläche beträgt 111 bis 130 Quadratmeter
        pub wfl_111m2_130m2: Option<i64>,
        /// Wohnfläche ab 131m2
        ///
        /// Wohnfläche beträgt ab 131 Quadratmeter
        pub wfl_131m2_max: Option<i64>,
        /// Wohnfläche unbekannt
        ///
        /// Wohnfläche der Wohnung ist unbekannt
        pub wfl_unbekannt: Option<i64>,
        /// Gebäudetyp EFH
        ///
        /// Gebäudetyp Einfamilienhaus
        pub gb_efh: Option<i64>,
        /// Gebäudetyp MFH
        ///
        /// Gebäudetyp Mehrfamilienhaus
        pub gb_mfh: Option<i64>,
        /// Gebäudetyp gemischte Nutzung
        ///
        /// Gebäudetyp gemischte Nutzung: Gewerbe- und Wohnnutzung im gleichen Gebäude
        pub gb_gemischte_nutzung: Option<i64>,
        /// Gebäudetyp andere
        ///
        /// Anderer Gebäudetyp: Mehrfamilienhaus oder gemischte Nutzung
        pub gb_andere: Option<i64>,
        /// Bauperiode bis 1920
        ///
        /// Bauperiode des Gebäudes bis 1920
        pub pd_min_1920: Option<i64>,
        /// Bauperiode 1921 bis 1950
        ///
        /// Bauperiode des Gebäudes von 1921 bis 1950
        pub pd_1921_1950: Option<i64>,
        /// Bauperiode 1951 bis 1980
        ///
        /// Bauperiode des Gebäudes von 1951 bis 1980
        pub pd_1951_1980: Option<i64>,
        /// Bauperiode 1981 bis 2010
        ///
        /// Bauperiode des Gebäudes von 1981 bis 2010
        pub pd_1981_2010: Option<i64>,
        /// Bauperiode ab 2011
        ///
        /// Bauperiode des Gebäudes ab 2011
        pub pd_2011_max: Option<i64>,
        /// Renovationsstatus renoviert
        ///
        /// Wohnung wurde renoviert, umgebaut oder totalsaniert in den letzten 2 Jahren
        pub rn_renoviert: Option<i64>,
        /// Renovationsstatus nicht renoviert
        ///
        /// Wohnung wurde nicht renoviert in den letzten 2 Jahren
        pub rn_nicht_renoviert: Option<i64>,
        /// Renovationsstatus neu gebaut
        ///
        /// Wohnung wurde neu gebaut in den letzten 2 Jahren
        pub rn_neu_gebaut: Option<i64>,
        /// Angebotsart Miete
        ///
        /// Wohnung wird nur zur Miete angeboten
        pub ang_miete: Option<i64>,
        /// Angebotsart Kauf
        ///
        /// Wohnung wird nur zum Kauf angeboten
        pub ang_kauf: Option<i64>,
        /// Angebotsart Miete und Kauf
        ///
        /// Wohnung wird zum Kauf und zur Miete angeboten
        pub ang_miete_kauf: Option<i64>,
        /// Nettomiete CHF bis 1000
        pub p_min_1000: Option<i64>,
        /// Nettomiete CHF 1001 bis 1250
        pub p_1001_1250: Option<i64>,
        /// Nettomiete CHF 1251 bis 1500
        pub p_1251_1500: Option<i64>,
        /// Nettomiete CHF 1501 bis 1750
        pub p_1501_1750: Option<i64>,
        /// Nettomiete CHF 1751 bis 2000
        pub p_1751_2000: Option<i64>,
        /// Nettomiete CHF 2001 bis 2250
        pub p_2001_2250: Option<i64>,
        /// Nettomiete CHF 2251 bis 2500
        pub p_2251_2500: Option<i64>,
        /// Nettomiete CHF 2501 bis 2750
        pub p_2501_2750: Option<i64>,
        /// Nettomiete CHF 2751 bis 3000
        pub p_2751_3000: Option<i64>,
        /// Nettomiete CHF 3001 bis 3250
        pub p_3001_3250: Option<i64>,
        /// Nettomiete CHF 3251 bis 3500
        pub p_3251_3500: Option<i64>,
        /// Nettomiete unbekannt
        ///
        /// Nettomiete ist unbekannt
        pub p_unbekannt: Option<i64>,
        /// Nettomiete CHF ab 3501
        pub p_3501_max: Option<i64>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        WovId,
        WovName,
        WohnbezirkId,
        BezLabel,
        BezName,
        Total,
        ZimmerzahlGanzzahlig,
        WflMin30m2,
        Wfl31m250m2,
        Wfl51m270m2,
        Wfl71m290m2,
        Wfl91m2110m2,
        Wfl111m2130m2,
        Wfl131m2Max,
        WflUnbekannt,
        GbEfh,
        GbMfh,
        GbGemischteNutzung,
        GbAndere,
        PdMin1920,
        Pd19211950,
        Pd19511980,
        Pd19812010,
        Pd2011Max,
        RnRenoviert,
        RnNichtRenoviert,
        RnNeuGebaut,
        AngMiete,
        AngKauf,
        AngMieteKauf,
        PMin1000,
        P10011250,
        P12511500,
        P15011750,
        P17512000,
        P20012250,
        P22512500,
        P25012750,
        P27513000,
        P30013250,
        P32513500,
        PUnbekannt,
        P3501Max,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::WohnbezirkId => "wohnbezirk_id",
                Field::BezLabel => "bez_label",
                Field::BezName => "bez_name",
                Field::Total => "total",
                Field::ZimmerzahlGanzzahlig => "zimmerzahl_ganzzahlig",
                Field::WflMin30m2 => "wfl_min_30m2",
                Field::Wfl31m250m2 => "wfl_31m2_50m2",
                Field::Wfl51m270m2 => "wfl_51m2_70m2",
                Field::Wfl71m290m2 => "wfl_71m2_90m2",
                Field::Wfl91m2110m2 => "wfl_91m2_110m2",
                Field::Wfl111m2130m2 => "wfl_111m2_130m2",
                Field::Wfl131m2Max => "wfl_131m2_max",
                Field::WflUnbekannt => "wfl_unbekannt",
                Field::GbEfh => "gb_efh",
                Field::GbMfh => "gb_mfh",
                Field::GbGemischteNutzung => "gb_gemischte_nutzung",
                Field::GbAndere => "gb_andere",
                Field::PdMin1920 => "pd_min_1920",
                Field::Pd19211950 => "pd_1921_1950",
                Field::Pd19511980 => "pd_1951_1980",
                Field::Pd19812010 => "pd_1981_2010",
                Field::Pd2011Max => "pd_2011_max",
                Field::RnRenoviert => "rn_renoviert",
                Field::RnNichtRenoviert => "rn_nicht_renoviert",
                Field::RnNeuGebaut => "rn_neu_gebaut",
                Field::AngMiete => "ang_miete",
                Field::AngKauf => "ang_kauf",
                Field::AngMieteKauf => "ang_miete_kauf",
                Field::PMin1000 => "p_min_1000",
                Field::P10011250 => "p_1001_1250",
                Field::P12511500 => "p_1251_1500",
                Field::P15011750 => "p_1501_1750",
                Field::P17512000 => "p_1751_2000",
                Field::P20012250 => "p_2001_2250",
                Field::P22512500 => "p_2251_2500",
                Field::P25012750 => "p_2501_2750",
                Field::P27513000 => "p_2751_3000",
                Field::P30013250 => "p_3001_3250",
                Field::P32513500 => "p_3251_3500",
                Field::PUnbekannt => "p_unbekannt",
                Field::P3501Max => "p_3501_max",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100010/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gesundheitsversorgung (GSV): Pflegeheime
pub mod gesundheitsversorgung_gsv_pflegeheime {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// ID-Nummer
        ///
        /// Identifikationsnummer des Pflegeheims
        pub id: Option<i64>,
        /// Pflegeheimname
        ///
        /// Name des Pflegeheims
        pub name: Option<String>,
        /// Pflegeplätze
        ///
        /// Anzahl der Pflegeplätze des Pflegeheims
        pub anzahl_pflegeplaetze: Option<i64>,
        /// Pensions- und Pflegetage
        ///
        /// Anzahl der Pensions- und Pflegetage des Pflegeheims
        pub anzahl_pensions_pflegetage: Option<i64>,
        /// Auslastung
        ///
        /// Prozentuale Auslastung des jeweiligens Pflegeheims
        pub auslastung: Option<f64>,
        /// Pflegestufe
        ///
        /// Durchschnittliche Pflegestufe des Pflegeheims
        pub pflegestufe: Option<f64>,
        /// Kosten Pension
        ///
        /// Total der Kosten für Pension und Betreuung
        pub kosten_pension_betreuung: Option<f64>,
        /// KVG-Pflegekosten
        ///
        /// Total der Kosten, die über das Krankenversicherungsgesetz (KVG) abgerechnet wurden.
        pub kvg_pflegekosten: Option<f64>,
        /// Erträge Taxeinnahmen
        ///
        /// Erträge der Taxeinnahmen
        pub ertraege_taxeinnahmen: Option<f64>,
        /// Geopunkte
        pub geopunkte: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Id,
        Name,
        AnzahlPflegeplaetze,
        AnzahlPensionsPflegetage,
        Auslastung,
        Pflegestufe,
        KostenPensionBetreuung,
        KvgPflegekosten,
        ErtraegeTaxeinnahmen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Id => "id",
                Field::Name => "name",
                Field::AnzahlPflegeplaetze => "anzahl_pflegeplaetze",
                Field::AnzahlPensionsPflegetage => "anzahl_pensions_pflegetage",
                Field::Auslastung => "auslastung",
                Field::Pflegestufe => "pflegestufe",
                Field::KostenPensionBetreuung => "kosten_pension_betreuung",
                Field::KvgPflegekosten => "kvg_pflegekosten",
                Field::ErtraegeTaxeinnahmen => "ertraege_taxeinnahmen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100318/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gestorbene nach Altersklasse, Geschlecht und Sterbedatum
pub mod gestorbene_nach_altersklasse_geschlecht_und_sterbedatum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr des Todesfalls
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat des Todesfalls
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Laufnummer der Woche innerhalb eines Jahres
        pub woche_in_jahr: Option<i64>,
        /// Startdatum Woche
        ///
        /// Datum des Montags der Woche
        pub datum_wochenstart_sterbedatum: Option<Date>,
        /// Tag-Nr.
        ///
        /// Laufnummer des Tages innerhalb eines Jahres
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Sterbedatum
        ///
        /// Datum des Todesfalls
        pub sterbedatum: Option<Date>,
        /// Anzahl Männer 0-64
        ///
        /// Gestorbene Männer im Alter zwischen 0 und 64 Jahren
        pub anz_maenner_0_64: Option<i64>,
        /// Anzahl Männer 65+
        ///
        /// Gestorbene Männer im Alter von 65 und mehr Jahren
        pub anz_maenner_65_plus: Option<i64>,
        /// Anzahl Frauen 0-64
        ///
        /// Gestorbene Frauen im Alter zwischen 0 und 64 Jahren
        pub anz_frauen_0_64: Option<i64>,
        /// Anzahl Frauen 65+
        ///
        /// Gestorbene Frauen im Alter von 65 und mehr Jahren
        pub anz_frauen_65_plus: Option<i64>,
        /// Anzahl Gestorbene total
        ///
        /// Total gestorbene Personen an einem Tag
        pub anz_total: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartSterbedatum,
        TagInJahr,
        Wochentag,
        Sterbedatum,
        AnzMaenner064,
        AnzMaenner65Plus,
        AnzFrauen064,
        AnzFrauen65Plus,
        AnzTotal,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartSterbedatum => "datum_wochenstart_sterbedatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::Sterbedatum => "sterbedatum",
                Field::AnzMaenner064 => "anz_maenner_0_64",
                Field::AnzMaenner65Plus => "anz_maenner_65_plus",
                Field::AnzFrauen064 => "anz_frauen_0_64",
                Field::AnzFrauen65Plus => "anz_frauen_65_plus",
                Field::AnzTotal => "anz_total",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100079/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Dokumente
pub mod grosser_rat_dokumente {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Dokumentendatum
        ///
        /// Datum des Dokuments (entweder letztes Bearbeitungsdatum oder im Text explizit genanntes Dokumentendatum)
        pub dokudatum: Option<Date>,
        /// Laufnummer Dokument
        ///
        /// Laufnummer des Dokuments
        pub dok_laufnr: Option<String>,
        /// Signatur Dokument
        ///
        /// Signatur des Dokuments
        pub signatur_dok: Option<String>,
        /// Titel Dokument
        ///
        /// Nummer und Titel des Dokuments
        pub titel_dok: Option<String>,
        /// Link Dokument
        ///
        /// Link zum Dokument auf der Webseite des Grossen Rates
        pub url_dok: Option<String>,
        /// Laufnummer Geschäft
        ///
        /// Laufnummer des Hauptgeschäfts zum zugehörigen Dokument
        pub laufnr_ges: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Hauptgeschäfts zum zugehörigen Dokument
        pub signatur_ges: Option<String>,
        /// Status Geschäft
        ///
        /// Status des Hauptgeschäfts zum zugehörigen Dokument (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Hauptgeschäfts zum zugehörigen Dokument
        pub titel_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Hauptgeschäfts zum zugehörigen Dokument
        pub ga_rr_gr: Option<String>,
        /// Geschäft grosserrat.bs.ch
        ///
        /// Link zum Hauptgeschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach Hauptgeschäft des aktuellen Dokuments.
        pub url_geschaeft_ods: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Dokudatum,
        DokLaufnr,
        SignaturDok,
        TitelDok,
        UrlDok,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        GaRrGr,
        UrlGes,
        UrlGeschaeftOds,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Dokudatum => "dokudatum",
                Field::DokLaufnr => "dok_laufnr",
                Field::SignaturDok => "signatur_dok",
                Field::TitelDok => "titel_dok",
                Field::UrlDok => "url_dok",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100313/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Monatliche Sterberaten nach Geschlecht und Altersgruppe
pub mod monatliche_sterberaten_nach_geschlecht_und_altersgruppe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr des Todes
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat des Todes
        pub monat: Option<i64>,
        /// Jahr und Monat
        ///
        /// Jahr und Monat des Todes in einer Spalte
        pub jahr_monat: Option<Date>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Altersgruppe
        ///
        /// Altersgruppe des Verstorbenen.
        pub altersgruppen: Option<String>,
        /// Anzahl Verstorbene
        ///
        /// Gemeldete Anzahl Verstorbene im jeweiligen Jahr, Monat, Geschlecht und Altersgruppe. Quelle: Kantonale Bevölkerungsstatistik
        pub beobachtet_tote: Option<i64>,
        /// Mittlere Bevölkerung
        ///
        /// Mittlere Bevölkerung zum jeweiligen Zeitpunkt des Monats und Jahres für die entsprechende Altersgruppe und Geschlecht. Quelle: Kantonale Bevölkerungsstatistik
        pub mittlere_bev: Option<i64>,
        /// Rohe Sterbeziffer pro 1000 Einwohner
        ///
        /// Anzahl Verstorbene pro 1000 Einwohner des jeweiligen Monats und Jahres für die entsprechende Altersgruppe und Geschlecht. Die Kennzahl berechnet sich aus der Anzahl Todesfälle geteilt durch die mittlere Bevölkerung mal 1000.
        pub sterberate_1000_roh: Option<f64>,
        /// Erwartete Anzahl Verstorbene
        ///
        /// Anhand der rohen Sterbeziffer und der entsprechenden Referenzbevölkerung wird die Anzahl zu erwartender Todesfälle für die jeweilige Gruppe berechnet, unter der Annahme, dass die Bevölkerungsstruktur über die Zeit konstant geblieben wäre.
        pub erwartet_tote: Option<i64>,
        /// Mittlere Referenzbevölkerung
        ///
        /// Die mittlere Bevölkerung des Monats Januar des Jahres 2012 dient als Referenzbevölkerung. Diese Zahl ist für die jeweilige Altersgruppe und Geschlecht konstant und dient dazu die standardisierten Sterberaten zu berechnen, um Vergleiche über die Zeit zu ermöglichen.
        pub mittlere_bev_referenz: Option<i64>,
        /// Standardisierte Sterberate
        ///
        /// Durch Division der erwarteten Todesfälle durch die Referenzbevölkerung lässt sich eine standardisierte Sterberate berechnen. Diese Zahl ermöglicht einen Vergleich über die Zeit unter der Annahme, dass sich die Bevölkerungsstruktur nicht verändert. Für die Altersgruppe Alle" ergibt das eine altersbereinigte Sterberate für das jeweilige Geschlecht."
        pub smr_1000: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        JahrMonat,
        Geschlecht,
        Altersgruppen,
        BeobachtetTote,
        MittlereBev,
        Sterberate1000Roh,
        ErwartetTote,
        MittlereBevReferenz,
        Smr1000,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::JahrMonat => "jahr_monat",
                Field::Geschlecht => "geschlecht",
                Field::Altersgruppen => "altersgruppen",
                Field::BeobachtetTote => "beobachtet_tote",
                Field::MittlereBev => "mittlere_bev",
                Field::Sterberate1000Roh => "sterberate_1000_roh",
                Field::ErwartetTote => "erwartet_tote",
                Field::MittlereBevReferenz => "mittlere_bev_referenz",
                Field::Smr1000 => "smr_1000",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100173/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Baumkataster: Baumbestand
pub mod baumkataster_baumbestand {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// Baumnummer
        ///
        /// Eindeutige Nummer des Baums
        pub baumnr: Option<String>,
        /// Baumart
        ///
        /// Botanische und deutsche Bezeichnung der Baumart
        pub art: Option<String>,
        /// Baumart lateinisch
        ///
        /// Botanische Bezeichnung der Baumart
        pub baumart_lateinisch: Option<String>,
        /// Baumart deutsch
        ///
        /// Deutsche Bezeichnung der Baumart
        pub baumart_deutsch: Option<String>,
        /// Pflanzdatum
        ///
        /// Datum der Baumpflanzung am aktuellen Ort, wenn bekannt; In der Regel werden Bäume in einem Alter von ca. 10 Jahren gepflanzt.
        pub pflanzdatu: Option<Date>,
        /// Baumalter
        ///
        /// Alter des Baumes bei Publikation des Datensatzes. Entspricht in der Regel der Spalte «Standjahr» plus ca. 10 Jahre.
        pub baumalter: Option<i64>,
        /// Standjahr
        ///
        /// Anzahl Jahre, während derer der Baum am aktuellen Ort steht. Entspricht der Anzahl Jahre, welche zwischen dem Pflanzdatum und der Publikation der Datensatzes liegt.
        pub standjahr: Option<i64>,
        /// ID_Schutzstatus
        ///
        /// ID des Schutzstatus
        pub id_schutzs: Option<i64>,
        /// Schutzstatus
        ///
        /// Beschreibung des Schutzstatus: "Geschützt (Umfang)": Geschützt wegen gemessenem Baumumfang. "Gemäss Baumschutzgesetz (BSchG)": Baumumfang wurde nicht unbedingt aktuell gemessen, Baum wurde trotzdem konservativ als geschützt eingeteilt. "Geschützt (Ersatzpflanzung)": Aktueller Baum ist geschützt, da er einen vormalig geschützten Baum ersetzt.
        pub schutzstat: Option<String>,
        /// Strasse
        ///
        /// Strasse des Baumstandortes
        pub strasse: Option<String>,
        /// Kreis
        ///
        /// Gebietseinteilung durch die Stadtgärtnerei
        pub kreis: Option<String>,
        /// ID_Gruppe
        ///
        /// ID der Gruppe
        pub id_gruppe: Option<i64>,
        /// Gruppe
        ///
        /// Beschreibung der Gruppe
        pub gruppe: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinde des Baumstandorts
        pub gemeinde: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Baumnr,
        Art,
        BaumartLateinisch,
        BaumartDeutsch,
        Pflanzdatu,
        Baumalter,
        Standjahr,
        IdSchutzs,
        Schutzstat,
        Strasse,
        Kreis,
        IdGruppe,
        Gruppe,
        Gemeinde,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Baumnr => "baumnr",
                Field::Art => "art",
                Field::BaumartLateinisch => "baumart_lateinisch",
                Field::BaumartDeutsch => "baumart_deutsch",
                Field::Pflanzdatu => "pflanzdatu",
                Field::Baumalter => "baumalter",
                Field::Standjahr => "standjahr",
                Field::IdSchutzs => "id_schutzs",
                Field::Schutzstat => "schutzstat",
                Field::Strasse => "strasse",
                Field::Kreis => "kreis",
                Field::IdGruppe => "id_gruppe",
                Field::Gruppe => "gruppe",
                Field::Gemeinde => "gemeinde",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100052/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): In Basel-Stadt verabreichte Impfungen
pub mod coronavirus_covid_19_in_basel_stadt_verabreichte_impfungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Total verabreichte Impfungen
        ///
        /// Total bis dato im Kanton Basel-Stadt gegen SARS-CoV-2 verabreichte Impfungen
        pub total_verabreichte_impfungen: Option<i64>,
        /// Total Personen mit erster Dosis
        ///
        /// Total Personen, welche bis dato im Kanton Basel-Stadt mit mindestens einer Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_erster_dosis: Option<i64>,
        /// Total Personen mit ausschliesslich erster Dosis
        ///
        /// Total Personen, welche bis dato im Kanton Basel-Stadt ausschliesslich mit erster Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_ausschliesslich_erster_dosis: Option<i64>,
        /// Total Personen mit zweiter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit zweiter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_zweiter_dosis: Option<i64>,
        /// Total Personen mit dritter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit dritter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_dritter_dosis: Option<i64>,
        /// Total Personen mit vierter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit vierter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_vierter_dosis: Option<i64>,
        /// Total Personen mit fünfter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit fünfter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_fuenfter_dosis: Option<i64>,
        /// Im Impfzentrum verabreichte Impfungen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum gegen SARS-CoV-2 verabreichte Impfungen pro Tag
        pub im_impfzentrum_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit erster Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit erster Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit zweiter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit zweiter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit dritter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit dritter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit vierter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit vierter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit fünfter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit fünfter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen verabreichte Impfungen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen gegen SARS-CoV-2 verabreichte Impfungen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub in_aph_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit erster Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit erster Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit zweiter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit zweiter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit dritter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit dritter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit vierter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit vierter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit fünfter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit fünfter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Total verabreichte Impfungen pro Tag
        ///
        /// Total im Kanton Basel-Stadt gegen SARS-CoV-2 verabreichte Impfungen pro Tag
        pub total_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Im Spital verabreichte Impfungen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern gegen SARS-CoV-2 verabreichte Impfungen pro Tag
        pub im_spital_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Im Spital mit erster Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit erster Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit zweiter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit zweiter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit dritter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit dritter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit vierter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit vierter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit fünfter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit fünfter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo verabreichte Impfungen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Anderswo mit erster Dosis geimpfte Personen pro tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit erster Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit zweiter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit zweiter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit dritter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit dritter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit vierter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit vierter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit fünfter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit fünfter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Total Auffrischimpfungen (Booster)
        ///
        /// Total der im Rahmen der Auffrischimpfung (Booster) verabreichte Impfungen
        pub total_auffrischimpfungen: Option<i64>,
        /// Auffrischimpfungen (Booster) pro Tag
        ///
        /// Anzahl der im Rahmen der Auffrischimpfung (Booster) verabreichte Impfungen an einem Tag
        pub auffrischimpfungen_pro_tag: Option<i64>,
        /// Total Drittimpfungen (oder mehr) als Teil der Grundimmunisierung
        ///
        /// Total der im Rahmen der Grundimmunisierung mit dritter (oder mehr) Dosis verabreichten Impfungen
        pub total_drittimpfungen_u_m_grundimmunisierung: Option<i64>,
        /// Drittimpfungen (oder mehr) als Teil der Grundimmunisierung pro Tag
        ///
        /// Anzahl der im Rahmen der Grundimmunisierung mit dritter (oder mehr) Dosis verabreichten Impfungen
        pub drittimpfungen_u_m_grundimmunisierung_pro_tag: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        TotalVerabreichteImpfungen,
        TotalPersonenMitErsterDosis,
        TotalPersonenMitAusschliesslichErsterDosis,
        TotalPersonenMitZweiterDosis,
        TotalPersonenMitDritterDosis,
        TotalPersonenMitVierterDosis,
        TotalPersonenMitFuenfterDosis,
        ImImpfzentrumVerabreichteImpfungenProTag,
        ImImpfzentrumMitErsterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitZweiterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitDritterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitVierterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitFuenfterDosisGeimpftePersonenProTag,
        InAphVerabreichteImpfungenProTag,
        ImAphMitErsterDosisGeimpftePersonenProTag,
        ImAphMitZweiterDosisGeimpftePersonenProTag,
        ImAphMitDritterDosisGeimpftePersonenProTag,
        ImAphMitVierterDosisGeimpftePersonenProTag,
        ImAphMitFuenfterDosisGeimpftePersonenProTag,
        TotalVerabreichteImpfungenProTag,
        ImSpitalVerabreichteImpfungenProTag,
        ImSpitalMitErsterDosisGeimpftePersonenProTag,
        ImSpitalMitZweiterDosisGeimpftePersonenProTag,
        ImSpitalMitDritterDosisGeimpftePersonenProTag,
        ImSpitalMitVierterDosisGeimpftePersonenProTag,
        ImSpitalMitFuenfterDosisGeimpftePersonenProTag,
        AnderswoVerabreichteImpfungenProTag,
        AnderswoMitErsterDosisGeimpftePersonenProTag,
        AnderswoMitZweiterDosisGeimpftePersonenProTag,
        AnderswoMitDritterDosisGeimpftePersonenProTag,
        AnderswoMitVierterDosisGeimpftePersonenProTag,
        AnderswoMitFuenfterDosisGeimpftePersonenProTag,
        TotalAuffrischimpfungen,
        AuffrischimpfungenProTag,
        TotalDrittimpfungenUMGrundimmunisierung,
        DrittimpfungenUMGrundimmunisierungProTag,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::TotalVerabreichteImpfungen => "total_verabreichte_impfungen",
                Field::TotalPersonenMitErsterDosis => "total_personen_mit_erster_dosis",
                Field::TotalPersonenMitAusschliesslichErsterDosis => {
                    "total_personen_mit_ausschliesslich_erster_dosis"
                }
                Field::TotalPersonenMitZweiterDosis => "total_personen_mit_zweiter_dosis",
                Field::TotalPersonenMitDritterDosis => "total_personen_mit_dritter_dosis",
                Field::TotalPersonenMitVierterDosis => "total_personen_mit_vierter_dosis",
                Field::TotalPersonenMitFuenfterDosis => "total_personen_mit_fuenfter_dosis",
                Field::ImImpfzentrumVerabreichteImpfungenProTag => {
                    "im_impfzentrum_verabreichte_impfungen_pro_tag"
                }
                Field::ImImpfzentrumMitErsterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitZweiterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitDritterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitVierterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitFuenfterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::InAphVerabreichteImpfungenProTag => "in_aph_verabreichte_impfungen_pro_tag",
                Field::ImAphMitErsterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitZweiterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitDritterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitVierterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitFuenfterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::TotalVerabreichteImpfungenProTag => "total_verabreichte_impfungen_pro_tag",
                Field::ImSpitalVerabreichteImpfungenProTag => {
                    "im_spital_verabreichte_impfungen_pro_tag"
                }
                Field::ImSpitalMitErsterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitZweiterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitDritterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitVierterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitFuenfterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoVerabreichteImpfungenProTag => {
                    "anderswo_verabreichte_impfungen_pro_tag"
                }
                Field::AnderswoMitErsterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitZweiterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitDritterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitVierterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitFuenfterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::TotalAuffrischimpfungen => "total_auffrischimpfungen",
                Field::AuffrischimpfungenProTag => "auffrischimpfungen_pro_tag",
                Field::TotalDrittimpfungenUMGrundimmunisierung => {
                    "total_drittimpfungen_u_m_grundimmunisierung"
                }
                Field::DrittimpfungenUMGrundimmunisierungProTag => {
                    "drittimpfungen_u_m_grundimmunisierung_pro_tag"
                }
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100111/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Tagesordnungen und Traktandenlisten der Grossratssitzungen
pub mod grosser_rat_tagesordnungen_und_traktandenlisten_der_grossratssitzungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Tagesordnung-ID
        ///
        /// Individuelle Identifikationsnummer der Tagesordnung
        pub tagesordnung_idnr: Option<i64>,
        /// Versanddatum Tagesordnung
        ///
        /// Datum der Aufschaltung und Publikation der Tagesordnung
        #[serde(with = "time::serde::iso8601::option")]
        pub versand: Option<OffsetDateTime>,
        /// Tag 1
        ///
        /// Datum der ersten Sitzung der Tagesordnung
        pub tag1: Option<Date>,
        /// Sitzungstyp Tag 1
        ///
        /// Beschreibung der ersten Sitzung
        pub text1: Option<String>,
        /// Tag 2
        ///
        /// Datum der zweiten Sitzung der Tagesordnung
        pub tag2: Option<Date>,
        /// Sitzungstyp Tag 2
        ///
        /// Beschreibung der zweiten Sitzung
        pub text2: Option<String>,
        /// Tag 3
        ///
        /// Datum der dritten Sitzung der Tagesordnung
        pub tag3: Option<Date>,
        /// Sitzungstyp Tag 3
        ///
        /// Beschreibung der dritten Sitzung
        pub text3: Option<String>,
        /// Bemerkung
        ///
        /// Weitere Informationen zur Tagesordnung
        pub bemerkung: Option<String>,
        /// Tagesordnung auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument der Tagesordnung
        pub url_tagesordnung_dok: Option<String>,
        /// Geschäftsverzeichnis auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument des Geschäftsverzeichnisses
        pub url_geschaeftsverzeichnis: Option<String>,
        /// Sammelmappe auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument der Sammelmappe
        pub url_sammelmappe: Option<String>,
        /// ZIP-Archiv der Session (Achtung - grosse Datei)
        ///
        /// Link zum PDF-Dokument des ZIP-Archivs
        pub url_alle_dokumente: Option<String>,
        /// Vollprotokoll auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument des Vollprotokolls, falls vorhanden
        pub url_vollprotokoll: Option<String>,
        /// Audio-Protokoll Tag 1
        ///
        /// Link zu den Ton- und Videoaufzeichnungen der ersten Sitzung auf protokolle.grosserrat-basel.ch (bis und mit Juni 2023)
        pub url_audioprotokoll_tag1: Option<String>,
        /// Audio-Protokoll Tag 2
        ///
        /// Link zu den Ton- und Videoaufzeichnungen der zweiten Sitzung auf protokolle.grosserrat-basel.ch (bis und mit Juni 2023)
        pub url_audioprotokoll_tag2: Option<String>,
        /// Audio-Protokoll Tag 3
        ///
        /// Link zu den Ton- und Videoaufzeichnungen der dritten Sitzung auf protokolle.grosserrat-basel.ch (bis und mit Januar 2023)
        pub url_audioprotokoll_tag3: Option<String>,
        /// Gruppennummer
        ///
        /// Nummer der Gruppe des Traktandums
        pub gruppennummer: Option<i64>,
        /// Gruppentitel
        ///
        /// Gruppentitel des Traktandums
        pub gruppentitel: Option<String>,
        /// Gruppentitel Position
        ///
        /// Erste Laufnummer der Gruppe
        pub gruppentitel_pos: Option<i64>,
        /// Traktandum-ID
        ///
        /// Individuelle Identifikationsnummer des Traktandums
        pub traktanden_idnr: Option<i64>,
        /// Laufnummer
        pub laufnr: Option<i64>,
        /// Laufnummer 2
        ///
        /// Weitergehende Laufnummer
        pub laufnr_2: Option<i64>,
        /// Status
        ///
        /// Status des Traktandums (erledigt, offen, in Behandlung, abgesetzt, zurückgezogen, 2. Lesung, verschoben)
        pub status: Option<String>,
        /// Titel
        ///
        /// Titel des Traktandums
        pub titel: Option<String>,
        /// Kommissionen
        ///
        /// Die für das Traktandum zuständigen Kommissionen
        pub kommission: Option<String>,
        /// Departemente
        ///
        /// Die für das Traktandum zuständigen Departemente
        pub departement: Option<String>,
        /// Signaturen
        ///
        /// Die zu dem Traktandum zugehörigen Dokumenten-Signaturen (getrennt durch Komma)
        pub signatur: Option<String>,
        /// Geschäfte auf grosserrat.bs.ch
        ///
        /// Links der Geschäfte auf die Webseite des Grossen Rates (getrennt durch Semikolon)
        pub url_ges: Option<String>,
        /// Geschäfte auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach den Geschäften in den Signaturen.
        pub url_geschaeft_ods: Option<String>,
        /// Dokumente auf grosserrat.bs.ch
        ///
        /// Links der Dokumente auf der Webseite des Grossen Rates (getrennt durch Semikolon)
        pub url_dok: Option<String>,
        /// Dokumente auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Dokumente". Gefiltert nach den Signaturen.
        pub url_dokument_ods: Option<String>,
        /// Abstimmungen
        ///
        /// Die zu dem Traktandum zugehörige Abstimmungen. Gespeichert im JSON-Format
        pub abstimmung: Option<String>,
        /// Abstimmungsnummern
        ///
        /// Die dem Traktandum zugehörigen Nummern der Abstimmungen (getrennt durch Komma)
        pub anr: Option<String>,
        /// Abstimmungen auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Live-Abstimmungsergebnisse". Gefiltert nach den Abstimmungen.
        pub url_abstimmungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TagesordnungIdnr,
        Versand,
        Tag1,
        Text1,
        Tag2,
        Text2,
        Tag3,
        Text3,
        Bemerkung,
        UrlTagesordnungDok,
        UrlGeschaeftsverzeichnis,
        UrlSammelmappe,
        UrlAlleDokumente,
        UrlVollprotokoll,
        UrlAudioprotokollTag1,
        UrlAudioprotokollTag2,
        UrlAudioprotokollTag3,
        Gruppennummer,
        Gruppentitel,
        GruppentitelPos,
        TraktandenIdnr,
        Laufnr,
        Laufnr2,
        Status,
        Titel,
        Kommission,
        Departement,
        Signatur,
        UrlGes,
        UrlGeschaeftOds,
        UrlDok,
        UrlDokumentOds,
        Abstimmung,
        Anr,
        UrlAbstimmungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TagesordnungIdnr => "tagesordnung_idnr",
                Field::Versand => "versand",
                Field::Tag1 => "tag1",
                Field::Text1 => "text1",
                Field::Tag2 => "tag2",
                Field::Text2 => "text2",
                Field::Tag3 => "tag3",
                Field::Text3 => "text3",
                Field::Bemerkung => "bemerkung",
                Field::UrlTagesordnungDok => "url_tagesordnung_dok",
                Field::UrlGeschaeftsverzeichnis => "url_geschaeftsverzeichnis",
                Field::UrlSammelmappe => "url_sammelmappe",
                Field::UrlAlleDokumente => "url_alle_dokumente",
                Field::UrlVollprotokoll => "url_vollprotokoll",
                Field::UrlAudioprotokollTag1 => "url_audioprotokoll_tag1",
                Field::UrlAudioprotokollTag2 => "url_audioprotokoll_tag2",
                Field::UrlAudioprotokollTag3 => "url_audioprotokoll_tag3",
                Field::Gruppennummer => "gruppennummer",
                Field::Gruppentitel => "gruppentitel",
                Field::GruppentitelPos => "gruppentitel_pos",
                Field::TraktandenIdnr => "traktanden_idnr",
                Field::Laufnr => "laufnr",
                Field::Laufnr2 => "laufnr_2",
                Field::Status => "status",
                Field::Titel => "titel",
                Field::Kommission => "kommission",
                Field::Departement => "departement",
                Field::Signatur => "signatur",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
                Field::UrlDok => "url_dok",
                Field::UrlDokumentOds => "url_dokument_ods",
                Field::Abstimmung => "abstimmung",
                Field::Anr => "anr",
                Field::UrlAbstimmungen => "url_abstimmungen",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100348/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Zuweisungen von Geschäften
pub mod grosser_rat_zuweisungen_von_geschaeften {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kurzname Gremium An
        ///
        /// Kurzname des Gremiums, dem das Geschäft zugewiesen wurde
        pub kurzname_an: Option<String>,
        /// Name Gremium An
        ///
        /// Name des Gremiums, dem das Geschäft zugewiesen wurde
        pub name_an: Option<String>,
        /// ID Gremium An
        ///
        /// Individuelle Identifikationsnummer des Gremiums, dem das Geschäft zugewiesen wurde, innerhalb der Datenbank des Grossen Rates
        pub uni_nr_an: Option<String>,
        /// Link Gremium An
        ///
        /// Link zum Datensatz "Grosser Rat: Gremium". Gefiltert nach dem aktuellen Gremium, dem das Geschäft zugewiesen wurde.
        pub url_gremium_an: Option<String>,
        /// Erledigt Datum
        ///
        /// Datum, an dem die zugewiesene Aufgabe erledigt wurde
        pub erledigt: Option<Date>,
        /// Status Zuweisung
        ///
        /// Status der Zuweisung (In Bearbeitung, Fertig, Abgeschlossen oder Abgebrochen). "Abgeschlossen" und "Fertig" unterscheiden sich nur darin, dass bei "Fertig" nur die zugewiesene Aufgabe abgeschlossen ist, aber noch nicht das ganze Geschäft.
        pub status_zuw: Option<String>,
        /// Termin Zuweisung
        ///
        /// Datum, an dem die Zuweisung abgeschlossen sein soll.
        pub termin: Option<Date>,
        /// Titel Zuweisung
        ///
        /// Titel der Zuweisung
        pub titel_zuw: Option<String>,
        /// Bemerkung
        ///
        /// Bemerkung zur Zuweisung
        pub bem: Option<String>,
        /// Laufnummer Geschäft
        ///
        /// Laufnummer des Geschäfts zur zugehörigen Zuweisung
        pub laufnr_ges: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Geschäfts zur zugehörigen Zuweisung
        pub signatur_ges: Option<String>,
        /// Status Geschäft
        ///
        /// Status des Geschäfts zur zugehörigen Zuweisung (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Geschäfts zur zugehörigen Zuweisung
        pub titel_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Geschäfts zur zugehörigen Zuweisung
        pub ga_rr_gr: Option<String>,
        /// Geschäft grosserrat.bs.ch
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach aktuellem Geschäft.
        pub url_geschaeft_ods: Option<String>,
        /// Kurzname Gremium Von
        ///
        /// Kurzname des Gremiums, das das Geschäft zuweist
        pub kurzname_von: Option<String>,
        /// Name Gremium Von
        ///
        /// Name des Gremiums, das das Geschäft zuweist
        pub name_von: Option<String>,
        /// ID Gremium Von
        ///
        /// Individuelle Identifikationsnummer des Gremiums, das das Geschäft zuweist, innerhalb der Datenbank des Grossen Rates
        pub uni_nr_von: Option<String>,
        /// Link Gremium Von
        ///
        /// Link zum Datensatz "Grosser Rat: Gremium". Gefiltert nach dem aktuellem Gremium, das das Geschäft zugewiesen hat.
        pub url_gremium_von: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        KurznameAn,
        NameAn,
        UniNrAn,
        UrlGremiumAn,
        Erledigt,
        StatusZuw,
        Termin,
        TitelZuw,
        Bem,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        GaRrGr,
        UrlGes,
        UrlGeschaeftOds,
        KurznameVon,
        NameVon,
        UniNrVon,
        UrlGremiumVon,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::KurznameAn => "kurzname_an",
                Field::NameAn => "name_an",
                Field::UniNrAn => "uni_nr_an",
                Field::UrlGremiumAn => "url_gremium_an",
                Field::Erledigt => "erledigt",
                Field::StatusZuw => "status_zuw",
                Field::Termin => "termin",
                Field::TitelZuw => "titel_zuw",
                Field::Bem => "bem",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
                Field::KurznameVon => "kurzname_von",
                Field::NameVon => "name_von",
                Field::UniNrVon => "uni_nr_von",
                Field::UrlGremiumVon => "url_gremium_von",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100312/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// EuroAirport: Tägliche Flugbewegungen, Passagiere und Fracht
pub mod euroairport_taegliche_flugbewegungen_passagiere_und_fracht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub date: Option<Date>,
        /// Kategorie
        ///
        /// Andere Kategorien = allgemeiner und anderer nicht-gewerblicher Verkehr
        pub kategorie: Option<String>,
        /// Flugpassagiere
        ///
        /// Anzahl Passagiere
        pub pax: Option<i64>,
        /// Luftfracht
        ///
        /// in Tonnen
        pub fret: Option<f64>,
        /// Flugbewegungen
        ///
        /// Starts und Landungen
        pub mvt: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Date,
        Kategorie,
        Pax,
        Fret,
        Mvt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Kategorie => "kategorie",
                Field::Pax => "pax",
                Field::Fret => "fret",
                Field::Mvt => "mvt",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100078/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Bezirk
pub mod wohnbevoelkerung_nach_bezirk {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// Wohnviertel-ID
        pub wov_id: Option<String>,
        /// Bezirk
        pub wohnbezirk: Option<String>,
        /// Bezirks-ID
        pub bez_id: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
        /// Monat
        pub monat: Option<i64>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Wohnviertel,
        WovId,
        Wohnbezirk,
        BezId,
        Gemeinde,
        Anzahl,
        Jahr,
        Monat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Wohnviertel => "wohnviertel",
                Field::WovId => "wov_id",
                Field::Wohnbezirk => "wohnbezirk",
                Field::BezId => "bez_id",
                Field::Gemeinde => "gemeinde",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100125/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Feinstaubmessungen auf BVB-Trams
pub mod feinstaubmessungen_auf_bvb_trams {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum und Zeit
        ///
        /// Datum und Zeit in UTC
        #[serde(with = "time::serde::iso8601::option")]
        pub time: Option<OffsetDateTime>,
        /// Sensoren-ID
        ///
        /// Identitätsnummer des Feinstaubsensors
        ///Sensoren 236 und 240 sind stationär aufgestellt.
        ///Sensoren 227, 228, 234, 235 und 237 sind auf den Trams montiert.
        pub sensornr: Option<i64>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm25: Option<f64>,
        /// PM10
        ///
        /// Feinstaub mit Partikelgrösse < 10 tausendstel Millimeter
        pub pm10: Option<f64>,
        /// Geopunkte
        ///
        /// Standort der Messung
        pub column_7: Option<GeoPoint2d>,
        /// Längengrad
        pub longitude: Option<f64>,
        /// Breitengrad
        pub latitude: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Time,
        Sensornr,
        Pm25,
        Pm10,
        Longitude,
        Latitude,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Time => "time",
                Field::Sensornr => "sensornr",
                Field::Pm25 => "pm25",
                Field::Pm10 => "pm10",
                Field::Longitude => "longitude",
                Field::Latitude => "latitude",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100113/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// BachApp: Extras
pub mod bachapp_extras {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        pub sichtbar_bis: Option<Date>,
        /// Status
        pub status: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Untertitel
        pub untertitel: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        SichtbarVon,
        SichtbarBis,
        Status,
        Titel,
        Untertitel,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Status => "status",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100290/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Veranstaltungen mit potenziellem Einfluss auf Veloverkehr
pub mod veranstaltungen_mit_potenziellem_einfluss_auf_veloverkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Termin-ID
        ///
        /// ID eines Termins. Beispiel: Der Bummelsonntag hat innerhalb eines Jahres verschiedene Termin-Ids.
        pub termin_key: Option<i64>,
        /// Veranstaltung-ID
        ///
        /// ID einer Veranstaltung über alle Jahre. Beispiel: Die Fasnacht hat über alle Jahre dieselbe Veranstaltungs-ID.
        pub veranstaltung_key: Option<i64>,
        /// Name
        ///
        /// Name der Veranstaltung
        pub name: Option<String>,
        /// Code
        ///
        /// Code der Veranstaltung
        pub code: Option<String>,
        /// Kategorie
        ///
        /// Kategorie der Veranstaltung
        pub kategorie_name: Option<String>,
        /// Aktiv-Code
        ///
        /// Anzeige, ob eine Veranstaltung noch durchgeführt wird oder nicht. Wertebereich: 1=aktiv, 0=inaktiv.
        pub aktiv_code: Option<i64>,
        /// Wiederkehrend-Code
        ///
        /// Anzeige, ob eine Veranstaltung einmal oder mehrmals durchgeführt wird. Wertebereich: 1=wiederkehrend, 0=nicht wiederkehrend.
        pub wiederkehrend_code: Option<i64>,
        /// Start der Erfassung
        ///
        /// Datum, ab welchem eine Veranstaltung erfasst wurde.
        pub erfasst_ab: Option<Date>,
        /// Veranstaltungstag
        ///
        /// Tag, an welchem eine Veranstaltung stattfindet
        pub tag_datum: Option<Date>,
        /// Jahr
        ///
        /// Jahr, in welchem eine Veranstaltung stattfindet
        pub jahr_nummer: Option<String>,
        /// Dauer in Tagen
        ///
        /// Dauer der Veranstaltung in Tagen
        pub dauer_in_tagen: Option<i64>,
        /// Startdatum
        ///
        /// Erster Tag der Veranstaltung
        pub datum_von: Option<Date>,
        /// Enddatum
        ///
        /// Letzter Tag der Veranstaltung
        pub datum_bis: Option<Date>,
        /// Blockseite
        ///
        /// Blockseite, an der die Veranstaltung stattfindet; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub eingang_id_blockseite: Option<i64>,
        /// Geo-Punkt
        ///
        /// Geo-Koordinaten; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate des Gebäudes; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht) wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub gebaeude_koordinate_x: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate des Gebäudes;Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub gebaeude_koordinate_y: Option<String>,
        /// Strassenname
        ///
        /// Strassenname; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub strasse_name_kanton: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, an welcher die Veranstaltung stattfindet; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub eingang_hausnummer: Option<String>,
        /// Block-ID
        ///
        /// ID des Blocks; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnblock_id_kdm_vzbbb: Option<i64>,
        /// Bezirk-ID
        ///
        /// ID des Bezirks; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnbezirk_id_kdm: Option<i64>,
        /// Bezirk
        ///
        /// Name des Bezirks; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnbezirk_name: Option<String>,
        /// Wohnviertel-ID
        ///
        /// ID des Wohnviertels oder der Landgemeinde; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnviertel_id_kdm: Option<i64>,
        /// Wohnviertel
        ///
        /// Name des Wohnviertels oder der Landgemeinde; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnviertel_name: Option<String>,
        /// Gemeinde
        ///
        /// Name der Gemeinde; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub gemeinde_name: Option<String>,
        /// Wiederkehrend
        ///
        /// Anzeige, ob eine Veranstaltung einmal oder mehrmals durchgeführt wird.
        pub wiederkehrend: Option<String>,
        /// Aktiv
        ///
        /// Anzeige, ob eine Veranstaltung noch durchgeführt wird oder nicht.
        pub aktiv: Option<String>,
        /// Beschreibung
        ///
        /// Beschreibung der Veranstaltung
        pub beschreibung: Option<String>,
        /// Bemerkungen
        ///
        /// Bemerkungen zur Veranstaltung
        pub veranstaltung_bemerkung: Option<String>,
        /// Hinweise
        ///
        /// Hinweise zu einem Termin
        pub termin_bemerkung: Option<String>,
        /// Beschreibung der Kategorie
        ///
        /// Beschreibung der Veranstaltungskategorie
        pub kategorie_beschreibung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TerminKey,
        VeranstaltungKey,
        Name,
        Code,
        KategorieName,
        AktivCode,
        WiederkehrendCode,
        ErfasstAb,
        TagDatum,
        JahrNummer,
        DauerInTagen,
        DatumVon,
        DatumBis,
        EingangIdBlockseite,
        GebaeudeKoordinateX,
        GebaeudeKoordinateY,
        StrasseNameKanton,
        EingangHausnummer,
        WohnblockIdKdmVzbbb,
        WohnbezirkIdKdm,
        WohnbezirkName,
        WohnviertelIdKdm,
        WohnviertelName,
        GemeindeName,
        Wiederkehrend,
        Aktiv,
        Beschreibung,
        VeranstaltungBemerkung,
        TerminBemerkung,
        KategorieBeschreibung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TerminKey => "termin_key",
                Field::VeranstaltungKey => "veranstaltung_key",
                Field::Name => "name",
                Field::Code => "code",
                Field::KategorieName => "kategorie_name",
                Field::AktivCode => "aktiv_code",
                Field::WiederkehrendCode => "wiederkehrend_code",
                Field::ErfasstAb => "erfasst_ab",
                Field::TagDatum => "tag_datum",
                Field::JahrNummer => "jahr_nummer",
                Field::DauerInTagen => "dauer_in_tagen",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::EingangIdBlockseite => "eingang_id_blockseite",
                Field::GebaeudeKoordinateX => "gebaeude_koordinate_x",
                Field::GebaeudeKoordinateY => "gebaeude_koordinate_y",
                Field::StrasseNameKanton => "strasse_name_kanton",
                Field::EingangHausnummer => "eingang_hausnummer",
                Field::WohnblockIdKdmVzbbb => "wohnblock_id_kdm_vzbbb",
                Field::WohnbezirkIdKdm => "wohnbezirk_id_kdm",
                Field::WohnbezirkName => "wohnbezirk_name",
                Field::WohnviertelIdKdm => "wohnviertel_id_kdm",
                Field::WohnviertelName => "wohnviertel_name",
                Field::GemeindeName => "gemeinde_name",
                Field::Wiederkehrend => "wiederkehrend",
                Field::Aktiv => "aktiv",
                Field::Beschreibung => "beschreibung",
                Field::VeranstaltungBemerkung => "veranstaltung_bemerkung",
                Field::TerminBemerkung => "termin_bemerkung",
                Field::KategorieBeschreibung => "kategorie_beschreibung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100074/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Gebäudeadressen und -informationen
pub mod gebaeudeadressen_und_informationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        ///
        pub geo_point_2d: Option<GeoPoint2d>,
        ///
        pub geo_shape: Option<GeoJson>,
        /// Objekt-ID
        ///
        ///
        pub objid: Option<String>,
        /// Gebäudeadresse-ID
        ///
        /// Gebäudeadresselaufnummer
        pub gebadrlauf: Option<String>,
        /// Gebäude-ID
        ///
        /// Gebäudelaufnummer
        pub geblaufnr: Option<String>,
        /// Strassencode
        ///
        /// Strassenkennzahl
        pub str_code: Option<String>,
        /// Strassen-ID
        ///
        /// Strassenidentifikator
        pub str_id: Option<String>,
        /// Strassenname
        ///
        ///
        pub str_name: Option<String>,
        /// Hausnummer
        ///
        ///
        pub hausnr: Option<String>,
        /// Hausnummerzusatz
        ///
        /// Kleinbuchstaben (a-z) werden als Zusatz zur Hausnummer verwendet (z.B. 18a, 18b).
        pub hausnr_zus: Option<String>,
        /// Hausnummerindex
        ///
        /// Die zu einem Hauptgebäude gehörenden Nebengebäude werden mit der Hausnummer des Hauptgebäudes, einem Punkt und einem fortlaufenden Index nummeriert (z.B. 19.1, 19.2).
        pub hausnr_idx: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        ///
        ///
        pub ort: Option<String>,
        /// EDID
        ///
        /// Eidgenössischer Adressidentifikator, siehe auch https://www.housing-stat.ch/de/help/faq/id.html
        pub eidgident: Option<i64>,
        /// Abfuhrzone
        ///
        /// Der Adresse zugewiesene Abfuhrzonen (siehe auch Datensatz https://data.bs.ch/explore/dataset/100095)
        pub abfuhrzone: Option<String>,
        /// Gebäudestatus
        ///
        /// Bestehende (1004), abgebrochene (1007), projektierte (1001) bzw. sich im Bau befindende (1003) Gebäude sind verschiedene Gebäudestati.
        pub gebstatus: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objid,
        Gebadrlauf,
        Geblaufnr,
        StrCode,
        StrId,
        StrName,
        Hausnr,
        HausnrZus,
        HausnrIdx,
        Plz,
        Ort,
        Eidgident,
        Abfuhrzone,
        Gebstatus,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Gebadrlauf => "gebadrlauf",
                Field::Geblaufnr => "geblaufnr",
                Field::StrCode => "str_code",
                Field::StrId => "str_id",
                Field::StrName => "str_name",
                Field::Hausnr => "hausnr",
                Field::HausnrZus => "hausnr_zus",
                Field::HausnrIdx => "hausnr_idx",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Eidgident => "eidgident",
                Field::Abfuhrzone => "abfuhrzone",
                Field::Gebstatus => "gebstatus",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100259/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Parkflächen
pub mod parkflaechen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<String>,
        /// Strasse
        ///
        /// Name der Strasse, in der sich die Parkfläche befindet.
        pub strasse: Option<String>,
        /// Anzahl Parkplätze pro Parkfeld
        ///
        /// Anzahl der Parkplätze, die in dieser Parkfläche zur Verfügung stehen.
        pub anzahl_parkfelder: Option<i64>,
        /// Parkflächentyp
        ///
        /// Kategorie der Parkfläche, z.B. Blaue Zone, Weisse Zone, etc.
        pub typ: Option<String>,
        /// Tarif-Gebiet
        ///
        /// Vier verschiedene Kategorien (-, A, B, C)
        pub tarif_gebiet: Option<String>,
        /// Tarif pro Stunde
        ///
        /// Hängt von Tarif Gebiet ab.
        pub sopfg_geb: Option<i64>,
        /// Tarif-ID
        ///
        /// Eindeutige Kennung für den spezifischen Tarif.
        pub tarif_id: Option<i64>,
        /// Tarif-Subzone
        ///
        /// Weitere Unterteilung von Tarif Gebiet
        pub tarif_code: Option<String>,
        /// Gebührenpflichtiger Zeitraum
        ///
        /// Hängt von Tarif-Subzone ab
        pub gebpflicht: Option<String>,
        /// Maximale Parkierdauer
        ///
        /// Hängt von Tarif-Subzone ab
        pub maxparkz: Option<i64>,
        /// Zeitraum ohne max. Parkierdauer
        ///
        /// Hängt von Tarif-Subzone ab
        pub keinl: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Wohnviertel-ID
        ///
        /// Eindeutige Kennung für das Wohnviertel, in dem die Parkfläche liegt.
        pub wov_id: Option<String>,
        /// Wohnviertel
        ///
        /// Name des Wohnviertels, in dem sich die Parkfläche befindet.
        pub wov_name: Option<String>,
        /// Bezirks-ID
        ///
        /// Eindeutige Kennung für den Bezirk, in dem sich die Parkfläche befindet.
        pub bez_id: Option<String>,
        /// Bezirk
        ///
        /// Name des Bezirks, in dem sich die Parkfläche befindet.
        pub bez_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Strasse,
        AnzahlParkfelder,
        Typ,
        TarifGebiet,
        SopfgGeb,
        TarifId,
        TarifCode,
        Gebpflicht,
        Maxparkz,
        Keinl,
        Plz,
        WovId,
        WovName,
        BezId,
        BezName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Strasse => "strasse",
                Field::AnzahlParkfelder => "anzahl_parkfelder",
                Field::Typ => "typ",
                Field::TarifGebiet => "tarif_gebiet",
                Field::SopfgGeb => "sopfg_geb",
                Field::TarifId => "tarif_id",
                Field::TarifCode => "tarif_code",
                Field::Gebpflicht => "gebpflicht",
                Field::Maxparkz => "maxparkz",
                Field::Keinl => "keinl",
                Field::Plz => "plz",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::BezId => "bez_id",
                Field::BezName => "bez_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100329/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Geschwindigkeitsmonitoring: Einzelmessungen ab 2024
pub mod geschwindigkeitsmonitoring_einzelmessungen_ab_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Timestamp
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit in km/h
        pub geschwindigkeit: Option<f64>,
        /// Zeit
        ///
        /// Uhrzeit (hh:mm:ss) einer gemessenen Fahrt
        pub zeit: Option<String>,
        /// Datum
        pub datum: Option<String>,
        /// Datum und Zeit
        ///
        /// Datum und Uhrzeit als Text formatiert
        pub datum_zeit: Option<String>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        pub messende: Option<Date>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<f64>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Übertretungsquote
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit überschritten haben
        pub ue_quote: Option<f64>,
        /// Geschwindigkeit V50
        ///
        /// Höchstgeschwindigkeit, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50: Option<f64>,
        /// Geschwindigkeit V85
        ///
        /// Höchstgeschwindigkeit, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85: Option<f64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge während einer Messung
        pub fzg: Option<i64>,
        /// Fahrzeuglänge
        ///
        /// Vom Radar gemessene Fahrzeuglänge
        pub fahrzeuglange: Option<f64>,
        /// Kennzahlen pro Mess-Standort
        ///
        /// Link zum nach der aktuellen Messung gefilterten Datensatz "Kennzahlen pro Mess-Standort"
        pub link_zu_messung: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        MessungId,
        RichtungId,
        Geschwindigkeit,
        Zeit,
        Datum,
        DatumZeit,
        Messbeginn,
        Messende,
        Zone,
        Ort,
        Richtung,
        UeQuote,
        V50,
        V85,
        Strasse,
        StrasseNr,
        Fzg,
        Fahrzeuglange,
        LinkZuMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::MessungId => "messung_id",
                Field::RichtungId => "richtung_id",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Zeit => "zeit",
                Field::Datum => "datum",
                Field::DatumZeit => "datum_zeit",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Zone => "zone",
                Field::Ort => "ort",
                Field::Richtung => "richtung",
                Field::UeQuote => "ue_quote",
                Field::V50 => "v50",
                Field::V85 => "v85",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Fzg => "fzg",
                Field::Fahrzeuglange => "fahrzeuglange",
                Field::LinkZuMessung => "link_zu_messung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100097/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abfuhrtermine
pub mod abfuhrtermine {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Termin
        ///
        /// Datum der Abfuhr
        pub termin: Option<Date>,
        /// Art
        ///
        /// Art der Abfuhr
        pub art: Option<String>,
        /// Wochentag
        ///
        /// Wochentag des Abfuhrtermins
        pub wochentag: Option<String>,
        /// Tag der Woche
        ///
        /// Wochentag als Zahl (1=Montag, 2=Dienstag, etc.)
        pub dayofweek: Option<i64>,
        /// Zone
        ///
        /// Abfuhrzone
        pub zone: Option<String>,
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Termin,
        Art,
        Wochentag,
        Dayofweek,
        Zone,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Termin => "termin",
                Field::Art => "art",
                Field::Wochentag => "wochentag",
                Field::Dayofweek => "dayofweek",
                Field::Zone => "zone",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100096/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Liegenschaften: Parzellen
pub mod liegenschaften_parzellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Geo Punkt
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Name Art Liegenschaft
        ///
        /// Unterschieden wird zwischen Liegenschaft und Allmendparzelle.
        pub r1_art_txt: Option<String>,
        /// Fläche in Quadratmeter m2
        ///
        /// Fläche gemäss Eigentumsauskunft in Quadratmeter m2
        pub flaechenma: Option<i64>,
        /// EGRID
        ///
        /// Die Eidgenössische Grundstücksidentifikation (E-GRID) dient der eindeutigen Identifikation jedes Grundstücks gemäss schweizerischem Grundbuchrecht.
        pub r1_egris_e: Option<String>,
        /// Parzellennummer
        ///
        /// Die Parzellennummer ist einer Parzelle, also einem Stück Land, eindeutig zugeordnet. Anhand dieser Nummer ist es möglich, Parzellen zu identifizieren und weitere Informationen zu ihnen einzuholen.
        pub parzellennummer: Option<String>,
        /// Sektion
        ///
        /// Sektion des Grundbuchkreises
        pub r1_sektion: Option<String>,
        /// NBIdent
        ///
        /// Nummerierungsbereich-Identifikator
        pub r1_nbident: Option<String>,
        /// Objektnummer
        ///
        /// Anhand dieser Nummer ist es möglich, Parzellen zu identifizieren und weitere Informationen zu ihnen einzuholen. Setzt sich zusammen aus Parzellennummer und Index.
        pub r1_nummer: Option<String>,
        /// Code Art Liegenschaft
        ///
        /// Code zur Art der Liegenschaft
        pub r1_art: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        R1ArtTxt,
        Flaechenma,
        R1EgrisE,
        Parzellennummer,
        R1Sektion,
        R1Nbident,
        R1Nummer,
        R1Art,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::R1ArtTxt => "r1_art_txt",
                Field::Flaechenma => "flaechenma",
                Field::R1EgrisE => "r1_egris_e",
                Field::Parzellennummer => "parzellennummer",
                Field::R1Sektion => "r1_sektion",
                Field::R1Nbident => "r1_nbident",
                Field::R1Nummer => "r1_nummer",
                Field::R1Art => "r1_art",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100201/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte der Zählstellen für Verkehrszähldaten
pub mod standorte_der_zaehlstellen_fuer_verkehrszaehldaten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_ZST
        pub id_zst: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// GEMEINDE
        pub gemeinde: Option<String>,
        /// KLASSE
        pub klasse: Option<String>,
        /// KOMBINIERT
        pub kombiniert: Option<String>,
        /// ART
        pub art: Option<String>,
        /// ARME
        pub arme: Option<f64>,
        /// FAHRSTREIF
        pub fahrstreif: Option<f64>,
        /// ZWECK
        pub zweck: Option<String>,
        /// TYP
        pub typ: Option<String>,
        /// STRTYP
        pub strtyp: Option<String>,
        /// EIGENTUM
        pub eigentum: Option<String>,
        /// BETRIEBNAH
        #[serde(with = "time::serde::iso8601::option")]
        pub betriebnah: Option<OffsetDateTime>,
        /// BETRIEBZUS
        pub betriebzus: Option<String>,
        /// LINK
        pub link: Option<String>,
        /// FORMAT
        pub format: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdZst,
        Name,
        Gemeinde,
        Klasse,
        Kombiniert,
        Art,
        Arme,
        Fahrstreif,
        Zweck,
        Typ,
        Strtyp,
        Eigentum,
        Betriebnah,
        Betriebzus,
        Link,
        Format,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdZst => "id_zst",
                Field::Name => "name",
                Field::Gemeinde => "gemeinde",
                Field::Klasse => "klasse",
                Field::Kombiniert => "kombiniert",
                Field::Art => "art",
                Field::Arme => "arme",
                Field::Fahrstreif => "fahrstreif",
                Field::Zweck => "zweck",
                Field::Typ => "typ",
                Field::Strtyp => "strtyp",
                Field::Eigentum => "eigentum",
                Field::Betriebnah => "betriebnah",
                Field::Betriebzus => "betriebzus",
                Field::Link => "link",
                Field::Format => "format",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100038/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Güteklassen öffentlicher Verkehr
pub mod gueteklassen_oeffentlicher_verkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJECTID
        pub objectid: Option<i64>,
        /// OEVGKl
        pub oevgkl: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Objectid,
        Oevgkl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objectid => "objectid",
                Field::Oevgkl => "oevgkl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100022/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Tägliche Logiernächte, verfügbare und belegte Zimmer
pub mod taegliche_logiernaechte_verfuegbare_und_belegte_zimmer {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub datum: Option<Date>,
        /// Hotelkategorie
        ///
        /// Hotelkategorie; 1- und 2-Sterne, 3-Sterne, 4- und 5-Sterne, Übrige. Die Kategorie Übrige umfasst: Hotels, die (noch) nicht kategorisiert wurden sowie B&Bs und Jugendherbergen.
        pub hotelkategorie: Option<String>,
        /// Anzahl Logiernächte
        ///
        /// Anzahl Übernachtungen an einem bestimmten Tag in baselstädtischen Hotels
        pub anzlogiernaechte: Option<i64>,
        /// Anzahl verfügbare Zimmer
        ///
        /// Anzahl Zimmer, welche an einem bestimmten Tag in einem baselstädtischen Hotel zur Verfügung stehen
        pub anzzimmerverfuegbarundgeoeffnet: Option<i64>,
        /// Anzahl belegte Zimmer
        ///
        /// Anzahl an einem bestimmten Tag belegte Zimmer in einem baselstädtischen Hotel
        pub anzzimmerbelegungen: Option<i64>,
        /// Jahr
        pub jahr: Option<Date>,
        /// Monat
        pub monat: Option<i64>,
        /// Tag
        pub tag: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Hotelkategorie,
        Anzlogiernaechte,
        Anzzimmerverfuegbarundgeoeffnet,
        Anzzimmerbelegungen,
        Jahr,
        Monat,
        Tag,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Hotelkategorie => "hotelkategorie",
                Field::Anzlogiernaechte => "anzlogiernaechte",
                Field::Anzzimmerverfuegbarundgeoeffnet => "anzzimmerverfuegbarundgeoeffnet",
                Field::Anzzimmerbelegungen => "anzzimmerbelegungen",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Tag => "tag",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100106/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bade-, Trinkwasser- und Zierbrunnen in Basel
pub mod bade_trinkwasser_und_zierbrunnen_in_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// Description
        pub desc: Option<String>,
        /// Picture
        pub gx_media_links: Option<File>,
        pub picture_link: Option<String>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
        Desc,
        PictureLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Desc => "desc",
                Field::PictureLink => "picture_link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100008/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Geimpfte Personen mit Wohnsitz in Basel-Stadt
pub mod coronavirus_covid_19_geimpfte_personen_mit_wohnsitz_in_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum
        pub vacc_day: Option<Date>,
        /// Vollständig Geimpfte
        ///
        /// Anzahl Personen, welche als vollständig gegen SARS-CoV-2 geimpft gelten. Dieser Status kann auf verschiedene Weise erreicht werden.
        pub vollstaendig_geimpft: Option<i64>,
        /// Teilweise Geimpfte
        ///
        /// Anzahl Personen, welche als teilweise gegen SARS-CoV-2 geimpft gelten.
        pub teilweise_geimpft: Option<i64>,
        /// Mit mind. einer Dosis Geimpfte
        ///
        /// Anzahl Personen, welche mit mindestens einer Dosis gegen SARS-CoV-2 geimpft sind.
        pub mit_mindestens_einer_dosis_geimpft: Option<i64>,
        /// Auffrischimpfung (Booster)
        ///
        /// Anzahl Personen, welche zusätzlich zur Grundimmunisierung eine Auffrischimpfung gegen SARS-CoV-2 erhalten haben.
        pub impfung_aufgefrischt: Option<i64>,
        /// Neu teilweise Geimpfte
        ///
        /// Anzahl Personen, welche an einem bestimmten Datum gegenüber dem Vortag neu als teilweise gegen SARS-CoV-2 geimpft gelten.
        pub neu_teilweise_geimpft: Option<i64>,
        /// Neu vollständig Geimpfte
        ///
        /// Anzahl Personen, welche an einem bestimmten Datum gegenüber dem Vortag neu als vollständig gegen SARS-CoV-2 geimpft gelten.
        pub neu_vollstaendig_geimpft: Option<i64>,
        /// Neu mit Auffrischimpfung (Booster)
        ///
        /// Anzahl Personen, welche an einem bestimmten Datum gegenüber dem Vortag neu als zusätzlich mit einer Auffrischimpfung gegen SARS-CoV-2 geimpft gelten.
        pub neu_impfung_aufgefrischt: Option<i64>,
        /// Anteil vollst. Geimpfte
        ///
        /// Anteil vollständig gegen SARS-CoV-2 geimpfter Personen an der Wohnbevölkerung
        pub anteil_vollstaendig_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Anteil teilw. Geimpfte
        ///
        /// Anteil teilweise gegen SARS-CoV-2 geimpfter Personen an der Wohnbevölkerung
        pub anteil_teilweise_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Anteil mit Auffrischimpfung
        ///
        /// Anteil Personen, welche zusätzlich zur Grundimmunisierung eine Auffrischimpfung gegen SARS-CoV-2 erhalten haben an der Gesamtbevölkerung.
        pub anteil_impfung_aufgefrischt_an_wohnbevoelkerung: Option<f64>,
        /// Anteil mit mind. 1 Dosis Geimpfte
        ///
        /// Anteil Personen, welche mit mindestens einer Dosis gegen SARS-CoV-2 geimpft sind an der Gesamtbevölkerung.
        pub anteil_mit_mindestens_einer_dosis_geimpft: Option<f64>,
        /// 1. Dosis Mehrdosisimpfung (Grundimmunisierung)
        ///
        /// Anzahl Personen, welche mit der ersten Dosis einer Mehrfachdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x11_erste_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// 2. Dosis Mehrdosisimpfung (Grundimmunisierung)
        ///
        /// Anzahl Personen, welche im Rahmen der Grundimmunisierung mit der zweiten Dosis einer Mehrdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x12_zweite_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// Genesen mit 1. Dosis Mehrdosisimpfung
        ///
        /// Anzahl Personen, welche als genesen gelten (positiver PCR-Test) und zusätzlich mit einer ersten Dosis einer Mehrdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x101_genesen_mit_erster_dosis_einer_mehrdosisimpfung: Option<i64>,
        /// 3. Impfungen Auffrischimpfung
        ///
        /// Anzahl Personen, welche im Rahmen der Auffrischimpfung mit mindestens einer dritten Dosis gegen SARS-CoV-2 geimpft sind.
        pub x29_mindestens_dritte_dosis_einer_mehrdosisimpfung_auffrischimpfung: Option<i64>,
        /// 3. Impfungen Grundimmunisierung
        ///
        /// Anzahl Personen, welche im Rahmen der Grundimmunisierung mit mindestens drei Dosen einer Mehrdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x19_mindestens_dritte_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// Impfung mit Einmaldosis (Grundimmunisierung)
        ///
        /// Anzahl Personen, welche im Rahmen der Grundimmunisierung mit einer Einmaldosisimpfung gegen SARS-COV-2 geimpft sind.
        pub x1_impfung_mit_einmaldosis_grundimmunisierung: Option<i64>,
        /// Genesen mit Einmaldosis
        ///
        /// Anzahl Personen, welche als genesen gelten (positiver PCR-Test) und zusätzlich im Rahmen der Grundimmunisierung mit einer Einmaldosisimpfung gegen SARS-COV-2 geimpft sind.
        pub x100_genesen_mit_einmaldosis: Option<i64>,
        /// 2. Dosis mit Mehrdosisimpfung (Auffrischimpfung)
        ///
        /// Anzahl Personen, welche im Rahmen der Auffrischimpfung (nach Grundimmunisierung mit Einmaldosisimpfung) mit einer zweiten Dosis einer Mehrdosisimpfung gegen SRAS-CoV-2 geimpft sind.
        pub x22_zweite_dosis_mit_einer_mehrdosisimpfung_auffrischimpfung_einer_impfung_mit_einmaldosis:
            Option<i64>,
        /// Andere
        ///
        /// Andere Impftypen
        pub x1_andere: Option<i64>,
        /// Bevölkerungszahl Statpop
        ///
        /// Bevölkerungszähl gemäss Bundesamt für Statistik (STATPOP)
        pub bevoelkerungszahl_statpop: Option<i64>,
        /// Anteil mit mindestens dritter Dosis geimpft an Wohnbevölkerung
        ///
        /// Anteil Personen, welche mit mindestens dritter Dosis gegen SARS-CoV-2 geimpft sind an der Gesamtbevölkerung.
        pub anteil_mit_mindestens_dritter_dosis_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Anteil mit mindestens zweiter Auffrischimpfung geimpft an Wohnbevölkerung
        ///
        /// Anteil Personen, welche mit mindestens zweiter Auffrischimpfung gegen SARS-CoV-2 geimpft sind an der Gesamtbevölkerung.
        pub anteil_mit_mindestens_zweiter_auffrischimpfung_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Genesen mit 2. Dosis Grundimmunisierung
        ///
        /// Anzahl genesene Personen (positiver PCR-Test), welche mit 2. Dosis einer Mehrdosisimpfung im Rahmen der Grundimmunisierung gegen SARS-CoV-2 geimpft sind.
        pub x102_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// Genesen mit 2. Dosis (Auffrischimpfung)
        ///
        /// Anzahl genesene Personen (positiver PCR-Test), welche mit 2. Dosis einer Mehrdosisimpfung im Rahmen der Auffrischimpfung gegen SARS-CoV-2 geimpft sind.
        pub x202_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_auffrischimpfung: Option<i64>,
        /// Mind. 2. Auffrischimpfung
        ///
        /// Anzahl Personen, welche mindestens eine zweite Auffrischimpfung erhalten haben.
        pub x39_mindestens_zweite_auffrischimpfung: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        VaccDay,
        VollstaendigGeimpft,
        TeilweiseGeimpft,
        MitMindestensEinerDosisGeimpft,
        ImpfungAufgefrischt,
        NeuTeilweiseGeimpft,
        NeuVollstaendigGeimpft,
        NeuImpfungAufgefrischt,
        AnteilVollstaendigGeimpftAnWohnbevoelkerung,
        AnteilTeilweiseGeimpftAnWohnbevoelkerung,
        AnteilImpfungAufgefrischtAnWohnbevoelkerung,
        AnteilMitMindestensEinerDosisGeimpft,
        X11ErsteDosisEinerMehrdosisimpfungGrundimmunisierung,
        X12ZweiteDosisEinerMehrdosisimpfungGrundimmunisierung,
        X101GenesenMitErsterDosisEinerMehrdosisimpfung,
        X29MindestensDritteDosisEinerMehrdosisimpfungAuffrischimpfung,
        X19MindestensDritteDosisEinerMehrdosisimpfungGrundimmunisierung,
        X1ImpfungMitEinmaldosisGrundimmunisierung,
        X100GenesenMitEinmaldosis,
        X22ZweiteDosisMitEinerMehrdosisimpfungAuffrischimpfungEinerImpfungMitEinmaldosis,
        X1Andere,
        BevoelkerungszahlStatpop,
        AnteilMitMindestensDritterDosisGeimpftAnWohnbevoelkerung,
        AnteilMitMindestensZweiterAuffrischimpfungGeimpftAnWohnbevoelkerung,
        X102GenesenMitZweiterDosisEinerMehrdosisimpfungGrundimmunisierung,
        X202GenesenMitZweiterDosisEinerMehrdosisimpfungAuffrischimpfung,
        X39MindestensZweiteAuffrischimpfung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
Field::VaccDay => "vacc_day",
Field::VollstaendigGeimpft => "vollstaendig_geimpft",
Field::TeilweiseGeimpft => "teilweise_geimpft",
Field::MitMindestensEinerDosisGeimpft => "mit_mindestens_einer_dosis_geimpft",
Field::ImpfungAufgefrischt => "impfung_aufgefrischt",
Field::NeuTeilweiseGeimpft => "neu_teilweise_geimpft",
Field::NeuVollstaendigGeimpft => "neu_vollstaendig_geimpft",
Field::NeuImpfungAufgefrischt => "neu_impfung_aufgefrischt",
Field::AnteilVollstaendigGeimpftAnWohnbevoelkerung => "anteil_vollstaendig_geimpft_an_wohnbevoelkerung",
Field::AnteilTeilweiseGeimpftAnWohnbevoelkerung => "anteil_teilweise_geimpft_an_wohnbevoelkerung",
Field::AnteilImpfungAufgefrischtAnWohnbevoelkerung => "anteil_impfung_aufgefrischt_an_wohnbevoelkerung",
Field::AnteilMitMindestensEinerDosisGeimpft => "anteil_mit_mindestens_einer_dosis_geimpft",
Field::X11ErsteDosisEinerMehrdosisimpfungGrundimmunisierung => "11_erste_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X12ZweiteDosisEinerMehrdosisimpfungGrundimmunisierung => "12_zweite_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X101GenesenMitErsterDosisEinerMehrdosisimpfung => "101_genesen_mit_erster_dosis_einer_mehrdosisimpfung",
Field::X29MindestensDritteDosisEinerMehrdosisimpfungAuffrischimpfung => "29_mindestens_dritte_dosis_einer_mehrdosisimpfung_auffrischimpfung",
Field::X19MindestensDritteDosisEinerMehrdosisimpfungGrundimmunisierung => "19_mindestens_dritte_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X1ImpfungMitEinmaldosisGrundimmunisierung => "1_impfung_mit_einmaldosis_grundimmunisierung",
Field::X100GenesenMitEinmaldosis => "100_genesen_mit_einmaldosis",
Field::X22ZweiteDosisMitEinerMehrdosisimpfungAuffrischimpfungEinerImpfungMitEinmaldosis => "22_zweite_dosis_mit_einer_mehrdosisimpfung_auffrischimpfung_einer_impfung_mit_einmaldosis",
Field::X1Andere => "1_andere",
Field::BevoelkerungszahlStatpop => "bevoelkerungszahl_statpop",
Field::AnteilMitMindestensDritterDosisGeimpftAnWohnbevoelkerung => "anteil_mit_mindestens_dritter_dosis_geimpft_an_wohnbevoelkerung",
Field::AnteilMitMindestensZweiterAuffrischimpfungGeimpftAnWohnbevoelkerung => "anteil_mit_mindestens_zweiter_auffrischimpfung_geimpft_an_wohnbevoelkerung",
Field::X102GenesenMitZweiterDosisEinerMehrdosisimpfungGrundimmunisierung => "102_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X202GenesenMitZweiterDosisEinerMehrdosisimpfungAuffrischimpfung => "202_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_auffrischimpfung",
Field::X39MindestensZweiteAuffrischimpfung => "39_mindestens_zweite_auffrischimpfung",
}
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100162/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wasserstand Grundwasser: Langjährige Statistiken
pub mod wasserstand_grundwasser_langjaehrige_statistiken {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationId
        ///
        /// Identifikationsnummer
        pub stationid: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// 10YMin
        ///
        /// kleinster Messwert (nach 10 Jahren)
        pub x10ymin: Option<f64>,
        /// 10YMean
        ///
        /// Mittelwert aller Messwerte (nach 10 Jahren)
        pub x10ymean: Option<f64>,
        /// 10YMax
        ///
        /// grösster Messwert (nach 10 Jahren)
        pub x10ymax: Option<f64>,
        /// startStatist
        ///
        /// Start Messung
        pub startstatist: Option<String>,
        /// endStatist
        ///
        /// Ende Messung
        pub endstatist: Option<String>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_start_timestamp: Option<OffsetDateTime>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_end_timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Stationnr,
        Stationid,
        Stationname,
        Sensornr,
        Sensname,
        Lat,
        Lon,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        X10ymin,
        X10ymean,
        X10ymax,
        Startstatist,
        Endstatist,
        BohrkatasterLink,
        StatStartTimestamp,
        StatEndTimestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Stationnr => "stationnr",
                Field::Stationid => "stationid",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::X10ymin => "10ymin",
                Field::X10ymean => "10ymean",
                Field::X10ymax => "10ymax",
                Field::Startstatist => "startstatist",
                Field::Endstatist => "endstatist",
                Field::BohrkatasterLink => "bohrkataster_link",
                Field::StatStartTimestamp => "stat_start_timestamp",
                Field::StatEndTimestamp => "stat_end_timestamp",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100180/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Sauberkeitsindex pro Monat und Strassenabschnitt
pub mod sauberkeitsindex_pro_monat_und_strassenabschnitt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datenstand
        ///
        /// Stand der Daten zu einem bestimmten Zeitpunkt
        pub datenstand: Option<Date>,
        /// ID Strassenabschnitt
        ///
        /// Eindeutiger Identifikator
        pub id: Option<String>,
        /// Strassenabschnitt
        ///
        /// Name des Strassenabschnitts
        pub strasse: Option<String>,
        /// CCI
        ///
        /// CCI steht für «Clean City Index» und ist der Sauberkeitsindex, der zwischen 0 (schmutzig) bis 5 (sauber) liegt.
        pub cci: Option<f64>,
        /// Anzahl Messungen
        ///
        /// Die Anzahl der Messungen umfasst die Anzahl der Durchfahrten des Kehrrichtlastwagens im jeweiligen Strassenabschnitt pro Monat.
        pub anzahl_messungen: Option<i64>,
        /// Letzte Messung
        ///
        /// Die letzte Messung des Sauberkeitsindexes des jeweiligen Strassenabschnitts.
        #[serde(with = "time::serde::iso8601::option")]
        pub letzte_messung: Option<OffsetDateTime>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datenstand,
        Id,
        Strasse,
        Cci,
        AnzahlMessungen,
        LetzteMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datenstand => "datenstand",
                Field::Id => "id",
                Field::Strasse => "strasse",
                Field::Cci => "cci",
                Field::AnzahlMessungen => "anzahl_messungen",
                Field::LetzteMessung => "letzte_messung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100288/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Nutzungsplan - Zonenplan Stadt Basel:  Überlagernde Festlegungen
pub mod nutzungsplan_zonenplan_stadt_basel_ueberlagernde_festlegungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Überlagende_Festlegung
        ///
        /// Eindeutiger Identifikator
        pub idueberfes: Option<String>,
        /// Festlegung überlagernd
        ///
        /// Art der Festlegung
        pub festueber: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Verbindlichkeit
        pub verbindli: Option<String>,
        /// Schutzzweck
        ///
        /// Schutzzweck von Natur- und Landschaftsschutzzonen
        pub schutzzwec: Option<String>,
        /// rekurshängig
        ///
        /// 1 (bzw. true) wenn ein Rekurs vorhanden ist. Wenn ein Rekurs hängig ist, enthält das Objekt die neue, geplante Ausprägung, entgegen dem Geschäftsstatus ist diese jedoch noch nicht in Kraft.
        pub rekurshaen: Option<String>,
        /// Bezeichnung
        ///
        /// Bezeichnung der Festlegung
        pub bezeichnng: Option<String>,
        /// Id_Geschäft
        ///
        /// Eindeutiger Identifikator
        pub idgeschae: Option<String>,
        /// Geschäftsstatus
        pub geschaesta: Option<String>,
        /// Datum Status
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        pub geolink: Option<String>,
        /// Geschäftsbezeichnung
        pub geschaebez: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idueberfes,
        Festueber,
        Verbindli,
        Schutzzwec,
        Rekurshaen,
        Bezeichnng,
        Idgeschae,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idueberfes => "idueberfes",
                Field::Festueber => "festueber",
                Field::Verbindli => "verbindli",
                Field::Schutzzwec => "schutzzwec",
                Field::Rekurshaen => "rekurshaen",
                Field::Bezeichnng => "bezeichnng",
                Field::Idgeschae => "idgeschae",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100234/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Bohrkataster
pub mod bohrkataster {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Art der Bohrung
        pub art: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Grundwasserdaten (0/1)
        ///
        /// Grundwasserdaten vorhanden (0 = Nein, 1 = Ja)
        pub grundwasserdaten: Option<String>,
        /// Flurabstand
        ///
        /// Differenz Höhe Gelände und Grundwasserspiegel
        pub flurabstand: Option<f64>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID-Bohrung
        ///
        /// Eindeutiger Identifikator
        pub id_bohrung: Option<i64>,
        /// Erdwärmesonde vorhanden
        pub geothermal: Option<i64>,
        /// Vollständige Laufnummer
        pub catnum45: Option<String>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Bohrung
        pub xkoord: Option<i64>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Bohrung
        pub ykoord: Option<i64>,
        /// Schrägbohrung (0/1)
        ///
        /// 0 = Nein, 1 = Ja
        pub schraeg: Option<String>,
        /// Bohrjahr
        ///
        /// Erstellungsjahr der Bohrung
        pub erstellung: Option<i64>,
        /// Strasse
        pub strasse: Option<String>,
        /// Hausnummer
        pub hausnummer: Option<String>,
        /// Bohransatz-Kote
        ///
        /// Kote Ansatz der Bohrung m.ü.M
        pub hoehestart: Option<f64>,
        /// Oberkante Fels-Kote
        ///
        /// Kote Felsoberfläche der Bohrung m.ü.M
        pub hoehefels: Option<f64>,
        /// Oberkante Fels-Stratigraphie
        ///
        /// Beschreibung Felsoberfläche (z.B. Cyrenenmergel)
        pub artfels: Option<String>,
        /// Sohle-Kote
        ///
        /// Kote Sohle der Bohrung m.ü.M.
        pub hoehesole: Option<f64>,
        /// Im hydrografischen Jahrbuch
        ///
        /// Bohrung im hydrografischen Jahrbuch vorhanden, 0 = Nein, 1 = Ja
        pub jahrbuch: Option<i64>,
        /// Zustand der Bohrung
        ///
        /// messbar, verschlammt, etc. (Zustand einer Messstelle)
        pub zuststelle: Option<String>,
        /// Höhe des Geländes
        pub hoehegelae: Option<f64>,
        /// Geplant (0/1)
        ///
        /// Geplante Bohrung (wird für online Visualisierung "geplante Bohrung" verwendet), 0 = Nein, 1 = Ja
        pub bohgeplant: Option<i64>,
        /// Rohrdurchmesser
        ///
        /// Durchmesser des eingebauten Rohrs in mm
        pub rohrdurchm: Option<f64>,
        /// Höhe Rohrabschnitt oben
        ///
        /// Höhe des Rohrabschnitts gemesen oben in m ü. M.
        pub rohrhoehet: Option<f64>,
        /// Höhe Rohrabschnitt unten
        ///
        /// Höhe des Rohrabschnitts gemesen unten in m ü. M.
        pub rohrhoeheb: Option<f64>,
        /// Grundwasserspiegel
        ///
        /// Höhe des Grundwasserstandes in m ü. M
        pub heohegwl: Option<f64>,
        /// Format des Datums
        ///
        /// Format des Datums (dd.mm.yyyy)
        pub datumforma: Option<String>,
        /// Datum des Grundwasserstandes
        ///
        /// Datum des Grundwasserstandes (z.B. 04.11.1965)
        pub datumgwl: Option<String>,
        /// Bohrprofil-Dokument
        ///
        /// Bohrprofil-Dokument zur Bohrung
        pub dokbohrpro: Option<String>,
        /// Situationsplan-Dokument
        ///
        /// Situationsplan-Dokument zur Bohrung
        pub doksituat: Option<String>,
        /// Bild zur Bohrung
        pub bildbohrun: Option<String>,
        /// Art der Grundwassermessstelle
        pub gwlmesssta: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Art,
        Grundwasserdaten,
        Flurabstand,
        IdBohrung,
        Geothermal,
        Catnum45,
        Xkoord,
        Ykoord,
        Schraeg,
        Erstellung,
        Strasse,
        Hausnummer,
        Hoehestart,
        Hoehefels,
        Artfels,
        Hoehesole,
        Jahrbuch,
        Zuststelle,
        Hoehegelae,
        Bohgeplant,
        Rohrdurchm,
        Rohrhoehet,
        Rohrhoeheb,
        Heohegwl,
        Datumforma,
        Datumgwl,
        Dokbohrpro,
        Doksituat,
        Bildbohrun,
        Gwlmesssta,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Art => "art",
                Field::Grundwasserdaten => "grundwasserdaten",
                Field::Flurabstand => "flurabstand",
                Field::IdBohrung => "id_bohrung",
                Field::Geothermal => "geothermal",
                Field::Catnum45 => "catnum45",
                Field::Xkoord => "xkoord",
                Field::Ykoord => "ykoord",
                Field::Schraeg => "schraeg",
                Field::Erstellung => "erstellung",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Hoehestart => "hoehestart",
                Field::Hoehefels => "hoehefels",
                Field::Artfels => "artfels",
                Field::Hoehesole => "hoehesole",
                Field::Jahrbuch => "jahrbuch",
                Field::Zuststelle => "zuststelle",
                Field::Hoehegelae => "hoehegelae",
                Field::Bohgeplant => "bohgeplant",
                Field::Rohrdurchm => "rohrdurchm",
                Field::Rohrhoehet => "rohrhoehet",
                Field::Rohrhoeheb => "rohrhoeheb",
                Field::Heohegwl => "heohegwl",
                Field::Datumforma => "datumforma",
                Field::Datumgwl => "datumgwl",
                Field::Dokbohrpro => "dokbohrpro",
                Field::Doksituat => "doksituat",
                Field::Bildbohrun => "bildbohrun",
                Field::Gwlmesssta => "gwlmesssta",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100182/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Staatsangehörigkeit und Gemeinde
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub gemeindename: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<i64>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_al: Option<i64>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub gesbev_f: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Gemeindename,
        Gemeinde,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Gemeindename => "gemeindename",
                Field::Gemeinde => "gemeinde",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100059/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Unfallschwerpunkte
pub mod unfallschwerpunkte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id-Unfallschwerpunkt
        ///
        /// Eindeutiger Identifikator
        pub id_ufsp: Option<String>,
        /// Kategorie
        ///
        /// Kategorie des Unfallschwerpunktes
        pub kategorie: Option<String>,
        /// Beschreibung der Kategorie des Unfallschwerpunktes
        pub kategoriebeschreibung: Option<String>,
        /// Jahr
        pub jahr: Option<Date>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
        /// Anlagetyp
        pub anlagetyp: Option<String>,
        /// Lichtsignalanlage
        ///
        /// Ist eine Lichtsignalanlage vorhanden
        pub lichtsign: Option<String>,
        /// Gemeinde
        pub ortschaft: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdUfsp,
        Kategorie,
        Kategoriebeschreibung,
        Jahr,
        Strasse,
        Anlagetyp,
        Lichtsign,
        Ortschaft,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdUfsp => "id_ufsp",
                Field::Kategorie => "kategorie",
                Field::Kategoriebeschreibung => "kategoriebeschreibung",
                Field::Jahr => "jahr",
                Field::Strasse => "strasse",
                Field::Anlagetyp => "anlagetyp",
                Field::Lichtsign => "lichtsign",
                Field::Ortschaft => "ortschaft",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100216/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Allmendbewilligungen
pub mod allmendbewilligungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BegehrenID
        ///
        /// Kennziffer des Begehrens. Ein Begehren kann mehrere Adressbelegungen umfassen.
        pub begehrenid: Option<i64>,
        /// LokalitätID
        ///
        /// Kennziffer des Standorts
        pub lokalitaid: Option<i64>,
        /// BelegungID
        ///
        /// Kennziffer der Belegung
        pub belegungid: Option<i64>,
        /// Bezeichnung
        ///
        /// Beschreibung der Belegung
        pub bezeichng: Option<String>,
        /// BegehrensartID
        ///
        /// Kennziffer der Art des Begehrens
        pub artbeg_id: Option<i64>,
        /// Begehrensart-Bezeichnung
        ///
        /// Bezeichnung der Art des Begehrens
        pub artbeg_bez: Option<String>,
        /// Eingangsdatum
        pub eingangsdatum: Option<Date>,
        /// Entscheid-Datum
        pub entscheid_datum: Option<Date>,
        /// EntscheidID
        ///
        /// Kennziffer der Entscheidkategorie
        pub entsch_id: Option<i64>,
        /// Entscheid-Bezeichnung
        ///
        /// Name der Entscheidkategorie
        pub entsch_bez: Option<String>,
        /// StrassenID
        ///
        /// Strassen-Nummer
        pub strassenid: Option<i64>,
        /// BelegungsartID
        ///
        /// Kennziffer der Art der Belegung
        pub belgartid: Option<i64>,
        /// Belegungsart-Bezeichnung
        ///
        /// Name der Art der Belegung
        pub belgartbez: Option<String>,
        /// BelastungsartID
        ///
        /// Kennziffer der Belastungsart
        pub belaartid: Option<i64>,
        /// Belastungsart-Bezeichnung
        ///
        /// Name der Belastungsart
        pub belaartbez: Option<String>,
        /// MerkmalID
        ///
        /// Kennziffer des Merkmals des Geschäfts
        pub merkmal_id: Option<i64>,
        /// Geschäftsmerkmal-Bezeichnung
        ///
        /// Name des Merkmals des Geschäfts
        pub merkmalbez: Option<String>,
        /// MerkmalWert
        ///
        /// Wert des Merkmals des Geschäfts, z. B. Baukosten
        pub merkmalwrt: Option<String>,
        /// EinheitID
        ///
        /// Kennziffer der Einheit
        pub einheit_id: Option<i64>,
        /// Belegungseinheit-Bezeichnung
        ///
        /// Einheit, in welcher die Belegung erfasst ist. Kosten werden über die Einheit berechnet. Z.B. m2 oder Wochen.
        pub einheitbez: Option<String>,
        /// BelegungsstatusID
        ///
        /// Kennziffer des Status der Belegung
        pub belestatid: Option<i64>,
        /// Belegungsstatus-Bezeichung
        ///
        /// Name des Status der Belegung
        pub belestatbe: Option<String>,
        /// IDUnique
        pub idunique: Option<String>,
        /// DatumEing
        pub datumeing: Option<String>,
        /// DatumEnts
        pub datuments: Option<String>,
        /// Datum_von
        pub datum_von: Option<Date>,
        /// Datum_bis
        pub datum_bis: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Begehrenid,
        Lokalitaid,
        Belegungid,
        Bezeichng,
        ArtbegId,
        ArtbegBez,
        Eingangsdatum,
        EntscheidDatum,
        EntschId,
        EntschBez,
        Strassenid,
        Belgartid,
        Belgartbez,
        Belaartid,
        Belaartbez,
        MerkmalId,
        Merkmalbez,
        Merkmalwrt,
        EinheitId,
        Einheitbez,
        Belestatid,
        Belestatbe,
        Idunique,
        Datumeing,
        Datuments,
        DatumVon,
        DatumBis,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Begehrenid => "begehrenid",
                Field::Lokalitaid => "lokalitaid",
                Field::Belegungid => "belegungid",
                Field::Bezeichng => "bezeichng",
                Field::ArtbegId => "artbeg_id",
                Field::ArtbegBez => "artbeg_bez",
                Field::Eingangsdatum => "eingangsdatum",
                Field::EntscheidDatum => "entscheid_datum",
                Field::EntschId => "entsch_id",
                Field::EntschBez => "entsch_bez",
                Field::Strassenid => "strassenid",
                Field::Belgartid => "belgartid",
                Field::Belgartbez => "belgartbez",
                Field::Belaartid => "belaartid",
                Field::Belaartbez => "belaartbez",
                Field::MerkmalId => "merkmal_id",
                Field::Merkmalbez => "merkmalbez",
                Field::Merkmalwrt => "merkmalwrt",
                Field::EinheitId => "einheit_id",
                Field::Einheitbez => "einheitbez",
                Field::Belestatid => "belestatid",
                Field::Belestatbe => "belestatbe",
                Field::Idunique => "idunique",
                Field::Datumeing => "datumeing",
                Field::Datuments => "datuments",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100018/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (Covid-19): Fallzahlen und Inzidenzen Basel-Stadt
pub mod coronavirus_covid_19_fallzahlen_und_inzidenzen_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Testresultat
        ///
        /// Datum, an welchem das Testresultat vorliegt. In der Regel liegt ein Testresultat innerhalb von 24 Stunden nach dem erfolgten Test vor.
        pub test_datum: Option<Date>,
        /// Tägliche Fälle Basel-Stadt
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz im Kanton Basel-Stadt
        pub faelle_bs: Option<i64>,
        /// Kumulierte Fälle Basel-Stadt
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz im Kanton Basel-Stadt
        pub faelle_bs_kum: Option<i64>,
        /// Tägliche Fälle Basel
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz in der Stadt Basel
        pub faelle_basel: Option<i64>,
        /// Kumulierte Fälle Basel
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz in der Stadt Basel
        pub faelle_basel_kum: Option<i64>,
        /// Tägliche Fälle Riehen
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz in der Gemeinde Riehen
        pub faelle_riehen: Option<i64>,
        /// Kumulierte Fälle Riehen
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz in der Gemeinde Riehen
        pub faelle_riehen_kum: Option<i64>,
        /// Tägliche Fälle Bettingen
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz in der Gemeinde Bettingen
        pub faelle_bettingen: Option<i64>,
        /// Kumulierte Fälle Bettingen
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz in der Gemeinde Bettingen
        pub faelle_bettingen_kum: Option<i64>,
        /// 7d-Inzidenz Basel-Stadt
        ///
        /// 7-Tage-Inzidenz Basel-Stadt; berechnet nach der Formel: (("Kumulierte Fälle BS" heute) minus ("Kumulierte Fälle BS" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz07_bs: Option<f64>,
        /// 14d-Inzidenz Basel-Stadt
        ///
        /// 14-Tage-Inzidenz Basel-Stadt; berechnet nach der Formel: (("Kumulierte Fälle BS" heute) minus ("Kumulierte Fälle BS" heute-14 Tage) durch (Einwohnerzahl durch 100 000 Personen))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz14_bs: Option<f64>,
        /// Summe 7 Tage Basel-Stadt
        ///
        /// Summe der Anzahl positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz in Basel-Stadt der letzten 7 Tage
        pub summe_07_tage_bs: Option<i64>,
        /// Summe 14 Tage Basel-Stadt
        ///
        /// Summe der Anzahl positiv auf SARS-Cov-2 getesteten Personen mit Wohnsitz in Basel-Stadt der letzten 14 Tage
        pub summe_14_tage_bs: Option<i64>,
        /// Mittel 7 Tage Basel-Stadt
        ///
        /// Mittel der Anzahl positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz in Basel-Stadt pro Tag über die letzten 7 Tage
        pub mittel_07_tage_bs: Option<f64>,
        /// Mittel 14 Tage Basel-Stadt
        ///
        /// Mittel der Anzahl positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz in Basel-Stadt pro Tag über die letzten 14 Tage
        pub mittel_14_tage_bs: Option<f64>,
        /// 7d-Inzidenz Basel
        ///
        /// 7-Tage-Inzidenz Basel; berechnet nach der Formel: (("Kumulierte Fälle Basel" heute) minus ("Kumulierte Fälle Basel" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_basel_07: Option<f64>,
        /// 14d-Inzidenz Basel
        ///
        /// 14-Tage-Inzidenz Basel; berechnet nach der Formel: (("Kumulierte Fälle Basel" heute) minus ("Kumulierte Fälle Basel" heute-14 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_basel_14: Option<f64>,
        /// 7d-Inzidenz Riehen
        ///
        /// 7-Tage-Inzidenz Riehen; berechnet nach der Formel: (("Kumulierte Fälle Riehen" heute) minus ("Kumulierte Fälle Riehen" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_riehen_07: Option<f64>,
        /// 14d-Inzidenz Riehen
        ///
        /// 14-Tage-Inzidenz Riehen; berechnet nach der Formel: (("Kumulierte Fälle Riehen" heute) minus ("Kumulierte Fälle Riehen" heute-14 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_riehen_14: Option<f64>,
        /// 7d-Inzidenz Bettingen
        ///
        /// 7-Tage-Inzidenz Bettingen; berechnet nach der Formel: (("Kumulierte Fälle Bettingen" heute) minus ("Kumulierte Fälle Bettingen" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_bettingen_07: Option<f64>,
        /// 14d-Inzidenz Bettingen
        ///
        /// 14-Tage-Inzidenz Bettingen; berechnet nach der Formel: (("Kumulierte Fälle Bettingen" heute) minus ("Kumulierte Fälle Bettingen" heute-14 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_bettingen_14: Option<f64>,
        /// Wochentag Nummer
        ///
        /// Nummer des Wochentags (Montag=0, Sonntag=6)
        pub weekday_nr: Option<i64>,
        /// Weekday
        ///
        /// Name des Wochentags auf Englisch
        pub weekday: Option<String>,
        /// Wochentag
        ///
        /// Name des Wochentags auf Deutsch
        pub wochentag: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TestDatum,
        FaelleBs,
        FaelleBsKum,
        FaelleBasel,
        FaelleBaselKum,
        FaelleRiehen,
        FaelleRiehenKum,
        FaelleBettingen,
        FaelleBettingenKum,
        Inzidenz07Bs,
        Inzidenz14Bs,
        Summe07TageBs,
        Summe14TageBs,
        Mittel07TageBs,
        Mittel14TageBs,
        InzidenzBasel07,
        InzidenzBasel14,
        InzidenzRiehen07,
        InzidenzRiehen14,
        InzidenzBettingen07,
        InzidenzBettingen14,
        WeekdayNr,
        Weekday,
        Wochentag,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TestDatum => "test_datum",
                Field::FaelleBs => "faelle_bs",
                Field::FaelleBsKum => "faelle_bs_kum",
                Field::FaelleBasel => "faelle_basel",
                Field::FaelleBaselKum => "faelle_basel_kum",
                Field::FaelleRiehen => "faelle_riehen",
                Field::FaelleRiehenKum => "faelle_riehen_kum",
                Field::FaelleBettingen => "faelle_bettingen",
                Field::FaelleBettingenKum => "faelle_bettingen_kum",
                Field::Inzidenz07Bs => "inzidenz07_bs",
                Field::Inzidenz14Bs => "inzidenz14_bs",
                Field::Summe07TageBs => "summe_07_tage_bs",
                Field::Summe14TageBs => "summe_14_tage_bs",
                Field::Mittel07TageBs => "mittel_07_tage_bs",
                Field::Mittel14TageBs => "mittel_14_tage_bs",
                Field::InzidenzBasel07 => "inzidenz_basel_07",
                Field::InzidenzBasel14 => "inzidenz_basel_14",
                Field::InzidenzRiehen07 => "inzidenz_riehen_07",
                Field::InzidenzRiehen14 => "inzidenz_riehen_14",
                Field::InzidenzBettingen07 => "inzidenz_bettingen_07",
                Field::InzidenzBettingen14 => "inzidenz_bettingen_14",
                Field::WeekdayNr => "weekday_nr",
                Field::Weekday => "weekday",
                Field::Wochentag => "wochentag",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100108/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Verkehrslärm
pub mod smarte_strasse_verkehrslaerm {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Mittelungspegel
        ///
        /// Gemittelter Schalldruckpegel in dB(A) über 5 Minuten
        pub general_level: Option<f64>,
        /// 25 Hz
        ///
        /// Terzbandpegel bei 25 Hz über 5 Minuten
        pub level_00025: Option<f64>,
        /// 31.5 Hz
        ///
        /// Terzbandpegel bei 31.5 Hz über 5 Minuten
        pub level_00031_5: Option<f64>,
        /// 40 Hz
        ///
        /// Terzbandpegel bei 40 Hz über 5 Minuten
        pub level_00040: Option<f64>,
        /// 50 Hz
        ///
        /// Terzbandpegel bei 50 Hz über 5 Minuten
        pub level_00050: Option<f64>,
        /// 63 Hz
        ///
        /// Terzbandpegel bei 63 Hz über 5 Minuten
        pub level_00063: Option<f64>,
        /// 80 Hz
        ///
        /// Terzbandpegel bei 80 Hz über 5 Minuten
        pub level_00080: Option<f64>,
        /// 100 Hz
        ///
        /// Terzbandpegel bei 100 Hz über 5 Minuten
        pub level_00100: Option<f64>,
        /// 125 Hz
        ///
        /// Terzbandpegel bei 125 Hz über 5 Minuten
        pub level_00125: Option<f64>,
        /// 160 Hz
        ///
        /// Terzbandpegel bei 160 Hz über 5 Minuten
        pub level_00160: Option<f64>,
        /// 200 Hz
        ///
        /// Terzbandpegel bei 200 Hz über 5 Minuten
        pub level_00200: Option<f64>,
        /// 250 Hz
        ///
        /// Terzbandpegel bei 250 Hz über 5 Minuten
        pub level_00250: Option<f64>,
        /// 315 Hz
        ///
        /// Terzbandpegel bei 315 Hz über 5 Minuten
        pub level_00315: Option<f64>,
        /// 400 Hz
        ///
        /// Terzbandpegel bei 400 Hz über 5 Minuten
        pub level_00400: Option<f64>,
        /// 500 Hz
        ///
        /// Terzbandpegel bei 500 Hz über 5 Minuten
        pub level_00500: Option<f64>,
        /// 630 Hz
        ///
        /// Terzbandpegel bei 630 Hz über 5 Minuten
        pub level_00630: Option<f64>,
        /// 800 Hz
        ///
        /// Terzbandpegel bei 800 Hz über 5 Minuten
        pub level_00800: Option<f64>,
        /// 1000 Hz
        ///
        /// Terzbandpegel bei 1000 Hz über 5 Minuten
        pub level_01000: Option<f64>,
        /// 1250 Hz
        ///
        /// Terzbandpegel bei 1250 Hz über 5 Minuten
        pub level_01250: Option<f64>,
        /// 1600 Hz
        ///
        /// Terzbandpegel bei 1600 Hz über 5 Minuten
        pub level_01600: Option<f64>,
        /// 2000 Hz
        ///
        /// Terzbandpegel bei 2000 Hz über 5 Minuten
        pub level_02000: Option<f64>,
        /// 2500 Hz
        ///
        /// Terzbandpegel bei 2500 Hz über 5 Minuten
        pub level_02500: Option<f64>,
        /// 3150 Hz
        ///
        /// Terzbandpegel bei 3150 Hz über 5 Minuten
        pub level_03150: Option<f64>,
        /// 4000 Hz
        ///
        /// Terzbandpegel bei 4000 Hz über 5 Minuten
        pub level_04000: Option<f64>,
        /// 5000 Hz
        ///
        /// Terzbandpegel bei 5000 Hz über 5 Minuten
        pub level_05000: Option<f64>,
        /// 6300 Hz
        ///
        /// Terzbandpegel bei 6300 Hz über 5 Minuten
        pub level_06300: Option<f64>,
        /// 8000 Hz
        ///
        /// Terzbandpegel bei 8000 Hz über 5 Minuten
        pub level_08000: Option<f64>,
        /// 10000 Hz
        ///
        /// Terzbandpegel bei 10000 Hz über 5 Minuten
        pub level_10000: Option<f64>,
        /// 12500 Hz
        ///
        /// Terzbandpegel bei 12500 Hz über 5 Minuten
        pub level_12500: Option<f64>,
        /// 16000 Hz
        ///
        /// Terzbandpegel bei 16000 Hz über 5 Minuten
        pub level_16000: Option<f64>,
        pub timestamp_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        GeneralLevel,
        Level00025,
        Level000315,
        Level00040,
        Level00050,
        Level00063,
        Level00080,
        Level00100,
        Level00125,
        Level00160,
        Level00200,
        Level00250,
        Level00315,
        Level00400,
        Level00500,
        Level00630,
        Level00800,
        Level01000,
        Level01250,
        Level01600,
        Level02000,
        Level02500,
        Level03150,
        Level04000,
        Level05000,
        Level06300,
        Level08000,
        Level10000,
        Level12500,
        Level16000,
        TimestampText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::GeneralLevel => "general_level",
                Field::Level00025 => "level_00025",
                Field::Level000315 => "level_00031_5",
                Field::Level00040 => "level_00040",
                Field::Level00050 => "level_00050",
                Field::Level00063 => "level_00063",
                Field::Level00080 => "level_00080",
                Field::Level00100 => "level_00100",
                Field::Level00125 => "level_00125",
                Field::Level00160 => "level_00160",
                Field::Level00200 => "level_00200",
                Field::Level00250 => "level_00250",
                Field::Level00315 => "level_00315",
                Field::Level00400 => "level_00400",
                Field::Level00500 => "level_00500",
                Field::Level00630 => "level_00630",
                Field::Level00800 => "level_00800",
                Field::Level01000 => "level_01000",
                Field::Level01250 => "level_01250",
                Field::Level01600 => "level_01600",
                Field::Level02000 => "level_02000",
                Field::Level02500 => "level_02500",
                Field::Level03150 => "level_03150",
                Field::Level04000 => "level_04000",
                Field::Level05000 => "level_05000",
                Field::Level06300 => "level_06300",
                Field::Level08000 => "level_08000",
                Field::Level10000 => "level_10000",
                Field::Level12500 => "level_12500",
                Field::Level16000 => "level_16000",
                Field::TimestampText => "timestamp_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100170/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Geschwindigkeitsmessungen
pub mod smarte_strasse_geschwindigkeitsmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Startzeit
        ///
        /// Startzeit des Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub localdatetime_interval_start: Option<OffsetDateTime>,
        /// Stoppzeit
        ///
        /// Stoppzeit des Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub localdatetime_interval_end: Option<OffsetDateTime>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit bei Durchfahrt in km/h
        pub speed: Option<f64>,
        /// Schalldruckpegel
        ///
        /// Schalldruckpegel bei Durchfahrt in dB(A)
        pub level: Option<f64>,
        /// Fahrzeug-Zufallszahl
        ///
        /// Zufällig nummerierte Reihenfolge
        pub vehicle_rand_number: Option<i64>,
        /// Intervalldauer Text
        ///
        /// Dauer des Messintervalls in Textform
        pub interval_length_string: Option<String>,
        /// Intervalldauer Sek.
        ///
        /// Dauer des Messintervalls in Sekunden
        pub interval_length_seconds: Option<f64>,
        /// localDateTime_interval_start_text
        pub localdatetime_interval_start_text: Option<String>,
        /// localDateTime_interval_end_text
        pub localdatetime_interval_end_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        LocaldatetimeIntervalStart,
        LocaldatetimeIntervalEnd,
        Speed,
        Level,
        VehicleRandNumber,
        IntervalLengthString,
        IntervalLengthSeconds,
        LocaldatetimeIntervalStartText,
        LocaldatetimeIntervalEndText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::LocaldatetimeIntervalStart => "localdatetime_interval_start",
                Field::LocaldatetimeIntervalEnd => "localdatetime_interval_end",
                Field::Speed => "speed",
                Field::Level => "level",
                Field::VehicleRandNumber => "vehicle_rand_number",
                Field::IntervalLengthString => "interval_length_string",
                Field::IntervalLengthSeconds => "interval_length_seconds",
                Field::LocaldatetimeIntervalStartText => "localdatetime_interval_start_text",
                Field::LocaldatetimeIntervalEndText => "localdatetime_interval_end_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100175/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrszähldaten motorisierter Individualverkehr
pub mod verkehrszaehldaten_motorisierter_individualverkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ZST_NR
        ///
        /// Zählstellennummer
        pub zst_nr: Option<String>,
        /// SiteCode
        ///
        /// Zählstellencode
        pub sitecode: Option<String>,
        /// SiteName
        ///
        /// Zählstellenname
        pub sitename: Option<String>,
        /// DateTimeFrom
        ///
        /// Datum und Uhrzeit Messbeginn (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimefrom: Option<OffsetDateTime>,
        /// DateTimeTo
        ///
        /// Datum und Uhrzeit Messende (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimeto: Option<OffsetDateTime>,
        /// DirectionName
        ///
        /// Richtung/Strassenseite
        pub directionname: Option<String>,
        /// LaneCode
        ///
        /// Spurnummer
        pub lanecode: Option<i64>,
        /// LaneName
        ///
        /// Spurname
        pub lanename: Option<String>,
        /// ValuesApproved
        ///
        /// Daten validiert (1 ja, 0 nein) [Validierte Verkehrszahlen sind kontrollierte und ergänzte Rohdaten. Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesapproved: Option<i64>,
        /// ValuesEdited
        ///
        /// Ersatzwerte (1 ja, 0 nein) [Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesedited: Option<i64>,
        /// TrafficType
        ///
        /// Verkehrsmittel (MIV = motorisierter Individualverkehr)
        pub traffictype: Option<String>,
        /// Total
        ///
        /// Anzahl Fahrzeuge
        pub total: Option<i64>,
        /// MR
        ///
        /// Motorrad
        pub mr: Option<i64>,
        /// PW
        ///
        /// Personenwagen
        pub pw: Option<i64>,
        /// PW+
        ///
        /// Personenwagen mit Anhänger
        pub pw0: Option<i64>,
        /// Lief
        ///
        /// Lieferwagen
        pub lief: Option<i64>,
        /// Lief+
        ///
        /// Lieferwagen mit Anhänger
        pub lief0: Option<i64>,
        /// Lief+Aufl.
        ///
        /// Lieferwagen mit Auflieger
        pub lief_aufl: Option<i64>,
        /// LW
        ///
        /// Lastwagen
        pub lw: Option<i64>,
        /// LW+
        ///
        /// Lastwagen mit Anhänger
        pub lw0: Option<i64>,
        /// Sattelzug
        pub sattelzug: Option<i64>,
        /// Bus
        pub bus: Option<i64>,
        /// nicht klassifizierbare Fahrzeuge
        pub andere: Option<i64>,
        /// Year
        ///
        /// Jahr
        pub year: Option<String>,
        /// Month
        ///
        /// Monat (1=Januar, 12=Dezember)
        pub month: Option<i64>,
        /// Day
        ///
        /// Tag
        pub day: Option<i64>,
        /// Weekday
        ///
        /// Wochentag (0=Montag, 6=Sonntag)
        pub weekday: Option<i64>,
        /// HourFrom
        ///
        /// Stunde des Messbeginns
        pub hourfrom: Option<i64>,
        /// Date
        ///
        /// Datum der Messung als Text
        pub date: Option<String>,
        /// TimeFrom
        ///
        /// Zeit Messbeginn als Text
        pub timefrom: Option<String>,
        /// TimeTo
        ///
        /// Zeit Messende als Text
        pub timeto: Option<String>,
        /// DayOfYear
        ///
        /// Nummer des Tages innerhalb des aktuellen Jahres
        pub dayofyear: Option<i64>,
        /// Zst_id
        pub zst_id: Option<i64>,
        /// Geo Point
        ///
        /// Standort der Zählstelle
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        ZstNr,
        Sitecode,
        Sitename,
        Datetimefrom,
        Datetimeto,
        Directionname,
        Lanecode,
        Lanename,
        Valuesapproved,
        Valuesedited,
        Traffictype,
        Total,
        Mr,
        Pw,
        Pw0,
        Lief,
        Lief0,
        LiefAufl,
        Lw,
        Lw0,
        Sattelzug,
        Bus,
        Andere,
        Year,
        Month,
        Day,
        Weekday,
        Hourfrom,
        Date,
        Timefrom,
        Timeto,
        Dayofyear,
        ZstId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ZstNr => "zst_nr",
                Field::Sitecode => "sitecode",
                Field::Sitename => "sitename",
                Field::Datetimefrom => "datetimefrom",
                Field::Datetimeto => "datetimeto",
                Field::Directionname => "directionname",
                Field::Lanecode => "lanecode",
                Field::Lanename => "lanename",
                Field::Valuesapproved => "valuesapproved",
                Field::Valuesedited => "valuesedited",
                Field::Traffictype => "traffictype",
                Field::Total => "total",
                Field::Mr => "mr",
                Field::Pw => "pw",
                Field::Pw0 => "pw0",
                Field::Lief => "lief",
                Field::Lief0 => "lief0",
                Field::LiefAufl => "lief_aufl",
                Field::Lw => "lw",
                Field::Lw0 => "lw0",
                Field::Sattelzug => "sattelzug",
                Field::Bus => "bus",
                Field::Andere => "andere",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Hourfrom => "hourfrom",
                Field::Date => "date",
                Field::Timefrom => "timefrom",
                Field::Timeto => "timeto",
                Field::Dayofyear => "dayofyear",
                Field::ZstId => "zst_id",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100006/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Strassen und Wege: Durchgangsstrassen
pub mod strassen_und_wege_durchgangsstrassen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Durchgangsstrasse
        ///
        /// Eindeutiger Identifikator der Durchgangsstrassen
        pub id_dgstr: Option<i64>,
        /// Strassennummer
        ///
        /// Hauptstrassennummer
        pub strassennr: Option<String>,
        /// Strassentyp
        pub strtyp: Option<String>,
        /// Strecke
        pub strecke: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdDgstr,
        Strassennr,
        Strtyp,
        Strecke,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdDgstr => "id_dgstr",
                Field::Strassennr => "strassennr",
                Field::Strtyp => "strtyp",
                Field::Strecke => "strecke",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100242/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Coronavirus (COVID-19): SARS-CoV-2 im Abwasser und positiv auf SARS-CoV-2 getestete Personen
pub mod coronavirus_covid_19_sars_cov_2_im_abwasser_und_positiv_auf_sars_cov_2_getestete_personen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// 7d-Median SARS-CoV-2 Abwasser
        ///
        /// 7-Tage-Median der SARS-CoV-2 RNA-Kopien pro Tag und 100'000 Personen
        pub x7_tagemedian_of_e_n1_n2_pro_tag_100_000_pers: Option<f64>,
        /// 7d-Median SARS-CoV-2-Fälle
        ///
        /// 7-Tage-Median der positiv auf SARS-CoV-2 getesteten Personen im Einzugsgebiet der ARA Basel (Kt. BS + 6 Gemeinden BL)
        pub x7t_median_bs_bl: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        X7TagemedianOfEN1N2ProTag100000Pers,
        X7tMedianBsBl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::X7TagemedianOfEN1N2ProTag100000Pers => {
                    "7_tagemedian_of_e_n1_n2_pro_tag_100_000_pers"
                }
                Field::X7tMedianBsBl => "7t_median_bs_bl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100187/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrsberuhigte Zonen: Tempo 30 - Zone
pub mod verkehrsberuhigte_zonen_tempo_30_zone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Tempo30Zone
        ///
        /// Eindeutiger Identifikator der Tempo30Zonen
        pub id_tempo30: Option<String>,
        /// Regime
        ///
        /// Regime der Zone
        pub regime: Option<String>,
        /// Regimenummer
        ///
        /// Nummer des Regimes
        pub regimenr: Option<String>,
        /// Name
        ///
        /// Name des Regimes
        pub name: Option<String>,
        /// Umsetzungsdatum
        ///
        /// Datum der Umsetzung
        pub umdatum: Option<String>,
        /// Umsetzungsjahr
        ///
        /// Jahr der Umsetzung
        pub umjahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdTempo30,
        Regime,
        Regimenr,
        Name,
        Umdatum,
        Umjahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdTempo30 => "id_tempo30",
                Field::Regime => "regime",
                Field::Regimenr => "regimenr",
                Field::Name => "name",
                Field::Umdatum => "umdatum",
                Field::Umjahr => "umjahr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100252/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Verkehrsberuhigte Zonen: Begegnungszone
pub mod verkehrsberuhigte_zonen_begegnungszone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Begegnungszone
        ///
        /// Eindeutiger Identifikator der Begegnungszonen
        pub id_begegnu: Option<String>,
        /// Regime
        ///
        /// Regime der Zone
        pub regime: Option<String>,
        /// Regimenummer
        ///
        /// Nummer des Regimes
        pub regimenr: Option<String>,
        /// Name
        ///
        /// Name des Regimes
        pub name: Option<String>,
        /// Umsetzungsdatum
        ///
        /// Datum der Umsetzung
        pub umdatum: Option<String>,
        /// Umsetzungsjahr
        ///
        /// Jahr der Umsetzung
        pub umjahr: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IdBegegnu,
        Regime,
        Regimenr,
        Name,
        Umdatum,
        Umjahr,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdBegegnu => "id_begegnu",
                Field::Regime => "regime",
                Field::Regimenr => "regimenr",
                Field::Name => "name",
                Field::Umdatum => "umdatum",
                Field::Umjahr => "umjahr",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100215/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// BachApp: Am Fluss
pub mod bachapp_am_fluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        pub sichtbar_bis: Option<Date>,
        /// Kategorie
        ///
        /// Art des Informationstext
        pub kategorie: Option<String>,
        /// Thema
        ///
        /// Thema, das die Information betrifft
        pub titel_kurz: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Informationstext
        pub text: Option<String>,
        /// Icon
        pub icon: Option<String>,
        /// Image_Top
        pub image_top: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Kategorie,
        TitelKurz,
        Titel,
        Text,
        Icon,
        ImageTop,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Kategorie => "kategorie",
                Field::TitelKurz => "titel_kurz",
                Field::Titel => "titel",
                Field::Text => "text",
                Field::Icon => "icon",
                Field::ImageTop => "image_top",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100255/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Lohntabelle des Kantons Basel-Stadt
pub mod lohntabelle_des_kantons_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Gueltigkeit
        ///
        /// Gültigkeit der Lohntabelle
        pub gueltigkeit: Option<Date>,
        /// Lohnklassen
        pub lohnklassen: Option<i64>,
        /// Lohnstufe
        pub lohnstufe: Option<String>,
        /// Jahreslohn ohne 13. Monatslohn
        ///
        /// Bruttojahreslohn ohne 13. Monatslohn
        pub jahrbruttolohnohne13: Option<i64>,
        /// Monatslohn ohne 13. Monatslohn
        ///
        /// Bruttomonatslohn ohne 13. Monatslohn
        pub monatbruttoohne13: Option<f64>,
        /// Stundenlohn ohne 13. Monatslohn
        ///
        /// Bruttostudenlohn ohne 13. Monatslohn
        pub stundenbruttoohne13: Option<f64>,
        /// Jahreslohn inkl. 13. Monatslohn
        ///
        /// Bruttojahreslohn inkl. 13.Monatslohn
        pub jahrbruttolohnmit13: Option<f64>,
        /// Sortiervariable
        ///
        /// Sortiervariable für die Spalte mit den Lohnstufen
        pub sortiervariable: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Jahr,
        Gueltigkeit,
        Lohnklassen,
        Lohnstufe,
        Jahrbruttolohnohne13,
        Monatbruttoohne13,
        Stundenbruttoohne13,
        Jahrbruttolohnmit13,
        Sortiervariable,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Gueltigkeit => "gueltigkeit",
                Field::Lohnklassen => "lohnklassen",
                Field::Lohnstufe => "lohnstufe",
                Field::Jahrbruttolohnohne13 => "jahrbruttolohnohne13",
                Field::Monatbruttoohne13 => "monatbruttoohne13",
                Field::Stundenbruttoohne13 => "stundenbruttoohne13",
                Field::Jahrbruttolohnmit13 => "jahrbruttolohnmit13",
                Field::Sortiervariable => "sortiervariable",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100123/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Basel Info: Interessante Orte (POI)
pub mod basel_info_interessante_orte_poi {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// TID
        pub tid: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// SUBKATGEO
        pub subkatgeo: Option<String>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// BESCHREIBG
        pub beschreibg: Option<String>,
        /// ART
        pub art: Option<String>,
        /// STRASSE
        pub strasse: Option<String>,
        /// ORT
        pub ort: Option<String>,
        /// TELEFON
        pub telefon: Option<String>,
        /// WWW_LINK
        pub www_link: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Tid,
        Name,
        Subkatgeo,
        Kategorie,
        Beschreibg,
        Art,
        Strasse,
        Ort,
        Telefon,
        WwwLink,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Tid => "tid",
                Field::Name => "name",
                Field::Subkatgeo => "subkatgeo",
                Field::Kategorie => "kategorie",
                Field::Beschreibg => "beschreibg",
                Field::Art => "art",
                Field::Strasse => "strasse",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::WwwLink => "www_link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100015/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Luftqualität Vergleichsmessungen
pub mod smarte_strasse_luftqualitaet_vergleichsmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel = Anfangszeit des 30 minütigen Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// A2 Hard NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor A2 Hard
        pub a2hard_no2: Option<f64>,
        /// A2 Hard O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor A2 Hard
        pub a2hard_o3: Option<f64>,
        /// A2 Hard PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor A2 Hard
        pub a2hard_pm25: Option<f64>,
        /// Feldbergstrasse NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Feldbergstrasse
        pub feldbergstr2_no2: Option<f64>,
        /// Feldbergstrasse O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Feldbergstrasse
        pub feldbergstr2_o3: Option<f64>,
        /// Feldbergstrasse PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Feldbergstrasse
        pub feldbergstr2_pm25: Option<f64>,
        /// St. Johannsplatz NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor St. Johannsplatz
        pub stjohann2_no2: Option<f64>,
        /// St. Johannsplatz O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor St. Johannsplatz
        pub stjohann2_o3: Option<f64>,
        /// St. Johannsplatz PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor St. Johannsplatz
        pub stjohann2_pm25: Option<f64>,
        pub timestamp_text: Option<String>,
        /// Anfangszeit
        pub anfangszeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        A2hardNo2,
        A2hardO3,
        A2hardPm25,
        Feldbergstr2No2,
        Feldbergstr2O3,
        Feldbergstr2Pm25,
        Stjohann2No2,
        Stjohann2O3,
        Stjohann2Pm25,
        TimestampText,
        Anfangszeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::A2hardNo2 => "a2hard_no2",
                Field::A2hardO3 => "a2hard_o3",
                Field::A2hardPm25 => "a2hard_pm25",
                Field::Feldbergstr2No2 => "feldbergstr2_no2",
                Field::Feldbergstr2O3 => "feldbergstr2_o3",
                Field::Feldbergstr2Pm25 => "feldbergstr2_pm25",
                Field::Stjohann2No2 => "stjohann2_no2",
                Field::Stjohann2O3 => "stjohann2_o3",
                Field::Stjohann2Pm25 => "stjohann2_pm25",
                Field::TimestampText => "timestamp_text",
                Field::Anfangszeit => "anfangszeit",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100178/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Flächen der Schulstandorte (Gemeinde Basel)
pub mod flaechen_der_schulstandorte_gemeinde_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Schulstandort
        ///
        /// Bezeichnung des Schulstandorts
        pub schulstand: Option<String>,
        /// Schultyp
        ///
        /// Art des Schulhauses
        pub schultyp: Option<String>,
        /// Strasse
        ///
        /// Strassenname des Schulhauses
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer des Schulhauses
        pub hausnr: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl des Schulhauses
        pub plz: Option<String>,
        /// Ortschaft
        ///
        /// Ortschaftsname des Schulhauses
        pub ort: Option<String>,
        /// Link
        ///
        /// Internetadresse des Schulhauses
        pub link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Schulstand,
        Schultyp,
        Strasse,
        Hausnr,
        Plz,
        Ort,
        Link,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schulstand => "schulstand",
                Field::Schultyp => "schultyp",
                Field::Strasse => "strasse",
                Field::Hausnr => "hausnr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Link => "link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100342/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rheintrübung kontinuierlich
pub mod rheintruebung_kontinuierlich {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start
        ///
        /// Start der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub startzeitpunkt: Option<OffsetDateTime>,
        /// Ende
        ///
        /// Ende der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub endezeitpunkt: Option<OffsetDateTime>,
        /// Trübung [FNU]
        ///
        /// Stundenmittelwert der Trübung gemessen in FNU ("Formazin Nephelometric Unit", was auf Deutsch "Nephelometrische Formazin-Einheit" bedeutet)
        pub rus_w_o_ms_tr: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Startzeitpunkt,
        Endezeitpunkt,
        RusWOMsTr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Startzeitpunkt => "startzeitpunkt",
                Field::Endezeitpunkt => "endezeitpunkt",
                Field::RusWOMsTr => "rus_w_o_ms_tr",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100323/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Luftqualität Station Chrischona
pub mod luftqualitaet_station_chrischona {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp_text: Option<OffsetDateTime>,
        pub o3_stundenmittelwerte_ug_m3: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        O3StundenmittelwerteUgM3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::O3StundenmittelwerteUgM3 => "o3_stundenmittelwerte_ug_m3",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100048/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Grosser Rat: Ratsmitgliedschaften
pub mod grosser_rat_ratsmitgliedschaften {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Aktiv
        ///
        /// Mitgliedschaft in momentan laufender Legislaturperiode
        pub ist_aktuell_grossrat: Option<String>,
        /// Anrede
        ///
        /// Die Anrede nach amtlichem Geschlecht
        pub anrede: Option<String>,
        /// Titel
        ///
        /// Akademischer Titel des (ehemaligen) Grossratsmitglieds
        pub titel: Option<String>,
        /// Name
        ///
        /// Nachname des (ehemaligen) Grossratsmitglieds
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname des (ehemaligen) Grossratsmitglieds
        pub vorname: Option<String>,
        /// Name, Vorname
        ///
        /// Name und Vorname des (ehemaligen) Grossratsmitglieds
        pub name_vorname: Option<String>,
        /// Geburtsdatum
        ///
        /// Geburtsdatum des (ehemaligen) Grossratsmitglieds
        pub gebdatum: Option<Date>,
        /// Sitz Nr.
        ///
        /// Nummer des Sitzes des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub gr_sitzplatz: Option<i64>,
        /// Wahlkreis
        ///
        /// Wahlkreis des (ehemaligen) Grossratsmitglieds
        pub gr_wahlkreis: Option<String>,
        /// Partei
        ///
        /// Parteizugehörigkeit des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei: Option<String>,
        /// Partei abgekürzt
        ///
        /// Abkürzung der Parteizugehörigkeit des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei_kname: Option<String>,
        /// Beginn Grossratsmitgliedschaft
        ///
        /// Startdatum der Mitgliedschaft im Grossen Rat
        pub gr_beginn: Option<Date>,
        /// Ende Grossratsmitgliedschaft
        ///
        /// Enddatum der Mitgliedschaft im Grossen Rat
        pub gr_ende: Option<Date>,
        /// Ratsmitglied grosserrat.bs.ch
        ///
        /// Link zum (ehemaligen) Grossratsmitglied auf der Webseite des Grossen Rates
        pub url: Option<String>,
        /// ID
        ///
        /// Individuelle Identifikationsnummer des (ehemaligen) Grossratsmitglied innerhalb der Datenbank des Grossen Rates
        pub uni_nr: Option<String>,
        /// Strasse
        ///
        /// Strasse an der das Grossratsmitglied wohnhaft ist.
        pub strasse: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl an der das Grossratsmitglied wohnhaft ist.
        pub plz: Option<String>,
        /// Ort
        ///
        /// Ortschaft in der das Grossratsmitglied wohnhaft ist.
        pub ort: Option<String>,
        /// Berufliche Tätigkeit
        ///
        /// Berufliche Tätigkeit des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub gr_beruf: Option<String>,
        /// Arbeitgeber
        ///
        /// Arbeitgeber des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub gr_arbeitgeber: Option<String>,
        /// Homepage
        ///
        /// Homepage des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub homepage: Option<String>,
        /// Gremiumsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Mitgliedschaften in Gremien". Gefiltert nach aktuellem Grossratsmitglied.
        pub url_gremiumsmitgliedschaften: Option<String>,
        /// Interessensbindungen data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Interessensbindungen Ratsmitglieder". Gefiltert nach aktuellem Grossratsmitglied.
        pub url_interessensbindungen: Option<String>,
        /// Urheber von
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach Geschäften, denen das aktuelle Grossratsmitglied als Urheber dient.
        pub url_urheber: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        IstAktuellGrossrat,
        Anrede,
        Titel,
        Name,
        Vorname,
        NameVorname,
        Gebdatum,
        GrSitzplatz,
        GrWahlkreis,
        Partei,
        ParteiKname,
        GrBeginn,
        GrEnde,
        Url,
        UniNr,
        Strasse,
        Plz,
        Ort,
        GrBeruf,
        GrArbeitgeber,
        Homepage,
        UrlGremiumsmitgliedschaften,
        UrlInteressensbindungen,
        UrlUrheber,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IstAktuellGrossrat => "ist_aktuell_grossrat",
                Field::Anrede => "anrede",
                Field::Titel => "titel",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::NameVorname => "name_vorname",
                Field::Gebdatum => "gebdatum",
                Field::GrSitzplatz => "gr_sitzplatz",
                Field::GrWahlkreis => "gr_wahlkreis",
                Field::Partei => "partei",
                Field::ParteiKname => "partei_kname",
                Field::GrBeginn => "gr_beginn",
                Field::GrEnde => "gr_ende",
                Field::Url => "url",
                Field::UniNr => "uni_nr",
                Field::Strasse => "strasse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::GrBeruf => "gr_beruf",
                Field::GrArbeitgeber => "gr_arbeitgeber",
                Field::Homepage => "homepage",
                Field::UrlGremiumsmitgliedschaften => "url_gremiumsmitgliedschaften",
                Field::UrlInteressensbindungen => "url_interessensbindungen",
                Field::UrlUrheber => "url_urheber",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100307/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wohnbevölkerung nach Staatsangehörigkeit und Wohnviertel
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// WOV_NAME
        pub wov_name: Option<String>,
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// WOV_LABEL
        pub wov_label: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_al: Option<String>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub gesbev_f: Option<i64>,
        pub gemeinde_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        WovName,
        Wohnviertel,
        WovLabel,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
        GemeindeName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WovName => "wov_name",
                Field::Wohnviertel => "wohnviertel",
                Field::WovLabel => "wov_label",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
                Field::GemeindeName => "gemeinde_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100060/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Einzugsgebiet der ARA Basel
pub mod einzugsgebiet_der_ara_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Name
        pub name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100336/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Fischereiverbotszonen Rhein
pub mod fischereiverbotszonen_rhein {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<i64>,
        /// Beschreibung
        pub beschreibung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        Beschreibung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Beschreibung => "beschreibung",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100278/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rhein Wasserstand, Pegel und Abfluss
pub mod rhein_wasserstand_pegel_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmetern pro Sekunde
        pub abfluss: Option<f64>,
        /// Pegel
        ///
        /// Pegelstand in cm über dem Pegelnullstand von 240 m ü. M.
        pub pegelhoehe: Option<f64>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Abfluss,
        Pegelhoehe,
        Pegel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Abfluss => "abfluss",
                Field::Pegelhoehe => "pegelhoehe",
                Field::Pegel => "pegel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100089/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Rohdaten-Zeitreihe der Belegung der Elektroauto-Ladestationen der IWB
pub mod rohdaten_zeitreihe_der_belegung_der_elektroauto_ladestationen_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Strasse und Hausnummer
        pub addresse: Option<String>,
        /// Ladeleistung
        pub power: Option<String>,
        /// Ort
        pub location: Option<String>,
        /// Parkfeld-Nr
        ///
        /// Eine Ladestation kann mehrere Parkfelder haben
        pub parkingfield: Option<i64>,
        /// Total Parkfelder
        ///
        /// Anzahl Parkfelder einer Ladestation
        pub totalparkings: Option<i64>,
        /// Available / Occupied entspricht frei / belegt
        pub status: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Addresse,
        Power,
        Location,
        Parkingfield,
        Totalparkings,
        Status,
        Timestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Addresse => "addresse",
                Field::Power => "power",
                Field::Location => "location",
                Field::Parkingfield => "parkingfield",
                Field::Totalparkings => "totalparkings",
                Field::Status => "status",
                Field::Timestamp => "timestamp",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100149/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kandidierende der Grossratswahlen 2024 nach Häufigkeit der Kandidatur seit 2008
pub mod kandidierende_der_grossratswahlen_2024_nach_haeufigkeit_der_kandidatur_seit_2008 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Häufigkeit
        ///
        /// Häufigkeit von Kandidaturen
        pub haufigkeit: Option<String>,
        /// Kandidaturen
        ///
        /// Kandidaturen seit 2008
        pub kandidaturen: Option<String>,
        /// Gewählt (2008 bis 2020)
        ///
        /// Gewählt zwischen 2008 bis 2020
        pub gewahlt: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kandidierende
        pub anzahl: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Haufigkeit,
        Kandidaturen,
        Gewahlt,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Haufigkeit => "haufigkeit",
                Field::Kandidaturen => "kandidaturen",
                Field::Gewahlt => "gewahlt",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100393/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Kennzahlen der Abstimmungen
pub mod kennzahlen_der_abstimmungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// ID
        ///
        /// Die ID besteht aus dem Datum, der ID der Vorlage und der ID der Gemeinde
        pub id: Option<String>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anzahl gültige Stimmzettel geteilt durch Anzahl Stimmberechtigte im Kanton Basel-Stadt
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmende
        ///
        /// Anzahl brieflich abgegebene Stimmen geteilt durch Anzahl abgegebener Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmende
        ///
        /// Anzahl elektronisch Stimmender
        pub anz_elektr_pro_abst_art: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag am Total der Stimmen mit gültiger Antwort
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Gegenvorschlag
        pub gege_oga_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Stichfrage
        pub sti_oga_anz: Option<i64>,
        /// Datum (Text)
        pub abst_datum_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        AbstDatum,
        AbstId,
        AbstTitel,
        AbstIdTitel,
        AbstArt,
        GemeinId,
        GemeinName,
        Id,
        ResultArt,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        StimmrAnz,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        InitOgaAnz,
        GegeOgaAnz,
        StiOgaAnz,
        AbstDatumText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::AbstDatum => "abst_datum",
                Field::AbstId => "abst_id",
                Field::AbstTitel => "abst_titel",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstArt => "abst_art",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::Id => "id",
                Field::ResultArt => "result_art",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::StimmrAnz => "stimmr_anz",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::InitOgaAnz => "init_oga_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::AbstDatumText => "abst_datum_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100346/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Durchschnittlicher Tagesverkehr (basierend auf dem Geschwindigkeitsmonitoring der Kantonspolizei)
pub mod durchschnittlicher_tagesverkehr_basierend_auf_dem_geschwindigkeitsmonitoring_der_kantonspolizei {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// ausserordendliche Verkehrsführung
        ///
        /// Messung während ausserordentlicher Verkehrsführung
        pub extraordinary_traffic_routing: Option<String>,
        /// Anfangszeit
        ///
        /// Anfangszeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub min_timestamp: Option<OffsetDateTime>,
        /// Endzeit
        ///
        /// Endzeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub max_timestamp: Option<OffsetDateTime>,
        /// Messdauer (Stunden)
        ///
        /// Messdauer in Stunden
        pub messdauer_h: Option<f64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Anzahl Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge
        pub count: Option<i64>,
        /// Anzahl Fahrzeuge bis 3.5 m
        ///
        /// Anzahl Fahrzeuge der Längenklasse bis 3.5 m
        pub count_lt_3_5m: Option<i64>,
        /// Anzahl Fahrzeuge zwischen 3.5 m und 8 m
        ///
        /// Anzahl Fahrzeuge der Längenklasse zwischen 3.5 m und 8 m
        pub count_3_5_to_lt_8m: Option<i64>,
        /// Anzahl Fahrzeuge ab 8 m
        ///
        /// Anzahl Fahrzeuge der Längenklasse 8 m oder grösser
        pub count_gte_8m: Option<i64>,
        /// Durchschnittlicher Tagesverkehr (DTV)
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum
        pub dtv: Option<f64>,
        /// DTV Fahrzeuge bis 3.5 m
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum der Fahrzeuge der Längenklasse bis 3.5 m
        pub dtv_lt_3_5m: Option<f64>,
        /// DTV Fahrzeuge zwischen 3.5 m und 8 m
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum der Fahrzeuge der Längenklasse zwischen 3.5 m und 8 m
        pub dtv_3_5_to_lt_8m: Option<f64>,
        /// DTV Fahrzeuge ab 8 m
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum der Fahrzeuge der Längenklasse über 8 m
        pub dtv_gte_8m: Option<f64>,
        /// Datensatz-ID
        ///
        /// Datensatz-ID der Einzelmessungen
        pub dataset_id: Option<i64>,
        /// Einzelmessungen
        ///
        /// Link zu den Einzelmessungen
        pub link_zu_einzelmessungen: Option<String>,
        /// Anfangszeit (Text)
        ///
        /// Anfangszeit der Messung im Textformat
        pub min_timestamp_text: Option<String>,
        /// Endzeit (Text)
        ///
        /// Endzeit der Messung im Textformat
        pub max_timestamp_text: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        MessungId,
        Strasse,
        StrasseNr,
        Ort,
        ExtraordinaryTrafficRouting,
        MinTimestamp,
        MaxTimestamp,
        MessdauerH,
        RichtungId,
        Richtung,
        Count,
        CountLt35m,
        Count35ToLt8m,
        CountGte8m,
        Dtv,
        DtvLt35m,
        Dtv35ToLt8m,
        DtvGte8m,
        DatasetId,
        LinkZuEinzelmessungen,
        MinTimestampText,
        MaxTimestampText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::MessungId => "messung_id",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Ort => "ort",
                Field::ExtraordinaryTrafficRouting => "extraordinary_traffic_routing",
                Field::MinTimestamp => "min_timestamp",
                Field::MaxTimestamp => "max_timestamp",
                Field::MessdauerH => "messdauer_h",
                Field::RichtungId => "richtung_id",
                Field::Richtung => "richtung",
                Field::Count => "count",
                Field::CountLt35m => "count_lt_3_5m",
                Field::Count35ToLt8m => "count_3_5_to_lt_8m",
                Field::CountGte8m => "count_gte_8m",
                Field::Dtv => "dtv",
                Field::DtvLt35m => "dtv_lt_3_5m",
                Field::Dtv35ToLt8m => "dtv_3_5_to_lt_8m",
                Field::DtvGte8m => "dtv_gte_8m",
                Field::DatasetId => "dataset_id",
                Field::LinkZuEinzelmessungen => "link_zu_einzelmessungen",
                Field::MinTimestampText => "min_timestamp_text",
                Field::MaxTimestampText => "max_timestamp_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100199/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wiese Wasserstand und Abfluss
pub mod wiese_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmetern pro Sekunde
        pub abfluss: Option<f64>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Abfluss,
        Pegel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Abfluss => "abfluss",
                Field::Pegel => "pegel",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100235/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Parkplatzbelegung
pub mod smarte_strasse_parkplatzbelegung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Blau: Total Parkplätze
        ///
        /// Total Anzahl erfasster blauer Parkplätze
        pub blue_total: Option<i64>,
        /// Blau: verfügbar
        ///
        /// Anzahl verfügbarer blauer Parkplätze
        pub blue_available: Option<i64>,
        /// Blau: besetzt
        ///
        /// Anzahl besetzte blaue Parkplätze
        pub blue_occupied: Option<i64>,
        /// Gelb: Total Parkplätze
        ///
        /// Total Anzahl erfasste gelbe Parkplätze
        pub yellow_total: Option<i64>,
        /// Gelb: verfügbar
        ///
        /// Anzahl verfügbare gelbe Parkplätze
        pub yellow_available: Option<i64>,
        /// Gelb: besetzt
        ///
        /// Anzahl besetzte gelbe Parkplätze
        pub yellow_occupied: Option<i64>,
        pub timestamp_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        BlueTotal,
        BlueAvailable,
        BlueOccupied,
        YellowTotal,
        YellowAvailable,
        YellowOccupied,
        TimestampText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::BlueTotal => "blue_total",
                Field::BlueAvailable => "blue_available",
                Field::BlueOccupied => "blue_occupied",
                Field::YellowTotal => "yellow_total",
                Field::YellowAvailable => "yellow_available",
                Field::YellowOccupied => "yellow_occupied",
                Field::TimestampText => "timestamp_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100160/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Temperatur Grundwasser
pub mod temperatur_grundwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Value
        ///
        /// Messwert: Grundwassertemperatur [°C]
        pub value: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// Status
        ///
        /// Rohadaten/ungeprüfte Daten (raw)
        ///bereinigte/geprüfte Daten (cleansed)
        pub status: Option<String>,
        /// on/offline
        pub on_offline: Option<String>,
        /// Date
        ///
        /// Datum in mitteleuropäischer Winterzeit (UTC+1)
        pub date: Option<String>,
        /// Time
        ///
        /// Zeit in mitteleuropäischer Winterzeit (UTC+1)
        pub time: Option<String>,
        /// Zeitstempel in mitteleuropäischer Winterzeit (UTC+1)
        pub timestamp_text: Option<String>,
        /// StationId
        ///
        /// Katasternummer gemäss Bohrkataster
        pub stationid: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Stationnr,
        Stationname,
        Sensornr,
        Sensname,
        Value,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        Status,
        OnOffline,
        Date,
        Time,
        TimestampText,
        Stationid,
        Lat,
        Lon,
        BohrkatasterLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Stationnr => "stationnr",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Value => "value",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::Status => "status",
                Field::OnOffline => "on_offline",
                Field::Date => "date",
                Field::Time => "time",
                Field::TimestampText => "timestamp_text",
                Field::Stationid => "stationid",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::BohrkatasterLink => "bohrkataster_link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100179/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Belegung der Elektroauto-Ladestationen der IWB
pub mod belegung_der_elektroauto_ladestationen_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub addresse: Option<String>,
        pub power: Option<String>,
        pub location: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
        pub parkingfield: Option<i64>,
        pub totalparkings: Option<i64>,
        pub status: Option<String>,
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Addresse,
        Power,
        Location,
        Parkingfield,
        Totalparkings,
        Status,
        Timestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Addresse => "addresse",
                Field::Power => "power",
                Field::Location => "location",
                Field::Parkingfield => "parkingfield",
                Field::Totalparkings => "totalparkings",
                Field::Status => "status",
                Field::Timestamp => "timestamp",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100004/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abstimmungen Details
pub mod abstimmungen_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum der Abstimmung
        pub abst_datum: Option<Date>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Gemeinde-ID
        ///
        /// Numerische Kennung, die jeder Gemeinde eine eindeutige Identifikation zuweist
        pub gemein_id: Option<i64>,
        /// Gemeinde
        ///
        /// Die "Gemeinde" bezeichnet die geografische oder politische Einheit, in der die Abstimmung oder Wahl stattgefunden hat
        pub gemein_name: Option<String>,
        /// Wahllokal-ID
        ///
        /// Numerische Kennung, die jedem Wahllokal eine eindeutige Identifikation zugewiesen wird
        pub wahllok_id: Option<i64>,
        /// Wahllokal
        ///
        /// Standort, an dem die Abstimmung durchgeführt wurde
        pub wahllok_name: Option<String>,
        /// ID
        ///
        /// Die ID besteht aus dem Datum, der ID der Vorlage und der ID des Wahllokals
        pub id: Option<String>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen). Zwischenresultate werden durch Schlussresultate überschrieben.
        pub result_art: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Gegenvorschlag Stimmen ohne gültige Antwort
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Stimmen ohne gültige Antwort
        pub sti_oga_anz: Option<i64>,
        /// Datum der Abstimmung
        pub abst_datum_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        AbstDatum,
        AbstId,
        AbstTitel,
        AbstIdTitel,
        AbstArt,
        GemeinId,
        GemeinName,
        WahllokId,
        WahllokName,
        Id,
        ResultArt,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        InitOgaAnz,
        GegeOgaAnz,
        StiOgaAnz,
        AbstDatumText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::AbstDatum => "abst_datum",
                Field::AbstId => "abst_id",
                Field::AbstTitel => "abst_titel",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstArt => "abst_art",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::WahllokId => "wahllok_id",
                Field::WahllokName => "wahllok_name",
                Field::Id => "id",
                Field::ResultArt => "result_art",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::InitOgaAnz => "init_oga_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::AbstDatumText => "abst_datum_text",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100345/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Temperatur Wiese
pub mod temperatur_wiese {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp_text: Option<OffsetDateTime>,
        /// Temperatur
        ///
        /// Temperatur in Grad Celsius
        pub temperatur: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        TimestampText,
        Temperatur,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TimestampText => "timestamp_text",
                Field::Temperatur => "temperatur",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100269/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wetterstation Rosental Mitte
pub mod wetterstation_rosental_mitte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Niederschlag
        ///
        /// Total der Niederschläge innerhalb der letzten Stunde
        pub precipitation: Option<f64>,
        /// Luftfeuchtigkeit
        ///
        /// Luftfeuchtigkeit bezieht sich auf die Menge an Wassertröpfchen oder Wasserdampf, die in der Luft vorhanden sind.
        pub relativehumidityhc: Option<f64>,
        /// Globalstrahlung [W/m2]
        ///
        /// Globalstrahlung ist die Menge an Sonnenenergie, die auf eine horizontale Fläche in einer bestimmten Zeitspanne (normalerweise in Stunden) auftrifft.
        pub solarradiation: Option<f64>,
        /// Lufttemperatur
        ///
        /// Lufttemperatur bezieht sich auf die Masseinheit der Wärmeenergie, die in der Luft vorhanden ist.
        pub airtemperaturehc: Option<f64>,
        /// Windgeschwindigkeit
        ///
        /// Windgeschwindigkeit bezieht sich auf die Geschwindigkeit, mit der sich Luft in horizontaler Richtung bewegt.
        pub windspeedultrasonic: Option<f64>,
        /// Windrichtung
        ///
        /// Windrichtung bezieht sich auf die Richtung, aus der der Wind weht. Sie wird normalerweise in Grad gemessen, wobei 0 Grad für Nord, 90 Grad für Ost, 180 Grad für Süd und 270 Grad für West steht.
        pub winddirultrasonic: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Timestamp,
        Precipitation,
        Relativehumidityhc,
        Solarradiation,
        Airtemperaturehc,
        Windspeedultrasonic,
        Winddirultrasonic,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Precipitation => "precipitation",
                Field::Relativehumidityhc => "relativehumidityhc",
                Field::Solarradiation => "solarradiation",
                Field::Airtemperaturehc => "airtemperaturehc",
                Field::Windspeedultrasonic => "windspeedultrasonic",
                Field::Winddirultrasonic => "winddirultrasonic",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100294/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Transformation Areal Rosental: Standorte
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_standorte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// X-Koordinate
        pub x_coord: Option<f64>,
        /// Y-Koordinate
        pub y_coord: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Name,
        XCoord,
        YCoord,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100293/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Abwassermonitoring: Influenza und RSV
pub mod abwassermonitoring_influenza_und_rsv {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<Date>,
        /// KW
        pub kw: Option<i64>,
        /// Sample Ba-Nr.
        pub sample_ba_nr: Option<String>,
        /// InfA (gc/PCR)
        pub infa_gc_pcr: Option<f64>,
        /// InfB (gc/PCR)
        pub infb_gc_pcr: Option<f64>,
        /// RSV (gc/PCR)
        pub rsv_gc_pcr: Option<f64>,
        /// InfA (gc/L)
        pub infa_gc_l: Option<f64>,
        /// InfB (gc/L)
        pub infb_gc_l: Option<f64>,
        /// RSV (gc/L)
        pub rsv_gc_l: Option<f64>,
        /// InfA (gc/L) 7-d median
        pub infa_gc_l_7_d_median: Option<f64>,
        /// InfB (gc/L) 7-d median
        pub infb_gc_l_7_d_median: Option<f64>,
        /// RSV (gc/L) 7-d median
        pub rsv_gc_l_7_d_median: Option<f64>,
        /// InfA (gc /100'000 P)
        pub infa_gc_100_000_p: Option<f64>,
        /// InfB (gc/100'000 P)
        pub infb_gc_100_000_p: Option<f64>,
        /// RSV (gc /100'000 P)
        pub rsv_gc_100_000_p: Option<f64>,
        /// InfA (gc/100'000 P) 7-d median
        pub infa_gc_100_000_p_7_d_median: Option<f64>,
        /// InfB (gc/100'000 P) 7-d median
        pub infb_gc_100_000_p_7_d_median: Option<f64>,
        /// RSV (gc/100'000 P) 7-d median
        pub rsv_gc_100_000_p_7_d_median: Option<f64>,
        /// InfA (gc/PMMoV)
        pub infa_gc_pmmov: Option<f64>,
        /// InfB (gc/PMMoV)
        pub infb_gc_pmmov: Option<f64>,
        /// RSV (gc /PMMoV)
        pub rsv_gc_pmmov: Option<f64>,
        /// InfA (gc/PMMoV) 7-d median
        pub infa_gc_pmmov_7_d_median: Option<f64>,
        /// InfB (gc/PMMoV) 7-d median
        pub infb_gc_pmmov_7_d_median: Option<f64>,
        /// RSV (gc/PMMoV) 7-d median
        pub rsv_gc_pmmov_7_d_median: Option<f64>,
        /// weekly_Anz_pos_RSV
        pub kw_anz_pos_rsv_usb: Option<i64>,
        /// Anz_pos_A_BS
        pub anz_pos_a_bs: Option<i64>,
        /// Anz_pos_B_BS
        pub anz_pos_b_bs: Option<i64>,
        /// Anz_pos_H1_BS
        pub anz_pos_h1_bs: Option<i64>,
        /// Anz.pos.A_BL
        pub anz_pos_a_bl: Option<i64>,
        /// Anz.pos.B_BL
        pub anz_pos_b_bl: Option<i64>,
        /// Anz.pos.all_BL
        pub anz_pos_all_bl: Option<i64>,
        /// InfA_BS+BL
        pub infa_bs_bl: Option<i64>,
        /// InfB_BS+BL
        pub infb_bs_bl: Option<i64>,
        /// 7t_median_InfA
        pub x7t_median_infa: Option<i64>,
        /// 7t_median_InfB
        pub x7t_median_infb: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Datum,
        Kw,
        SampleBaNr,
        InfaGcPcr,
        InfbGcPcr,
        RsvGcPcr,
        InfaGcL,
        InfbGcL,
        RsvGcL,
        InfaGcL7DMedian,
        InfbGcL7DMedian,
        RsvGcL7DMedian,
        InfaGc100000P,
        InfbGc100000P,
        RsvGc100000P,
        InfaGc100000P7DMedian,
        InfbGc100000P7DMedian,
        RsvGc100000P7DMedian,
        InfaGcPmmov,
        InfbGcPmmov,
        RsvGcPmmov,
        InfaGcPmmov7DMedian,
        InfbGcPmmov7DMedian,
        RsvGcPmmov7DMedian,
        KwAnzPosRsvUsb,
        AnzPosABs,
        AnzPosBBs,
        AnzPosH1Bs,
        AnzPosABl,
        AnzPosBBl,
        AnzPosAllBl,
        InfaBsBl,
        InfbBsBl,
        X7tMedianInfa,
        X7tMedianInfb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Kw => "kw",
                Field::SampleBaNr => "sample_ba_nr",
                Field::InfaGcPcr => "infa_gc_pcr",
                Field::InfbGcPcr => "infb_gc_pcr",
                Field::RsvGcPcr => "rsv_gc_pcr",
                Field::InfaGcL => "infa_gc_l",
                Field::InfbGcL => "infb_gc_l",
                Field::RsvGcL => "rsv_gc_l",
                Field::InfaGcL7DMedian => "infa_gc_l_7_d_median",
                Field::InfbGcL7DMedian => "infb_gc_l_7_d_median",
                Field::RsvGcL7DMedian => "rsv_gc_l_7_d_median",
                Field::InfaGc100000P => "infa_gc_100_000_p",
                Field::InfbGc100000P => "infb_gc_100_000_p",
                Field::RsvGc100000P => "rsv_gc_100_000_p",
                Field::InfaGc100000P7DMedian => "infa_gc_100_000_p_7_d_median",
                Field::InfbGc100000P7DMedian => "infb_gc_100_000_p_7_d_median",
                Field::RsvGc100000P7DMedian => "rsv_gc_100_000_p_7_d_median",
                Field::InfaGcPmmov => "infa_gc_pmmov",
                Field::InfbGcPmmov => "infb_gc_pmmov",
                Field::RsvGcPmmov => "rsv_gc_pmmov",
                Field::InfaGcPmmov7DMedian => "infa_gc_pmmov_7_d_median",
                Field::InfbGcPmmov7DMedian => "infb_gc_pmmov_7_d_median",
                Field::RsvGcPmmov7DMedian => "rsv_gc_pmmov_7_d_median",
                Field::KwAnzPosRsvUsb => "kw_anz_pos_rsv_usb",
                Field::AnzPosABs => "anz_pos_a_bs",
                Field::AnzPosBBs => "anz_pos_b_bs",
                Field::AnzPosH1Bs => "anz_pos_h1_bs",
                Field::AnzPosABl => "anz_pos_a_bl",
                Field::AnzPosBBl => "anz_pos_b_bl",
                Field::AnzPosAllBl => "anz_pos_all_bl",
                Field::InfaBsBl => "infa_bs_bl",
                Field::InfbBsBl => "infb_bs_bl",
                Field::X7tMedianInfa => "7t_median_infa",
                Field::X7tMedianInfb => "7t_median_infb",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100302/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Wilde Abfall-Deponien
pub mod wilde_abfall_deponien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Laufnummer
        pub id: Option<String>,
        /// Zeitpunkt der Meldung
        ///
        ///
        #[serde(with = "time::serde::iso8601::option")]
        pub bearbeitungszeit_meldung: Option<OffsetDateTime>,
        /// Abfallkategorie
        ///
        /// Kategorisierung; AUE steht für das Amt für Umwelt und Energie.
        pub abfallkategorie: Option<String>,
        /// Geopunkt
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Wohnviertel
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub wov_name: Option<String>,
        /// Bezirk
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub bez_name: Option<String>,
        /// Wohnviertel-ID
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub wov_id_bez: Option<String>,
        /// Bezirk-ID
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub bez_id: Option<String>,
        /// Bezirk Label
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub bez_label: Option<String>,
        /// Gemeinde
        pub gemeinde_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Id,
        BearbeitungszeitMeldung,
        Abfallkategorie,
        WovName,
        BezName,
        WovIdBez,
        BezId,
        BezLabel,
        GemeindeName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::BearbeitungszeitMeldung => "bearbeitungszeit_meldung",
                Field::Abfallkategorie => "abfallkategorie",
                Field::WovName => "wov_name",
                Field::BezName => "bez_name",
                Field::WovIdBez => "wov_id_bez",
                Field::BezId => "bez_id",
                Field::BezLabel => "bez_label",
                Field::GemeindeName => "gemeinde_name",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100070/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smarte Strasse: Elektroauto-Ladestationen
pub mod smarte_strasse_elektroauto_ladestationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start Time
        ///
        /// Start Zeitpunkt des Ladevorgangs
        #[serde(with = "time::serde::iso8601::option")]
        pub starttime: Option<OffsetDateTime>,
        /// Stop Time
        ///
        /// Ende des Ladevorgangs
        #[serde(with = "time::serde::iso8601::option")]
        pub stoptime: Option<OffsetDateTime>,
        /// Duration min
        ///
        /// Ladedauer in Minuten
        pub duration: Option<i64>,
        /// [Wh]
        ///
        /// Lademenge in Wh
        pub watthour: Option<i64>,
        /// [kWh]
        ///
        /// Lademenge in [kWh]
        pub kilowatthour: Option<f64>,
        /// Ladeleistung
        ///
        /// Maximale Ladeleistung der Ladestation
        pub station_capacity: Option<i64>,
        /// Connector
        ///
        /// Anschluss 1 oder 2 der Ladestation
        pub connectorid: Option<i64>,
        /// Location Latitude
        ///
        /// Standort GPS Koordinaten Breitengrad
        pub station_location_coordinates_lat: Option<f64>,
        /// Location Longitude
        ///
        /// Standort GPS Koordinaten Längengrad
        pub station_location_coordinates_lng: Option<f64>,
        /// Connector Type
        ///
        /// Anschluss/ Stecker Typ
        pub station_connectortype: Option<i64>,
        /// station.location
        pub station_location: Option<GeoPoint2d>,
        /// startTimeText
        pub starttimetext: Option<String>,
        /// stopTimeText
        pub stoptimetext: Option<String>,
        pub time_measured: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Starttime,
        Stoptime,
        Duration,
        Watthour,
        Kilowatthour,
        StationCapacity,
        Connectorid,
        StationLocationCoordinatesLat,
        StationLocationCoordinatesLng,
        StationConnectortype,
        Starttimetext,
        Stoptimetext,
        TimeMeasured,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Starttime => "starttime",
                Field::Stoptime => "stoptime",
                Field::Duration => "duration",
                Field::Watthour => "watthour",
                Field::Kilowatthour => "kilowatthour",
                Field::StationCapacity => "station_capacity",
                Field::Connectorid => "connectorid",
                Field::StationLocationCoordinatesLat => "station_location_coordinates_lat",
                Field::StationLocationCoordinatesLng => "station_location_coordinates_lng",
                Field::StationConnectortype => "station_connectortype",
                Field::Starttimetext => "starttimetext",
                Field::Stoptimetext => "stoptimetext",
                Field::TimeMeasured => "time_measured",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100047/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Zeitreihe der Belegung öffentlicher Parkhäuser Basel
pub mod zeitreihe_der_belegung_oeffentlicher_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationszeit
        ///
        /// Datum und Uhrzeit der Publikation des Wertes
        #[serde(with = "time::serde::iso8601::option")]
        pub published: Option<OffsetDateTime>,
        /// Anzahl frei
        ///
        /// Anzahl freie Parkplätze
        pub free: Option<i64>,
        /// Total Plätze
        ///
        /// Anzahl Plätze insgesamt
        pub total: Option<i64>,
        /// Anteil belegter Parkplätze in Prozent
        pub auslastungen: Option<f64>,
        /// Eindeutige ID des Parkhauses
        pub id: Option<String>,
        /// Eindeutige ID des Parkhauses weltweit
        pub id2: Option<String>,
        /// Titel
        ///
        /// Name des Parkhauses
        pub title: Option<String>,
        /// Name
        ///
        /// Name des Parkhauses ohne den Text "Parkhaus"
        pub name: Option<String>,
        /// Adresse
        pub address: Option<String>,
        /// Link zu den Detailinformationen des jeweiligen Parkhauses
        pub link: Option<String>,
        /// Standort des Parkhauses
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Beschreibung
        ///
        /// Text, der die Anzahl freier Parkplätze enthält
        pub description: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Published,
        Free,
        Total,
        Auslastungen,
        Id,
        Id2,
        Title,
        Name,
        Address,
        Link,
        Description,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Published => "published",
                Field::Free => "free",
                Field::Total => "total",
                Field::Auslastungen => "auslastungen",
                Field::Id => "id",
                Field::Id2 => "id2",
                Field::Title => "title",
                Field::Name => "name",
                Field::Address => "address",
                Field::Link => "link",
                Field::Description => "description",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100014/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Solarkataster: Solarpotenzial
pub mod solarkataster_solarpotenzial {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Gebäude
        ///
        /// Identifikator des Gebäudes
        pub idgebaeude: Option<i64>,
        /// Gebäudenummer
        ///
        /// GWR-Nummer des Gebäudes
        pub gebaeudenr: Option<i64>,
        /// Photovoltaik Beste Eignung
        ///
        /// Dachfläche mit bester Eignung für Photovoltaik in m2 (> 1100 kWh/m2a und 10m2 Mindestfläche)
        pub pv_best_ei: Option<f64>,
        /// Photovoltaik Gute Eignung
        ///
        /// Dachfläche mit guter Eignung für Photovoltaik in m2 (800 bis 1100 kWh/m2a und 10m2 Mindestfläche)
        pub pv_gute_ei: Option<f64>,
        /// Fassade Gute Eignung
        ///
        /// Fassadenfläche mit guter Eignung für Photovoltaik in m2 (>600kWh/m2a)
        pub f_gute_ei: Option<f64>,
        /// Solarthermie Beste Eignung
        ///
        /// Dachfläche mit bester Eignung für Solarthermie in m2 (> 1100 kWh/m2a und 5m2 Mindestfläche)
        pub st_best_ei: Option<f64>,
        /// Solarthermie Gute Eignung
        ///
        /// Dachfläche mit guter Eignung für Solarthermie in m2 (800 bis 1100 kWh/m2a und 5m2 Mindestfläche)
        pub st_gute_ei: Option<f64>,
        /// Photovoltaik Ertrag Jahr
        ///
        /// Möglicher Stromertrag pro Jahr für Dachflächen mit Photovoltaik in kWh
        pub pv_ertrg_j: Option<i64>,
        /// Photovoltaik Ertrag Winter
        ///
        /// Möglicher Stromertrag pro Winterhalbjahr für Dachflächen mit Photovoltaik in kWh
        pub pv_ertrg_w: Option<i64>,
        /// Photovoltaik Ertrag Sommer
        ///
        /// Möglicher Stromertrag pro Sommerhalbjahr für Dachflächen mit Photovoltaik in kWh
        pub pv_ertrg_s: Option<i64>,
        /// Fassade Ertrag Jahr
        ///
        /// Möglicher Stromertrag pro Jahr für Fassadenflächen mit Photovoltaik in kWh
        pub f_ertrg_j: Option<i64>,
        /// Fassade Ertrag Winter
        ///
        /// Möglicher Stromertrag pro Winterhalbjahr für Fassadenflächen mit Photovoltaik in kWh
        pub f_ertrg_w: Option<i64>,
        /// Fassade Ertrag Sommer
        ///
        /// Möglicher Stromertrag pro Sommerhalbjahr für Fassadenflächen mit Photovoltaik in kWh
        pub f_ertrg_s: Option<i64>,
        /// Solarthermie Ertrag Jahr
        ///
        /// Möglicher Wärmeertrag pro Jahr für Dachflächen mit Solarthermie in kWh
        pub st_ertrg_j: Option<i64>,
        /// Solarthermie Ertrag Winter
        ///
        /// Möglicher Wärmeertrag pro Winterhalbjahr für Dachflächen mit Solarthermie in kWh
        pub st_ertrg_w: Option<i64>,
        /// Solarthermie Ertrag Sommer
        ///
        /// Möglicher Wärmeertrag pro Sommerhalbjahr für Dachflächen mit Solarthermie in kWh
        pub st_ertrg_s: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Idgebaeude,
        Gebaeudenr,
        PvBestEi,
        PvGuteEi,
        FGuteEi,
        StBestEi,
        StGuteEi,
        PvErtrgJ,
        PvErtrgW,
        PvErtrgS,
        FErtrgJ,
        FErtrgW,
        FErtrgS,
        StErtrgJ,
        StErtrgW,
        StErtrgS,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idgebaeude => "idgebaeude",
                Field::Gebaeudenr => "gebaeudenr",
                Field::PvBestEi => "pv_best_ei",
                Field::PvGuteEi => "pv_gute_ei",
                Field::FGuteEi => "f_gute_ei",
                Field::StBestEi => "st_best_ei",
                Field::StGuteEi => "st_gute_ei",
                Field::PvErtrgJ => "pv_ertrg_j",
                Field::PvErtrgW => "pv_ertrg_w",
                Field::PvErtrgS => "pv_ertrg_s",
                Field::FErtrgJ => "f_ertrg_j",
                Field::FErtrgW => "f_ertrg_w",
                Field::FErtrgS => "f_ertrg_s",
                Field::StErtrgJ => "st_ertrg_j",
                Field::StErtrgW => "st_ertrg_w",
                Field::StErtrgS => "st_ertrg_s",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100382/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Standorte Mess-Stationen Smart Climate Luftklima
pub mod standorte_mess_stationen_smart_climate_luftklima {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station-ID
        ///
        /// ID der Wetterstation
        pub name_original: Option<String>,
        /// Name
        ///
        /// Name der Wetterstation
        pub name_custom: Option<String>,
        /// Werte seit
        ///
        /// Älteste Aufzeichnung von Wetterdaten durch diese Station
        #[serde(with = "time::serde::iso8601::option")]
        pub dates_min_date: Option<OffsetDateTime>,
        /// Werte bis
        ///
        /// Neuste Aufzeichnung von Wetterdaten durch diese Station
        #[serde(with = "time::serde::iso8601::option")]
        pub dates_max_date: Option<OffsetDateTime>,
        /// Koordinaten
        ///
        /// Automatisch plausibilisierte Koordinaten
        pub coords: Option<GeoPoint2d>,
        /// Längengrad
        pub lon: Option<f64>,
        /// Breitengrad
        pub lat: Option<f64>,
        /// Stadtklima Basel Link
        ///
        /// Link auf die entsprechende Station auf der "Stadtklima Basel" Website, wo historische Daten und Vorhersagen abgerufen werden können.
        pub stadtklima_basel_link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        NameOriginal,
        NameCustom,
        DatesMinDate,
        DatesMaxDate,
        Lon,
        Lat,
        StadtklimaBaselLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::NameOriginal => "name_original",
                Field::NameCustom => "name_custom",
                Field::DatesMinDate => "dates_min_date",
                Field::DatesMaxDate => "dates_max_date",
                Field::Lon => "lon",
                Field::Lat => "lat",
                Field::StadtklimaBaselLink => "stadtklima_basel_link",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100082/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Smart Climate Luftklima
pub mod smart_climate_luftklima {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station-ID
        ///
        /// ID der Wetterstation
        pub name_original: Option<String>,
        /// Name
        ///
        /// Name der Wetterstation
        pub name_custom: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Zeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub dates_max_date: Option<OffsetDateTime>,
        /// Lufttemperatur
        pub meta_airtemp: Option<f64>,
        /// Regen in 1 h
        ///
        /// Total der Niederschläge innerhalb der letzten Stunde
        pub meta_rain_1h_val: Option<f64>,
        /// Regen in 24 h
        ///
        /// Total der Niederschläge innerhalb der letzten 24 Stunden
        pub meta_rain24h_sum: Option<f64>,
        /// Regen in 48 h
        ///
        /// Total der Niederschläge innerhalb der letzten 48 Stunden
        pub meta_rain48h_sum: Option<f64>,
        /// Koordinaten
        pub coords: Option<GeoPoint2d>,
        /// Stadtklima Basel Link
        ///
        /// Link auf die entsprechende Station auf der "Stadtklima Basel" Website, wo historische Daten und Vorhersagen abgerufen werden können.
        pub stadtklima_basel_link: Option<String>,
        /// Unix Zeitstempel
        ///
        /// Zeitstempel der Messung in Sekunden seit 1. Januar 1970
        pub unix_timestamp: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        NameOriginal,
        NameCustom,
        DatesMaxDate,
        MetaAirtemp,
        MetaRain1hVal,
        MetaRain24hSum,
        MetaRain48hSum,
        StadtklimaBaselLink,
        UnixTimestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::NameOriginal => "name_original",
                Field::NameCustom => "name_custom",
                Field::DatesMaxDate => "dates_max_date",
                Field::MetaAirtemp => "meta_airtemp",
                Field::MetaRain1hVal => "meta_rain_1h_val",
                Field::MetaRain24hSum => "meta_rain24h_sum",
                Field::MetaRain48hSum => "meta_rain48h_sum",
                Field::StadtklimaBaselLink => "stadtklima_basel_link",
                Field::UnixTimestamp => "unix_timestamp",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100009/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Überwachung Luftqualität Transformation Areal Rosental: Staubgebundene Schadstoffe
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_staubgebundene_schadstoffe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messbeginn
        ///
        /// Beginn der Messung
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Ende der Messung
        pub messende: Option<Date>,
        /// Standort
        ///
        /// Name des Standorts
        pub standort: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff
        pub parameter: Option<String>,
        /// Messwert
        ///
        /// Gemessener Wert
        pub messwert: Option<String>,
        /// Messwert (Zahlenformat bis auf 3 Dezimalstellen)
        ///
        /// Gemessener Wert bis auf 3 Dezimalstellen
        pub messwert_zahlenformat: Option<f64>,
        /// 3_dezimalstellen_messwert
        ///
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub x3_dezimalstellen_messwert: Option<f64>,
        /// 4_dezimalstellen_messwert
        ///
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub x4_dezimalstellen_messwert: Option<f64>,
        /// 5_dezimalstellen_messwert
        ///
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub x5_dezimalstellen_messwert: Option<f64>,
        /// Interventionswert
        pub interventionswert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub interventionswert_3_dez: Option<f64>,
        /// Warnwert
        pub warnwert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub warnwert_3_dez: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird
        pub einheit: Option<String>,
        /// Messmethode
        pub messmethode: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Messbeginn,
        Messende,
        Standort,
        Parameter,
        Messwert,
        MesswertZahlenformat,
        X3DezimalstellenMesswert,
        X4DezimalstellenMesswert,
        X5DezimalstellenMesswert,
        Interventionswert,
        Interventionswert3Dez,
        Warnwert,
        Warnwert3Dez,
        Einheit,
        Messmethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::Messwert => "messwert",
                Field::MesswertZahlenformat => "messwert_zahlenformat",
                Field::X3DezimalstellenMesswert => "3_dezimalstellen_messwert",
                Field::X4DezimalstellenMesswert => "4_dezimalstellen_messwert",
                Field::X5DezimalstellenMesswert => "5_dezimalstellen_messwert",
                Field::Interventionswert => "interventionswert",
                Field::Interventionswert3Dez => "interventionswert_3_dez",
                Field::Warnwert => "warnwert",
                Field::Warnwert3Dez => "warnwert_3_dez",
                Field::Einheit => "einheit",
                Field::Messmethode => "messmethode",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100274/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

/// Aktuelle Belegung der öffentlichen Parkhäuser Basel
pub mod aktuelle_belegung_der_oeffentlichen_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name des Parkhauses
        pub title: Option<String>,
        /// Publikationszeit
        ///
        /// Datum und Uhrzeit der Publikation des Wertes
        #[serde(with = "time::serde::iso8601::option")]
        pub published: Option<OffsetDateTime>,
        /// Anzahl frei
        ///
        /// Anzahl freie Parkplätze
        pub free: Option<i64>,
        /// Total
        ///
        /// Anzahl Parkplätze total
        pub total: Option<i64>,
        /// Anteil frei
        ///
        /// Anteil freier Parkplätze
        pub anteil_frei: Option<f64>,
        /// Auslastung
        ///
        /// Anteil belegter Parkplätze
        pub auslastung: Option<f64>,
        /// Auslastung in Prozent
        ///
        /// Anteil belegter Parkplätze in Prozent
        pub auslastung_prozent: Option<f64>,
        /// Link
        ///
        /// Link zu den Detailinformationen des jeweiligen Parkhauses
        pub link: Option<String>,
        /// Standort des Parkhauses
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Beschreibung
        ///
        /// Text, der die Anzahl freier Parkplätze enthält
        pub description: Option<String>,
        /// Name
        pub name: Option<String>,
        pub id2: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Clone, Copy)]
    pub enum Field {
        Title,
        Published,
        Free,
        Total,
        AnteilFrei,
        Auslastung,
        AuslastungProzent,
        Link,
        Description,
        Name,
        Id2,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Title => "title",
                Field::Published => "published",
                Field::Free => "free",
                Field::Total => "total",
                Field::AnteilFrei => "anteil_frei",
                Field::Auslastung => "auslastung",
                Field::AuslastungProzent => "auslastung_prozent",
                Field::Link => "link",
                Field::Description => "description",
                Field::Name => "name",
                Field::Id2 => "id2",
            }
        }
    }

    #[derive(Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100088/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}
