use geojson::GeoJson;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use time::macros::format_description;
use time::{Date, OffsetDateTime};

#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub struct GeoPoint2d {
    pub lat: f64,
    pub lon: f64,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct File {
    pub url: String,
    pub width: u16,
    pub height: u16,
}

fn deserialize_date<'de, D>(deserializer: D) -> Result<Option<Date>, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    let format = format_description!("[year]-[month]-[day]");
    let date = time::Date::parse(&s, format).unwrap();
    Ok(Some(date))
}

fn serialize_date<S: Serializer>(date: &Option<Date>, serializer: S) -> Result<S::Ok, S::Error> {
    if let Some(date) = date {
        serializer.serialize_some(&format!(
            "{:04}-{:02}-{:02}",
            date.year(),
            date.month(),
            date.day()
        ))
    } else {
        serializer.serialize_none()
    }
}
fn escape(value: &str) -> String {
    value.replace('\\', "\\\\").replace('"', "\\\"")
}

#[doc = "Wahl von sieben Pr\u{e4}sidentinnen oder Pr\u{e4}sidenten des Strafgerichts"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Resultate des 1. Wahlgangs der Wahl zu sieben Pr\u{e4}sidentinnen oder Pr\u{e4}sidenten des Strafgerichts Basel-Stadt vom 9. Mai 2021.\u{a0}</p>"]
pub mod wahl_von_sieben_praesidentinnen_oder_praesidenten_des_strafgerichts {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<i64>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub resultats_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anz_sitze: Option<i64>,
        /// Kandidaten-Nr
        pub kandidat_nr: Option<i64>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub name_ganz: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewaehlt: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Wahlzettel
        ///
        /// Anzahl eingelegte Wahlzettel
        pub eingelegte: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leere Wahlzettel
        pub leere: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültige Wahlzettel
        pub ungueltige: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub gueltige: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub anz_briefliche: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total
        pub stimmber_total: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmber_maen: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmber_fraue: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Stimmen + leere Stimmen)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub ant_brieflich: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ResultatsTyp,
        Datum,
        AnzSitze,
        KandidatNr,
        NameGanz,
        Name,
        Vorname,
        Gemeinde,
        Stimmen,
        Vereinzelte,
        Gewaehlt,
        Stimmrechtsausweise,
        Eingelegte,
        Leere,
        Ungueltige,
        Gueltige,
        AnzBriefliche,
        StimmberTotal,
        StimmberMaen,
        StimmberFraue,
        AbsolutesMehr,
        Stimmbeteiligung,
        AntBrieflich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ResultatsTyp => "resultats_typ",
                Field::Datum => "datum",
                Field::AnzSitze => "anz_sitze",
                Field::KandidatNr => "kandidat_nr",
                Field::NameGanz => "name_ganz",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Vereinzelte => "vereinzelte",
                Field::Gewaehlt => "gewaehlt",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Eingelegte => "eingelegte",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::AnzBriefliche => "anz_briefliche",
                Field::StimmberTotal => "stimmber_total",
                Field::StimmberMaen => "stimmber_maen",
                Field::StimmberFraue => "stimmber_fraue",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AntBrieflich => "ant_brieflich",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100133/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Massentests an Schulen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die SARS-CoV-2-Tests, welche ab Mitte M\u{e4}rz 2022 an Sch\u{fc}lerinnen und Sch\u{fc}lern (SuS) sowie Lehrpersonen an baselst\u{e4}dtischen Schulen durchgef\u{fc}hrt wurden. Es werden die Anzahl durchgef\u{fc}hrter Tests sowie die Test-Positivit\u{e4}tsrate pro Woche aufgef\u{fc}hrt. Weitere Informationen zum Coronavirus im Kanton Basel-Stadt:\u{a0}<a href=\"https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co\" target=\"_blank\">https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co</a><a href=\"https://www.coronavirus.bs.ch/testen/testen-in-schulen.html\" target=\"_blank\"></a></p><p>Daten zu Massentests an Schulen vor Mitte M\u{e4}rz 2022, sowie in Betrieben im Kanton Basel-Stadt sind hier zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/?sort=modified&amp;q=massentests\" target=\"_blank\">https://data.bs.ch/explore/?sort=modified&amp;q=massentests</a></p>"]
pub mod coronavirus_covid_19_massentests_an_schulen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<i64>,
        /// Resultat
        ///
        /// Resultat der Tests (negativ oder positiv)
        pub result: Option<String>,
        /// Pos./neg. getestete Personen pro Woche
        ///
        /// Anzahl positiv resp. negativ getesteter Personen pro Woche
        pub count: Option<i64>,
        /// Getestete Personen pro Woche
        ///
        /// Anzahl total getesteter Schülerinnen, Schüler oder Lehrpersonen pro Woche
        pub counttotal: Option<i64>,
        /// Positivitätsrate
        ///
        /// Anteil der positiven Tests an der Gesamtzahl der Tests der betreffenden Woche
        pub positivityratepercent: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100183/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Parkplatz-Zonen"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Der Datensatz zeigt die Standorte der Parkpl\u{e4}tze, die im Rahmen des Projekts \u{ab}Smarte Strasse\u{bb} f\u{fc}r die Testung der Sensoren einbezogen werden.<br/>Zus\u{e4}tzlich relevante Datens\u{e4}tze f\u{fc}r die Parkplatzbelegung:</p><ul><li style=\"\"><a href=\"https://data.bs.ch/explore/dataset/100171/\" target=\"_blank\">Zu- und Wegfahrten, Parkplatzauslastung</a></li><li style=\"\"><a href=\"https://data.bs.ch/explore/dataset/100160/\" target=\"_blank\">Parkplatzbelegung</a><br/></li></ul><p class=\"\" style=\"font-family: sans-serif;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</p><ul><li>Weitere Informationen zum Projekt\u{a0}\u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b>Hinweis:<br/>Die Parkplatz-Kamera an der Gundeldingerstrasse wurde am Dienstag 4.10.2022 abmontiert. Es werden keine Daten mehr erhoben.</b><br/></p>"]
pub mod smarte_strasse_parkplatz_zonen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<f64>,
        /// Breitengrad
        pub lat: Option<f64>,
        /// Längengrad
        pub lon: Option<f64>,
        /// Koordinaten
        pub coord: Option<GeoPoint2d>,
        /// Adresse
        pub adresse: Option<String>,
        /// Typ
        ///
        /// Parkplatztyp
        pub typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Lat,
        Lon,
        Adresse,
        Typ,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::Adresse => "adresse",
                Field::Typ => "typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100176/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte Mess-Stationen Smart Climate Schallpegelmessungen"]
#[doc = ""]
#[doc = "Der Datensatz zeigt die Standorte der Mess-Stationen f\u{fc}r den Datensatz <a href=\"https://data.bs.ch/explore/dataset/100087\" target=\"_blank\">\u{ab}Smart Climate Schallpegelmessungen\u{bb}</a>."]
pub mod standorte_mess_stationen_smart_climate_schallpegelmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station
        ///
        /// Name der Station
        pub station_id: Option<String>,
        /// EUI
        ///
        /// ID der Mess-Station
        pub eui: Option<String>,
        /// Geopunkt
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geographische Breite
        pub latitude: Option<f64>,
        /// Geographische Länge
        pub longitude: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        StationId,
        Eui,
        Latitude,
        Longitude,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::Eui => "eui",
                Field::Latitude => "latitude",
                Field::Longitude => "longitude",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100090/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 27. November 2022"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 27. November 2022 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_27_november_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Gegenvorschlag
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Stichfrage
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag am Total der Stimmen mit gültiger Antwort
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100240/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Staatsarchiv: Neuzug\u{e4}nge im \u{f6}ffentlichen Archivkatalog"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt die j\u{e4}hrlich neu im Archivkatalog\nverzeichneten und \u{f6}ffentlich zug\u{e4}nglich gemachten Unterlagen (Akten, Pl\u{e4}ne,\nBilder, etc.). Diese sind damit im <a href=\"https://dls.staatsarchiv.bs.ch/\" target=\"_blank\">Digitalen Lesesaal</a> (https://dls.staatsarchiv.bs.ch/) recherchierbar und\nk\u{f6}nnen eingesehen werden. </p><p>Der Datensatz umfasst Informationen zum Inhalt der\nUnterlagen und deren Zeitraum, zur abliefernden Stelle, zum Umfang sowie zur\nArchivsignatur. </p><p>Er bildet die laufende Erschliessungsarbeit des\nStaatsarchivs ab. Mit der Erschliessung wird der Entstehungszusammenhang der\nUnterlagen nachvollziehbar gemacht und ihre Auffindbarkeit erm\u{f6}glicht. Zur\nErschliessungsarbeit geh\u{f6}ren das Ordnen der Unterlagen, das Verzeichnen im\nOnline-Archivkatalog, Verpacken, Etikettieren und Magazinieren.</p>"]
pub mod staatsarchiv_neuzugaenge_im_oeffentlichen_archivkatalog {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr, in dem die Aktenerschliessung stattgefunden hat.
        pub jahr: Option<String>,
        /// Abteilung
        ///
        /// Oberste Ebene (Abteilung) im Archivplan, unter welcher die Unterlagen eingeordnet sind
        pub abteilung: Option<String>,
        /// Unterabteilung / Subtyp
        ///
        /// Für Unterabteilung zweite Ebene im Archivplan, unter welcher die Unterlagen zu finden sind. Subtypen («Zuwachs zu bestehenden Privatarchiven» und «Neue Privatarchive») zeigen für Privatarchive einen neuen oder bestehenden Bestand an.
        pub unterabteilung_subtyp: Option<String>,
        /// Signatur
        ///
        /// Signatur, unter welcher die Neuzugänge im Archivkatalog zu finden sind.
        pub signatur: Option<String>,
        /// Abliefernde Stelle
        ///
        /// Stelle, welche die Unterlagen abgeliefert und in der Regel auch erstellt hat. Kann ein kantonales Amt, eine öffentlich-rechtliche oder private Organisation oder auch eine Privatperson oder Familie sein.
        pub abliefernde_stelle: Option<String>,
        /// Beschreibung
        ///
        /// Eine stichwortartige Beschreibung des Inhalts der Unterlagen
        pub betreff_beschreibung: Option<String>,
        /// Zeitraum
        ///
        /// Der Zeitraum, in dem die Unterlagen erstellt worden sind.
        pub zeitraum: Option<String>,
        /// Umfang (Lfm)
        ///
        /// Umfang der verzeichneten Unterlagen in Laufmeter. Standardeinheit für physische Unterlagen (primär Papier)
        pub umfang_lfm: Option<f64>,
        /// Umfang (Band)
        ///
        /// Umfang in Bänden. Selten bei Büchern verwendet
        pub umfang_band: Option<f64>,
        /// Umfang (Stück)
        ///
        /// Umfang in Stück. Selten bei unterschiedlichen Objekten verwendet
        pub umfang_stuck: Option<f64>,
        /// Umfang (MB)
        ///
        /// Umfang der verzeichneten Unterlagen in Megabyte. Bei digitalen Unterlagen verwendet
        pub umfang_mb: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Abteilung,
        UnterabteilungSubtyp,
        Signatur,
        AblieferndeStelle,
        BetreffBeschreibung,
        Zeitraum,
        UmfangLfm,
        UmfangBand,
        UmfangStuck,
        UmfangMb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Abteilung => "abteilung",
                Field::UnterabteilungSubtyp => "unterabteilung_subtyp",
                Field::Signatur => "signatur",
                Field::AblieferndeStelle => "abliefernde_stelle",
                Field::BetreffBeschreibung => "betreff_beschreibung",
                Field::Zeitraum => "zeitraum",
                Field::UmfangLfm => "umfang_lfm",
                Field::UmfangBand => "umfang_band",
                Field::UmfangStuck => "umfang_stuck",
                Field::UmfangMb => "umfang_mb",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100365/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Nationalratswahlen 2023 (aggregierte Daten)"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die aggregierten Resultate der Nationalratswahl vom 22. Oktober 2023.<o:p></o:p></p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_nationalratswahlen_2023_aggregierte_daten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listen-Nr
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// HLV-Nr
        ///
        /// Nummer der Hauptlistenverbindung
        pub hlv_nr: Option<String>,
        /// HLV-Bezeichnung
        ///
        /// Name der Hauptlistenverbindung
        pub hlv_bezeichnung: Option<String>,
        /// ULV-Nr
        ///
        /// Nummer der Unterlistenverbindung
        pub ulv_nr: Option<String>,
        /// ULV-Bezeichnung
        ///
        /// Name der Unterlistenverbindung
        pub ulv_bezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen
        ///
        /// Anzahl Stimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub kandidatenstimmen: Option<i64>,
        /// Zusatzstimmen
        ///
        /// Anzahl Zusatzstimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub zusatzstimmen: Option<i64>,
        /// Parteistimmen
        pub parteistimmen: Option<i64>,
        /// Anteil an Summe in %
        pub anteil_an_summe_in: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ListenNr,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        HlvNr,
        HlvBezeichnung,
        UlvNr,
        UlvBezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        Kandidatenstimmen,
        Zusatzstimmen,
        Parteistimmen,
        AnteilAnSummeIn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ListenNr => "listen_nr",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::HlvNr => "hlv_nr",
                Field::HlvBezeichnung => "hlv_bezeichnung",
                Field::UlvNr => "ulv_nr",
                Field::UlvBezeichnung => "ulv_bezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::Kandidatenstimmen => "kandidatenstimmen",
                Field::Zusatzstimmen => "zusatzstimmen",
                Field::Parteistimmen => "parteistimmen",
                Field::AnteilAnSummeIn => "anteil_an_summe_in",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100297/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Einzelmessungen der Smiley-Geschwindigkeitsanzeigen"]
#[doc = ""]
#[doc = "<p>Einzelmessungen der Smiley-Geschwindigkeitsanzeigen der Kantonspolizei Basel-Stadt ab 2023 (Zeitpunkt des Beginns der Messung). Die Smiley-Geschwindigkeitsanzeigen sind nicht geeicht und entsprechend k\u{f6}nnen die Werte von der tats\u{e4}chlich gefahrenen Geschwindigkeit abweichen. Hinweis: Die Messungen sind nicht repr\u{e4}sentativ f\u{fc}r das ganze Jahr und m\u{fc}ssen im Kontext des Erhebungsdatums betrachtet werden. Dar\u{fc}ber hinaus wurden gewisse Messungen w\u{e4}hrend einer ausserordentlichen Verkehrsf\u{fc}hrung (z.B. Umleitungsverkehr infolge von Baustellent\u{e4}tigkeiten etc.) erhoben. Manipulationen an Ger\u{e4}ten k\u{f6}nnen zu fehlerhaften Messungen f\u{fc}hren.</p><p class=\"MsoNormal\"><span class=\"ui-provider\">Die Geschwindigkeitsmessungen\ndurchlaufen vier Phasen: <b>Vormessung</b>, <b>Betrieb</b>, <b>Nachmessung</b> und <b>nach Ende</b>. In der\nVormessungsphase wird die Geschwindigkeit der Fahrzeuge an den\nSmiley-Geschwindigkeitsanzeigen gemessen, wobei die Anzeigen nicht aktiviert\nsind. In der Betriebsphase sind die Smiley-Geschwindigkeitsanzeigen hingegen\neingeschaltet. Nachfolgend werden die Anzeigen ausgeschaltet und die\nGeschwindigkeit der Fahrzeuge an den Smiley-Geschwindigkeitsanzeigen wird\nerneut gemessen. Die letzte Phase \"nach Ende\" sind Messungen, die\nausserhalb des im Projekt definierten Zeitraums vorfallen.\u{a0}<o:p></o:p></span></p>"]
pub mod einzelmessungen_der_smiley_geschwindigkeitsanzeigen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zyklus
        ///
        /// Messzyklus (1, 2 oder 3)
        pub zyklus: Option<String>,
        /// Phase
        ///
        /// Phase der Messung (Vormessung, Betrieb, Nachmessung oder nach Ende)
        pub phase: Option<String>,
        /// ID Standort
        ///
        /// Eindeutige Standortkennung
        pub id_standort: Option<String>,
        /// Strassenname
        pub strassenname: Option<String>,
        /// Ort
        ///
        /// Ortsname
        pub ort: Option<String>,
        /// Ort Abkürzung
        pub ort_abkuerzung: Option<String>,
        /// Zeitpunkt Messung
        ///
        /// Zeitpunkt der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub messung_timestamp: Option<OffsetDateTime>,
        /// Messung Datum
        ///
        /// Datum der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messung_datum: Option<Date>,
        /// Messung Zeit
        ///
        /// Zeit der Messung
        pub messung_zeit: Option<String>,
        /// Einfahrtstempo
        ///
        /// Geschwindigkeit bei Einfahrt
        pub v_einfahrt: Option<i64>,
        /// Ausfahrtstempo
        ///
        /// Geschwindigkeit bei Ausfahrt
        pub v_ausfahrt: Option<i64>,
        /// Differenztempo
        ///
        /// Geschwindigkeitsdifferenz (Einfahrt minus Ausfahrt)
        pub v_delta: Option<i64>,
        /// Tempolimit
        ///
        /// Maximale erlaubte Geschwindigkeit
        pub geschwindigkeit: Option<i64>,
        /// Halterung
        ///
        /// Art der Befestigung (permanent oder mobil)
        pub halterung: Option<String>,
        /// Start Vormessung
        ///
        /// Beginn der Vormessung (mit ausgeschalteter Anzeige)
        #[serde(with = "time::serde::iso8601::option")]
        pub start_vormessung: Option<OffsetDateTime>,
        /// Start Betrieb
        ///
        /// Beginn des aktiven Betriebs
        #[serde(with = "time::serde::iso8601::option")]
        pub start_betrieb: Option<OffsetDateTime>,
        /// Start Nachmessung
        ///
        /// Beginn der Nachmessung (mit ausgeschalteter Anzeige)
        #[serde(with = "time::serde::iso8601::option")]
        pub start_nachmessung: Option<OffsetDateTime>,
        /// Ende
        ///
        /// Ende des Messzyklus am Standort
        #[serde(with = "time::serde::iso8601::option")]
        pub ende: Option<OffsetDateTime>,
        /// Messung Jahr
        ///
        /// Jahr der Messung
        pub messung_jahr: Option<String>,
        /// Geopunkt
        ///
        /// Geografische Koordinaten der Smiley-Geschwindigkeitsanzeige
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Zyklus,
        Phase,
        IdStandort,
        Strassenname,
        Ort,
        OrtAbkuerzung,
        MessungTimestamp,
        MessungDatum,
        MessungZeit,
        VEinfahrt,
        VAusfahrt,
        VDelta,
        Geschwindigkeit,
        Halterung,
        StartVormessung,
        StartBetrieb,
        StartNachmessung,
        Ende,
        MessungJahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zyklus => "zyklus",
                Field::Phase => "phase",
                Field::IdStandort => "id_standort",
                Field::Strassenname => "strassenname",
                Field::Ort => "ort",
                Field::OrtAbkuerzung => "ort_abkuerzung",
                Field::MessungTimestamp => "messung_timestamp",
                Field::MessungDatum => "messung_datum",
                Field::MessungZeit => "messung_zeit",
                Field::VEinfahrt => "v_einfahrt",
                Field::VAusfahrt => "v_ausfahrt",
                Field::VDelta => "v_delta",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Halterung => "halterung",
                Field::StartVormessung => "start_vormessung",
                Field::StartBetrieb => "start_betrieb",
                Field::StartNachmessung => "start_nachmessung",
                Field::Ende => "ende",
                Field::MessungJahr => "messung_jahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100268/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom  28. November 2021"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 28. November 2021 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.<br></p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_28_november_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100163/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom  26. September 2021"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 26. September 2021 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_26_september_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100155/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 15. Mai 2022"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 15. Mai 2022 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p><a href=\"https://data.bs.ch/explore/dataset/100071\"></a></p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_15_mai_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100195/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 25. September 2022"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 25. September 2022 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p><a href=\"https://data.bs.ch/explore/dataset/100071\"></a></p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_25_september_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100207/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 26. November 2023 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 26. November 2023 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_26_november_2023_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100327/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 25. September 2022 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 25. September 2022 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_25_september_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100206/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 18. Juni 2023"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 18. Juni 2023 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_18_juni_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100299/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 18. Juni 2023 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 18.Juni 2023 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_18_juni_2023_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100298/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung 13. Juni 2021 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 13. Juni 2021 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_13_juni_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Gegenvorschlag Stimmen ohne gültige Antwort
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stichfrage Stimmen ohne gültige Antwort
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100144/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Ordnungsbussen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die durch die Kantonspolizei Basel-Stadt ausgestellten Ordnungsbussen gem\u{e4}ss <a href=\"https://www.fedlex.admin.ch/eli/oc/2019/93/de\" target=\"_blank\">eidg. Ordnungsbussenverordnung</a>. Es handelt sich ausschliesslich um bereits bezahlte Bussen.</p><p>Der Datensatz enth\u{e4}lt die Ordnungsbussen ab Januar 2017.</p><p>Die Daten im Zeitraum vom 1.1.2017 bis 30.11.2019 wurden korrigiert. Die entsprechenden Werte k\u{f6}nnen deshalb minim von jenen abweichen, welche vor dem 21. April 2020 an dieser Stelle publiziert waren.</p>"]
pub mod ordnungsbussen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Laufnummer
        ///
        ///
        pub laufnummer: Option<i64>,
        /// Kategorie Bezeichnung
        ///
        /// Fahrzeugkategorie; enthält auch Fussgänger und Beifahrer;
        pub kategorie_bezeichnung: Option<String>,
        /// Wochentag
        ///
        /// Nummer und Bezeichnung des Wochentags, an welchem die Übertretung stattgefunden hat
        pub wochentag: Option<String>,
        /// Übertretungs-Wochentagnummer
        ///
        /// Nummer des Wochentags, an welchem die Übertretung stattgefunden hat (1 = Sonntag, 2 = Montag, etc.)
        pub ubertretungswochentagnummer: Option<i64>,
        /// Übertretungs-Wochentag
        ///
        /// Wochentag, an welchem die Übertretung stattgefunden hat
        pub ubertretungswochentag: Option<String>,
        /// Übertretungsmonat
        ///
        /// Monat, in welchem die Übertretung stattgefunden hat
        pub ubertretungsmonat: Option<i64>,
        /// Übertretungsjahr
        ///
        /// Jahr, in welchem die Übertretung stattgefunden hat
        pub ubertretungsjahr: Option<String>,
        /// Geschwindigkeitslimite
        ///
        /// Erlaubte Höchstgeschwindigkeit am Ort der Übertretung
        pub gk_limite: Option<f64>,
        /// Übertretungs-PLZ
        ///
        /// Postleitzahl des Ortes, an dem eine Übertretung stattgefunden hat
        pub u_ort_plz: Option<String>,
        /// Übertretungsort
        ///
        /// Gemeinde, in welcher eine Übertretung stattgefunden hat
        pub u_ort_ort: Option<String>,
        /// Bussenbetrag
        ///
        /// Höhe der Busse in Franken
        pub bussen_betrag: Option<i64>,
        /// Bussenziffer
        ///
        /// Ziffer aus der eidg. Ordnungsbussenverordnung
        pub buzi: Option<String>,
        /// Bussenziffer Zusatz
        ///
        /// Zusatz zur Ziffer aus der eidg. Ordnungsbussenverordnung
        pub buzi_zus: Option<String>,
        /// Bussenziffer Text
        ///
        /// Beschreibender Text zur Art der Übertretung gemäss eidg. Ordnungsbussenverordnung und Zusatz zur Ziffer aus der OBV
        pub buzi_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Laufnummer,
        KategorieBezeichnung,
        Wochentag,
        Ubertretungswochentagnummer,
        Ubertretungswochentag,
        Ubertretungsmonat,
        Ubertretungsjahr,
        GkLimite,
        UOrtPlz,
        UOrtOrt,
        BussenBetrag,
        Buzi,
        BuziZus,
        BuziText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Laufnummer => "laufnummer",
                Field::KategorieBezeichnung => "kategorie_bezeichnung",
                Field::Wochentag => "wochentag",
                Field::Ubertretungswochentagnummer => "ubertretungswochentagnummer",
                Field::Ubertretungswochentag => "ubertretungswochentag",
                Field::Ubertretungsmonat => "ubertretungsmonat",
                Field::Ubertretungsjahr => "ubertretungsjahr",
                Field::GkLimite => "gk_limite",
                Field::UOrtPlz => "u_ort_plz",
                Field::UOrtOrt => "u_ort_ort",
                Field::BussenBetrag => "bussen_betrag",
                Field::Buzi => "buzi",
                Field::BuziZus => "buzi_zus",
                Field::BuziText => "buzi_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100058/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Ersatzwahl Regierungspr\u{e4}sidium 3. M\u{e4}rz 2024"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate des ersten Wahlgangs der Regierungspr\u{e4}sidiums-Ersatzwahl vom 3. M\u{e4}rz 2024.</p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_ersatzwahl_regierungspraesidium_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100338/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Ersatzwahl Regierungsrat 7. April 2024 (2. Wahlgang)"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate des zweiten Wahlgangs der Regierungsrats-Ersatzwahl vom 7. April 2024.</p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\"><o:p></o:p></p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im <a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">www.kantonsblatt.ch</a>) des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_ersatzwahl_regierungsrat_7_april_2024_2_wahlgang {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1). Für zweiten Wahlgang nicht vorhanden.
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        ///
        /// Spalte, damit bei Grafik "Vereinzelte" abgebildet werden kann
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100360/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Regierungsrats- und Regierungspr\u{e4}sidiumswahl 2020"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\">Dieser Datensatz zeigt die Resultate der Regierungsratswahl\nund der Regierungspr\u{e4}sidiumswahl vom 25. Oktober und vom 29. November 2020. <o:p></o:p></p><p>\n\n</p><p class=\"MsoNormal\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen\nSchlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.<o:p></o:p></p>"]
pub mod regierungsrats_und_regierungspraesidiumswahl_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<String>,
        /// Art der Wahl
        ///
        /// Gesamterneuerungswahl oder Ersatzwahl
        pub art_der_wahl: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anzahl_sitze: Option<i64>,
        /// Listen-Nr.
        pub listen_nr: Option<i64>,
        /// Liste
        ///
        /// Kürzel der unterstützenden Parteien
        pub liste: Option<String>,
        /// Kandidaten-Nr.
        pub kandidaten_nr: Option<i64>,
        /// Bisher
        ///
        /// Angabe ob, eine Regierungsrätin oder ein Regierungsrat in der abgelaufenen Legislatur Mitglied des Regierungsrats war
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Alter am Jahresende 2020
        ///
        /// Alter, berechnet mit der Formel "2020 minus Jahrgang"
        pub alter: Option<i64>,
        /// Partei
        ///
        /// Kürzel der Partei
        pub partei: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewahlt: Option<String>,
        /// Wahlzettel
        ///
        /// Anzahl eingelegter Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_stimmzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_stimmzettel: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültiger Wahlzettel
        pub gultige_stimmzettel: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte_stimmen: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: Ganzzahl((gültige Stimmen + leere Stimmen)/2) + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Stimmen Regierungspräsidium
        ///
        /// Anzahl Stimmen für das Regierungspräsidium
        pub stimmen_prasidium: Option<i64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_stimmende: Option<f64>,
        /// Regierungspräsidium
        ///
        /// 1 = Kandidiert für das Regierungspräsidium
        pub prasidium: Option<i64>,
        /// Kandidaten-Nr. Regierungspräsidium
        ///
        /// Kandidaten-Nr. für die Wahl ins Regierungspräsidium
        pub kandidaten_nr_praidium: Option<i64>,
        /// Bisher Regierungspräsidium
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der vorherigen Legislatur das Regierungspräsidium innehatte
        pub bisher_prasidium: Option<String>,
        /// Gewählt Regierungspräsidium
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat für das Regierungspräsidium gewählt ist
        pub gewahlt_prasidium: Option<String>,
        /// Wahlzettel Regierungspräsidium
        ///
        /// Anzahl eingelegte Wahlzettel für das Regierungspräsidium
        pub wahlzettel_prasidium: Option<i64>,
        /// Briefliche Stimmabgaben Präsidium
        ///
        /// Anzahl brieflich eingelegte Wahlzettel für das Regierungspräsidium
        pub briefliche_stimmabgaben_prasidium: Option<i64>,
        /// Leere Wahlzettel Regierungspräsidium
        ///
        /// Anzahl leer eingelegter Wahlzettel für das Regierungspräsidium
        pub leere_stimmzettel_prasidium: Option<i64>,
        /// Ungültige Wahlzettel Regierungspräsidium
        ///
        /// Anzahl ungültiger Wahlzettel für das Regierungspräsidium
        pub ungultige_stimmzettel_prasidium: Option<i64>,
        /// Gültige Wahlzettel Regierungspräsidium
        ///
        /// Anzahl gültiger Wahlzettel für das Regierungspräsidium
        pub gultige_stimmzettel_prasidium: Option<i64>,
        /// Vereinzelte Stimmen Regierungspräsidium
        ///
        /// Anzahl Stimmen, welche für nicht für das Regierungspräsidium kandidierende Personen eingegangen sind
        pub vereinzelte_stimmen_prasidium: Option<i64>,
        /// Absolutes Mehr Regierungspräsidium
        ///
        /// berechnet nach der Formel: Ganzzahl((gültige Stimmen + leere Stimmen)/2) + 1)
        pub absolutes_mehr_prasidium: Option<i64>,
        /// Stimmbeteiligung Regierungspräsidium
        ///
        /// Anteil eingelegter Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung_prasidium: Option<f64>,
        /// Anteil brieflich Wählender Regierungspräsidium
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_stimmende_prasidium: Option<f64>,
        /// Gemeinde-ID
        pub gemeinde_id: Option<String>,
        /// Stimmberechtigte
        ///
        /// Total der Stimmberechtigten
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Jahrgang numerisch
        ///
        /// Jahrgang formatiert als ganze Zahl
        pub jahrgang_num: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ArtDerWahl,
        Datum,
        AnzahlSitze,
        ListenNr,
        Liste,
        KandidatenNr,
        Bisher,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Alter,
        Partei,
        Beruf,
        Gemeinde,
        Stimmen,
        Gewahlt,
        Wahlzettel,
        BrieflicheStimmabgaben,
        LeereStimmzettel,
        UngultigeStimmzettel,
        GultigeStimmzettel,
        VereinzelteStimmen,
        AbsolutesMehr,
        Stimmbeteiligung,
        StimmenPrasidium,
        AnteilBrieflichStimmende,
        Prasidium,
        KandidatenNrPraidium,
        BisherPrasidium,
        GewahltPrasidium,
        WahlzettelPrasidium,
        BrieflicheStimmabgabenPrasidium,
        LeereStimmzettelPrasidium,
        UngultigeStimmzettelPrasidium,
        GultigeStimmzettelPrasidium,
        VereinzelteStimmenPrasidium,
        AbsolutesMehrPrasidium,
        StimmbeteiligungPrasidium,
        AnteilBrieflichStimmendePrasidium,
        GemeindeId,
        Stimmberechtigte,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmrechtsausweise,
        JahrgangNum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ArtDerWahl => "art_der_wahl",
                Field::Datum => "datum",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::ListenNr => "listen_nr",
                Field::Liste => "liste",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Bisher => "bisher",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Alter => "alter",
                Field::Partei => "partei",
                Field::Beruf => "beruf",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Gewahlt => "gewahlt",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::LeereStimmzettel => "leere_stimmzettel",
                Field::UngultigeStimmzettel => "ungultige_stimmzettel",
                Field::GultigeStimmzettel => "gultige_stimmzettel",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::StimmenPrasidium => "stimmen_prasidium",
                Field::AnteilBrieflichStimmende => "anteil_brieflich_stimmende",
                Field::Prasidium => "prasidium",
                Field::KandidatenNrPraidium => "kandidaten_nr_praidium",
                Field::BisherPrasidium => "bisher_prasidium",
                Field::GewahltPrasidium => "gewahlt_prasidium",
                Field::WahlzettelPrasidium => "wahlzettel_prasidium",
                Field::BrieflicheStimmabgabenPrasidium => "briefliche_stimmabgaben_prasidium",
                Field::LeereStimmzettelPrasidium => "leere_stimmzettel_prasidium",
                Field::UngultigeStimmzettelPrasidium => "ungultige_stimmzettel_prasidium",
                Field::GultigeStimmzettelPrasidium => "gultige_stimmzettel_prasidium",
                Field::VereinzelteStimmenPrasidium => "vereinzelte_stimmen_prasidium",
                Field::AbsolutesMehrPrasidium => "absolutes_mehr_prasidium",
                Field::StimmbeteiligungPrasidium => "stimmbeteiligung_prasidium",
                Field::AnteilBrieflichStimmendePrasidium => "anteil_brieflich_stimmende_prasidium",
                Field::GemeindeId => "gemeinde_id",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::JahrgangNum => "jahrgang_num",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100102/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Zuordnung von Parzellen auf Statistische Raumeinheiten"]
#[doc = ""]
#[doc = "Zuordnung von Liegenschaften und Allmendparzellen auf Statistische Raumeinheiten (Wohnviertel, Bezirk, Block). Zur Methodik: Von jeder Parzelle wird ein Mittelpunkt berechnet (Zentroid), und mit der Geometrie der statistischen Raumeinheiten verschnitten. Falls ein Parzellenmittelpunkt auf eine Grenze zwischen mehreren Raumeinheiten zu liegen kommt, so wird die Parzelle all diesen Raumeinheiten zugeordnet (es entstehen dadurch pro Parzelle mehrere Zeilen im Datensatz). Parzellen auf dem Rhein werden keiner statistischen Raumeinheit zugeordnet."]
pub mod zuordnung_von_parzellen_auf_statistische_raumeinheiten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Parzellennummer
        pub r1_nummer: Option<i64>,
        /// EGRID
        ///
        /// Eidgenössischer Grundstücksidentifikator
        pub r1_egris_e: Option<String>,
        /// Code Art Liegenschaft
        ///
        /// Code zur Art der Liegenschaft
        pub r1_art: Option<i64>,
        /// Name Art Liegenschaft
        ///
        /// Text zur Art der Liegenschaft
        pub r1_art_txt: Option<String>,
        /// Sektion
        ///
        /// Sektion des Grundbuchkreises
        pub r1_sektion: Option<String>,
        /// Bezirks-ID
        ///
        /// ID des Bezirks
        pub bez_id: Option<String>,
        /// Bezirksname
        ///
        /// Name des Bezirks
        pub bez_name: Option<String>,
        /// Wohnviertel-ID
        ///
        /// ID des Wohnviertels
        pub wov_id: Option<String>,
        /// Wohnviertelname
        ///
        /// Name des Wohnviertels
        pub wov_name: Option<String>,
        /// Block-ID
        ///
        /// ID des Blocks
        pub blo_id: Option<String>,
        /// Blockname
        ///
        /// Name des Blocks
        pub blo_label: Option<String>,
        /// Gemeindename
        ///
        /// Name der Gemeinde
        pub gemeinde_name: Option<String>,
        /// Objekt-Identifikator
        ///
        /// Eine eindeutige Identifizierungsnummer
        pub oid: Option<String>,
        /// X-Koordinate
        ///
        /// Geographische Länge in Projektion WGS 84
        pub point_x: Option<f64>,
        /// Y-Koordinate
        ///
        /// Geographische Breite in Projektion WGS 84
        pub point_y: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        R1Nummer,
        R1EgrisE,
        R1Art,
        R1ArtTxt,
        R1Sektion,
        BezId,
        BezName,
        WovId,
        WovName,
        BloId,
        BloLabel,
        GemeindeName,
        Oid,
        PointX,
        PointY,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::R1Nummer => "r1_nummer",
                Field::R1EgrisE => "r1_egris_e",
                Field::R1Art => "r1_art",
                Field::R1ArtTxt => "r1_art_txt",
                Field::R1Sektion => "r1_sektion",
                Field::BezId => "bez_id",
                Field::BezName => "bez_name",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::BloId => "blo_id",
                Field::BloLabel => "blo_label",
                Field::GemeindeName => "gemeinde_name",
                Field::Oid => "oid",
                Field::PointX => "point_x",
                Field::PointY => "point_y",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100202/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 29. November 2020"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 29. November 2020 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_29_november_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100104/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sch\u{fc}lerprognose Riehen und Bettingen"]
#[doc = ""]
#[doc = "Das Statistische Amt erstellt kleinr\u{e4}umige Prognosen zu den Sch\u{fc}lerzahlen in den \u{f6}ffentlichen Schulen der Gemeinden Riehen und Bettingen. Die Sch\u{fc}lerzahlen werden f\u{fc}r die ersten 8 Schulstufen (Kindergarten und Primarschule), 13 Schulperimeter und 5 Schuljahre in die Zukunft prognostiziert. Die Perimeter dienen als Planungsgrundlage und nicht als effektive Einzugsgebiete. Die Prognosen werden im Auftrag der Gemeinde Riehen erstellt und j\u{e4}hrlich aktualisiert. Die Sch\u{fc}lerinnen und Sch\u{fc}ler mit dem Schutzstatus S werden in diesem Datensatz nicht ausgewiesen."]
pub mod schuelerprognose_riehen_und_bettingen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Schuljahr
        ///
        /// Schuljahr August - Juli, Stichtag jeweils zu Schuljahresbeginn im September.
        pub schuljahr: Option<String>,
        /// Perimeter ID
        pub nummer: Option<i64>,
        /// Perimeter
        ///
        /// Einteilung der beiden Gemeinden in 13 Planungsperimeter. Die Schülerinnen und Schüler werden nach ihrer Wohnadresse den Perimetern zugeordnet.
        pub perimeter: Option<String>,
        /// Schulstufe
        ///
        /// Einteilung gemäss HarmoS-Schulstufen. Schulstufen 1 und 2 bezeichnen die beiden Jahre im Kindergarten, die Schulstufen 3-6 die umgangssprachlich als Primarschuljahre 1-6 bezeichneten Schulstufen.
        pub schulstufe: Option<i64>,
        /// Schülerinnen und Schüler
        ///
        /// Schülerinnen und Schüler in öffentlichen Schulen von Riehen oder Bettingen, die in einem der Perimeter in  Riehen oder Bettingen wohnhaft sind. Prognosejahre erkennt man am beistehenden Prognoseintervall. In den Prognosen nicht berücksichtigt sind künftige Arealentwicklungen.
        pub sus: Option<i64>,
        /// Unteres Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das untere Prognoseintervall bezeichnet die untere Grenze dieser Bandbreite.
        pub unteres_prognoseintervall: Option<String>,
        /// Oberes Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das obere Prognoseintervall bezeichnet die obere Grenze dieser Bandbreite.
        pub oberes_prognoseintervall: Option<String>,
        /// Typ
        ///
        /// Ist-Wert oder Resultat der Prognose
        pub typ: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Schuljahr,
        Nummer,
        Perimeter,
        Schulstufe,
        Sus,
        UnteresPrognoseintervall,
        OberesPrognoseintervall,
        Typ,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schuljahr => "schuljahr",
                Field::Nummer => "nummer",
                Field::Perimeter => "perimeter",
                Field::Schulstufe => "schulstufe",
                Field::Sus => "sus",
                Field::UnteresPrognoseintervall => "unteres_prognoseintervall",
                Field::OberesPrognoseintervall => "oberes_prognoseintervall",
                Field::Typ => "typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100122/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 13. Juni 2021"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 13. Juni 2021 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_13_juni_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Gegenvorschlag
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Stichfrage
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag am Total der Stimmen mit gültiger Antwort
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100143/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kantonale Abstimmungen"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Resultate der Volksabstimmungen im Kanton Basel-Stadt seit 1875. Die Daten vor 1921 wurden von <a href=\"https://baselvotes.ch/\" target=\"_blank\">baselvotes (https://baselvotes.ch)</a> zur Verf\u{fc}gung gestellt. Seit 1921 basieren die Daten auf den Statistischen Jahrb\u{fc}chern. F\u{fc}r jede Abstimmungsvorlage sind alle amtlich publizierten Kennzahlen zum Schlussresultat ausgewiesen.<br><br>Zus\u{e4}tzlich sind alle Vorlagen inhaltlich dem haupts\u{e4}chlich betroffenen Politikbereich zugeordnet. Die Zuteilung erfolgt auf Basis der Einteilung des Bundesamtes f\u{fc}r Statistik, die im eidgen\u{f6}ssischen Abstimmungsdatensatz der Datenplattform <a \'=\"\" href=\"https://swissvotes.ch/votes\" target=\"_blank\">swissvotes (https://swissvotes.ch/votes)</a> des Instituts f\u{fc}r Politikwissenschaft der Universit\u{e4}t Bern verwendet wird."]
pub mod kantonale_abstimmungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BS-ID
        ///
        /// Eindeutige Identifikationsnummer einer Vorlage. Sie setzt sich zusammen aus dem vierstelligen Abstimmungsjahr, der zweistelligen Laufnummer des Abstimmungstermins, und der zweistelligen Laufnummer der Vorlage.
        pub bs_id: Option<String>,
        /// Jahr
        ///
        /// Jahr der Abstimmung
        pub jahr: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Laufnummer des Abstimmungstermins
        ///
        /// Laufnummer des Abstimmungstermins. Auch Termine ohne kantonale Abstimmung sind bei der chronologischen Vergabe der Laufnummer pro Kalenderjahr berücksichtigt.
        pub abstimmungstermin_nr: Option<i64>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage. Finden gleichzeitig eidgenössische Abstimmungen statt, setzen die kantonalen Vorlagen die Nummerierung fort.
        pub vorlagen_id: Option<i64>,
        /// Titel der Vorlage
        ///
        /// Offizieller Wortlaut der Vorlage gemäss Abstimmungsunterlagen.
        pub titel: Option<String>,
        /// Kurztitel
        ///
        /// Kurzform des offiziellen Wortlauts der Vorlage.
        pub kurztitel: Option<String>,
        /// Thema
        ///
        /// Betroffener Politikbereich. Klassifikation nach dem Codebook von swissvotes. Zuordnung durch das Statistische Amt Basel-Stadt.
        pub thema: Option<String>,
        /// Unterthema
        ///
        /// Betroffener Politik-Detailbereich. Klassifikation nach dem Codebook von swissvotes. Zuordnung durch das Statistische Amt Basel-Stadt.
        pub unterthema: Option<String>,
        /// Vorlagentyp
        ///
        /// Rechtsform der Vorlage. Beim fakultativen Referendum kann vom Stimmvolk mit 2000 Unterschriften (bis 1974 1000) eine Volksabstimmung über Gesetze und Grossratsbeschlüsse erwirkt werden. Bei Initiativen zu Verfassungs- oder Gesetzesvorlagen sind 3000 Unterschriften (bis Juni 1939 1000, danach 2000, von 1975 bis 2005 4000) erforderlich. Der Grosse Rat kann dem Stimmvolk einen Gegenvorschlag zu einer Initiative vorlegen. Verfassungsvorlagen unterliegen einem Abstimmungsobligatorium. Legt der Grosse Rat den Stimmberechtigten freiwillig weitere Vorlagen zur Abstimmung vor, handelt es sich um eine angeordnete Abstimmung.
        pub vorlagentyp: Option<String>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigte
        pub stimmberechtigte: Option<i64>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl abgegebener Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub stimmzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Stimmzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Stimmende
        ///
        /// Anteil der brieflich abgegebenen Stimmzettel am Total der eingelegten Stimmzettel
        pub briefliche: Option<f64>,
        /// Ergebnis
        ///
        /// Abstimmungsergebnis. Beträgt der Anteil Ja-Stimmen über 50%, gilt die Vorlage als angenommen, bei unter 50% als abgelehnt. Bei Referenden bedeutet «Angenommen» eine Bestätigung des Grossratsbeschlusses (Erfolg des Parlaments). Bei einer Ablehnung ist das Referendumskomitee erfolgreich. Bis 1911 kam nicht die Volksinitiative, sondern der Grossratsbeschluss zur Volksinitiative an die Urne. Lautete die Empfehlung des Grossen Rates «Nein», bedeutete eine Nein-Mehrheit Annahme der Initiative.
        pub ergebnis: Option<String>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leere: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub ungueltige: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub gueltige: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_stimmen: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_stimmen: Option<i64>,
        /// Ja-Anteil
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub ja_anteil: Option<f64>,
        /// Datum Grossratsbeschluss
        ///
        /// Datum des Grossratsbeschlusses
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub grossratsbeschlussdatum: Option<Date>,
        /// Stichfragenannahmen
        ///
        /// Anzahl Stimmberechtigte, die sich bei der Stichfrage für die jeweilige Vorlage aussprechen
        pub stichfragenannahmen: Option<i64>,
        /// Stichfragenauslassung
        ///
        /// Anzahl Stimmberechtigte, die beim Stichentscheid keine gültige Antwort abgeben
        pub stichfragenauslassung: Option<i64>,
        /// Unterschriften
        ///
        /// Anzahl eingereichter Unterschriften, um Initiativen und Referenden dem Volk zur Abstimmung vorzulegen
        pub unterschriften: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        BsId,
        Jahr,
        Datum,
        AbstimmungsterminNr,
        VorlagenId,
        Titel,
        Kurztitel,
        Thema,
        Unterthema,
        Vorlagentyp,
        Stimmberechtigte,
        Stimmrechtsausweise,
        Stimmzettel,
        Stimmbeteiligung,
        Briefliche,
        Ergebnis,
        Leere,
        Ungueltige,
        Gueltige,
        JaStimmen,
        NeinStimmen,
        JaAnteil,
        Grossratsbeschlussdatum,
        Stichfragenannahmen,
        Stichfragenauslassung,
        Unterschriften,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BsId => "bs_id",
                Field::Jahr => "jahr",
                Field::Datum => "datum",
                Field::AbstimmungsterminNr => "abstimmungstermin_nr",
                Field::VorlagenId => "vorlagen_id",
                Field::Titel => "titel",
                Field::Kurztitel => "kurztitel",
                Field::Thema => "thema",
                Field::Unterthema => "unterthema",
                Field::Vorlagentyp => "vorlagentyp",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Stimmzettel => "stimmzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::Briefliche => "briefliche",
                Field::Ergebnis => "ergebnis",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::JaStimmen => "ja_stimmen",
                Field::NeinStimmen => "nein_stimmen",
                Field::JaAnteil => "ja_anteil",
                Field::Grossratsbeschlussdatum => "grossratsbeschlussdatum",
                Field::Stichfragenannahmen => "stichfragenannahmen",
                Field::Stichfragenauslassung => "stichfragenauslassung",
                Field::Unterschriften => "unterschriften",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100229/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung 29. November 2020 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 29. November 2020 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_29_november_2020_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        WahllokId,
        GemeinId,
        GemeinName,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100103/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Monatliche Ank\u{fc}nfte und Logiern\u{e4}chte"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Anzahl Ank\u{fc}nfte und Logiern\u{e4}chte in baselst\u{e4}dtischen Hotels nach Herkunftsland auf monatlicher Basis."]
pub mod monatliche_ankuenfte_und_logiernaechte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Herkunftsland
        ///
        /// Herkunftsland des Gastes
        pub herkunftsland: Option<String>,
        /// Anzahl Ankünfte
        ///
        /// Anzahl in baselstädtischen Hotels angekommene Gäste
        pub anzankuenfte: Option<i64>,
        /// Anzahl Logiernächte
        ///
        /// Anzahl Übernachtungen in baselstädtischen Hotels
        pub anzlogiernaechte: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
        /// Monat
        pub monat: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Herkunftsland,
        Anzankuenfte,
        Anzlogiernaechte,
        Jahr,
        Monat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Herkunftsland => "herkunftsland",
                Field::Anzankuenfte => "anzankuenfte",
                Field::Anzlogiernaechte => "anzlogiernaechte",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100107/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): Erg\u{e4}nzte Fallzahlen ganze Schweiz"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz bildet die Grundlage des Covid-19 Dashboards (<a href=\"https://data.bs.ch/pages/covid-19-dashboard\" target=\"_blank\">https://data.bs.ch/pages/covid-19-dashboard</a>). Bitte verwenden Sie f\u{fc}r Ihre Analysen nicht den vorliegenden Datensatz, sondern diesen: <a href=\"https://data.bs.ch/explore/dataset/100077\" target=\"_blank\">https://data.bs.ch/explore/dataset/100077</a>.</p>\n<p>Zum Zweck der einfachen Visualisierung wurden Tage ohne gemeldete Fallzahlen mit den letzten gemeldeten Fallzahlen des entsprechenden Kantons aufgef\u{fc}llt.</p>"]
pub mod coronavirus_covid_19_ergaenzte_fallzahlen_ganze_schweiz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Kanton
        pub abbreviation_canton_and_fl: Option<String>,
        /// Anzahl Fälle kumuliert
        ///
        /// Anzahl bestätigte Infektionen mit dem SARS-CoV-2 Virus
        pub ncumul_conf: Option<i64>,
        /// Anzahl Fälle im Spital
        ///
        /// Anzahl Personen mit COVID-19 Erkrankung, welche in einem Spital behandelt werden
        pub current_hosp: Option<i64>,
        /// Anzahl Fälle auf Intensivstation
        ///
        /// Anzahl Personen mit COVID-19 Erkrankung, welche in der Intensivstation eines Spitals behandelt werden
        pub current_icu: Option<i64>,
        /// Anzahl Genesene
        ///
        /// Anzahl Personen, die eine COVID-19-Erkrankung überstanden haben insgesamt (kumuliert)
        pub ncumul_released: Option<i64>,
        /// Anzahl Verstorbene
        ///
        /// Anzahl mit SARS-CoV-2 infizierte Verstorbene
        pub ncumul_deceased: Option<i64>,
        /// Isolierte
        ///
        /// Mit dem neuen Coronavirus infizierte Personen, welche ausserhalb des Spitals isoliert sind
        pub current_isolated: Option<i64>,
        /// Kontaktpersonen in Quarantäne
        ///
        /// Personen, welche in engem Kontakt zu einem Infizierten Fall waren und sich deshalb in Quarantäne befinden
        pub current_quarantined: Option<i64>,
        pub current_quarantined_riskareatravel: Option<i64>,
        /// Differenz Anzahl Fälle
        ///
        /// Neu gemeldete Fälle gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_conf: Option<i64>,
        /// Differenz Anzahl Genesene
        ///
        /// Neu gemeldete Genesene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_released: Option<i64>,
        /// Differenz Anzahl Verstorbene
        ///
        /// Neu gemeldete Gestorbene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_deceased: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        AbbreviationCantonAndFl,
        NcumulConf,
        CurrentHosp,
        CurrentIcu,
        NcumulReleased,
        NcumulDeceased,
        CurrentIsolated,
        CurrentQuarantined,
        CurrentQuarantinedRiskareatravel,
        NdiffConf,
        NdiffReleased,
        NdiffDeceased,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::AbbreviationCantonAndFl => "abbreviation_canton_and_fl",
                Field::NcumulConf => "ncumul_conf",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentIcu => "current_icu",
                Field::NcumulReleased => "ncumul_released",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::CurrentIsolated => "current_isolated",
                Field::CurrentQuarantined => "current_quarantined",
                Field::CurrentQuarantinedRiskareatravel => "current_quarantined_riskareatravel",
                Field::NdiffConf => "ndiff_conf",
                Field::NdiffReleased => "ndiff_released",
                Field::NdiffDeceased => "ndiff_deceased",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100085/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 9. Juni 2024"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 9. Juni 2024 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im <a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">https://www.kantonsblatt.ch/#!/search/publications</a>) des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_9_juni_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100370/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 27. September 2020"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 27. September 2020 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.\u{a0}</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_27_september_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100072/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Ersatzwahl Regierungspr\u{e4}sidium 3. M\u{e4}rz 2024"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">F\u{fc}r die Ersatzwahl des Regierungspr\u{e4}sidiums vom 3. M\u{e4}rz 2024 kandidieren vier Personen.</p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">Dieser Datensatz zeigt die Kandidierenden des ersten Wahlgangs nach Geschlecht, Jahrgang und Beruf.</p>"]
pub mod kandidierende_der_ersatzwahl_regierungspraesidium_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100334/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der B\u{fc}rgergemeinderatswahlen 2023"]
#[doc = ""]
#[doc = "<p>Der vorliegende Datensatz beinhaltet Resultate der B\u{fc}rgergemeinderatswahlen Basel 2023 auf Ebene der einzelnen Kandidierenden. Weitere Informationen zu den Wahlen sind hier zu finden:\u{a0}<a href=\"https://bgbasel.ch/de/politische-organe/buergergemeinderat/wahlen2023.html\" target=\"_blank\">https://bgbasel.ch/de/politische-organe/buergergemeinderat/wahlen2023.html</a><br/></p>"]
pub mod resultate_der_buergergemeinderatswahlen_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze Wahlkreis
        ///
        /// Anzahl Sitze, die für einen Wahlkreis zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aller Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Kumulation
        ///
        /// K: eine Kandidatin oder ein Kandidat auf einem unveränderten Wahlzettel ist mehrfach aufgeführt.
        pub kumulation: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Rangfolge
        ///
        /// Rangfolge innerhalb einer Liste gemäss Anzahl Stimmen (bei Stimmengleichheit entscheidet das Los).
        pub rangfolge: Option<i64>,
        /// 00 OHNE
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer Liste ohne Bezeichnung
        pub x00_ohne: Option<i64>,
        /// 01 FDP
        ///
        /// FDP. Die Liberalen Basel-Stadt und Jungfreisinnige; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x01_fdp: Option<i64>,
        /// 03 LDP
        ///
        /// LDP Liberal-Demokratische Partei Basel-Stadt und Jungliberale; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x03_ldp: Option<i64>,
        /// 04 EVP
        ///
        /// Evangelische Volkspartei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x04_evp: Option<i64>,
        /// 05 SP
        ///
        /// Sozialdemokratische Partei Basel-Stadt (SP) und JUSO; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x05_sp: Option<i64>,
        /// 07 MITTE
        ///
        /// Die Mitte Basel-Stadt (MITTE); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x07_mitte: Option<i64>,
        /// 10 GLP
        ///
        /// Grünliberale Partei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x10_glp: Option<i64>,
        /// 12 SVP
        ///
        /// Schweizerische Volkspartei Basel-Stadt (SVP); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x12_svp: Option<i64>,
        /// 17 GP
        ///
        /// Grüne Partei (GP); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x17_gp: Option<i64>,
        /// 27 BastA!
        ///
        /// Basels starke Alternative (BastA!); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x27_basta: Option<i64>,
        /// 30 Unabh.
        ///
        /// Unabhängige (Unabh.); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x30_unabh: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus unveränderten Wahlzetteln
        pub stimmen_unveranderte_wahlzettel: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus veränderten Wahlzetteln
        pub stimmen_veranderte_wahlzettel: Option<i64>,
        /// Stimmen Total aus Wahlzettel
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten
        pub stimmen_total_aus_wahlzettel: Option<i64>,
        /// Total der gültigen Wahlzettel
        pub total_der_gultigen_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Stimmbeteiligung: Berechnet als Anzahl Wahlzettel geteilt durch das Total der Stimmberechtigten
        pub stimmbeteiligung: Option<GeoPoint2d>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil brieflich Wählende: Berechnet als Anzahl Briefliche Stimmabgaben geteilt durch das Anzahl Wahlzettel.
        pub anteil_brieflich_wahlende: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        Kumulation,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Rangfolge,
        X00Ohne,
        X01Fdp,
        X03Ldp,
        X04Evp,
        X05Sp,
        X07Mitte,
        X10Glp,
        X12Svp,
        X17Gp,
        X27Basta,
        X30Unabh,
        UngestempelteWahlzettel,
        ListenNr,
        StimmenUnveranderteWahlzettel,
        StimmenVeranderteWahlzettel,
        StimmenTotalAusWahlzettel,
        TotalDerGultigenWahlzettel,
        AnteilBrieflichWahlende,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Rangfolge => "rangfolge",
                Field::X00Ohne => "00_ohne",
                Field::X01Fdp => "01_fdp",
                Field::X03Ldp => "03_ldp",
                Field::X04Evp => "04_evp",
                Field::X05Sp => "05_sp",
                Field::X07Mitte => "07_mitte",
                Field::X10Glp => "10_glp",
                Field::X12Svp => "12_svp",
                Field::X17Gp => "17_gp",
                Field::X27Basta => "27_basta",
                Field::X30Unabh => "30_unabh",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::ListenNr => "listen_nr",
                Field::StimmenUnveranderteWahlzettel => "stimmen_unveranderte_wahlzettel",
                Field::StimmenVeranderteWahlzettel => "stimmen_veranderte_wahlzettel",
                Field::StimmenTotalAusWahlzettel => "stimmen_total_aus_wahlzettel",
                Field::TotalDerGultigenWahlzettel => "total_der_gultigen_wahlzettel",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100300/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Ersatzwahl Regierungspr\u{e4}sidium 7. April 2024 (2. Wahlgang)"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate des zweiten Wahlgangs der Regierungspr\u{e4}sidiums-Ersatzwahl vom 7. April 2024.</p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im <a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">www.kantonsblatt.ch</a>) des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_ersatzwahl_regierungspraesidium_7_april_2024_2_wahlgang {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1). Für zweiten Wahlgang nicht vorhanden.
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100361/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Studierende der Universit\u{e4}t Basel nach Geschlecht und Fakult\u{e4}t"]
#[doc = ""]
#[doc = "Der Datensatz zeigt die Studierenden der Universit\u{e4}t Basel nach Geschlecht, Fakult\u{e4}t und Staatsangeh\u{f6}rigkeit. Die Daten werden j\u{e4}hrlich aktualisiert."]
pub mod studierende_der_universitaet_basel_nach_geschlecht_und_fakultaet {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Das Jahr bezeichnet das Wintersemster (bis 2006) oder das Herbstsemester (seit 2007) des gegeben Jahres. Stichtag für das Wintersemester ist der 15. Dezember, für das Herbstsemester der 15. November.
        pub jahr: Option<String>,
        /// Internationale Studenten
        ///
        /// Studenten, welche vor Studienbeginn einen Wohnort im Ausland hatten.
        pub internationale_studenten: Option<i64>,
        /// Schweizer Studenten
        ///
        /// Studenten, welche vor Studienbeginn einen Wohnort in der Schweiz hatten.
        pub schweizer_studenten: Option<i64>,
        /// Studenten_total
        ///
        /// Gesamtanzahl Studenten an der Universität Basel.
        pub studenten_total: Option<i64>,
        /// Internationale Studentinnen
        ///
        /// Studentinnen, welche vor Studienbeginn einen Wohnort  im Ausland hatten.
        pub internationale_studentinnen: Option<i64>,
        /// Schweizer Studentinnen
        ///
        /// Studentinnen, welche vor Studienbeginn einen Wohnort in der Schweiz hatten.
        pub schweizer_studentinnen: Option<i64>,
        /// Studentinnen_total
        ///
        /// Gesamtanzahl Studentinnen an der Universität Basel.
        pub studentinnen_total: Option<i64>,
        /// Studierende_total
        ///
        /// Gesamtanzahl Studierende an der Universität Basel.
        pub studierende_total: Option<i64>,
        /// Theologie_m
        ///
        /// Studenten an der Theologischen Fakultät.
        pub theologie_m: Option<i64>,
        /// Theologie_f
        ///
        /// Studentinnen an der Theologischen Fakultät.
        pub theologie_f: Option<i64>,
        /// Theologie_total
        ///
        /// Gesamtanzahl Studierende an der Theologischen Fakultät.
        pub theologie_total: Option<i64>,
        /// Jurisprudenz_m
        ///
        /// Studenten an der Juristischen Fakultät.
        pub jurisprudenz_m: Option<i64>,
        /// Jurisprudenz_f
        ///
        /// Studentinnen an der Juristischen Fakultät.
        pub jurisprudenz_f: Option<i64>,
        /// Jurisprudenz_total
        ///
        /// Gesamtanzahl Studierende an der Juristischen Fakultät.
        pub jurisprudenz_total: Option<i64>,
        /// Medizin_m
        ///
        /// Studenten an der Medizinischen Fakultät.
        pub medizin_m: Option<i64>,
        /// Medizin_f
        ///
        /// Studentinnen an der Medizinischen Fakultät.
        pub medizin_f: Option<i64>,
        /// Medizin_total
        ///
        /// Gesamtanzahl Studierende an der Medizinischen Fakultät.
        pub medizin_total: Option<i64>,
        /// Philosophie1_m
        ///
        /// Studenten an der Philosophisch-Historischen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie1_m: Option<i64>,
        /// Philosophie1_f
        ///
        /// Studentinnen an der Philosophisch-Historischen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie1_f: Option<i64>,
        /// Philosophie1_total
        ///
        /// Gesamtanzahl Studierende an der Philosophisch-Historischen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie1_total: Option<i64>,
        /// Psychologie_m
        ///
        /// Studenten an der Psychologischen Fakultät (seit 2003 wird der Fachbereich Psychologie in einer eigenen Fakultät geführt und ist damit nicht mehr Teil der Philosophisch-Historischen Fakultät).
        pub psychologie_m: Option<i64>,
        /// Psychologie_f
        ///
        /// Studentinnen an der Psychologischen Fakultät (seit 2003 wird der Fachbereich Psychologie in einer eigenen Fakultät geführt und ist damit nicht mehr Teil der Philosophisch-Historischen Fakultät).
        pub psychologie_f: Option<i64>,
        /// Psychologie_total
        ///
        /// Gesamtanzahl Studierende an der Psychologischen Fakultät (seit 2003 wird der Fachbereich Psychologie in einer eigenen Fakultät geführt und ist damit nicht mehr Teil der Philosophisch-Historischen Fakultät).
        pub psychologie_total: Option<i64>,
        /// Wirtschaft_m
        ///
        /// Studenten an der Wirtschaftlichen Fakultät (seit 1995 wird der Fachbereich Wirtschaft in einer eigenen Fakultät der Wirtschaftswissenschaften geführt, davor wurde das Fach Ökonomie in der Philosophisch-Historischen Fakultät Philosophie geführt
        ///).
        pub wirtschaft_m: Option<i64>,
        /// Wirtschaft_f
        ///
        /// Studentinnen an der Wirtschaftlichen Fakultät (seit 1995 wird der Fachbereich Wirtschaft in einer eigenen Fakultät der Wirtschaftswissenschaften geführt, davor wurde das Fach Ökonomie in der Philosophisch-Historischen Fakultät Philosophie geführt).
        pub wirtschaft_f: Option<i64>,
        /// Wirtschaft_total
        ///
        /// Gesamtanzahl Studierende an der Wirtschaftlichen Fakultät (seit 1995 wird der Fachbereich Wirtschaft in einer eigenen Fakultät der Wirtschaftswissenschaften geführt, davor wurde das Fach Ökonomie in der Philosophisch-Historischen Fakultät Philosophie geführt).
        pub wirtschaft_total: Option<i64>,
        /// Philosophie2_m
        ///
        /// Studenten an der Philosophisch-Naturwissenschaftlichen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie2_m: Option<i64>,
        /// Philosophie2_f
        ///
        /// Studentinnen an derPhilosophisch-Naturwissenschaftlichen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie2_f: Option<i64>,
        /// Philosophie2_total
        ///
        /// Gesamtanzahl Studierende an der Philosophisch-Naturwissenschaftlichen Fakultät (seit 1966 ohne Lehramtsstudierende).
        pub philosophie2_total: Option<i64>,
        /// UniversitätBasel_m
        ///
        /// Studenten mit einem Studienfach, welches von mehreren Fakultäten gemeinsam angeboten wird (seit 2005 werden die Studierenden separat ausgewiesen).
        pub universitaetbasel_m: Option<i64>,
        /// UniversitätBasel_f
        ///
        /// Studentinnen mit einem Studienfach, welches von mehreren Fakultäten gemeinsam angeboten wird (seit 2005 werden die Studierenden separat ausgewiesen).
        pub universitaetbasel_f: Option<i64>,
        /// UniversitätBasel_total
        ///
        /// Gesamtanzahl Studierende mit einem Studienfach, welches von mehreren Fakultäten gemeinsam angeboten wird (seit 2005 werden die Studierenden separat ausgewiesen).
        pub universitaetbasel_total: Option<i64>,
        /// Lehrerausbildung_m
        ///
        /// Studenten in der Lehrerausbildung (Lehramtsstudierende werden von 1966 bis 2012 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub lehrerausbildung_m: Option<i64>,
        /// Lehrerausbildung_f
        ///
        /// Studentinnen in der Lehrerausbildung (Lehramtsstudierende werden von 1966 bis 2012 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden
        ///).
        pub lehrerausbildung_f: Option<i64>,
        /// Lehrerausbildung_total
        ///
        /// Gesamtanzahl Studierende in der Lehrerausbildung (Lehramtsstudierende werden von 1966 bis 2012 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub lehrerausbildung_total: Option<i64>,
        /// AdvancedStudies_m
        ///
        /// Studenten im Advanced Studies Programm der Universität Basel (seit 2004).
        pub advancedstudies_m: Option<i64>,
        /// AdvancedStudies_f
        ///
        /// Studentinnen im Advanced Studies Programm der Universität Basel (seit 2004).
        pub advancedstudies_f: Option<i64>,
        /// AdvancedStudies_total
        ///
        /// Gesamtanzahl Studierende im Advanced Studies Programm der Universität Basel (seit 2004).
        pub advancedstudies_total: Option<i64>,
        /// Bildungswissenschaften_m
        ///
        /// Studenten in der Fachrichtung Bildungswissenschaften (Studierende der Bildungswissenschaften werden seit 2016 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub bildungswissenschaften_m: Option<i64>,
        /// Bildungswissenschaften_f
        ///
        /// Studentinnen in der Fachrichtung Bildungswissenschaften (Studierende der Bildungswissenschaften werden seit 2016 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub bildungswissenschaften_f: Option<i64>,
        /// Bildungswissenschaften_total
        ///
        /// Gesamtanzahl Studierende in der Fachrichtung Bildungswissenschaften (Studierende der Bildungswissenschaften werden seit 2016 separat ausgewiesen, obwohl sie keine eigene Fakultät bilden).
        pub bildungswissenschaften_total: Option<i64>,
        /// Philosophie_m
        ///
        /// Studenten in der Philosophischen Fakultät (seit 1937 gibt es die Philosophisch-Naturwissenschaftliche Fakultät und die Philosophisch-Historische Fakultät, welche durch eine Aufspaltung der Philosophischen Fakultät entstanden sind).
        pub philosophie_m: Option<i64>,
        /// Philosophie_f
        ///
        /// Studentinnen in der Philosophischen Fakultät (seit 1937 gibt es die Philosophisch-Naturwissenschaftliche Fakultät und die Philosophisch-Historische Fakultät, welche durch eine Aufspaltung der Philosophischen Fakultät entstanden sind).
        pub philosophie_f: Option<i64>,
        /// Philosophie_total
        ///
        /// Gesamtanzahl Studierende in der Philosophischen Fakultät (seit 1937 gibt es die Philosophisch-Naturwissenschaftliche Fakultät und die Philosophisch-Historische Fakultät, welche durch eine Aufspaltung der Philosophischen Fakultät entstanden sind).
        pub philosophie_total: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        InternationaleStudenten,
        SchweizerStudenten,
        StudentenTotal,
        InternationaleStudentinnen,
        SchweizerStudentinnen,
        StudentinnenTotal,
        StudierendeTotal,
        TheologieM,
        TheologieF,
        TheologieTotal,
        JurisprudenzM,
        JurisprudenzF,
        JurisprudenzTotal,
        MedizinM,
        MedizinF,
        MedizinTotal,
        Philosophie1M,
        Philosophie1F,
        Philosophie1Total,
        PsychologieM,
        PsychologieF,
        PsychologieTotal,
        WirtschaftM,
        WirtschaftF,
        WirtschaftTotal,
        Philosophie2M,
        Philosophie2F,
        Philosophie2Total,
        UniversitaetbaselM,
        UniversitaetbaselF,
        UniversitaetbaselTotal,
        LehrerausbildungM,
        LehrerausbildungF,
        LehrerausbildungTotal,
        AdvancedstudiesM,
        AdvancedstudiesF,
        AdvancedstudiesTotal,
        BildungswissenschaftenM,
        BildungswissenschaftenF,
        BildungswissenschaftenTotal,
        PhilosophieM,
        PhilosophieF,
        PhilosophieTotal,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::InternationaleStudenten => "internationale_studenten",
                Field::SchweizerStudenten => "schweizer_studenten",
                Field::StudentenTotal => "studenten_total",
                Field::InternationaleStudentinnen => "internationale_studentinnen",
                Field::SchweizerStudentinnen => "schweizer_studentinnen",
                Field::StudentinnenTotal => "studentinnen_total",
                Field::StudierendeTotal => "studierende_total",
                Field::TheologieM => "theologie_m",
                Field::TheologieF => "theologie_f",
                Field::TheologieTotal => "theologie_total",
                Field::JurisprudenzM => "jurisprudenz_m",
                Field::JurisprudenzF => "jurisprudenz_f",
                Field::JurisprudenzTotal => "jurisprudenz_total",
                Field::MedizinM => "medizin_m",
                Field::MedizinF => "medizin_f",
                Field::MedizinTotal => "medizin_total",
                Field::Philosophie1M => "philosophie1_m",
                Field::Philosophie1F => "philosophie1_f",
                Field::Philosophie1Total => "philosophie1_total",
                Field::PsychologieM => "psychologie_m",
                Field::PsychologieF => "psychologie_f",
                Field::PsychologieTotal => "psychologie_total",
                Field::WirtschaftM => "wirtschaft_m",
                Field::WirtschaftF => "wirtschaft_f",
                Field::WirtschaftTotal => "wirtschaft_total",
                Field::Philosophie2M => "philosophie2_m",
                Field::Philosophie2F => "philosophie2_f",
                Field::Philosophie2Total => "philosophie2_total",
                Field::UniversitaetbaselM => "universitaetbasel_m",
                Field::UniversitaetbaselF => "universitaetbasel_f",
                Field::UniversitaetbaselTotal => "universitaetbasel_total",
                Field::LehrerausbildungM => "lehrerausbildung_m",
                Field::LehrerausbildungF => "lehrerausbildung_f",
                Field::LehrerausbildungTotal => "lehrerausbildung_total",
                Field::AdvancedstudiesM => "advancedstudies_m",
                Field::AdvancedstudiesF => "advancedstudies_f",
                Field::AdvancedstudiesTotal => "advancedstudies_total",
                Field::BildungswissenschaftenM => "bildungswissenschaften_m",
                Field::BildungswissenschaftenF => "bildungswissenschaften_f",
                Field::BildungswissenschaftenTotal => "bildungswissenschaften_total",
                Field::PhilosophieM => "philosophie_m",
                Field::PhilosophieF => "philosophie_f",
                Field::PhilosophieTotal => "philosophie_total",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100191/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): F\u{fc}r Impfung angemeldete Personen nach Altersklasse"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Anzahl Personen, welche sich im Kanton Basel-Stadt f\u{fc}r eine Impfung gegen SARS-CoV-2 angemeldet, aber noch keine Impfung erhalten haben nach Altersklasse (\u{ab}Warteliste\u{bb}). Zudem wird angegeben, ob die Person bereits einen Termin f\u{fc}r die Impfung hat oder noch nicht.\u{a0}</p><p>Ab dem 25. Juni k\u{f6}nnen sich auch Personen im Alter zwischen 12 und 15 Jahren f\u{fc}r die Impfung anmelden. Entsprechend wird diese Altersklasse im Datensatz auch gef\u{fc}hrt.\u{a0}</p><p><br></p>"]
pub mod coronavirus_covid_19_fuer_impfung_angemeldete_personen_nach_altersklasse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Zeitstand
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Altersklasse
        ///
        /// Altersklasse der Personen, welche sich für eine Impfung gegen SARS-CoV-2 angemeldet haben
        pub age_group: Option<String>,
        /// Termin ja/nein
        ///
        /// Angabe, ob eine angemeldete Person bereits einen Termin hat (Yes), nicht (No), oder auf Grund fehlender historischer Daten unbekannt (Unknown)
        pub has_appointments: Option<String>,
        /// Anzahl Personen
        ///
        /// Anzahl Personen in der jeweiligen Gruppe
        pub count: Option<i64>,
        /// Woche
        ///
        /// Wochennummer
        pub week: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        AgeGroup,
        HasAppointments,
        Count,
        Week,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::AgeGroup => "age_group",
                Field::HasAppointments => "has_appointments",
                Field::Count => "count",
                Field::Week => "week",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100136/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Massentests in Betrieben"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die SARS-CoV-2-Tests, welche an Angestellten von baselst\u{e4}dtischen Betrieben durchgef\u{fc}hrt wurden. Es werden die Anzahl durchgef\u{fc}hrter Tests sowie die Test-Positivit\u{e4}tsrate pro Woche aufgef\u{fc}hrt. Weitere Informationen zum Coronavirus in Kanton Basel-Stadt:\u{a0}<a href=\"https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co\" target=\"_blank\">https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co</a></p>"]
pub mod coronavirus_covid_19_massentests_in_betrieben {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<i64>,
        /// Resultat
        ///
        /// Zeigt an, ob eine SARS-CoV-2-Test positiv oder negativ ausgefallen ist
        pub result: Option<String>,
        /// Pos./neg. getestete MA pro Woche
        ///
        /// Anzahl positiv resp. negativ getesteter Mitarbeiter pro Woche
        pub count: Option<i64>,
        /// Getestete MA pro Woche
        ///
        /// Anzahl getesteter Mitarbeiter pro Woche
        pub counttotal: Option<i64>,
        /// Positivitätsrate
        ///
        /// Zeigt den Prozentsatz der Tests, die positiv auf SARS-CoV-2 getestet wurden
        pub positivityratepercent: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100146/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen zu den Basler Wohnvierteln und Landgemeinden - langer Datensatz"]
#[doc = ""]
#[doc = "Ausgew\u{e4}hlte statistische Kennzahlen der 19 Wohnviertel der Stadt Basel sowie der zwei Gemeinden Riehen und Bettingen seit 2015. Aufgrund einer ver\u{e4}nderten Datenlage k\u{f6}nnen die Indikatoren 3 (Religionszugeh\u{f6}rigkeit) und 18 (Arbeitslosenquote) ab der Ausgabe 2020 nicht mehr dargestellt werden. Dieser lange Datensatz wurde zus\u{e4}tzlich zum bisher bereits bestehenden breiten Datensatz angelegt, um neben dem Publikationsjahr auch das jeweilige Datenjahr noch zu erg\u{e4}nzen. Die Berechnungsmethode f\u{fc}r die Sozialhilfequote wurde 2022 f\u{fc}r die Jahre ab 2017 r\u{fc}ckwirkend angepasst.Zur Definition: <a href=\"https://statistik.bs.ch/files/faltblatt/Erlaeuterungen-Quartierradar.pdf\" target=\"_blank\">https://statistik.bs.ch/files/faltblatt/Erlaeuterungen-Quartierradar.pdf</a>."]
pub mod kennzahlen_zu_den_basler_wohnvierteln_und_landgemeinden_langer_datensatz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationsjahr
        ///
        /// Jahr, in dem der Wert publiziert wurde
        pub publikationsjahr: Option<String>,
        /// Indikator_Nr
        pub indikator_nr: Option<i64>,
        /// Datenjahr
        ///
        /// Jahr, aus dem die Daten stammen
        pub datenjahr: Option<String>,
        /// Wert
        ///
        /// Wert des Indikators
        pub wert: Option<f64>,
        /// Definition des Indikators
        ///
        /// Definition des Indikators, Berechnungsgrundlage
        pub indikator_label: Option<String>,
        /// Indikator
        ///
        /// Kurzform des Indikators
        pub indikator_name: Option<String>,
        /// Wohnviertel ID
        ///
        /// Nummer des Wohnviertels (1-19) bzw. der Landgemeinde (20 und 30)
        pub wohnviertel_id: Option<i64>,
        /// Name des Wohnviertels
        ///
        /// Offizielle Bezeichnungen der 19 Basler Wohnviertel und 2 Landgemeinden
        pub wohnviertel: Option<String>,
        /// Rang
        pub rang: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Publikationsjahr,
        IndikatorNr,
        Datenjahr,
        Wert,
        IndikatorLabel,
        IndikatorName,
        WohnviertelId,
        Wohnviertel,
        Rang,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Publikationsjahr => "publikationsjahr",
                Field::IndikatorNr => "indikator_nr",
                Field::Datenjahr => "datenjahr",
                Field::Wert => "wert",
                Field::IndikatorLabel => "indikator_label",
                Field::IndikatorName => "indikator_name",
                Field::WohnviertelId => "wohnviertel_id",
                Field::Wohnviertel => "wohnviertel",
                Field::Rang => "rang",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100226/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wasserstand Grundwasser"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die Grundwasserst\u{e4}nde in m \u{fc}. M. des kantonalen Grundwassermessnetzes. Es weist zur Zeit um die 80 Messstationen auf. Bei den Stationen, die mit einer Datenfern\u{fc}bertragung ausger\u{fc}stet sind, liegen tagesaktuelle Stundenwerte vor.</p><p>Jede Messstation ist mit der Katasternummer gem\u{e4}ss Bohrkataster des Kantons Basel-Stadt versehen (<a href=\"https://data.bs.ch/explore/dataset/100182\" target=\"_blank\">https://data.bs.ch/explore/dataset/100182</a>). Die Bohrungen sind auch auf MapBS unter dem Thema Geologie abrufbar (<a href=\"http://www.geo.bs.ch/bohrkataster\" target=\"_blank\">www.geo.bs.ch/bohrkataster</a>).</p><p>Weitere Informationen:\u{a0}<a href=\"https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html\" target=\"_blank\">https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html</a></p><div><br></div>"]
pub mod wasserstand_grundwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Value
        ///
        /// Messwert: Grundwasserstand [m ü. M]
        pub value: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// Status
        ///
        /// Rohadaten/ungeprüfte Daten (raw)
        ///bereinigte/geprüfte Daten (cleansed)
        pub status: Option<String>,
        /// on/offline
        pub on_offline: Option<String>,
        /// Date
        ///
        /// Datum in mitteleuropäischer Winterzeit (UTC+1)
        pub date: Option<String>,
        /// Time
        ///
        /// Zeit in mitteleuropäischer Winterzeit (UTC+1)
        pub time: Option<String>,
        /// Zeitstempel in mitteleuropäischer Winterzeit (UTC+1)
        pub timestamp_text: Option<String>,
        /// StationId
        ///
        /// Katasternummer gemäss Bohrkataster
        pub stationid: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Stationnr,
        Stationname,
        Sensornr,
        Sensname,
        Value,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        Status,
        OnOffline,
        Date,
        Time,
        TimestampText,
        Stationid,
        Lat,
        Lon,
        BohrkatasterLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Stationnr => "stationnr",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Value => "value",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::Status => "status",
                Field::OnOffline => "on_offline",
                Field::Date => "date",
                Field::Time => "time",
                Field::TimestampText => "timestamp_text",
                Field::Stationid => "stationid",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::BohrkatasterLink => "bohrkataster_link",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100164/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 26. September 2021 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 26. September 2021 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_26_september_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100154/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsz\u{e4}hldaten Velos und Fussg\u{e4}nger"]
#[doc = ""]
#[doc = "<p>Resultate der Messungen der\u{a0}Dauerz\u{e4}hlstellen und Kurzzeitz\u{e4}hlstellen f\u{fc}r den Velo- und Fussg\u{e4}ngerverkehr.\u{a0}</p><p>Die Z\u{e4}hldaten f\u{fc}r den Fussg\u{e4}ngerverkehr werden monatlich durch Anwendung einer Korrekturfunktion angepasst und im Anschluss ver\u{f6}ffentlicht. Ausnahme bildet hier die Z\u{e4}hlstelle 817 Elisabethenanlage. Diese wird auf Grund der aktuellen COVID-19 Krise t\u{e4}glich aufgearbeitet und beobachtet </p><p>Aus Kostengr\u{fc}nden sind nur die Werte des aktuellen und des letzten Jahres als Tabelle / Visualisierung sichtbar bzw. via API abgreifbar. Die vollst\u{e4}ndigen Daten ab dem Jahr 2000 k\u{f6}nnen hier heruntergeladen werden: </p><ul><li><a href=\"https://data-bs.ch/mobilitaet/converted_Velo_Fuss_Count.csv\">Leicht aufbereiteter Datensatz: https://data-bs.ch/mobilitaet/converted_Velo_Fuss_Count.csv</a> </li><li><a href=\"https://data-bs.ch/mobilitaet/Velo_Fuss_Count.csv\">Rohdaten: https://data-bs.ch/mobilitaet/Velo_Fuss_Count.csv</a></li></ul><p>Die Daten einzelner Jahre ab dem Jahr 2000 k\u{f6}nnen einzeln heruntergeladen werden unter der URL mit dem Muster https://data-bs.ch/mobilitaet/[JAHR]_Velo_Fuss_Count.csv, also zum Beispiel f\u{fc}r das Jahr 2020 hier: <a href=\"https://data-bs.ch/mobilitaet/2020_Velo_Fuss_Count.csv\" target=\"_blank\">https://data-bs.ch/mobilitaet/2020_Velo_Fuss_Count.csv</a>.</p><p>Die Z\u{e4}hlstellen sind auf MET eingestellt (Spalten TimeFrom und TimeTo), d.h. die Zeitumstellung wird wie in Mitteleuropa ausgef\u{fc}hrt. Bei der Umstellung von Winter- auf Sommerzeit fehlt die Stunde der Umstellung, dieser Tag hat dann 23 Stunden. Bei der Umstellung von Sommer- auf Winterzeit ist eine Stunde zu viel enthalten (der Tag hat 25 Stunden). In diesem Fall werden die Z\u{e4}hldaten der beiden Stunden zusammengez\u{e4}hlt. </p><p><br/></p>"]
pub mod verkehrszaehldaten_velos_und_fussgaenger {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ZST_NR
        ///
        /// Zählstellennummer
        pub zst_nr: Option<String>,
        /// SiteCode
        ///
        /// Zählstellencode
        pub sitecode: Option<String>,
        /// SiteName
        ///
        /// Zählstellenname
        pub sitename: Option<String>,
        /// DateTimeFrom
        ///
        /// Datum und Uhrzeit Messbeginn (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimefrom: Option<OffsetDateTime>,
        /// DateTimeTo
        ///
        /// Datum und Uhrzeit Messende (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimeto: Option<OffsetDateTime>,
        /// DirectionName
        ///
        /// Richtung/Strassenseite
        pub directionname: Option<String>,
        /// LaneCode
        ///
        /// Spurnummer
        pub lanecode: Option<i64>,
        /// LaneName
        ///
        /// Spurname
        pub lanename: Option<String>,
        /// ValuesApproved
        ///
        /// Daten validiert (1 ja, 0 nein) [Validierte Verkehrszahlen sind kontrollierte und ergänzte Rohdaten. Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesapproved: Option<i64>,
        /// ValuesEdited
        ///
        /// Ersatzwerte (1 ja, 0 nein) [Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesedited: Option<i64>,
        /// TrafficType
        ///
        /// Verkehrsmittel (MIV = motorisierter Individualverkehr)
        pub traffictype: Option<String>,
        /// Total
        ///
        /// Anzahl Fahrzeuge
        pub total: Option<i64>,
        /// Year
        ///
        /// Jahr
        pub year: Option<String>,
        /// Month
        ///
        /// Monat (1=Januar, 12=Dezember)
        pub month: Option<i64>,
        /// Day
        ///
        /// Tag
        pub day: Option<i64>,
        /// Weekday
        ///
        /// Wochentag (0=Montag, 6=Sonntag)
        pub weekday: Option<i64>,
        /// HourFrom
        ///
        /// Stunde des Messbeginns
        pub hourfrom: Option<i64>,
        /// Date
        ///
        /// Datum der Messung als Text
        pub date: Option<String>,
        /// TimeFrom
        ///
        /// Zeit Messbeginn als Text
        pub timefrom: Option<String>,
        /// TimeTo
        ///
        /// Zeit Messende als Text
        pub timeto: Option<String>,
        /// DayOfYear
        ///
        /// Nummer des Tages innerhalb des aktuellen Jahres
        pub dayofyear: Option<i64>,
        /// Zst_id
        pub zst_id: Option<i64>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ZstNr,
        Sitecode,
        Sitename,
        Datetimefrom,
        Datetimeto,
        Directionname,
        Lanecode,
        Lanename,
        Valuesapproved,
        Valuesedited,
        Traffictype,
        Total,
        Year,
        Month,
        Day,
        Weekday,
        Hourfrom,
        Date,
        Timefrom,
        Timeto,
        Dayofyear,
        ZstId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ZstNr => "zst_nr",
                Field::Sitecode => "sitecode",
                Field::Sitename => "sitename",
                Field::Datetimefrom => "datetimefrom",
                Field::Datetimeto => "datetimeto",
                Field::Directionname => "directionname",
                Field::Lanecode => "lanecode",
                Field::Lanename => "lanename",
                Field::Valuesapproved => "valuesapproved",
                Field::Valuesedited => "valuesedited",
                Field::Traffictype => "traffictype",
                Field::Total => "total",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Hourfrom => "hourfrom",
                Field::Date => "date",
                Field::Timefrom => "timefrom",
                Field::Timeto => "timeto",
                Field::Dayofyear => "dayofyear",
                Field::ZstId => "zst_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100013/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Bev\u{f6}lkerung nach Geschlecht, Heimat und Altersjahr ab 1945"]
#[doc = ""]
#[doc = "Der Datensatz zeigt die Bev\u{f6}lkerung des Kantons Basel-Stadt nach Heimat, 1-Jahres-Altersklassen am Ende des Jahres. Die Daten werden j\u{e4}hrlich aktualisiert. <br><br>Methodischer Hinweise: <br>- In der Kategorie CH sind auch die Kantonsb\u{fc}rger (Kategorie BS) enthalten. Addiert man die beiden Kategorien, so werden die Kantonsb\u{fc}rger doppelt gez\u{e4}hlt.<br>- In den Jahren von 1964 bis 1990 basiert die Bev\u{f6}lkerungszahlen auf Fortschreibungen von Volksz\u{e4}hlungen; <br>- In den Jahren von 1990 bis 2011 beruhten die j\u{e4}hrlichen Fortschreibungen auf dem Bestand des kantonalen Einwohnerregisters am 31.12.1990.<br>- Seit dem Jahr 2012 basiert die Bev\u{f6}lkerungszahlen direkt auf Auswertungen aus dem kantonalen Einwohnerregister.<br>- Im Jahr 1989 und 1990:  Ab dem 94. Altersjahr wurden die Daten  an den Bestand der Einwohnerkontrolle Basel-Stadt angeglichen.<br> - Im Jahr 2019: Infolge einer Systemumstellung ohne Grenzg\u{e4}nger mit Wochenaufenthalt."]
pub mod bevoelkerung_nach_geschlecht_heimat_und_altersjahr_ab_1945 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Bevölkerungsstands am Ende des Jahres
        pub jahr: Option<String>,
        /// Alter
        ///
        /// Personenalter
        pub pers_alter: Option<i64>,
        /// Geschlecht
        ///
        /// Geschlecht (w: weiblich, m: männlich)
        pub geschlecht: Option<String>,
        /// Heimat
        ///
        /// CH: Bevölkerung mit schweizer Staatsangehörigkeit (Achtung: Alle Personen der Kategorie BS sind auch in der Kategorie CH enthalten.), A: Bevölkerungs mit ausländischer Staatsangehörigkeit, BS: Kantonsbürger des Kantons Basel-Stadt
        pub herkunft: Option<String>,
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        PersAlter,
        Geschlecht,
        Herkunft,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::PersAlter => "pers_alter",
                Field::Geschlecht => "geschlecht",
                Field::Herkunft => "herkunft",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100238/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): Todesf\u{e4}lle Basel-Stadt nach Alter und Geschlecht"]
#[doc = ""]
#[doc = "<div>Todesf\u{e4}lle von Einwohnern des Kantons Basel-Stadt mit der Coronavirus-Krankheit (COVID-19) nach Alter und Geschlecht. Die Daten wurden zu Beginn der Pandemie von Hand aus \u{f6}ffentlich zug\u{e4}nglichen offiziellen Quellen durch Mitarbeiter der Fachstelle OGD Basel-Stadt erfasst. Inzwischen erhalten wir die Daten der Gestorbenen direkt von den Gesundheitsdiensten des Kantons. Die Quellenangabe der jeweiligen Zahlen ist direkt der Tabelle zu entnehmen.</div><div><br/></div><div>Die gesamtschweizerischen Daten aller Kantone und des F\u{fc}rstentums Liechtenstein (FL), welche die F\u{e4}lle nach Alter und Geschlecht ausweisen, sind hier zu finden:</div><div><ul><li><a href=\"https://github.com/openZH/covid_19/tree/master/fallzahlen_kanton_alter_geschlecht_csv\" target=\"_blank\">https://github.com/openZH/covid_19/tree/master/fallzahlen_kanton_alter_geschlecht_csv</a></li></ul></div><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">\u{c4}nderungsprotokoll:</span></p><ul><li>Die Erhebung der Werte wurde per 5. Juli 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.\u{a0}Aktualisierungsintervall von \"DAILY\" auf \"NEVER\" ge\u{e4}ndert.</li></ul>"]
pub mod coronavirus_covid_19_todesfaelle_basel_stadt_nach_alter_und_geschlecht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum der Datenveröffentlichung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Kanton
        pub area: Option<String>,
        /// Alter
        ///
        /// Alter in Jahren; [leer] = nicht veröffentlicht
        pub ageyear: Option<i64>,
        /// Alter numerisch
        ///
        /// Alter in Jahren, falls explizite eindeutige Altersangabe vorhanden
        pub ageyear_numeric: Option<i64>,
        /// Geschlecht
        ///
        /// M = männlich, F = weiblich; [leer] = nicht veröffentlicht
        pub gender: Option<String>,
        /// Anzahl Verstorbene
        ///
        /// Anzahl mit COVID-19-Erkrankung verstorbene Personen mit Wohnsitz in Basel-Stadt
        pub newdeaths: Option<i64>,
        /// Bestehende Vorerkrankung
        ///
        /// Y = bestehende Vorerkrankung, N = keine bestehende Vorerkrankung; [leer] = nicht veröffentlicht
        pub preexistingcond: Option<String>,
        /// Anzahl Verstorbene kumuliert
        ///
        /// Anzahl Verstorbene Personen bis zum aktuellen Datum
        pub ncumul_deceased: Option<i64>,
        /// ID pro Tag
        ///
        /// Eindeutige ID des Todesfalls pro Tag
        pub casenumberperday: Option<i64>,
        /// Quelle
        ///
        /// Datenquelle(n)
        pub source: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        Area,
        Ageyear,
        AgeyearNumeric,
        Gender,
        Newdeaths,
        Preexistingcond,
        NcumulDeceased,
        Casenumberperday,
        Source,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Area => "area",
                Field::Ageyear => "ageyear",
                Field::AgeyearNumeric => "ageyear_numeric",
                Field::Gender => "gender",
                Field::Newdeaths => "newdeaths",
                Field::Preexistingcond => "preexistingcond",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::Casenumberperday => "casenumberperday",
                Field::Source => "source",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100076/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Regierungsratswahl 20. Oktober 2024"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">F\u{fc}r die Wahl der sieben Mitglieder des Regierungsrates des Regierungsrat vom 20. Oktober 2024 kandidieren zw\u{f6}lf Personen.</p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">Dieser Datensatz zeigt die Kandidierenden des ersten Wahlgangs nach Geschlecht, Jahrgang und Beruf.</p>"]
pub mod kandidierende_der_regierungsratswahl_20_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100386/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Zeitreihe der Belegung der Elektroauto-Ladestationen der IWB"]
#[doc = ""]
#[doc = "<p>IWB baut im Kanton Basel-Stadt ein Netz leistungsf\u{e4}higer \u{f6}ffentlich zug\u{e4}nglicher Ladestationen auf, um der umweltfreundlichen und gerade f\u{fc}r Ballungsgebiete idealen Elektromobilit\u{e4}t entscheidende Impulse zu geben. </p>\n\n<p>In der Pilotphase wurden die Parkpl\u{e4}tze mit LoRa-angebunden Sensoren ausgestattet. Ziel war es festzustellen, ob Parkpl\u{e4}tze durch Fahrzeuge besetzt werden, ohne dass diese einen aktiven Ladevorgang vornehmen. Nach internen Abstimmungen wird die IWB die \u{dc}bermittlung der Daten ab ca. Mitte September 2022 nicht weiterf\u{fc}hren. Gr\u{fc}nde daf\u{fc}r sind Schwierigkeiten bei der \u{dc}bertragung der Werte sowie eine fehlende Relevanz f\u{fc}r die Praxis. Beim Roll-Out der weiteren \u{f6}ffentlichen Ladestationen auf Allmend werden voraussichtlich keine LoRa-Sensoren mehr verbaut.</p>\n\n<p>Echtzeitdaten zur Belegung der Elektroauto-Ladestationen der gesamten Schweiz basierend auf dem Status des Ladevorgangs sind hier zu finden:\u{a0}<a href=\"https://opendata.swiss/de/dataset/ladestationen\" target=\"_blank\">https://opendata.swiss/de/dataset/ladestationen</a></p>\n\n<p>Hier finden Sie die Zeitreihe der Belegung der Ladestationen, welche t\u{e4}glich aktualisiert wird basierend auf der Zeitreihe der Rohdaten. Es wird jede Status\u{e4}nderung (belegt/frei) angegeben.\u{a0}</p>\n\n\n<p>Die Zeitreihe der Rohdaten ist hier zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100149\" target=\"_blank\">https://data.bs.ch/explore/dataset/100149</a>. Achtung: Die Rohdaten-Zeitreihe enth\u{e4}lt Duplikate, weil jede Push-Meldung eines Sensors abgebildet wird.\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100196\" target=\"_blank\"></a></p><p></p><p\">Der Datensatz mit nur den aktuellsten Statusmeldungen ist hier zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100004\" target=\"_blank\">https://data.bs.ch/explore/dataset/100004</a><a href=\"https://data.bs.ch/explore/dataset/100004\" target=\"_blank\"></a></p\"><p\"><br/></p\"><p\"><br/></p\"><p\">\u{c4}nderungsprotokoll: </p\"><p\"><br/></p\"><p\">20.09.2022 - Aktualisierungsintervall von \"CONT\" auf \"NEVER\" ge\u{e4}ndert.<br/><p></p></p\">"]
pub mod zeitreihe_der_belegung_der_elektroauto_ladestationen_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Adresse
        ///
        /// Strasse und Hausnummer
        pub address: Option<String>,
        /// Ladeleistung
        pub power: Option<String>,
        /// Parkfeld
        ///
        /// Eine Station kann mehrere Parkfelder mit Lademöglichkeit haben
        pub parkingfield: Option<i64>,
        /// Total Parkfelder
        ///
        /// Anzahl Parkfelder der Ladestation
        pub totalparkings: Option<i64>,
        /// Status
        ///
        /// Available / Occupied (verfügbar / belegt)
        pub status: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Address,
        Power,
        Parkingfield,
        Totalparkings,
        Status,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Address => "address",
                Field::Power => "power",
                Field::Parkingfield => "parkingfield",
                Field::Totalparkings => "totalparkings",
                Field::Status => "status",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100196/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geb\u{e4}udeeing\u{e4}nge (Geb\u{e4}ude- und Wohnungsregister GWR)"]
#[doc = ""]
#[doc = "Geb\u{e4}udeeing\u{e4}nge bzw. Geb\u{e4}udeadressen gem\u{e4}ss Geb\u{e4}ude- und Wohnungsregister (GWR). <br><br>Ein Geb\u{e4}udeeingang ist ein Zugang von aussen in ein Geb\u{e4}ude, wobei der Eingang durch eine Geb\u{e4}udeadresse idenzifiziert ist. Die Geb\u{e4}udeadressierung dient der Identifikation und dem Auffinden eines Geb\u{e4}udes. Zudem erleichtert sie Planungsarbeiten und verbessert, insbesondere in Notfallsituationen, eine zielgerichtete Routenwahl. Die Geb\u{e4}udeadresse setzt sich aus einem Strassennamen, einer Hausnummer (auch Eingangs- oder Polizeinummer genannt) und einer Ortschaft mit zugeh\u{f6}riger vierstelliger Postleitzahl (PLZ) zusammen. Die Kombination Strassenname und Hausnummer muss pro Ortschaft eindeutig sein, jede Adresse in der Schweiz gibt es somit nur einmal.<br><br>Weitere Einzelheiten zur Geb\u{e4}udeadressierung sind hier nachzulesen: <a href=\"https://www.bfs.admin.ch/bfsstatic/dam/assets/5566189/master\" target=\"_blank\">https://www.bfs.admin.ch/bfsstatic/dam/assets/5566189/master (Empfehlung Geb\u{e4}udeadressierung und Schreibweise von Strassennamen)</a><br><br>Einen \u{dc}berblick \u{fc}ber die im Register gef\u{fc}hrten Merkmal gibt folgendes Dokument: <a href=\"https://www.housing-stat.ch/files/881-2200.pdf\" target=\"_blank\">https://www.housing-stat.ch/files/881-2200.pdf (Merkmalskatalog 4.2)</a> bzw. online unter <a href=\"https://www.housing-stat.ch/de/help/42.html\" target=\"_blank\">https://www.housing-stat.ch/de/help/42.html (Online-Merkmalskatalog 4.2)</a><br><br>Die rechtliche Grundlage stellt die entsprechende eidgen\u{f6}ssische Gesetzgebung dar: <a href=\"https://www.fedlex.admin.ch/eli/cc/2017/376/de\" target=\"_blank\">https://www.fedlex.admin.ch/eli/cc/2017/376/de (Verordnung \u{fc}ber das eidgen\u{f6}ssische Geb\u{e4}ude- und Wohnungsregister (VGWR))</a><br><br>"]
pub mod gebaeudeeingaenge_gebaeude_und_wohnungsregister_gwr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// EGID
        ///
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<i64>,
        /// EDID
        ///
        /// Eidgenössischer Eingangsidentifikator
        pub edid: Option<i64>,
        /// EGAID
        ///
        /// Eidgenössischer Gebäudeadressidentifikator
        pub egaid: Option<i64>,
        /// Eingangsnummer Gebäude
        pub deinr: Option<String>,
        /// ESID
        ///
        /// Eidgenössischer Strassenidentifikator
        pub esid: Option<i64>,
        /// Strassenbezeichnung
        pub strname: Option<String>,
        /// Strassenbezeichnung kurz
        pub strnamk: Option<String>,
        /// Strassenbezeichnung Index
        pub strindx: Option<String>,
        /// Strassenbezeichnung Sprache Code
        pub strsp: Option<i64>,
        /// Strassenbezeichnung Sprache Bezeichnung
        pub strsp_decoded: Option<String>,
        /// Strassenbezeichnung offiziell Code
        pub stroffiziel: Option<i64>,
        /// Strassenbezeichnung offiziell Bezeichnung
        pub stroffiziel_decoded: Option<String>,
        /// Postleitzahl
        pub dplz4: Option<i64>,
        /// Postleitzahl-Zusatzziffer
        pub dplzz: Option<i64>,
        /// Postleitzahl-Name
        pub dplzname: Option<String>,
        /// E-Eingangskoordinate
        pub dkode: Option<f64>,
        /// N-Eingangskoordinate
        pub dkodn: Option<f64>,
        pub eingang_koordinaten: Option<GeoPoint2d>,
        /// Offizielle Adresse Code
        pub doffadr: Option<i64>,
        /// Offizielle Adresse Bezeichnung
        pub doffadr_decoded: Option<String>,
        /// Exportdatum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub dexpdat: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Egid,
        Edid,
        Egaid,
        Deinr,
        Esid,
        Strname,
        Strnamk,
        Strindx,
        Strsp,
        StrspDecoded,
        Stroffiziel,
        StroffizielDecoded,
        Dplz4,
        Dplzz,
        Dplzname,
        Dkode,
        Dkodn,
        Doffadr,
        DoffadrDecoded,
        Dexpdat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Edid => "edid",
                Field::Egaid => "egaid",
                Field::Deinr => "deinr",
                Field::Esid => "esid",
                Field::Strname => "strname",
                Field::Strnamk => "strnamk",
                Field::Strindx => "strindx",
                Field::Strsp => "strsp",
                Field::StrspDecoded => "strsp_decoded",
                Field::Stroffiziel => "stroffiziel",
                Field::StroffizielDecoded => "stroffiziel_decoded",
                Field::Dplz4 => "dplz4",
                Field::Dplzz => "dplzz",
                Field::Dplzname => "dplzname",
                Field::Dkode => "dkode",
                Field::Dkodn => "dkodn",
                Field::Doffadr => "doffadr",
                Field::DoffadrDecoded => "doffadr_decoded",
                Field::Dexpdat => "dexpdat",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100231/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Postleitzahl seit 1979"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Wohnbev\u{f6}lkerung des Kantons Basel-Stadt am Jahresende auf Ebene der Postleitzahlen-Gebiete ab dem Jahr 1979. Diese Gebiete orientieren sich nicht an den statistischen Raumeinheiten (Wohnviertel, Bezirk, Block,\u{2026}), sondern wurden von der Schweizerischen Post vergeben."]
pub mod wohnbevoelkerung_nach_postleitzahl_seit_1979 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Postleitzahl
        ///
        /// Vierstellige Postleitzahl, eingeführt 1964 durch die Schweizerische Post. Die Postleitzahl definiert den Leitweg einer Sendung auf ihrer Reise zum Bestimmungsort. In grossen Städten dient sie zudem der Sortierung nach Zustellgruppen und Filialpoststellen.
        pub postleitzahl: Option<String>,
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Postleitzahl,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Postleitzahl => "postleitzahl",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100197/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Vornamen der baselst\u{e4}dtischen Bev\u{f6}lkerung"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Wohnbev\u{f6}lkerung des Kantons Basel-Stadt nach Vornamen. Die Daten werden j\u{e4}hrlich aktualisiert. Bei mehreren Vornamen wird nur der erste ber\u{fc}cksichtigt. Durch Bindestrich verbundene Vornamen z\u{e4}hlen als ein Vorname. Vornamen, die weniger als viermal vorkommen, werden in der Rubrik \'\u{dc}brige\' zusammengefasst. <br>Die hier ver\u{f6}ffentlichten Werte der Jahre 1979 bis 2011 weichen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik ab: In Letzterer wurde bis zum Jahr 2011 die Bev\u{f6}lkerungszahl durch Fortschreibung ermittelt. Seit dem Jahr 2012 basiert sie direkt auf Auswertungen aus dem kantonalen Einwohnerregister. Die hier ver\u{f6}ffentlichten Werte hingegen basieren seit 1979 auf Auswertungen aus dem Einwohnerregister."]
pub mod vornamen_der_baselstaedtischen_bevoelkerung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Anzahl
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Vorname,
        Geschlecht,
        Anzahl,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100129/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Effektiver und erwarteter t\u{e4}glicher Stromverbrauch"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet den t\u{e4}glichen Stromverbrauch sowie den mittels eines Modells berechneten, anhand des Kalendertages und der Witterung zu erwartenden Stromverbrauch.<br>Der Stromverbrauch ist die Summe der elektrischen Energie, die im Kanton Basel-Stadt t\u{e4}glich aus dem Netz bezogen wird, inklusive Netzverluste. Der t\u{e4}gliche Stromverbrauch ergibt sich als Summe des viertelst\u{fc}ndlich ausgewiesenen Stromverbrauchs im OGD-Datensatz \"Kantonaler Stromverbrauch\" (<a href=\"https://data.bs.ch/explore/dataset/100233/\">https://data.bs.ch/explore/dataset/100233/</a>).<br><br>Der Code des Modells kann selber ausgef\u{fc}hrt und weiterentwickelt werden. Hierf\u{fc}r wird Renku verwendet. Renku ist eine Plattform, die verschiedene Werkzeuge f\u{fc}r reproduzierbare und kollaborative Datenanalyseprojekte b\u{fc}ndelt:<a href=\"https://renkulab.io/projects/statabs/reproducible-research/erwarteter-stromverbrauch-basel-stadt\">https://renkulab.io/projects/statabs/reproducible-research/erwarteter-stromverbrauch-basel-stadt</a>"]
pub mod effektiver_und_erwarteter_taeglicher_stromverbrauch {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub time: Option<Date>,
        /// Stromverbrauch effektiv
        ///
        /// Tägliche Summe des viertelstündlichen Stromverbrauchs
        pub stromverbrauch: Option<f64>,
        /// Stromverbrauch erwartet
        ///
        /// Prognostizierter Wert, abhängig von Kalendertag (z.B. Ferien oder Wochentag) und Witterung
        pub forecast: Option<f64>,
        /// Differenz Stromverbrauch (effektiv-erwartet)
        ///
        /// Differenz Stromverbrauch effektiv abzüglich Stromverbrauch
        pub vgl_real_minus_forecast: Option<f64>,
        /// Prognoseintervall tief
        ///
        /// Untere Grenze des 95%-Prognoseintervalls für täglich erwarteten Stromverbrauch
        pub forecast_lowfi: Option<f64>,
        /// Prognoseintervall hoch
        ///
        /// Obere Grenze des 95%-Prognoseintervalls für täglich erwarteten Stromverbrauch
        pub forecast_highfi: Option<f64>,
        /// data split
        ///
        /// Für die Modellevaluierung wurde der Datensatz in drei Teile unterteilt. Der Trainingsdatensatz dient zum Trainieren (Train) des Modells, der Tesdatensatz (Test) zur Bewertung der Modellleistung. Der Prognosedatensatz (Prognose) enthält neue, unbekannte Daten zur Vorhersage durch das mit Training- und Testdatensatz (Train und Test) trainierte Modell.
        pub trainorforecast: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Time,
        Stromverbrauch,
        Forecast,
        VglRealMinusForecast,
        ForecastLowfi,
        ForecastHighfi,
        Trainorforecast,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Time => "time",
                Field::Stromverbrauch => "stromverbrauch",
                Field::Forecast => "forecast",
                Field::VglRealMinusForecast => "vgl_real_minus_forecast",
                Field::ForecastLowfi => "forecast_lowfi",
                Field::ForecastHighfi => "forecast_highfi",
                Field::Trainorforecast => "trainorforecast",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100245/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gemeinden"]
#[doc = ""]
#[doc = "Zum Kanton Basel-Stadt z\u{e4}hlen die Stadt Basel und die Gemeinden Riehen und Bettingen."]
pub mod gemeinden {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ENTSTEHUNG
        pub entstehung: Option<String>,
        /// ORTSCHAFT_
        pub ortschaft: Option<String>,
        /// STATUS
        pub status: Option<i64>,
        /// STATUS_TXT
        pub status_txt: Option<String>,
        /// INAENDERUN
        pub inaenderun: Option<i64>,
        /// INAENDERU1
        pub inaenderu1: Option<String>,
        /// R1_OBJID
        pub r1_objid: Option<String>,
        /// R1_NBIDENT
        pub r1_nbident: Option<String>,
        /// R1_IDENTIF
        pub r1_identif: Option<String>,
        /// R1_BESCHRE
        pub r1_beschre: Option<String>,
        /// R1_GUELTIG
        pub r1_gueltig: Option<i64>,
        /// R1_GUELTI1
        pub r1_guelti1: Option<String>,
        /// R1_GUELTI2
        #[serde(with = "time::serde::iso8601::option")]
        pub r1_guelti2: Option<OffsetDateTime>,
        /// Name
        pub name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Entstehung,
        Ortschaft,
        Status,
        StatusTxt,
        Inaenderun,
        Inaenderu1,
        R1Objid,
        R1Nbident,
        R1Identif,
        R1Beschre,
        R1Gueltig,
        R1Guelti1,
        R1Guelti2,
        Name,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Entstehung => "entstehung",
                Field::Ortschaft => "ortschaft",
                Field::Status => "status",
                Field::StatusTxt => "status_txt",
                Field::Inaenderun => "inaenderun",
                Field::Inaenderu1 => "inaenderu1",
                Field::R1Objid => "r1_objid",
                Field::R1Nbident => "r1_nbident",
                Field::R1Identif => "r1_identif",
                Field::R1Beschre => "r1_beschre",
                Field::R1Gueltig => "r1_gueltig",
                Field::R1Guelti1 => "r1_guelti1",
                Field::R1Guelti2 => "r1_guelti2",
                Field::Name => "name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100017/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Postleitzahlenkreise"]
#[doc = ""]
#[doc = "Die Einteilung des Kantons in adressgenaue Postleitzahlenkreise ist eine Erweiterung der Amtlichen Vermessung des Kantons Basel-Stadt, welche in Zusammenarbeit mit der Post unterhalten wird. Sie wird f\u{fc}r die automatische Zuweisung der PLZ zu einer Adresse im kantonalen Datenmark verwendet und an das Bundesamt f\u{fc}r Landestopografie (swisstopo) weitergeleitet."]
pub mod postleitzahlenkreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ENTSTEHUNG
        pub entstehung: Option<String>,
        /// PLZ6_VON
        pub plz6_von: Option<String>,
        /// STATUS
        pub status: Option<i64>,
        /// STATUS_TXT
        pub status_txt: Option<String>,
        /// INAENDERUN
        pub inaenderun: Option<i64>,
        /// INAENDERU1
        pub inaenderu1: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ZUSATZZIFF
        pub zusatzziff: Option<i64>,
        /// R1_OBJID
        pub r1_objid: Option<String>,
        /// R1_NBIDENT
        pub r1_nbident: Option<String>,
        /// R1_IDENTIF
        pub r1_identif: Option<String>,
        /// R1_BESCHRE
        pub r1_beschre: Option<String>,
        /// R1_GUELTIG
        pub r1_gueltig: Option<i64>,
        /// R1_GUELTI1
        pub r1_guelti1: Option<String>,
        /// R1_GUELTI2
        #[serde(with = "time::serde::iso8601::option")]
        pub r1_guelti2: Option<OffsetDateTime>,
        /// R2_OBJID
        pub r2_objid: Option<String>,
        /// R2_ENTSTEH
        pub r2_entsteh: Option<String>,
        /// R2_ORTSCHA
        pub r2_ortscha: Option<String>,
        /// R2_STATUS_
        pub r2_status: Option<String>,
        /// R2_INAENDE
        pub r2_inaende: Option<i64>,
        /// R2_INAEND1
        pub r2_inaend1: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Entstehung,
        Plz6Von,
        Status,
        StatusTxt,
        Inaenderun,
        Inaenderu1,
        Plz,
        Zusatzziff,
        R1Objid,
        R1Nbident,
        R1Identif,
        R1Beschre,
        R1Gueltig,
        R1Guelti1,
        R1Guelti2,
        R2Objid,
        R2Entsteh,
        R2Ortscha,
        R2Status,
        R2Inaende,
        R2Inaend1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Entstehung => "entstehung",
                Field::Plz6Von => "plz6_von",
                Field::Status => "status",
                Field::StatusTxt => "status_txt",
                Field::Inaenderun => "inaenderun",
                Field::Inaenderu1 => "inaenderu1",
                Field::Plz => "plz",
                Field::Zusatzziff => "zusatzziff",
                Field::R1Objid => "r1_objid",
                Field::R1Nbident => "r1_nbident",
                Field::R1Identif => "r1_identif",
                Field::R1Beschre => "r1_beschre",
                Field::R1Gueltig => "r1_gueltig",
                Field::R1Guelti1 => "r1_guelti1",
                Field::R1Guelti2 => "r1_guelti2",
                Field::R2Objid => "r2_objid",
                Field::R2Entsteh => "r2_entsteh",
                Field::R2Ortscha => "r2_ortscha",
                Field::R2Status => "r2_status",
                Field::R2Inaende => "r2_inaende",
                Field::R2Inaend1 => "r2_inaend1",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100016/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Invasive Neophyten"]
#[doc = ""]
#[doc = "Die im Kanton Basel-Stadt am h\u{e4}ufigsten vorkommenden invasiven Neophyten (nicht heimische, problematische Pflanzenarten) wurden kartiert und die Fundorte je nach Pflanzenart als Fl\u{e4}chen oder Punkte aufgenommen. Die Kartierung wurde bisher in den Jahren 2006, 2009 und 2013 durchgef\u{fc}hrt."]
pub mod invasive_neophyten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Objekt-ID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// KART_ID
        pub kart_id: Option<String>,
        /// Fläche
        ///
        /// Fläche in m²
        pub flaeche: Option<f64>,
        /// Art
        ///
        /// Name der Art in deutsch und latein (in Klammern)
        pub art: Option<String>,
        /// Deckung
        ///
        /// Deckungsgrad in % gemäss den folgenden Klassen: <1, 1-5, 5-15, 15-25, 25-50, 50-75, 75-100.
        pub deckung: Option<String>,
        /// Abundanz
        ///
        /// Individuenzahl gemäss den folgenden Klassen: 1-10, 11-100, 101-1000, >1000.
        pub abundanz: Option<String>,
        /// Jahr
        ///
        /// Kartierungsjahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        KartId,
        Flaeche,
        Art,
        Deckung,
        Abundanz,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::KartId => "kart_id",
                Field::Flaeche => "flaeche",
                Field::Art => "art",
                Field::Deckung => "deckung",
                Field::Abundanz => "abundanz",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100043/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Handelsregister: Firmen mit Rechtsform und Standort"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz umfasst die Firmen des Kantons Basel-Stadt, die im Handelsregister des Zefix (Zentraler Firmenindex) registriert sind. Das Zefix bildet das \u{f6}ffentlich zug\u{e4}ngliche Angebot des Eidgen\u{f6}ssischen Amtes f\u{fc}r das Handelsregister (EHRA). Es stellt die Daten des Zentralregisters \u{fc}ber verschiedene Zug\u{e4}nge wie die Zefix Webapplikation (<a href=\"https://www.zefix.admin.ch/\" target=\"_blank\">https://www.zefix.admin.ch/</a>), die Zefix REST API (<a href=\"https://www.zefix.admin.ch/ZefixPublicREST)\" target=\"_blank\">https://www.zefix.admin.ch/ZefixPublicREST)</a>, die Zefix Mobile App (<a href=\"https://www.zefixapp.ch\" target=\"_blank\">https://www.zefixapp.ch</a>/) und als Linked Data in LINDAS (<a href=\"https://lindas.admin.ch/\" target=\"_blank\">https://lindas.admin.ch/</a>, was hier verwendet wurde) \u{fc}ber das Internet zur Verf\u{fc}gung. \u{dc}ber Zefix k\u{f6}nnen die Daten s\u{e4}mtlicher im Handelsregister eingetragener Rechtseinheiten sowie die t\u{e4}glichen Handelsregisterpublikationen im SHAB (Schweizerischen Handelsamtsblatt, <a href=\"https://www.shab.ch/\" target=\"_blank\">https://www.shab.ch/</a>)\u{a0}abgerufen werden. Der hier angebotene Datensatz beinhaltet tagesaktuelle Kerndaten der aktiven, im Handelsregister eingetragenen Rechtseinheiten, wie Firma/Name, Sitz und Domiziladresse.</p><p>LINDAS (Linked Data Service) fungiert in diesem Kontext als Plattform f\u{fc}r die Vernetzung und den Zugriff auf diverse Datenquellen in der Schweiz, einschliesslich der Daten aus dem Zefix. Zur Gewinnung spezifischer Informationen \u{fc}ber die im Kanton Basel-Stadt registrierten Unternehmen wird eine SPARQL-Abfrage verwendet. SPARQL, eine Abfragesprache f\u{fc}r Daten im RDF-Format, erm\u{f6}glicht den Zugriff auf detaillierte Datens\u{e4}tze \u{fc}ber die Firmen aus dem LINDAS-Netzwerk. Die SPARQL-Abfrage kann unter einem bereitgestellten Link (<a href=\"https://s.zazuko.com/2WjT8iZ\" target=\"_blank\">https://s.zazuko.com/2WjT8iZ</a>) aufgerufen werden. Die Abfrage wurde mithilfe der vorhandenen SPARQL-Abfrage von opendata.swiss (<a href=\"https://opendata.swiss/de/dataset/zefix-zentraler-firmenindex\" target=\"_blank\">https://opendata.swiss/de/dataset/zefix-zentraler-firmenindex</a>) zum Zefix erweitert:\u{a0}<a href=\"https://github.com/opendatabs/data-processing/blob/master/zefix_handelsregister/etl.py\" target=\"_blank\">https://github.com/opendatabs/data-processing/blob/master/zefix_handelsregister/etl.py</a></p><p>Diese Zefix-Daten und die der anderen Kantone werden von der Fachstelle OGD t\u{e4}glich aktualisiert und k\u{f6}nnen unter folgendem HTTPS-Link heruntergeladen werden: <br><i>https://data-bs.ch/stata/zefix_handelsregister/all_cantons/companies_[Kantonsk\u{fc}rzel].csv<br></i>Im Beispiel von Basel-Landschaft lautet der Link:<br><a href=\"https://data-bs.ch/stata/zefix_handelsregister/all_cantons/companies_BL.csv\" target=\"_blank\">https://data-bs.ch/stata/zefix_handelsregister/all_cantons/companies_BL.csv\u{a0}</a><br></p><p>Der Datensatz enth\u{e4}lt neben den Grundinformationen der Firmen auch erweiterte Spalten wie die Koordinaten der Unternehmen, die mithilfe der Betriebsadresse und von Nominatim (<a href=\"https://nominatim.org/\" target=\"_blank\">https://nominatim.org/</a>) berechnet wurden.\u{a0}Nominatim ist ein Open-Source-Tool zur Geokodierung, das heisst, es wandelt Standortdaten wie Adressen oder Ortsnamen in geografische Koordinaten (L\u{e4}ngen- und Breitengrade) um und umgekehrt.</p>"]
pub mod handelsregister_firmen_mit_rechtsform_und_standort {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Rechtsform
        ///
        /// Rechtsform der Firma
        pub company_type_de: Option<String>,
        /// Firmenname
        ///
        /// Rechtlicher Name der Firma wie im Handelsregister hinterlegt
        pub company_legal_name: Option<String>,
        /// Firma UID
        ///
        /// Unternehmens-Identifikationsnummer
        pub company_uid: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinde, in der die Firma im Handelsregister eingetragen ist. Offizieller Sitz der Firma gemäss Handelsregister.
        pub municipality: Option<String>,
        /// Adresse
        pub street: Option<String>,
        /// Zusatz
        ///
        /// Zusatz zur Adresse
        pub zusatz: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Betriebsgemeinde
        ///
        /// Physische Adresse der Firma. Es kann sich von der im Handelsregister eingetragenen Gemeinde unterscheiden.
        pub locality: Option<String>,
        /// Adresse
        ///
        /// Adresse mit der, mithilfe von einem Georeferenzierungstool, nach den Koordinaten gesucht wurde.
        pub address: Option<String>,
        /// Koordinaten
        pub coordinates: Option<GeoPoint2d>,
        /// URL Kantonaler Auszug
        ///
        /// URL zum Eintrag der Firma im kantonalen Register
        pub url_cantonal_register: Option<String>,
        /// Rechtsform URI
        ///
        /// URI (Uniform Resource Identifier) in ld.admin.ch der Rechtsform
        pub type_id: Option<String>,
        /// Firma URI
        ///
        /// URI (Uniform Resource Identifier) in ld.admin.ch/zefix des Unternehmens
        pub company_uri: Option<String>,
        /// Gemeinde URI
        ///
        /// URI (Uniform Resource Identifier) in ld.admin.ch der Gemeinde
        pub muni_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        CompanyTypeDe,
        CompanyLegalName,
        CompanyUid,
        Municipality,
        Street,
        Zusatz,
        Plz,
        Locality,
        Address,
        UrlCantonalRegister,
        TypeId,
        CompanyUri,
        MuniId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::CompanyTypeDe => "company_type_de",
                Field::CompanyLegalName => "company_legal_name",
                Field::CompanyUid => "company_uid",
                Field::Municipality => "municipality",
                Field::Street => "street",
                Field::Zusatz => "zusatz",
                Field::Plz => "plz",
                Field::Locality => "locality",
                Field::Address => "address",
                Field::UrlCantonalRegister => "url_cantonal_register",
                Field::TypeId => "type_id",
                Field::CompanyUri => "company_uri",
                Field::MuniId => "muni_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100330/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Velo-Einbahnstrassen und -Gefahrenstellen"]
#[doc = ""]
#[doc = "Der Velostadtplan zeigt dir passende Routen zu deinem Ziel und liefert Ideen, wohin du mit deinem Velo besonders gut fahren kannst. Er ist die elektronische Version der faltbaren Papierkarte, die im Buchhandel, bei Basel Tourismus, Pro Velo und Veloplus erh\u{e4}ltlich ist."]
pub mod velo_einbahnstrassen_und_gefahrenstellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// RECNUM
        pub recnum: Option<i64>,
        /// ART
        pub art: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Recnum,
        Art,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Recnum => "recnum",
                Field::Art => "art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100036/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Recyclingstationen"]
#[doc = ""]
#[doc = "Recyclingstationen f\u{fc}r Glas, Weissblech, Aluminium und Batterien im Kanton Basel-Stadt."]
pub mod recyclingstationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_RS
        pub id_rs: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// STATUS
        pub status: Option<i64>,
        /// ADRESSE
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<i64>,
        /// ORT
        pub ort: Option<String>,
        /// WEBSEITE
        pub webseite: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdRs,
        Name,
        Status,
        Adresse,
        Plz,
        Ort,
        Webseite,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdRs => "id_rs",
                Field::Name => "name",
                Field::Status => "status",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Webseite => "webseite",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100027/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sauberkeitsindex pro Quartal und Wohnviertel"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt den Sauberkeitsindex f\u{fc}r alle Wohnviertel in der Stadt Basel. Zur Berechnung des Sauberkeitsindex wird wie folgt vorgegangen:</p><p>Auf den Kehrrichtfahrzeugen sind Kameras installiert, die w\u{e4}hrend der Eins\u{e4}tze Videoaufnahmen der Strassen machen. Ein Computer durchsucht anschliessend diese Videoaufnahmen nach Abf\u{e4}llen. Dieser sortiert die Abf\u{e4}lle in verschiedene Abfallkategorien (Zigarettenstummel, Papier, PET-Flaschen etc.) und z\u{e4}hlt die Anzahl der gefundenen Abf\u{e4}lle jeder Kategorie. Zus\u{e4}tzlich wird f\u{fc}r jede Abfallkategorie der Verschmutzungsgrad und der St\u{f6}rfaktor bestimmt. Daraus wird der Sauberkeitsindex berechnet. Danach werden die Videoaufnahmen aus Datenschutzgr\u{fc}nden umgehend gel\u{f6}scht.</p><p>Der Sauberkeitsindex wird auf einer Skala von 0 bis 5 angegeben, wobei die Werte folgendermassen beurteilt werden:<br>Kleiner als 3: schlecht<br>Zwischen 3 und 4: mittel<br>Gr\u{f6}sser als 4: gut<br>Der Grosse Rat beauftragt das Tiefbauamt mit dem Erreichen eines Indexes f\u{fc}r die gesamte Stadt von mindestens 4.5.</p><p>Der Datensatz wird quartalsweise mit den Daten des Vorquartals aktualisiert.</p>"]
pub mod sauberkeitsindex_pro_quartal_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// SKI
        pub ski: Option<f64>,
        /// Quartal
        pub quartal: Option<String>,
        /// Jahr
        pub jahr: Option<String>,
        /// Quartalsnummer
        pub quartalsnummer: Option<String>,
        /// Beginn Quartal
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub quartal_beginn: Option<Date>,
        /// Ende Quartal
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub quartal_ende: Option<Date>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wohnviertel,
        Ski,
        Quartal,
        Jahr,
        Quartalsnummer,
        QuartalBeginn,
        QuartalEnde,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wohnviertel => "wohnviertel",
                Field::Ski => "ski",
                Field::Quartal => "quartal",
                Field::Jahr => "jahr",
                Field::Quartalsnummer => "quartalsnummer",
                Field::QuartalBeginn => "quartal_beginn",
                Field::QuartalEnde => "quartal_ende",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100362/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsreiche Strassen (50 km/h oder mehr)"]
#[doc = ""]
#[doc = "Der Velostadtplan zeigt dir passende Routen zu deinem Ziel und liefert Ideen, wohin du mit deinem Velo besonders gut fahren kannst. Er ist die elektronische Version der faltbaren Papierkarte, die im Buchhandel, bei Basel Tourismus, Pro Velo und Veloplus erh\u{e4}ltlich ist."]
pub mod verkehrsreiche_strassen_50_km_h_oder_mehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ATTRIBUTE1
        pub attribute1: Option<i64>,
        /// VELOPLAN_T
        pub veloplan_t: Option<String>,
        /// STR_NAME
        pub str_name: Option<String>,
        /// GEMEINDE
        pub gemeinde: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Attribute1,
        VeloplanT,
        StrName,
        Gemeinde,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Attribute1 => "attribute1",
                Field::VeloplanT => "veloplan_t",
                Field::StrName => "str_name",
                Field::Gemeinde => "gemeinde",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100034/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Steile Velo-Strecken"]
#[doc = ""]
#[doc = "Der Velostadtplan zeigt dir passende Routen zu deinem Ziel und liefert Ideen, wohin du mit deinem Velo besonders gut fahren kannst. Er ist die elektronische Version der faltbaren Papierkarte, die im Buchhandel, bei Basel Tourismus, Pro Velo und Veloplus erh\u{e4}ltlich ist."]
pub mod steile_velo_strecken {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID Steigung
        ///
        /// Identifikator Steigung
        pub id_steig: Option<i64>,
        /// Steigung
        ///
        /// Kategorisierung der Steigungsstärke von 1 bis 3
        pub steigung: Option<i64>,
        /// Winkel
        ///
        /// Winkel der Steigungsgeometrie (Darstellungswinkel des Symbols auf map.geo.bs.ch)
        pub winkel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdSteig,
        Steigung,
        Winkel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdSteig => "id_steig",
                Field::Steigung => "steigung",
                Field::Winkel => "winkel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100037/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Empfohlene Schwimmbereiche im Rhein"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die empfohlenen Schwimmbereiche im Rhein.</p>"]
pub mod empfohlene_schwimmbereiche_im_rhein {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {}

    impl Field {
        fn name(self) -> &'static str {
            match self {}
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100270/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Quartiertreffpunkte"]
#[doc = ""]
#[doc = "Quartiertreffpunkte sind wichtige Begegnungsorte f\u{fc}r junge Familien ebenso wie f\u{fc}r \u{e4}ltere Menschen, f\u{fc}r Alteingesessene wie auch Neuank\u{f6}mmlinge. Sie bieten ein breitgef\u{e4}chertes Angebot wie Beratung und Unterst\u{fc}tzung im Alltag, offene Treffpunkte, Mittagstische und weitere kulinarische Angebote, Spielabende, Filmvorf\u{fc}hrungen,kulturelle Veranstaltungen und vieles mehr."]
pub mod quartiertreffpunkte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// QT_ID
        pub qt_id: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// STRASSE_NR
        pub strasse_nr: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ORT
        pub ort: Option<String>,
        /// KANTON
        pub kanton: Option<String>,
        /// TELEFON
        pub telefon: Option<String>,
        /// LINK
        pub link: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        QtId,
        Name,
        StrasseNr,
        Plz,
        Ort,
        Kanton,
        Telefon,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::QtId => "qt_id",
                Field::Name => "name",
                Field::StrasseNr => "strasse_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Telefon => "telefon",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100026/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Baustellen in Gew\u{e4}ssern\u{e4}he"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt Informationen zu Baustellen in Gew\u{e4}ssern\u{e4}he, \u{fc}ber welche die Bev\u{f6}lkerung z.B. via BachApp informiert werden soll.\u{a0}</p>"]
pub mod baustellen_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// IDUnique
        pub idunique: Option<String>,
        /// Sichtbar_von
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Status
        pub status: Option<String>,
        /// Datum_von
        ///
        /// Datum Beginn der Baustelle
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_von: Option<Date>,
        /// Datum_bis
        ///
        /// Wenn bekannt, geplantes Ende der Baustelle. Sonst bis 31.12.2099
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_bis: Option<Date>,
        /// Titel
        ///
        /// Ort der Baustelle
        pub titel: Option<String>,
        /// Untertitel
        ///
        /// Beschreibung der Baustelle
        pub untertitel: Option<String>,
        /// Text
        ///
        /// Grund der Baustelle
        pub text: Option<String>,
        /// Image
        ///
        /// Bild
        pub image: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idunique,
        SichtbarVon,
        SichtbarBis,
        Status,
        DatumVon,
        DatumBis,
        Titel,
        Untertitel,
        Text,
        Image,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idunique => "idunique",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Status => "status",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Text => "text",
                Field::Image => "image",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100287/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Basler Index der Konsumentenpreise"]
#[doc = ""]
#[doc = "Entwicklung des Basler Index der Konsumentenpreise BIK (Basis Dezember 2020 = 100) nach Hauptgruppe seit 1939."]
pub mod basler_index_der_konsumentenpreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Erhebungsdatum
        ///
        /// Erhebungsmonat und -jahr
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Erhebungsjahr
        ///
        /// Jahr des Erhebungsdatums
        pub year: Option<String>,
        /// Erhebungsmonat
        ///
        /// Monat des Erhebungsdatums
        pub month: Option<i64>,
        /// PosNo
        ///
        /// Positionsnummer; der Identifikator des BFS für die Warenposition
        pub bfsid: Option<i64>,
        /// Warenkorb-Hierarchie
        ///
        /// Aneinanderreihung der Felder Hauptgruppe bis Ebene8
        pub warenkorb_hierarchie: Option<String>,
        /// Warenkorbposition
        ///
        /// Bezeichnung der Warenkorbposition
        pub name: Option<String>,
        /// Total
        ///
        /// Erste und oberste Ebene der hierarchischen Struktur des Warenkorbs
        pub name1: Option<String>,
        /// Hauptgruppe
        ///
        /// 2. Ebene der hierarchischen Struktur des Warenkorbs
        pub name2: Option<String>,
        /// Warengruppe
        ///
        /// 3. Ebene der hierarchischen Struktur des Warenkorbs
        pub name3: Option<String>,
        /// Ebene 4
        ///
        /// 4. Ebene der hierarchischen Struktur des Warenkorbs
        pub name4: Option<String>,
        /// Ebene 5
        ///
        /// 5. Ebene der hierarchischen Struktur des Warenkorbs
        pub name5: Option<String>,
        /// Ebene 6
        ///
        /// 6. Ebene der hierarchischen Struktur des Warenkorbs
        pub name6: Option<String>,
        /// Ebene 7
        ///
        /// 7. Ebene der hierarchischen Struktur des Warenkorbs
        pub name7: Option<String>,
        /// Ebene 8
        ///
        /// 8. Ebene der hierarchischen Struktur des Warenkorbs
        pub name8: Option<String>,
        /// Historisches Gewicht
        ///
        /// Das zum Erhebungsdatum gültige Gewicht der Warenkorbposition
        pub weight: Option<f64>,
        /// Historische Tiefe der Warenkorb-Hierarchie
        ///
        /// Die zum Erhebungsdatum gültige hierarchische Tiefe der Warenkorbposition in der Warenkorb-Hierarchie
        pub depth: Option<i64>,
        /// Sortierreihenfolge
        ///
        /// Die Sortier-Reihenfolge gemäss BFS in der aktuellen Erhebung
        pub currentsortorder: Option<i64>,
        /// Position
        ///
        /// Bezeichnung der Warenkorbposition in der aktuellen Erhebung
        pub currentname: Option<String>,
        /// Gewicht aktuell
        ///
        /// Gewicht in der aktuellen Erhebung
        pub currentweight: Option<f64>,
        /// Tiefencode
        ///
        /// Tiefe der Warenkorb-Hierarchie
        pub currentdepth: Option<i64>,
        /// Indexbasis Publikationsdatum
        ///
        /// Das Datum der Revision, die zum Zeitpunkt der Erhebung dieses Indexeintrags gültig war
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub revisiondate: Option<Date>,
        /// Indexbasis aktuell
        ///
        /// Das Datum der Revision, in der dieser Eintrag skaliert ist
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub viewrevisiondate: Option<Date>,
        /// Indexwert
        ///
        /// Basler Index aktuell, gerundet auf 4 Nachkommastellen
        ///Indexwert x(p) für die Warenposition p in der Erhebung t.
        pub currentvalue: Option<f64>,
        /// Indexwert Vormonat
        ///
        /// Basler Index Vormonat, gerundet auf 4 Nachkommastellen
        ///Indexwert x(p, t-1) im Vormonat für eine Warenposition p in der Erhebung t.
        pub lastmonthvalue: Option<f64>,
        /// Indexwert Vorjahr
        ///
        /// Basler Index Vorjahr, gerundet auf 4 Nachkommastellen
        ///Indexwert x(p, t-12) des gleichen Monats im Vorjahr für eine Warenposition p in der Erhebung t.
        pub lastyearvalue: Option<f64>,
        /// Monatsteuerung
        ///
        /// Monatsteuerung (in %), gerundet auf 4 Nachkommastellen
        pub monthpriceincrease: Option<f64>,
        /// Jahresteuerung
        ///
        /// Jahresteuerung (in %), gerundet auf 4 Nachkommastellen
        pub yearpriceincrease: Option<f64>,
        /// relWeight
        pub relweight: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        Year,
        Month,
        Bfsid,
        WarenkorbHierarchie,
        Name,
        Name1,
        Name2,
        Name3,
        Name4,
        Name5,
        Name6,
        Name7,
        Name8,
        Weight,
        Depth,
        Currentsortorder,
        Currentname,
        Currentweight,
        Currentdepth,
        Revisiondate,
        Viewrevisiondate,
        Currentvalue,
        Lastmonthvalue,
        Lastyearvalue,
        Monthpriceincrease,
        Yearpriceincrease,
        Relweight,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Year => "year",
                Field::Month => "month",
                Field::Bfsid => "bfsid",
                Field::WarenkorbHierarchie => "warenkorb_hierarchie",
                Field::Name => "name",
                Field::Name1 => "name1",
                Field::Name2 => "name2",
                Field::Name3 => "name3",
                Field::Name4 => "name4",
                Field::Name5 => "name5",
                Field::Name6 => "name6",
                Field::Name7 => "name7",
                Field::Name8 => "name8",
                Field::Weight => "weight",
                Field::Depth => "depth",
                Field::Currentsortorder => "currentsortorder",
                Field::Currentname => "currentname",
                Field::Currentweight => "currentweight",
                Field::Currentdepth => "currentdepth",
                Field::Revisiondate => "revisiondate",
                Field::Viewrevisiondate => "viewrevisiondate",
                Field::Currentvalue => "currentvalue",
                Field::Lastmonthvalue => "lastmonthvalue",
                Field::Lastyearvalue => "lastyearvalue",
                Field::Monthpriceincrease => "monthpriceincrease",
                Field::Yearpriceincrease => "yearpriceincrease",
                Field::Relweight => "relweight",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100003/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Defibrillatoren"]
#[doc = ""]
#[doc = "S\u{e4}mtliche Standorte \u{f6}ffentlich zug\u{e4}nglicher Defibrillatoren in Basel-Stadt sind im Geoportal und in der First Responder App einsehbar. Die entsprechenden Standorte sind mit einem gr\u{fc}nen Herz-Symbol signalisiert. Finden Sie den n\u{e4}chsten Defibrillator in Ihrer N\u{e4}he."]
pub mod defibrillatoren {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_DF
        pub id_df: Option<i64>,
        /// STANDORT
        pub standort: Option<String>,
        /// STRASSE
        pub strasse: Option<String>,
        /// HAUSNUMMER
        pub hausnummer: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ORT
        pub ort: Option<String>,
        /// KANTON
        pub kanton: Option<String>,
        /// VERFUEGBAR
        pub verfuegbar: Option<String>,
        /// BEMERKUNG
        pub bemerkung: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdDf,
        Standort,
        Strasse,
        Hausnummer,
        Plz,
        Ort,
        Kanton,
        Verfuegbar,
        Bemerkung,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdDf => "id_df",
                Field::Standort => "standort",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Verfuegbar => "verfuegbar",
                Field::Bemerkung => "bemerkung",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100019/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Politische Wahlkreise"]
#[doc = ""]
#[doc = "Enth\u{e4}lt die politischen Wahlkreise des Kantons Basel-Stadt."]
pub mod politische_wahlkreise {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_WAHLKRE
        pub objid: Option<i64>,
        /// KUERZEL
        pub text: Option<String>,
        /// WAHLKREIS
        pub wahlkreis: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Text,
        Wahlkreis,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Text => "text",
                Field::Wahlkreis => "wahlkreis",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100025/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Politische Vorst\u{f6}sse"]
#[doc = ""]
#[doc = "<p style=\"margin-top:0cm;margin-right:0cm;margin-bottom:7.5pt;margin-left:0cm\"><font face=\"Arial, sans-serif\"><span style=\"font-size: 13.3333px;\">Dieser Datensatz erm\u{f6}glicht einen thematischen \u{dc}berblick \u{fc}ber die politischen Vorst\u{f6}sse des Grossen Rats des Kantons Basel-Stadt. Es sind darin alle Gesch\u{e4}fte ab Januar 2019 enthalten, welche \u{fc}berwiesen und manuell mit Thema kategorisiert worden sind. Die Zuteilung zu Themen erfolgt durch die Kantons- und Stadtentwicklung. Weitere Informationen finden Sie unter <a href=\"https://politmonitor.bs.ch\" target=\"_blank\">politmonitor.bs.ch</a>.</span></font><br/></p>"]
pub mod grosser_rat_politische_vorstoesse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Signatur
        ///
        /// Laufnummer eines Vorstosses
        pub signatur: Option<String>,
        /// Geschäftstyp
        ///
        /// Art des Vorstosses
        pub geschaftstyp: Option<String>,
        /// Partei
        ///
        /// Partei, welcher der Urheber oder die Urheberin eines politischen Vorstosses aktuell angehört.
        pub partei: Option<String>,
        /// Urheber/in
        ///
        /// Urheberin oder Urheber des politischen Vorstosses
        pub urheber: Option<String>,
        /// Titel
        ///
        /// Titel des Vorstosses
        pub titel: Option<String>,
        /// Beginn-Datum
        ///
        /// Datum, an welchem ein Vorstoss an den Regierungsrat überwiesen wurde.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub beginn_datum: Option<Date>,
        /// Ende
        ///
        /// Datum, an welchem ein Geschäft den Status abgeschlossen erhält.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub ende: Option<Date>,
        /// Thema 1
        ///
        /// Unterthema des Themenbereichs 1
        pub thema_1: Option<String>,
        /// Thema 2
        ///
        /// Unterthema des Themenbereichs 2
        pub thema_2: Option<String>,
        /// Schwerpunkt
        ///
        /// Thematischer Schwerpunkt aus Sicht der Kantons- und Stadtentwicklung
        pub schwerpunkt: Option<String>,
        /// Geschäft
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub geschaft: Option<String>,
        /// Status
        ///
        /// A = Abgeschlossen; B = in Bearbeitung
        pub status: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Signatur,
        Geschaftstyp,
        Partei,
        Urheber,
        Titel,
        BeginnDatum,
        Ende,
        Thema1,
        Thema2,
        Schwerpunkt,
        Geschaft,
        Status,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Signatur => "signatur",
                Field::Geschaftstyp => "geschaftstyp",
                Field::Partei => "partei",
                Field::Urheber => "urheber",
                Field::Titel => "titel",
                Field::BeginnDatum => "beginn_datum",
                Field::Ende => "ende",
                Field::Thema1 => "thema_1",
                Field::Thema2 => "thema_2",
                Field::Schwerpunkt => "schwerpunkt",
                Field::Geschaft => "geschaft",
                Field::Status => "status",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100086/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Touristische Velorouten"]
#[doc = ""]
#[doc = "Die touristischen Velorouten zeigen in Basel-Stadt und in der n\u{e4}heren Umgebung die signalisierten Velorouten von EuroVelo und SchweizMobil sowie die signalisierten regionalen Velorouten wie der S\u{fc}dschwarzwald-Radweg und der Dreiland-Radweg."]
pub mod touristische_velorouten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// OBJECTID
        pub objectid: Option<i64>,
        /// INFORMATIO
        pub informatio: Option<String>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// ROUTENBEZ
        pub routenbez: Option<String>,
        /// RBESCHREIB
        pub rbeschreib: Option<String>,
        /// RICHTUNG
        pub richtung: Option<String>,
        /// SHAPE_LENG
        pub shape_leng: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Objectid,
        Informatio,
        Kategorie,
        Routenbez,
        Rbeschreib,
        Richtung,
        ShapeLeng,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Objectid => "objectid",
                Field::Informatio => "informatio",
                Field::Kategorie => "kategorie",
                Field::Routenbez => "routenbez",
                Field::Rbeschreib => "rbeschreib",
                Field::Richtung => "richtung",
                Field::ShapeLeng => "shape_leng",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100033/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Alltagsvelorouten"]
#[doc = ""]
#[doc = "Die Alltagsvelorouten zeigen in Basel-Stadt und in der n\u{e4}heren Umgebung die rot signalisierten Velorouten ohne Nummern. Sie leiten den Alltagsvelofahrenden zu den wichtigsten Zielen in der Stadt."]
pub mod alltagsvelorouten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// OBJECTID
        pub objectid: Option<i64>,
        /// INFORMATIO
        pub informatio: Option<String>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// ROUTENBEZ
        pub routenbez: Option<String>,
        /// RBESCHREIB
        pub rbeschreib: Option<String>,
        /// RICHTUNG
        pub richtung: Option<String>,
        /// SHAPE_LENG
        pub shape_leng: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Objectid,
        Informatio,
        Kategorie,
        Routenbez,
        Rbeschreib,
        Richtung,
        ShapeLeng,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Objectid => "objectid",
                Field::Informatio => "informatio",
                Field::Kategorie => "kategorie",
                Field::Routenbez => "routenbez",
                Field::Rbeschreib => "rbeschreib",
                Field::Richtung => "richtung",
                Field::ShapeLeng => "shape_leng",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100032/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Bio-Klappen"]
#[doc = ""]
#[doc = "Bio-Klappen f\u{fc}r organische K\u{fc}chenabf\u{e4}lle im Kanton Basel-Stadt."]
pub mod bio_klappen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_BK
        pub id_bk: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// PLZ
        pub plz: Option<i64>,
        /// ORT
        pub ort: Option<String>,
        /// WEBSEITE
        pub webseite: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdBk,
        Name,
        Plz,
        Ort,
        Webseite,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdBk => "id_bk",
                Field::Name => "name",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Webseite => "webseite",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100028/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Statistische Raumeinheiten: Bl\u{f6}cke"]
#[doc = ""]
#[doc = "Ein Block wird in der Regel von allen Seiten durch Strassen begrenzt. In einzelnen F\u{e4}llen wird die Abgrenzung durch Zonenplankategorien vorgegeben (Bahnareale, Wald, Gr\u{fc}nzone, Landwirtschaftszone etc.).\n\nStatistische Nummerierung:\nDie Nummerierung der Bl\u{f6}cke setzt sich zusammen aus der zweistelligen Wohnviertel-Nr., der einstelligen Bezirks-Nr. und der dreistelligen Block-Nr (im Label jeweils durch Punkte getrennt):\n- Bl\u{f6}cke haben keine Namensbezeichnung und werden lediglich \u{fc}ber die Nummer referenziert.\n- Beispiel Block rund um die Clarakirche: BLO_ID 121014, die Bezeichnung (BLO_Label) lautet 12.1.014"]
pub mod statistische_raumeinheiten_bloecke {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BLO_ID
        pub blo_id: Option<String>,
        /// BLO_LABEL
        pub blo_label: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// BEZ_ID
        pub bez_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        BloId,
        BloLabel,
        WovId,
        BezId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BloId => "blo_id",
                Field::BloLabel => "blo_label",
                Field::WovId => "wov_id",
                Field::BezId => "bez_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100040/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung 27. September 2020 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 27. September 2020 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_27_september_2020_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100071/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kantonaler Stromverbrauch"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz beinhaltet die Summe der elektrischen Energie, die im Kanton Basel-Stadt innert 15-Minuten Intervallen aus dem Netz bezogen wird, inklusive <a href=\"https://de.wikipedia.org/wiki/\u{dc}bertragungsverlust\" target=\"_blank\">Netzverluste</a>. </p><p>Lokal direkt am Ort der Produktion verbrauchte elektrische Energie (z.B. aus Photovoltaikanlagen), welche nicht ins \u{f6}ffentliche Netz eingespiesen wird, ist in den vorliegenden Daten nicht enthalten. Seit 1. September 2020 liegen auch Daten zum Verbrauch der Kunden in der Grundversorgung vs. dem freien Markt vor. </p><p>Die Daten umfassen den an allen im Netz installierten fernausgelesenen Z\u{e4}hlern gemessenen Verbrauch sowie erg\u{e4}nzend, da nicht 100 % der Z\u{e4}hler fernauslesbar sind, Daten aus den ins Netz eingespeisten Strommengen.\u{a0}</p><p>Hinweis: Die Werte der folgenden Messstartzeiten sind interpoliert: 01.01.2014 00:00, 01.11.2015 00:00 und 01.10.2019 00:00.</p><p>\u{c4}nderungsprotokoll: <br/>10.10.23: Aktualisierungsintervall von \"WEEKLY\" auf \"DAILY\" ge\u{e4}ndert.<br/></p>"]
pub mod kantonaler_stromverbrauch {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start der Messung
        ///
        /// Startzeitpunkt der Messperiode
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp_interval_start: Option<OffsetDateTime>,
        /// Start der Messung (Text)
        pub timestamp_interval_start_text: Option<String>,
        /// Stromverbrauch
        ///
        /// Stromverbrauch innerhalb des Viertelstundenintervalls
        pub stromverbrauch_kwh: Option<f64>,
        /// Grundversorgte Kunden
        ///
        /// Stromverbrauch durch Kunden in der Grundversorgung
        pub grundversorgte_kunden_kwh: Option<f64>,
        /// Freie Kunden
        ///
        /// Stromverbrauch durch Kunden, welche Strom im freien Markt beziehen
        pub freie_kunden_kwh: Option<f64>,
        /// Jahr
        ///
        /// Jahr als Text
        pub year: Option<String>,
        /// Monat
        ///
        /// Monat (1 = Januar, etc.)
        pub month: Option<i64>,
        /// Tag
        pub day: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag als Zahl (0 = Montag, 1 = Dienstag, etc.)
        pub weekday: Option<i64>,
        /// Tag des Jahres
        ///
        /// Tag innerhalb des Jahres (1. Januar = 1, etc.)
        pub dayofyear: Option<i64>,
        /// Quartal
        ///
        /// Quartal des Jahres (1, 2, 3, 4)
        pub quarter: Option<i64>,
        /// Woche des Jahres
        ///
        /// Woche (1, 2, 3, etc.)
        pub weekofyear: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TimestampIntervalStart,
        TimestampIntervalStartText,
        StromverbrauchKwh,
        GrundversorgteKundenKwh,
        FreieKundenKwh,
        Year,
        Month,
        Day,
        Weekday,
        Dayofyear,
        Quarter,
        Weekofyear,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TimestampIntervalStart => "timestamp_interval_start",
                Field::TimestampIntervalStartText => "timestamp_interval_start_text",
                Field::StromverbrauchKwh => "stromverbrauch_kwh",
                Field::GrundversorgteKundenKwh => "grundversorgte_kunden_kwh",
                Field::FreieKundenKwh => "freie_kunden_kwh",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Dayofyear => "dayofyear",
                Field::Quarter => "quarter",
                Field::Weekofyear => "weekofyear",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100233/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "BachApp: Infos - Allgemein"]
#[doc = ""]
#[doc = "Der Datensatz enth\u{e4}lt allgemeine Infotexte und Links, welche in der BachApp publiziert werden.\u{a0}"]
pub mod bachapp_infos_allgemein {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Titel
        ///
        /// Informationstext
        pub titel: Option<String>,
        /// Untertitel
        ///
        /// Informationstext
        pub untertitel: Option<String>,
        /// Text
        ///
        /// Ausführlicher Informationstext
        pub text: Option<String>,
        /// Image_Top
        pub image_top: Option<String>,
        /// Fischli_Anrede
        pub fischli_anrede: Option<String>,
        /// Fischli_Kurztext
        pub fischli_kurztext: Option<String>,
        /// Fischli_Onboarding
        pub fischli_onboarding: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Titel,
        Untertitel,
        Text,
        ImageTop,
        FischliAnrede,
        FischliKurztext,
        FischliOnboarding,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Text => "text",
                Field::ImageTop => "image_top",
                Field::FischliAnrede => "fischli_anrede",
                Field::FischliKurztext => "fischli_kurztext",
                Field::FischliOnboarding => "fischli_onboarding",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100246/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Schulwegsicherheit: Strassenquerungen"]
#[doc = ""]
#[doc = "Die Daten zur Schulwegsicherheit zeigen auf, wo Strassen\u{fc}berg\u{e4}nge f\u{fc}r Kinder im Kindergarten- und Schulalter \u{fc}bersichtlich und einfach sind, bzw. wo erh\u{f6}hte Anforderungen an das \u{dc}berqueren der Strasse gestellt werden. Der Datensatz enth\u{e4}lt die Daten zu den Strassen\u{fc}berg\u{e4}ngen (Querungen), also alle Verbindungen der Fusswegachsen. Es werden nicht nur die geeigneten Querungen erfasst, sondern alle. Erfasst wird immer die am schlechtesten bewertete Richtung, da jede Querung von zwei Seiten begehbar ist. Die Digitalisierungsrichtung entspricht demnach der schlechter bewerteten Richtung. Start und Ende m\u{fc}ssen auf einer Fusswegachse liegen. Jede Strassenquerung wird systematisch von einem Schulwegsinstruktor bewertet. Die Daten wurden in Basel, Bettingen und Riehen erhoben."]
pub mod schulwegsicherheit_strassenquerungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// ID
        ///
        /// Laufnummer
        pub id: Option<i64>,
        /// Strassenkategorie
        ///
        /// Schulwegrelevante Strassenkategorie
        pub strkat: Option<String>,
        /// Bewertung
        ///
        /// Bewertung der Strassenquerung bezgl. Sicherheit
        pub bewertung: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
        /// Tram
        ///
        /// Tramverkehr vorhanden
        pub tram: Option<String>,
        /// Konfliktgrün
        ///
        /// Konfliktgrün besteht dann, wenn eine Strasse und die Fussgänger über die Querstrasse (also parallel zur Grünrichtung) gleichzeitig grün haben.
        pub konfliktgr: Option<String>,
        /// Lichtsignalanlage
        ///
        /// Verkehrsregelungsanlage VRA ("Ampel") vorhanden
        pub vra: Option<String>,
        /// Vortritt-Typ
        ///
        /// Art / Grund des Fussgänger-Vortritts
        pub vortrtyp: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Id,
        Strkat,
        Bewertung,
        Bemerkung,
        Tram,
        Konfliktgr,
        Vra,
        Vortrtyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Id => "id",
                Field::Strkat => "strkat",
                Field::Bewertung => "bewertung",
                Field::Bemerkung => "bemerkung",
                Field::Tram => "tram",
                Field::Konfliktgr => "konfliktgr",
                Field::Vra => "vra",
                Field::Vortrtyp => "vortrtyp",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100053/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Schulwegsicherheit: Fusswege"]
#[doc = ""]
#[doc = "Die Daten zur Schulwegsicherheit zeigen auf, wo Strassen\u{fc}berg\u{e4}nge f\u{fc}r Kinder im Kindergarten- und Schulalter \u{fc}bersichtlich und einfach sind, bzw. wo erh\u{f6}hte Anforderungen an das \u{dc}berqueren der Strasse gestellt werden. Der Datensatz enth\u{e4}lt die Achsen der Fusswege, das heisst Trottoirs und wo n\u{f6}tig Strassen. Es werden alle f\u{fc}r Fussg\u{e4}nger begehbaren Wege, Strassen oder Parkwege innerhalb und an der Peripherie von Wohngebieten aufgenommen, sofern sie relevant f\u{fc}r Schulwege sind. In Parkanlagen wurden ausgew\u{e4}hlte Wege erfasst. Oberste Priorit\u{e4}t hat eine topologisch korrekte Aufnahme dieser Achsen. Die Daten wurden in Basel, Bettingen und Riehen erhoben."]
pub mod schulwegsicherheit_fusswege {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// ID
        ///
        /// Laufnummer
        pub id: Option<i64>,
        /// Fusswegtyp
        ///
        /// Schulwegrelevante Strassenkategorie. Begriffserklärung:
        ///ÖV-Station: Verkehrsinsel für ÖV-Haltestelle; Platz: meist ohne eindeutige Achsführung; Trottoirallee: mind. 2 Grünrabatten mit unterschiedlichen Troittoirspuren
        pub typ: Option<String>,
        /// Strassenkategorie
        ///
        /// Schulwegrelevante Strassenkategorie
        pub strkat: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Id,
        Typ,
        Strkat,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Id => "id",
                Field::Typ => "typ",
                Field::Strkat => "strkat",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100056/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Statistische Raumeinheiten: Blockseiten"]
#[doc = ""]
#[doc = "Die Blockseite ist die dem angrenzenden Strassenraum zugeordnete Seite eines Blocks.\n\nStatistische Nummerierung:\nDie Nummerierung der Blockseiten setzt sich zusammen aus der zweistelligen Wohnviertel-Nr., der einstelligen Bezirks-Nr. und der dreistelligen Block-Nr\n(im Label jeweils durch Punkte getrennt), gefolgt von der vierstelligen Block-Nr\n(sowohl im Label als auch in der ID durch einen Unterstrich verbunden):\n- Blockseiten haben wie die Bl\u{f6}cke keine Namensbezeichnung und werden lediglich \u{fc}ber die Nummer referenziert.\n- Beispiel Blockseite mit der Clarakirche: BLS_ID 121014_1741, die Bezeichnung (BLS_Label) lautet 12.1.014_1741"]
pub mod statistische_raumeinheiten_blockseiten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BLS_ID
        pub bls_id: Option<String>,
        /// BLS_LABEL
        pub bls_label: Option<String>,
        /// BLS_NAME
        pub bls_name: Option<String>,
        /// STR_CODE
        pub str_code: Option<i64>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// BEZ_ID
        pub bez_id: Option<String>,
        /// BLO_ID
        pub blo_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        BlsId,
        BlsLabel,
        BlsName,
        StrCode,
        WovId,
        BezId,
        BloId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BlsId => "bls_id",
                Field::BlsLabel => "bls_label",
                Field::BlsName => "bls_name",
                Field::StrCode => "str_code",
                Field::WovId => "wov_id",
                Field::BezId => "bez_id",
                Field::BloId => "blo_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100041/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rhein\u{fc}berwachungsstation: Umweltanalyse Schwebstoffe"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\"><span style=\"font-size: 11pt; line-height: 16.8667px; font-family: Calibri, sans-serif;\">Der Datensatz enth\u{e4}lt die Analysedaten aus der binationalen Rhein\u{fc}berwachungsstation (R\u{dc}S) in Weil am Rhein (Rhein-Kilometer 171,37) seit Bestehen der Station im Jahr 1993 aus der Matrix Schwebstoffe. </span></p><p class=\"MsoNormal\"><span style=\"font-family: Calibri, sans-serif; font-size: 11pt;\">Der Rhein wird aktuell auf 670 Schadstoffe untersucht, 420 davon t\u{e4}glich. Der Unterhalt der Anlage und die Analytik werden durch das Amt f\u{fc}r Umwelt und Energie des Kantons Basel-Stadt (AUE) geleistet. Auftraggeber sind die Landesanstalt f\u{fc}r Umwelt, Messungen und Naturschutz Baden-W\u{fc}rttemberg (LUBW) und das schweizerische Bundesamt f\u{fc}r Umwelt (BAFU).</span><br/></p><p class=\"MsoNormal\"><span style=\"line-height: 16.8667px;\"><font face=\"Calibri, sans-serif\"><span style=\"font-size: 14.6667px;\">Weitere Informationen: <a href=\"http://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html\" target=\"_blank\">http://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html</a></span></font></span></p>"]
pub mod rheinueberwachungsstation_umweltanalyse_schwebstoffe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in WPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in WPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme. Dauer codiert nach Konvention der Internationalen Kommission zum Schutz des Rheins (IKSR) 1M =24h; 14M=336h; 28M=672; 1M14 24h Mischprobe alle 14Tage; Sammelprobe=Dauer variabel abhängig von Schwebstoffanteil. MS steht für Mischung Stahl, MK für Mischung Kunststoff. E steht für Einzelmessung, M für Mischprobenentnahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probeentnahme.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100068/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Grossratswahlen nach Alter, Geschlecht und Liste seit 2020"]
#[doc = ""]
#[doc = "<p style=\"\">Dieser Datensatz zeigt die Kandidierenden der Grossratswahlen nach Altersgruppe, amtlichen Geschlecht und Liste seit 2020<br></p>"]
pub mod kandidierende_der_grossratswahlen_nach_alter_geschlecht_und_liste_seit_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Altersgruppe
        ///
        /// Altersgruppe Ende Wahljahr (berechnet als Wahljahr - Jahrgang)
        pub altersgruppe: Option<String>,
        /// Listenkurzbezeichnung
        ///
        /// Abkürzung der Liste
        pub listenkurzbezeichnung: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kandidierende
        pub anzahl: Option<i64>,
        /// Anteil
        ///
        /// Anteil im Wahljahr in %
        pub anteil: Option<f64>,
        /// Anteil in Altersgruppe
        ///
        /// Anteil im Wahljahr und in Altersgruppe in %
        pub anteil_altersgruppe: Option<f64>,
        /// Anteil in Liste
        ///
        /// Anteil im Wahljahr und in Liste in %
        pub anteil_liste: Option<f64>,
        /// Listen nach Frauenanteil
        pub frauenanteil_liste: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Altersgruppe,
        Listenkurzbezeichnung,
        Geschlecht,
        Anzahl,
        Anteil,
        AnteilAltersgruppe,
        AnteilListe,
        FrauenanteilListe,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Altersgruppe => "altersgruppe",
                Field::Listenkurzbezeichnung => "listenkurzbezeichnung",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
                Field::Anteil => "anteil",
                Field::AnteilAltersgruppe => "anteil_altersgruppe",
                Field::AnteilListe => "anteil_liste",
                Field::FrauenanteilListe => "frauenanteil_liste",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100392/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Grossratswahlen nach Geschlecht seit 1968"]
#[doc = ""]
#[doc = "<p style=\"\">Dieser Datensatz zeigt die Kandidierenden der Grossratswahlen nach amtlichen Geschlecht seit 1968</p>"]
pub mod kandidierende_der_grossratswahlen_nach_geschlecht_seit_1968 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Total
        ///
        /// Total Kandidierende
        pub total: Option<f64>,
        /// Frauen
        ///
        /// Anzahl weibliche Kandidierende
        pub frauen: Option<f64>,
        /// Männer
        ///
        /// Anzahl männliche Kandidierende
        pub manner: Option<f64>,
        /// Frauenanteil Kandidierende
        ///
        /// Anzahl Kandidatinnen / Total Kandidierende
        pub frauenanteil_kand: Option<f64>,
        /// Frauenanteil Gewählte
        ///
        /// Anzahl weibliche Gewählte / Anzahl Sitze im Grossen Rat (aktuell 100)
        pub frauenanteil_gew: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Total,
        Frauen,
        Manner,
        FrauenanteilKand,
        FrauenanteilGew,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Total => "total",
                Field::Frauen => "frauen",
                Field::Manner => "manner",
                Field::FrauenanteilKand => "frauenanteil_kand",
                Field::FrauenanteilGew => "frauenanteil_gew",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100391/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Teilhaltestellen des \u{f6}ffentlichen Verkehrs"]
#[doc = ""]
#[doc = "Der Datensatz zeigt die Teilhaltestellen (Haltebereich des Busses oder des Trams je Fahrtrichtung) des \u{f6}ffentlichen Verkehrs im Kanton Basel-Stadt sowie teilweise in der trinationalen Agglomeration. Es wird nach Liniennummer, Transportunternehmen, Art und Typ der Haltestelle unterschieden. "]
pub mod teilhaltestellen_des_oeffentlichen_verkehrs {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_Teilhaltestelle
        ///
        /// Eindeutiger Identifikator der Teilhaltestellen
        pub thst_nr: Option<String>,
        /// Haltestellen-Nr
        ///
        /// Nummer der Haltestelle nach BAV
        pub hst_nr: Option<String>,
        /// Haltestellen_Name
        ///
        /// Name der Haltestelle
        pub haltestl: Option<String>,
        /// Gebiet
        ///
        /// Gebiet. Wertebereich: Aargau (AG), Basel-Landschaft (BL), Basel-Stadt (BS), Deutschland (D), Frankreich (F), Jura (JU), Solothurn (SO).
        pub kt: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Haltestellenart
        ///
        /// Art der Haltestelle
        pub art: Option<String>,
        /// Haltestellentyp
        ///
        /// Typ der Haltestelle
        pub typ: Option<String>,
        /// Tramlinien
        ///
        /// Tramlinien, welche eine Teilhaltestelle bedienen
        pub tramlinien: Option<String>,
        /// Buslinien
        ///
        /// Buslinien, welche eine Teilhaltestelle bedienen
        pub buslinien: Option<String>,
        /// Fahrplan
        ///
        /// Link zum Fahrplan
        pub fahrplan: Option<String>,
        /// Nachtlinien
        ///
        /// Nachtlinien, welche eine Teilhaltestelle bedienen
        pub nachtlin: Option<String>,
        /// Tramzugang
        ///
        /// Zugangsmöglichkeit für Elektrorollstühle bei Tramhaltestellen; ja = hohe Kante (27 cm)
        pub tramzugang: Option<String>,
        /// Buszugang
        ///
        /// Zugangsmöglichkeit für Elektrorollstühle bei Bushaltestellen; ja = hohe Kante (22 cm)
        pub buszugang: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ThstNr,
        HstNr,
        Haltestl,
        Kt,
        Richtung,
        Art,
        Typ,
        Tramlinien,
        Buslinien,
        Fahrplan,
        Nachtlin,
        Tramzugang,
        Buszugang,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ThstNr => "thst_nr",
                Field::HstNr => "hst_nr",
                Field::Haltestl => "haltestl",
                Field::Kt => "kt",
                Field::Richtung => "richtung",
                Field::Art => "art",
                Field::Typ => "typ",
                Field::Tramlinien => "tramlinien",
                Field::Buslinien => "buslinien",
                Field::Fahrplan => "fahrplan",
                Field::Nachtlin => "nachtlin",
                Field::Tramzugang => "tramzugang",
                Field::Buszugang => "buszugang",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100065/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Liniennetz des \u{f6}ffentlichen Verkehrs"]
#[doc = ""]
#[doc = "Der Datensatz zeigt das Liniennetz des \u{f6}ffentlichen Verkehrs im Kanton Basel-Stadt sowie teilweise in der trinationalen Agglomeration. Es wird nach Liniennummer, Transportunternehmen und Zeitdauer das Angebots unterschieden. "]
pub mod liniennetz_des_oeffentlichen_verkehrs {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_Linie
        ///
        /// Eindeutiger Identifikator der Linien
        pub l_nr: Option<String>,
        /// Liniennummer
        pub liniennmr: Option<String>,
        /// Strecke
        pub strecke: Option<String>,
        /// Hin_Rueckweg
        ///
        /// Hin- und Rückweg
        pub hinrueck: Option<String>,
        /// Fahrzeug
        ///
        /// Transportmittel
        pub fahrzeug: Option<String>,
        /// Angebot
        ///
        /// Zeitraum, in welchem das Angebot besteht
        pub angebot: Option<String>,
        /// Transportunternehmen
        ///
        /// Name des Transportunternehmens
        pub tu: Option<String>,
        /// Shape_Length
        ///
        /// Liniengeometrie
        pub shp_length: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        LNr,
        Liniennmr,
        Strecke,
        Hinrueck,
        Fahrzeug,
        Angebot,
        Tu,
        ShpLength,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::LNr => "l_nr",
                Field::Liniennmr => "liniennmr",
                Field::Strecke => "strecke",
                Field::Hinrueck => "hinrueck",
                Field::Fahrzeug => "fahrzeug",
                Field::Angebot => "angebot",
                Field::Tu => "tu",
                Field::ShpLength => "shp_length",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100064/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Haltestellen des \u{f6}ffentlichen Verkehrs"]
#[doc = ""]
#[doc = "Der Datensatz zeigt die Haltestellen des \u{f6}ffentlichen Verkehrs im Kanton Basel-Stadt sowie teilweise in der trinationalen Agglomeration. Es wird nach Transportunternehmen, Art und Typ der Haltestelle unterschieden. "]
pub mod haltestellen_des_oeffentlichen_verkehrs {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Haltestellennummer
        ///
        /// Eindeutiger Identifikator der Haltestellen nach BAV
        pub hst_nr: Option<String>,
        /// Haltestellenname
        ///
        /// Haltestellenname nach BAV
        pub name: Option<String>,
        /// Angezeigter_Name
        ///
        /// Angezeigter Name der Haltestelle
        pub angezname: Option<String>,
        /// Transportunternehmen_Nummer
        ///
        /// Nummer des Transportunternehmens nach BAV
        pub tu_nr: Option<String>,
        /// Transportunternehmen_Name
        ///
        /// Name des Transportunternehmens
        pub tu: Option<String>,
        /// Gemeindenummer
        ///
        /// Gemeindenummer nach BFS
        pub gde_nr: Option<i64>,
        /// Gemeinde_Name
        ///
        /// Gemeinde
        pub gde: Option<String>,
        /// Gebiet
        ///
        /// Gebiet. Wertebereich: Aargau (AG), Basel-Landschaft (BL), Basel-Stadt (BS), Deutschland (D), Frankreich (F), Jura (JU), Solothurn (SO).
        pub kt: Option<String>,
        /// Höhe
        ///
        /// Höhe in m ü. M. (Angabe nach BAV)
        pub hoehe: Option<i64>,
        /// Haltestellenart
        ///
        /// Art der Haltestelle
        pub hstart: Option<String>,
        /// Haltestellentyp
        ///
        /// Typ der Haltestelle
        pub art: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        HstNr,
        Name,
        Angezname,
        TuNr,
        Tu,
        GdeNr,
        Gde,
        Kt,
        Hoehe,
        Hstart,
        Art,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::HstNr => "hst_nr",
                Field::Name => "name",
                Field::Angezname => "angezname",
                Field::TuNr => "tu_nr",
                Field::Tu => "tu",
                Field::GdeNr => "gde_nr",
                Field::Gde => "gde",
                Field::Kt => "kt",
                Field::Hoehe => "hoehe",
                Field::Hstart => "hstart",
                Field::Art => "art",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100063/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Eheschliessungen nach Trauungsdatum"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt alle Eheschliessungen in Basel-Stadt nach Trauungsdatum. Ber\u{fc}cksichtigt werden alle Eheschliessungen, bei welchen der Ehemann zum Zeitpunkt der Trauung in Basel-Stadt wohnhaft war. <br><br>Die hier ver\u{f6}ffentlichten Werte k\u{f6}nnen aus methodischen Gr\u{fc}nden von denjenigen in der \u{f6}ffentlichen Statistik abweichen: In Letzterer werden nachtr\u{e4}glich gemeldete Eheschliessungen im letzten noch nicht abgeschlossenen Jahr gez\u{e4}hlt. In diesem Datensatz werden sie nachtr\u{e4}glich im Jahr des Trauungsdatums gez\u{e4}hlt."]
pub mod eheschliessungen_nach_trauungsdatum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Trauungsdatum
        ///
        /// Datum der Trauung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub trauungsdat: Option<Date>,
        /// Jahr
        ///
        /// Jahr der Trauung
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat der Trauung
        pub monat: Option<i64>,
        /// Woche
        ///
        /// Woche im Jahr in welcher die Trauung stattfand
        pub woche_in_jahr: Option<i64>,
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche in welcher die Trauung stattfand
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_wochenstart_trauungsdatum: Option<Date>,
        /// Tag im Jahr
        ///
        /// Tag im Jahr an welchem die Trauung stattfand
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag an welchem die Trauung stattfand
        pub wochentag: Option<String>,
        /// Alter der Frau
        ///
        /// Alter der Frau bei der Trauung
        pub persalter_frau_vollendet: Option<i64>,
        /// Alter des Mannes
        ///
        /// Alter des Mannes bei der Trauung
        pub persalter_mann_vollendet: Option<i64>,
        /// Namenswahl der Frau
        pub namenswahl_frau: Option<String>,
        /// Namenswahl des Mannes
        pub namenswahl_mann: Option<String>,
        /// Staatsangehörigkeit der Frau
        pub nationalitat_frau: Option<String>,
        /// Staatsangehörigkeit des Mannes
        pub nationalitat_mann: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Trauungen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Trauungsdat,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartTrauungsdatum,
        TagInJahr,
        Wochentag,
        PersalterFrauVollendet,
        PersalterMannVollendet,
        NamenswahlFrau,
        NamenswahlMann,
        NationalitatFrau,
        NationalitatMann,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Trauungsdat => "trauungsdat",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartTrauungsdatum => "datum_wochenstart_trauungsdatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::PersalterFrauVollendet => "persalter_frau_vollendet",
                Field::PersalterMannVollendet => "persalter_mann_vollendet",
                Field::NamenswahlFrau => "namenswahl_frau",
                Field::NamenswahlMann => "namenswahl_mann",
                Field::NationalitatFrau => "nationalitat_frau",
                Field::NationalitatMann => "nationalitat_mann",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100156/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Umweltanalyse Grundwasser"]
#[doc = ""]
#[doc = "<p style=\'font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif; font-size: 12.495px;\'>Der Datensatz enth\u{e4}lt die Analysedaten der Grundwasser-Beprobungs-Kampagnen des Kantons Basel-Stadt seit dem Jahr 1993.\u{a0} Es werden Konzentrationsangaben zu verschiedenen Inhalts- resp. Schadstoffen mit Bezug auf den Brunnennamen sowie der geographischen Koordinaten gemacht.</p><p style=\'font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif; font-size: 12.495px;\'><span style=\"font-size: 12.495px;\">Weitere Informationen: <a href=\"https://www.aue.bs.ch/umweltanalytik/umweltdaten-gewaesser-feststoffe.html\" target=\"_blank\">https://www.aue.bs.ch/umweltanalytik/umweltdaten-gewaesser-feststoffe.html</a></span><br></p>"]
pub mod umweltanalyse_grundwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Geo Point
        ///
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probenahme.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100067/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Vornamen der Neugeborenen nach Geschlecht"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Vornamen der Neugeborenen im Kanton Basel-Stadt seit 2006. Als im Kanton Basel-Stadt Neugeborene gelten Kinder, welche ihren Wohnsitz ab Geburt im Kanton Basel-Stadt haben. Die Daten werden j\u{e4}hrlich aktualisiert."]
pub mod vornamen_der_neugeborenen_nach_geschlecht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Geburtsjahr, in dem das Kind den Vornamen erhalten hat
        pub jahr: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht des Kindes (m oder w)
        pub geschlecht: Option<String>,
        /// Vorname
        ///
        /// Erster Vorname des Kindes
        pub vorname: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kinder, die diesen spezifischen Vornamen in einem bestimmten Jahr tragen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Geschlecht,
        Vorname,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Geschlecht => "geschlecht",
                Field::Vorname => "vorname",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100192/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gasverbrauch im Versorgungsgebiet der IWB"]
#[doc = ""]
#[doc = "<p style=\"\">Dieser Datensatz beinhaltet die Summe des Gasverbrauchs, die innert Stunden-Intervallen aus dem Netz bezogen wird.\u{a0}Neben dem Kanton Basel-Stadt versorgt IWB auch weitere 29 Gemeinden in den Kantonen Basel-Landschaft, Solothurn und Aargau mit Gas. Diese sind auch im Datensatz enthalten.</p><p style=\"\">Die Gemeinden, die im Versorgungsgebiet enthalten sind, sind:<br>Aesch BL, Allschwil, Arlesheim, Augst, Basel, Bettingen, Binningen, Birsfelden, Bottmingen, Dornach, Eiken, Ettingen, Frenkendorf, Frick, F\u{fc}llinsdorf, Gipf-Oberfrick, Lausen, Liestal, M\u{f6}hlin, M\u{fc}nchenstein, Muttenz, Oberwil, Oeschgen, Pfeffingen, Pratteln, Reinach BL, Rheinfelden, Riehen, Sch\u{f6}nenbuch, Therwil, Wallbach<br></p>"]
pub mod gasverbrauch_im_versorgungsgebiet_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start der Messung
        ///
        /// Startzeitpunkt der Messperiode
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Gasverbrauch
        ///
        /// Gasverbrauch innerhalb des Stundenintervalls
        pub value: Option<f64>,
        /// Datum
        ///
        /// Tag der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Zeit
        ///
        /// Startuhrzeit der Messung
        pub time: Option<String>,
        /// Jahr
        ///
        /// Jahr als Text
        pub year: Option<String>,
        /// Monat
        ///
        /// Monat (1 = Januar, etc.)
        pub month: Option<i64>,
        /// Tag
        pub day: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag als Zahl (0 = Montag, 1 = Dienstag, etc.)
        pub weekday: Option<i64>,
        /// Tag des Jahres
        ///
        /// Tag innerhalb des Jahres (1. Januar = 1, etc.)
        pub dayofyear: Option<i64>,
        /// Quartal
        ///
        /// Quartal des Jahres (1, 2, 3, 4)
        pub quarter: Option<i64>,
        /// Woche des Jahres
        ///
        /// Woche (1, 2, 3, etc.)
        pub weekofyear: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Value,
        Date,
        Time,
        Year,
        Month,
        Day,
        Weekday,
        Dayofyear,
        Quarter,
        Weekofyear,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Value => "value",
                Field::Date => "date",
                Field::Time => "time",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Dayofyear => "dayofyear",
                Field::Quarter => "quarter",
                Field::Weekofyear => "weekofyear",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100304/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Umweltanalyse Oberfl\u{e4}chengew\u{e4}sser"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die Analysedaten der Beprobungen der Oberfl\u{e4}chengew\u{e4}sser des Kantons Basel-Stadt seit dem Jahr 1993. Die Daten des Rheins sind hiervon ausgenommen. Es werden Konzentrationsangaben zu verschiedenen Inhalts- resp. Schadstoffen mit Bezug auf die einzelnen Fliessgew\u{e4}sser, sowie der geographischen Koordinaten gemacht.</p><p>Weitere Informationen: <a href=\"https://www.aue.bs.ch/umweltanalytik/umweltdaten-gewaesser-feststoffe.html\" target=\"_blank\">https://www.aue.bs.ch/umweltanalytik/umweltdaten-gewaesser-feststoffe.html</a></p>"]
pub mod umweltanalyse_oberflaechengewaesser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Geo Point
        ///
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme. Dauer codiert nach Konvention der Internationalen Kommission zum Schutz des Rheins (IKSR) 1M =24h; 14M=336h; 28M=672; 1M14 24h Mischprobe alle 14Tage; Sammelprobe=Dauer variabel abhängig von Schwebstoffanteil. MS steht für Mischung Stahl, MK für Mischung Kunststoff. E steht für Einzelmessung, M für Mischprobenentnahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probenahme.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100066/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Vorg\u{e4}nge von Gesch\u{e4}ften"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt Vorg\u{e4}nge und Sitzungen von Gesch\u{e4}ften (beziehungsweise Beschl\u{fc}sse zu Gesch\u{e4}ften), die im Grossen Rat des Kantons Basel-Stadt behandelt werden.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch/\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_vorgaenge_von_geschaeften {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Beschlussnummer
        ///
        /// Nummer des Beschlusses des Vorgangs
        pub beschlnr: Option<String>,
        /// Vorgangsnummer
        ///
        /// Nummer des Vorgangs
        pub nummer: Option<String>,
        /// Vermerk
        ///
        /// Vermerk zum Vorgang
        pub vermerk: Option<String>,
        /// Sitzungsnummer
        ///
        /// Nummer der Sitzung, an der der Vorgang bearbeitet wurde
        pub siz_nr: Option<String>,
        /// Sitzungsdatum
        ///
        /// Datum der Sitzung, an der der Vorgang behandelt wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub siz_datum: Option<Date>,
        /// Laufnummer Geschäft
        ///
        /// Laufnummer des Geschäfts zum zugehörigen Vorgang
        pub laufnr_ges: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Geschäfts zum zugehörigen Vorgang
        pub signatur_ges: Option<String>,
        /// Status Geschäft
        ///
        /// Status des Geschäfts zum zugehörigen Vorgang (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Geschäfts zum zugehörigen Vorgang
        pub titel_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Geschäfts zum zugehörigen Vorgang
        pub ga_rr_gr: Option<String>,
        /// Geschäft grosserrat.bs.ch
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach aktuellem Geschäft.
        pub url_geschaeft_ods: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Beschlnr,
        Nummer,
        Vermerk,
        SizNr,
        SizDatum,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        GaRrGr,
        UrlGes,
        UrlGeschaeftOds,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Beschlnr => "beschlnr",
                Field::Nummer => "nummer",
                Field::Vermerk => "vermerk",
                Field::SizNr => "siz_nr",
                Field::SizDatum => "siz_datum",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100314/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Hospitalisierte in baselst\u{e4}dtischen Spit\u{e4}lern"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt Kennzahlen auf Tagesebene zu den in baselst\u{e4}dtischen Spit\u{e4}lern hospitalisierten Personen mit einem positiven Testresultat auf SARS-CoV-2. </p><p><b>Die t\u{e4}gliche Erhebung der baselst\u{e4}dtischen Spitalkapazit\u{e4}ten wurde per 1. Mai 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.</b></p><p>Weitere Angaben zu den positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz im Kanton Basel-Stadt finden Sie unter diesem Link:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100073/table/?sort=timestamp\">Coronavirus (COVID-19): Fallzahlen Basel-Stadt</a>.\u{a0}</p>"]
pub mod coronavirus_covid_19_hospitalisierte_in_baselstaedtischen_spitaelern {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Hospitalisierte total
        ///
        /// Anzahl in baselstädtischen Spitälern hospitalisierte Personen mit positivem Testresultat auf SARS-CoV-2.
        pub current_hosp: Option<i64>,
        /// Hospitalisierte mit Wohnsitz in Basel-Stadt
        ///
        /// Anzahl in baselstädtischen Spitälern hospitalisierte Personen mit Wohnsitz im Kanton Basel-Stadt und positivem Testresultat auf SARS-CoV-2.
        pub current_hosp_resident: Option<i64>,
        /// Hospitalisierte ausserkantonal und international
        ///
        /// Anzahl in baselstädtischen Spitälern hospitalisierte Personen mit ausserkantonalem oder internationalem Wohnsitz und positivem Testresultat auf SARS-CoV-2.
        pub current_hosp_non_resident: Option<i64>,
        /// Intensivstationäre Patienten
        ///
        /// Anzahl auf Intensivpflegestationen in baselstädtischen Spitälern hospitalisierten Personen mit positivem Testresultat auf SARS-CoV-2.
        pub current_icu: Option<i64>,
        /// Hospitalisierte auf intermediate care-Station
        ///
        /// Anzahl auf intermediate care-Stationen in baselstädtischen Spitälern hospitalisierte Personen mit positivem Testresultat auf SARS-CoV-2.
        pub imcu: Option<f64>,
        /// Hospitalisierte auf Normalstation
        ///
        /// Anzahl auf Normalstationen in baselstädtischen Spitälern hospitalisierte Personen mit positivem Testresultat auf SARS-CoV-2.
        pub normalstation: Option<f64>,
        /// Daten komplett
        ///
        /// True: Daten aller Spitäler sind für den entsprechenden Tag erfasst. False: Daten mindestens eines Spitals fehlen für den entsprechenden Tag.
        pub data_from_all_hosp: Option<String>,
        /// Daten plausibel
        ///
        /// True: Analyse der Daten hat keine Auffälligkeiten ergeben. False: Daten auffällig, sollten genau kontrolliert werden vor dem Gebrauch.
        pub data_plausible: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        CurrentHosp,
        CurrentHospResident,
        CurrentHospNonResident,
        CurrentIcu,
        Imcu,
        Normalstation,
        DataFromAllHosp,
        DataPlausible,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentHospResident => "current_hosp_resident",
                Field::CurrentHospNonResident => "current_hosp_non_resident",
                Field::CurrentIcu => "current_icu",
                Field::Imcu => "imcu",
                Field::Normalstation => "normalstation",
                Field::DataFromAllHosp => "data_from_all_hosp",
                Field::DataPlausible => "data_plausible",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100109/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Interessensbindungen Ratsmitglieder"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die aktiven Interessensbindungen von Grossratsmitgliedern w\u{e4}hrend ihrer Mitgliedschaft im Grossen Rat des Kantons Basel-Stadt.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch/\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_interessensbindungen_ratsmitglieder {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Rubrik
        ///
        /// Rubrik der Interessensbindung (Führung und Aufsicht oder staatliche Kommission)
        pub rubrik: Option<String>,
        /// Interessensbindung
        ///
        /// Name der zugehörigen Interessensbindung
        pub intr_bind: Option<String>,
        /// Funktion Ratsmitglied
        ///
        /// Funktion des Grossratsmitglieds in der Interessensbindung
        pub funktion: Option<String>,
        /// Interessensbindung und Funktion
        ///
        /// Name der zugehörigen Interessensbindung und Funktion des Grossratsmitglied
        pub text: Option<String>,
        /// Anrede
        ///
        /// Anrede des Grossratsmitglieds nach amtlichem Geschlecht
        pub anrede: Option<String>,
        /// Name Ratsmitglied
        ///
        /// Nachname des Grossratsmitglieds
        pub name: Option<String>,
        /// Vorname Ratsmiglied
        ///
        /// Vorname des Grossratsmitglieds
        pub vorname: Option<String>,
        /// Name, Vorname
        ///
        /// Name und Vorname des Grossratsmitglieds
        pub name_vorname: Option<String>,
        /// Partei abgekürzt
        ///
        /// Abkürzung der Parteizugehörigkeit des Grossratsmitglied (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei_kname: Option<String>,
        /// Ratsmitglied grosserrat.bs.ch
        ///
        /// Link zum Grossratsmitglied auf der Webseite des Grossen Rates
        pub url_adr: Option<String>,
        /// ID Ratsmitglied
        ///
        /// Individuelle Identifikationsnummer des Grossratsmitglieds innerhalb der Datenbank des Grossen Rates
        pub uni_nr: Option<String>,
        /// Grossratsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach aktueller Interessensbindung.
        pub url_ratsmitgliedschaften: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Rubrik,
        IntrBind,
        Funktion,
        Text,
        Anrede,
        Name,
        Vorname,
        NameVorname,
        ParteiKname,
        UrlAdr,
        UniNr,
        UrlRatsmitgliedschaften,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Rubrik => "rubrik",
                Field::IntrBind => "intr_bind",
                Field::Funktion => "funktion",
                Field::Text => "text",
                Field::Anrede => "anrede",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::NameVorname => "name_vorname",
                Field::ParteiKname => "partei_kname",
                Field::UrlAdr => "url_adr",
                Field::UniNr => "uni_nr",
                Field::UrlRatsmitgliedschaften => "url_ratsmitgliedschaften",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100309/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Events in Gew\u{e4}ssern\u{e4}he"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt Informationen zu Anl\u{e4}ssen u.\u{e4}. in Gew\u{e4}ssern\u{e4}he, welche z.B. in der BachApp publiziert werden.\u{a0}</p>"]
pub mod events_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// IDUnique
        ///
        /// ID
        pub idunique: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Status
        pub status: Option<String>,
        /// Datum_von
        ///
        /// Beginn des Events
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_von: Option<Date>,
        /// Datum_bis
        ///
        /// Ende des Events
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_bis: Option<Date>,
        /// Eventname
        ///
        /// Name des Events
        pub titel: Option<String>,
        /// Motto
        ///
        /// Motto des Events
        pub untertitel: Option<String>,
        /// Information
        ///
        /// Beschreibung des Events
        pub text: Option<String>,
        /// Image
        pub image: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idunique,
        SichtbarVon,
        SichtbarBis,
        Status,
        DatumVon,
        DatumBis,
        Titel,
        Untertitel,
        Text,
        Image,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idunique => "idunique",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Status => "status",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Text => "text",
                Field::Image => "image",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100247/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Feuerstellen in Gew\u{e4}ssern\u{e4}he"]
#[doc = ""]
#[doc = "<p>Gew\u{e4}ssernahe Feuerstellen.\u{a0}</p>"]
pub mod feuerstellen_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Bezeichnung
        pub bezeichnung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Bezeichnung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Bezeichnung => "bezeichnung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100276/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Teststellen"]
#[doc = ""]
#[doc = "<p>Eine \u{dc}bersicht der Standorte, an welchen sich die Bev\u{f6}lkerung w\u{e4}hrend der Corona-Pandemie auf SARS-CoV-2 testen lassen konnte. F\u{fc}r Kinder werden von gewissen Teststellen zus\u{e4}tzlich zum Abstrich im Rachenbereich alternative Testmethoden angeboten. </p><p><b>Der Datensatz wurde vom Gesundheitsdepartement aktuell gehalten. Dieser wird seit 8. M\u{e4}rz 2023 nicht mehr aktualisiert.\u{a0}Man kann sich weiterhin bei einzelnen Arztpraxen und Institutionen testen lassen.</b></p><p>Weitere\u{a0}Informationen zum Coronavirus in Basel-Stadt sind hier zu finden: <a href=\"https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co\" target=\"_blank\">https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co</a></p>"]
pub mod coronavirus_covid_19_teststellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_ts: Option<i64>,
        /// Teststelle
        ///
        /// Name der Teststelle
        pub institut: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
        /// Hausnummer
        pub hausnummer: Option<i64>,
        /// PLZ
        ///
        /// 4-stellige Postleitzahl
        pub plz: Option<String>,
        /// Ort
        ///
        /// Gemeinde
        pub ort: Option<String>,
        /// Telefonnummer
        ///
        /// Telefonnummer der Teststelle
        pub telefon: Option<String>,
        /// Nur bestehende Patienten
        ///
        /// Werden nur bestehende Patienten getestet
        pub bestehend: Option<String>,
        /// Terminvereinbarung
        ///
        /// Sind Terminvereinbarungen notwendig
        pub termin: Option<String>,
        /// Online-Anmeldung
        ///
        /// URL für Online Anmeldung
        pub online: Option<String>,
        /// Bemerkungen
        ///
        /// Bemerkungen zur Teststelle
        pub bemerkung: Option<String>,
        /// Öffnungszeiten Werktags
        ///
        /// Öffnungszeiten unter der Woche
        pub oeff_wt: Option<String>,
        /// Öffnungszeiten Wochenende
        ///
        /// Öffnungszeiten am Wochenende
        pub oeff_we: Option<String>,
        /// Schnelltest
        ///
        /// Verfügbarkeit von Schnelltests
        pub schnellte: Option<String>,
        /// Kinder
        ///
        /// Testet diese Teststelle auch Kinder?
        pub kinder: Option<String>,
        /// Kinder: Mindestalter
        ///
        /// Mindestalter für Tests. Teststellen, welche Personen erst ab einem bestimmten Mindestalter testen, sind spezialisiert auf Corona-Tests bei Kindern.
        pub alter: Option<String>,
        /// Kinder: Zusätzliche Testarten
        ///
        /// Art der durchführenden Tests
        pub testart: Option<String>,
        /// Kinder: Nur symptomatische
        ///
        /// Müssen Kinder COVID-19 Symptome haben, um durch diese Teststelle getestet zu werden?
        pub symptom: Option<String>,
        /// Kinder: Bemerkungen
        ///
        /// Bemerkungen zu Teststellen für Kinder
        pub kommentar: Option<String>,
        /// ADRESSID
        pub adressid: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdTs,
        Institut,
        Strasse,
        Hausnummer,
        Plz,
        Ort,
        Telefon,
        Bestehend,
        Termin,
        Online,
        Bemerkung,
        OeffWt,
        OeffWe,
        Schnellte,
        Kinder,
        Alter,
        Testart,
        Symptom,
        Kommentar,
        Adressid,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdTs => "id_ts",
                Field::Institut => "institut",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::Bestehend => "bestehend",
                Field::Termin => "termin",
                Field::Online => "online",
                Field::Bemerkung => "bemerkung",
                Field::OeffWt => "oeff_wt",
                Field::OeffWe => "oeff_we",
                Field::Schnellte => "schnellte",
                Field::Kinder => "kinder",
                Field::Alter => "alter",
                Field::Testart => "testart",
                Field::Symptom => "symptom",
                Field::Kommentar => "kommentar",
                Field::Adressid => "adressid",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100134/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sport- und Bewegungsanlagen"]
#[doc = ""]
#[doc = "Der Datensatz bildet vom Kanton Basel-Stadt betriebenen Sport- und Bewegungsanlagen ab sowie auch alle kantonalen Sportanlagen ausserhalb der Kantons- und Landesgrenzen. Im Datensatz sind zus\u{e4}tzlich kantonale R\u{e4}umlichkeiten aufgef\u{fc}hrt, welche f\u{fc}r den Sportbetrieb genutzt und gemietet werden."]
pub mod sport_und_bewegungsanlagen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID der Angebote
        ///
        /// Eindeutiger Identifikator
        pub id_angebot: Option<i64>,
        /// Name
        ///
        /// Name des Sportangebots
        pub name: Option<String>,
        /// Kategorie
        ///
        /// Kategorien unterschiedlicher Sport- und Bewegungsanlagen
        pub kategorie: Option<String>,
        /// Beschreibung
        ///
        /// Beschreibung des Sportangebots
        pub beschreibu: Option<String>,
        /// Strassennummer
        ///
        /// Strassenname und Hausnummer
        pub strassenr: Option<String>,
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Link
        ///
        /// Weitere Informationen
        pub link: Option<String>,
        /// Zustaendigkeit
        ///
        /// Zuständigkeit für das Sportangebot
        pub zustaendig: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
        /// Baselinfo
        ///
        /// Gibt Relevanz für das Fussgängerorientierungssystem Basel Info an
        pub baselinfo: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdAngebot,
        Name,
        Kategorie,
        Beschreibu,
        Strassenr,
        Plz,
        Ort,
        Link,
        Zustaendig,
        Bemerkung,
        Baselinfo,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdAngebot => "id_angebot",
                Field::Name => "name",
                Field::Kategorie => "kategorie",
                Field::Beschreibu => "beschreibu",
                Field::Strassenr => "strassenr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Link => "link",
                Field::Zustaendig => "zustaendig",
                Field::Bemerkung => "bemerkung",
                Field::Baselinfo => "baselinfo",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100151/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte der IWB Ladestationen f\u{fc}r Elektroautos"]
#[doc = ""]
#[doc = "<p>IWB baut im Kanton Basel-Stadt ein Netz leistungsf\u{e4}higer \u{f6}ffentlich zug\u{e4}nglicher Ladestationen auf, um der umweltfreundlichen und gerade f\u{fc}r Ballungsgebiete idealen Elektromobilit\u{e4}t entscheidende Impulse zu geben. Hier finden Sie unsere Ladestationen.</p>\n\n<p>In der Pilotphase wurden die Parkpl\u{e4}tze mit LoRa-angebunden Sensoren ausgestattet. Ziel war es festzustellen, ob Parkpl\u{e4}tze durch Fahrzeuge besetzt werden, ohne dass diese einen aktiven Ladevorgang vornehmen. Nach internen Abstimmungen wird die IWB die \u{dc}bermittlung der Daten ab ca. Mitte September 2022 nicht weiterf\u{fc}hren. Gr\u{fc}nde daf\u{fc}r sind Schwierigkeiten bei der \u{dc}bertragung der Werte sowie eine fehlende Relevanz f\u{fc}r die Praxis. Beim Roll-Out der weiteren \u{f6}ffentlichen Ladestationen auf Allmend werden voraussichtlich keine LoRa-Sensoren mehr verbaut.</p>\n\n<p>Echtzeitdaten zur Belegung der Elektroauto-Ladestationen der gesamten Schweiz basierend auf dem Status des Ladevorgangs sind hier zu finden:\u{a0}<a href=\"https://opendata.swiss/de/dataset/ladestationen\" target=\"_blank\">https://opendata.swiss/de/dataset/ladestationen</a></p>"]
pub mod standorte_der_iwb_ladestationen_fuer_elektroautos {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// Description
        pub description: Option<String>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        /// Beschreibung
        pub beschreibung: Option<String>,
        /// Art
        pub art: Option<String>,
        /// Ort
        pub ort: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
        Description,
        Beschreibung,
        Art,
        Ort,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Description => "description",
                Field::Beschreibung => "beschreibung",
                Field::Art => "art",
                Field::Ort => "ort",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100005/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geb\u{e4}ude (Geb\u{e4}ude- und Wohnungsregister GWR)"]
#[doc = ""]
#[doc = "Geb\u{e4}ude gem\u{e4}ss Geb\u{e4}ude- und Wohnungsregister (GWR). <br><br>Ein Geb\u{e4}ude ist ein auf Dauer angelegter, mit einem Dach versehener, mit dem Boden fest verbundener Bau, der Personen aufnehmen kann und zu Wohnzwecken oder Zwecken der Arbeit, der Ausbildung, der Kultur, des Sports oder jeglicher anderer menschlicher T\u{e4}tigkeit dient; ein Doppel-, Gruppen- und Reihenhaus z\u{e4}hlt ebenfalls als ein Geb\u{e4}ude, wenn es einen eigenen Zugang von aussen hat und wenn zwischen den Geb\u{e4}uden eine senkrechte vom Erdgeschoss bis zum Dach reichende tragende Trennmauer besteht.<br><br>Weitere Einzelheiten zur Erfassung von Geb\u{e4}uden sind hier nachzulesen: <a href=\"https://www.housing-stat.ch/files/1754-2300.pdf\" target=\"_blank\">https://www.housing-stat.ch/files/1754-2300.pdf (Weisung zur Erfassung der Geb\u{e4}ude in der amtlichen Vermessung (AV) und im Geb\u{e4}ude- und Wohnungsregister (GWR)) </a><br><br>Einen \u{dc}berblick \u{fc}ber die im Register gef\u{fc}hrten Merkmal gibt folgendes Dokument: <a href=\"https://www.housing-stat.ch/files/881-2200.pdf\" target=\"_blank\">https://www.housing-stat.ch/files/881-2200.pdf (Merkmalskatalog 4.2)</a> bzw. online unter <a href=\"https://www.housing-stat.ch/de/help/42.html\" target=\"_blank\">https://www.housing-stat.ch/de/help/42.html (Online-Merkmalskatalog 4.2)</a><br><br>Die rechtliche Grundlage stellt die entsprechende eidgen\u{f6}ssische Gesetzgebung dar: <a href=\"https://www.fedlex.admin.ch/eli/cc/2017/376/de\" target=\"_blank\">https://www.fedlex.admin.ch/eli/cc/2017/376/de (Verordnung \u{fc}ber das eidgen\u{f6}ssische Geb\u{e4}ude- und Wohnungsregister (VGWR))</a><br><br>"]
pub mod gebaeude_gebaeude_und_wohnungsregister_gwr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// EGID
        ///
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<i64>,
        /// Kanton
        ///
        /// Abkürzung Kanton
        pub gdekt: Option<String>,
        /// Gemeindenummer
        pub ggdenr: Option<i64>,
        /// Gemeindename
        pub ggdename: Option<String>,
        /// EGRID
        ///
        /// Eidgenössischer Grundstücksidentifikator
        pub egrid: Option<String>,
        /// Grundbuchkreisnummer
        ///
        /// Sektion
        pub lgbkr: Option<i64>,
        /// Grundstücksnummer
        ///
        /// Parzellennummer - nn(F) bedeutet, dass sich das Grundstück in Frankreich befindet.
        pub lparz: Option<String>,
        /// Suffix der Grundstücksnummer
        ///
        /// Suffix der Parzellennummer
        pub lparzsx: Option<String>,
        /// Typ des Grundstücks
        pub ltyp: Option<String>,
        /// Gebäudenummer
        pub gebnr: Option<i64>,
        /// Gebäudebezeichnung
        pub gbez: Option<String>,
        /// E-Gebäudekoordinate
        pub gkode: Option<f64>,
        /// N-Gebäudekoordinate
        pub gkodn: Option<f64>,
        /// Koordinatenherkunft Code
        pub gksce: Option<i64>,
        /// Koordinatenherkunft Bezeichnung
        pub gksce_decoded: Option<String>,
        /// Gebäudestatus Code
        pub gstat: Option<i64>,
        /// Gebäudestatus Bezeichnung
        pub gstat_decoded: Option<String>,
        /// Gebäudekategorie Code
        pub gkat: Option<i64>,
        /// Gebäudekategorie Bezeichnung
        pub gkat_decoded: Option<String>,
        /// Gebäudeklasse Code
        pub gklas: Option<i64>,
        /// Gebäudeklasse Bezeichnung
        pub gklas_decoded: Option<String>,
        /// Baujahr des Gebäudes
        pub gbauj: Option<i64>,
        /// Baumonat des Gebäudes
        pub gbaum: Option<i64>,
        /// Bauperiode Code
        pub gbaup: Option<i64>,
        /// Bauperiode Bezeichnung
        pub gbaup_decoded: Option<String>,
        /// Abbruchjahr des Gebäudes
        pub gabbj: Option<String>,
        /// Gebäudefläche (in m2)
        pub garea: Option<i64>,
        /// Gebäudevolumen (in m3)
        pub gvol: Option<i64>,
        /// Norm des Gebäudevolumens Code
        pub gvolnorm: Option<i64>,
        /// Norm des Gebäudevolumens Bezeichnung
        pub gvolnorm_decoded: Option<String>,
        /// Informationsquelle zum Gebäudevolumen Code
        pub gvolsce: Option<i64>,
        /// Informationsquelle zum Gebäudevolumen Bezeichnung
        pub gvolsce_decoded: Option<String>,
        /// Anzahl Geschosse
        ///
        /// Anzhl Geschosse
        pub gastw: Option<i64>,
        /// Anzahl Wohnungen
        ///
        /// Anzahl Wohnugnen
        pub ganzwhg: Option<i64>,
        /// Anzahl separate Wohnräume
        pub gazzi: Option<i64>,
        /// Zivilschutzraum Code
        pub gschutzr: Option<i64>,
        /// Zivilschutzraum Bezeichnung
        pub gschutzr_decoded: Option<String>,
        /// Energiebezugsfläche
        pub gebf: Option<i64>,
        /// Primärer Wärmeerzeuger der Heizung Code
        pub gwaerzh1: Option<i64>,
        /// Primärer Wärmeerzeuger der Heizung Bezeichnung
        pub gwaerzh1_decoded: Option<String>,
        /// Primäre Energiequelle der Heizung Code
        pub genh1: Option<i64>,
        /// Primäre Energiequelle der Heizung Bezeichnung
        pub genh1_decoded: Option<String>,
        /// Informationsquelle primäre Heizung Code
        pub gwaersceh1: Option<i64>,
        /// Informationsquelle primäre Heizung Bezeichnung
        pub gwaersceh1_decoded: Option<String>,
        /// Aktualisierungsdatum primäre Heizung
        ///
        /// Informationsquelle primäre Heizung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gwaerdath1: Option<Date>,
        /// Sekundärer Wärmeerzeuger der Heizung Code
        pub gwaerzh2: Option<i64>,
        /// Sekundärer Wärmeerzeuger der Heizung Bezeichnung
        pub gwaerzh2_decoded: Option<String>,
        /// Sekundäre Energiequelle der Heizung Code
        pub genh2: Option<i64>,
        /// Sekundäre Energiequelle der Heizung Bezeichnung
        pub genh2_decoded: Option<String>,
        /// Informationsquelle sekundäre Heizung Code
        pub gwaersceh2: Option<i64>,
        /// Informationsquelle sekundäre Heizung Bezeichnung
        pub gwaersceh2_decoded: Option<String>,
        /// Aktualisierungsdatum sekundäre Heizung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gwaerdath2: Option<Date>,
        /// Primärer Wärmeerzeuger Warmwasser Code
        pub gwaerzw1: Option<i64>,
        /// Primärer Wärmeerzeuger Warmwasser Bezeichnung
        pub gwaerzw1_decoded: Option<String>,
        /// Primäre Energiequelle Warmwasser Code
        pub genw1: Option<i64>,
        /// Primäre Energiequelle Warmwasser Bezeichnung
        pub genw1_decoded: Option<String>,
        /// Informationsquelle primäre Wasseraufbereitung Code
        pub gwaerscew1: Option<i64>,
        /// Informationsquelle primäre Wasseraufbereitung Bezeichnung
        pub gwaerscew1_decoded: Option<String>,
        /// Aktualisierungsdatum primäre Warmwasseraufbereitung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gwaerdatw1: Option<Date>,
        /// Sekundärer Wärmeerzeuger Warmwasser Code
        pub gwaerzw2: Option<i64>,
        /// Sekundärer Wärmeerzeuger Warmwasser Bezeichnung
        pub gwaerzw2_decoded: Option<String>,
        /// Sekundäre Energiequelle Warmwasser Code
        pub genw2: Option<i64>,
        /// Sekundäre Energiequelle Warmwasser Bezeichnung
        pub genw2_decoded: Option<String>,
        /// Informationsquelle sekundäre Warmwasseraufbereitung Code
        pub gwaerscew2: Option<i64>,
        /// Informationsquelle sekundäre Warmwasseraufbereitung Bezeichnung
        pub gwaerscew2_decoded: Option<String>,
        /// Aktualisierungsdatum sekundäre Warmwasseraufbereitung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gwaerdatw2: Option<Date>,
        /// Exportdatum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gexpdat: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Egid,
        Gdekt,
        Ggdenr,
        Ggdename,
        Egrid,
        Lgbkr,
        Lparz,
        Lparzsx,
        Ltyp,
        Gebnr,
        Gbez,
        Gkode,
        Gkodn,
        Gksce,
        GksceDecoded,
        Gstat,
        GstatDecoded,
        Gkat,
        GkatDecoded,
        Gklas,
        GklasDecoded,
        Gbauj,
        Gbaum,
        Gbaup,
        GbaupDecoded,
        Gabbj,
        Garea,
        Gvol,
        Gvolnorm,
        GvolnormDecoded,
        Gvolsce,
        GvolsceDecoded,
        Gastw,
        Ganzwhg,
        Gazzi,
        Gschutzr,
        GschutzrDecoded,
        Gebf,
        Gwaerzh1,
        Gwaerzh1Decoded,
        Genh1,
        Genh1Decoded,
        Gwaersceh1,
        Gwaersceh1Decoded,
        Gwaerdath1,
        Gwaerzh2,
        Gwaerzh2Decoded,
        Genh2,
        Genh2Decoded,
        Gwaersceh2,
        Gwaersceh2Decoded,
        Gwaerdath2,
        Gwaerzw1,
        Gwaerzw1Decoded,
        Genw1,
        Genw1Decoded,
        Gwaerscew1,
        Gwaerscew1Decoded,
        Gwaerdatw1,
        Gwaerzw2,
        Gwaerzw2Decoded,
        Genw2,
        Genw2Decoded,
        Gwaerscew2,
        Gwaerscew2Decoded,
        Gwaerdatw2,
        Gexpdat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Gdekt => "gdekt",
                Field::Ggdenr => "ggdenr",
                Field::Ggdename => "ggdename",
                Field::Egrid => "egrid",
                Field::Lgbkr => "lgbkr",
                Field::Lparz => "lparz",
                Field::Lparzsx => "lparzsx",
                Field::Ltyp => "ltyp",
                Field::Gebnr => "gebnr",
                Field::Gbez => "gbez",
                Field::Gkode => "gkode",
                Field::Gkodn => "gkodn",
                Field::Gksce => "gksce",
                Field::GksceDecoded => "gksce_decoded",
                Field::Gstat => "gstat",
                Field::GstatDecoded => "gstat_decoded",
                Field::Gkat => "gkat",
                Field::GkatDecoded => "gkat_decoded",
                Field::Gklas => "gklas",
                Field::GklasDecoded => "gklas_decoded",
                Field::Gbauj => "gbauj",
                Field::Gbaum => "gbaum",
                Field::Gbaup => "gbaup",
                Field::GbaupDecoded => "gbaup_decoded",
                Field::Gabbj => "gabbj",
                Field::Garea => "garea",
                Field::Gvol => "gvol",
                Field::Gvolnorm => "gvolnorm",
                Field::GvolnormDecoded => "gvolnorm_decoded",
                Field::Gvolsce => "gvolsce",
                Field::GvolsceDecoded => "gvolsce_decoded",
                Field::Gastw => "gastw",
                Field::Ganzwhg => "ganzwhg",
                Field::Gazzi => "gazzi",
                Field::Gschutzr => "gschutzr",
                Field::GschutzrDecoded => "gschutzr_decoded",
                Field::Gebf => "gebf",
                Field::Gwaerzh1 => "gwaerzh1",
                Field::Gwaerzh1Decoded => "gwaerzh1_decoded",
                Field::Genh1 => "genh1",
                Field::Genh1Decoded => "genh1_decoded",
                Field::Gwaersceh1 => "gwaersceh1",
                Field::Gwaersceh1Decoded => "gwaersceh1_decoded",
                Field::Gwaerdath1 => "gwaerdath1",
                Field::Gwaerzh2 => "gwaerzh2",
                Field::Gwaerzh2Decoded => "gwaerzh2_decoded",
                Field::Genh2 => "genh2",
                Field::Genh2Decoded => "genh2_decoded",
                Field::Gwaersceh2 => "gwaersceh2",
                Field::Gwaersceh2Decoded => "gwaersceh2_decoded",
                Field::Gwaerdath2 => "gwaerdath2",
                Field::Gwaerzw1 => "gwaerzw1",
                Field::Gwaerzw1Decoded => "gwaerzw1_decoded",
                Field::Genw1 => "genw1",
                Field::Genw1Decoded => "genw1_decoded",
                Field::Gwaerscew1 => "gwaerscew1",
                Field::Gwaerscew1Decoded => "gwaerscew1_decoded",
                Field::Gwaerdatw1 => "gwaerdatw1",
                Field::Gwaerzw2 => "gwaerzw2",
                Field::Gwaerzw2Decoded => "gwaerzw2_decoded",
                Field::Genw2 => "genw2",
                Field::Genw2Decoded => "genw2_decoded",
                Field::Gwaerscew2 => "gwaerscew2",
                Field::Gwaerscew2Decoded => "gwaerscew2_decoded",
                Field::Gwaerdatw2 => "gwaerdatw2",
                Field::Gexpdat => "gexpdat",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100230/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Grossratswahl 20. Oktober 2024"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">F\u{fc}r die Gesamterneuerungswahl der 100 Mitglieder vom Grossen Rat vom 20. Oktober 2024 kandidieren 870 Personen auf insgesamt 16 Listen.</p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">Dieser Datensatz zeigt die Kandidierenden nach Geschlecht, Jahrgang und Beruf.</p>"]
pub mod kandidierende_der_grossratswahl_20_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlkreis
        pub wahlkreis: Option<String>,
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenkurzbezeichnung
        ///
        /// Abkürzung der Liste
        pub listenkurzbezeichnung: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Kandidierenden-Nr.
        ///
        /// Nummer der Kandidatur
        pub kand_nr: Option<String>,
        /// Bisher
        ///
        /// War die kandidierende Person bisher im Grossen Rat?
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// Amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
        /// Altersgruppe
        pub altersgruppe: Option<String>,
        /// Alter Ende 2024
        pub alter: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlkreis,
        ListenNr,
        Listenkurzbezeichnung,
        Listenbezeichnung,
        KandNr,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
        Altersgruppe,
        Alter,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlkreis => "wahlkreis",
                Field::ListenNr => "listen_nr",
                Field::Listenkurzbezeichnung => "listenkurzbezeichnung",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::KandNr => "kand_nr",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
                Field::Altersgruppe => "altersgruppe",
                Field::Alter => "alter",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100385/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Luftqualit\u{e4}t Station Basel-Binningen"]
#[doc = ""]
#[doc = "<p>St\u{fc}ndliche Messungen der <a href=\"https://www.meteoschweiz.admin.ch/home/messwerte.html?param=messnetz-automatisch&amp;station=BAS\" target=\"_blank\">automatischen Wetterstation Basel-Binningen</a>.\u{a0}</p>"]
pub mod luftqualitaet_station_basel_binningen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        ///
        /// Zeitstempel in UTC
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        /// Zeitstempel als Text in Mitteleuropäischer Zeit ("Winterzeit")
        pub timestamp_text: Option<String>,
        /// O3 [ug/m3]
        ///
        /// Ozon
        pub o3_ug_m3: Option<f64>,
        /// NO2 [ug/m3]
        ///
        /// Stickstoffdioxid
        pub no2_ug_m3: Option<f64>,
        /// PM10 [ug/m3]
        ///
        /// Feinstaub mit Partikelgrösse < 10 tausendstel Millimeter
        pub pm10_ug_m3: Option<f64>,
        /// PM2.5 [ug/m3]
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm2_5_ug_m3: Option<f64>,
        /// CPC [1/cm3]
        ///
        /// Partikelanzahlkonzentration
        pub cpc_1_cm3: Option<f64>,
        /// EC [ug/m3]
        ///
        /// Russ (EC in PM2.5)
        pub ec_ug_m3: Option<f64>,
        /// PREC [mm]
        ///
        /// Niederschlag
        pub prec_mm: Option<f64>,
        /// RAD [W/m2]
        ///
        /// Globalstrahlung
        pub rad_w_m2: Option<f64>,
        /// SO2 [ug/m3]
        ///
        /// Schwefeldioxid
        pub so2_ug_m3: Option<f64>,
        /// NOX [ug/m3 eq. NO2]
        pub nox_ug_m3_eq_no2: Option<f64>,
        /// TEMP [C]
        pub temp_c: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        O3UgM3,
        No2UgM3,
        Pm10UgM3,
        Pm25UgM3,
        Cpc1Cm3,
        EcUgM3,
        PrecMm,
        RadWM2,
        So2UgM3,
        NoxUgM3EqNo2,
        TempC,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::O3UgM3 => "o3_ug_m3",
                Field::No2UgM3 => "no2_ug_m3",
                Field::Pm10UgM3 => "pm10_ug_m3",
                Field::Pm25UgM3 => "pm2_5_ug_m3",
                Field::Cpc1Cm3 => "cpc_1_cm3",
                Field::EcUgM3 => "ec_ug_m3",
                Field::PrecMm => "prec_mm",
                Field::RadWM2 => "rad_w_m2",
                Field::So2UgM3 => "so2_ug_m3",
                Field::NoxUgM3EqNo2 => "nox_ug_m3_eq_no2",
                Field::TempC => "temp_c",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100051/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gesundheitsversorgung (GSV): Spitalkennzahlen"]
#[doc = ""]
#[doc = "Wichtige Kennzahlen der baselst\u{e4}dtischen Spit\u{e4}ler. Dieser Datensatz fliesst in den Bericht des Bereiches Gesundheitsversorgung (GSV) des Gesundheitsdepartements, vor allem in Form eines Dashboards."]
pub mod gesundheitsversorgung_gsv_spitalkennzahlen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr: Option<Date>,
        /// Spital/Klinik
        ///
        /// Name des Spitals oder Klinik
        pub spital: Option<String>,
        /// Akutsomatik
        ///
        /// Klinik bietet akutsomatische Behandlungen an.
        pub angebot_akutsomatik: Option<String>,
        /// Psychiatrie
        ///
        /// Klinik bietet psychiatrische Behandlungen an.
        pub angebot_psychiatrie: Option<String>,
        /// Rehabilitation
        ///
        /// Klinik bietet Rehabilitationsbehandlungen an.
        pub angebot_rehabilitation: Option<String>,
        /// Betriebsertrag (in Mio. CHF)
        ///
        /// Totaler Betriebsertrag des jeweiligen Spitals eines Jahres. Angabe in Millionen CHF.
        pub total_betriebsertrag: Option<f64>,
        /// Betriebsertrag (in 1000 CHF)
        ///
        /// Totaler Betriebsertrag des jeweiligen Spitals eines Jahres. Angabe in 1'000 CHF.
        pub total_betriebsertrag_1000: Option<i64>,
        /// Ertrag Leistungserstellung (in 1000 CHF)
        ///
        /// Totaler Ertrag aus Leistungenerstellug des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_ertrag_leistung: Option<i64>,
        /// Ertrag Leistungserstellung (in Mio. CHF)
        pub ertrag_leistungserstellung_in_mio_chf: Option<f64>,
        /// Übriger Betriebsertrag (in Mio. CHF)
        pub ubriger_betriebsertrag_in_mio_chf: Option<f64>,
        /// Betriebsaufwand (in 1000 CHF)
        ///
        /// Totaler Betriebsaufwand des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_betriebsaufwand: Option<i64>,
        /// Betriebsaufwand (in Mio. CHF)
        pub betriebsaufwand_in_mio_chf: Option<f64>,
        /// Personalkosten (in 1000 CHF)
        ///
        /// Totaler Aufwand für Personalkosten des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_kosten_personal: Option<i64>,
        /// Personalkosten (in Mio. CHF)
        pub personalkosten_in_mio_chf: Option<f64>,
        /// Medizinischer Bedarf (in 1000 CHF)
        ///
        /// Totaler Aufwand für medizinischen Bedarf des jeweiligen Spitals. Angabe in 1'000 CHF.
        pub total_bedarf_medizinisch: Option<i64>,
        /// Medizinischer Bedarf (in Mio. CHF)
        pub medizinischer_bedarf_in_mio_chf: Option<f64>,
        /// Übriger Aufwand (in Mio. CHF)
        pub ubriger_aufwand_in_mio_chf: Option<f64>,
        /// Mitarbeitende (in 100% Stellen)
        ///
        /// Anzahl der Mitarbeitenden in Vollzeitäquivalenten, bzw. in 100%-Stellen im Jahresdurchschnitt.
        pub fte: Option<i64>,
        /// Anzahl Mitarbeitende (Personen)
        ///
        /// Anzahl der Mitarbeitenden in Personen im Jahrestotal.
        pub anz_ma: Option<i64>,
        /// Bettenbetriebstage
        ///
        /// Anzahl der Bettenbetriebstage. Ein Tag, an welchem ein Spitalbett zur Bewirtschaftung zur Verfügung steht, entspricht einem Bettenbetriebstag.
        pub bettenbetriebstage: Option<i64>,
        /// Case-Mix
        ///
        /// Der Case-Mix (CM) beschreibt in der Akutsomatik den (ökonomischen) Schweregrad eines abgerechneten Falles.
        pub case_mix: Option<i64>,
        /// Fälle
        ///
        /// Totale Anzahl aller Fälle des jeweiligen Spitals
        pub anz_faelle_alle: Option<i64>,
        /// Pflegetage
        ///
        /// Total der effektiven Pflegetage, bzw. Dauer des tatsächlichen Aufenthaltes in Tagen.
        pub pflegetage: Option<i64>,
        /// Langzeitpflegefälle
        ///
        /// Anzahl der Langzeitpflegefälle. Langzeitpflege bezeichnet die Pflege und Betreuung von Menschen mit Unterstützungsbedarf über einen längeren Zeitraum.
        pub anz_lzpf: Option<i64>,
        /// Fälle Allgemeine Abteilung
        ///
        /// Anzahl der Fälle, die auf der allgemeinen Abteilung behandelt wurden.
        pub anz_allgemein: Option<i64>,
        /// Allgemeine KVG-Fälle
        ///
        /// Anzahl der Fälle, welche nach dem Krankenversicherungsgesetz (KVG) abgerechnet und auf der allgemeinen Abteilung behandelt wurden.
        pub anz_kvg_allgklasse: Option<i64>,
        /// SwissDRG-Fälle
        ///
        /// Anzahl der Fälle, welche mit SwissDRG-Fallpauschalen abgegolten wurden.
        pub drg_faelle: Option<i64>,
        /// KVG-Fälle
        ///
        /// Anzahl der Fälle, welche nach dem Krankenversicherungsgesetz (KVG) abgerechnet wurden.
        pub anz_kvg_faelle: Option<i64>,
        /// Fälle UV, IV, MV
        ///
        /// Anzahl der Fälle, welche über die Unfall-, Invaliden- oder Militärversicherung abgerechnet wurden.
        pub anz_uvg_iv_faelle: Option<i64>,
        /// Fälle mit Wohnort BS
        ///
        /// Anzahl der Fälle, welche im Kanton Basel-Stadt wohnen.
        pub bs: Option<i64>,
        /// Fälle mit Wohnort BL
        ///
        /// Anzahl der Fälle, welche im Kanton Baselland wohnen.
        pub bl: Option<i64>,
        /// Fälle mit Wohnort AG/SO
        ///
        /// Anzahl der Fälle, welche im Kanton Aargau oder Solothurn wohnen.
        pub ag_so: Option<i64>,
        /// Fälle aus der Restschweiz
        ///
        /// Anzahl der Fälle in einem anderen Kanton als BS, BL, AG oder SO wohnen.
        pub restschweiz: Option<i64>,
        /// Fälle aus dem Ausland
        ///
        /// Anzahl der Fälle, welche im Ausland wohnen.
        pub ausland: Option<i64>,
        /// Männliche Fälle
        ///
        /// Anzahl der männlichen Fälle
        pub maennlich: Option<i64>,
        /// Weibliche Fälle
        ///
        /// Anzahl der weiblichen Fälle
        pub weiblich: Option<i64>,
        /// Alter 0-20 J
        ///
        /// Anzahl der Fälle zwischen 0 und 20 Jahren
        pub jahre_0_20: Option<i64>,
        /// Alter 21-40 J
        ///
        /// Anzahl der Fälle zwischen 21 und 40 Jahren
        pub jahre_21_40: Option<i64>,
        /// Alter 41-60 J
        ///
        /// Anzahl der Fälle zwischen 41 und 60 Jahren
        pub jahre_41_60: Option<i64>,
        /// Alter 61-80 J
        ///
        /// Anzahl der Fälle zwischen 61 und 80 Jahren
        pub jahre_61_80: Option<i64>,
        /// Alter >81 J
        ///
        /// Anzahl der Fälle über 80 Jahren
        pub jahre_ueber80: Option<i64>,
        /// Fälle Akutsomatik
        ///
        /// Gesamtzahl der stationär behandelten Fälle in der Akutsomatik
        pub total_akutsomatik: Option<i64>,
        /// Basispaket
        ///
        /// Anzahl der Fälle im Leistungsbereich Basispaket Chirurgie und innere Medizin oder Basispaket elektiv
        pub basispaket: Option<i64>,
        /// Gastroenterologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Gastroenterologie
        pub gastroenterologie: Option<i64>,
        /// Geburtshilfe
        ///
        /// Anzahl der Fälle des Leistungsbereichs Geburtshilfe
        pub geburtshilfe: Option<i64>,
        /// Gefässe
        ///
        /// Anzahl der Fälle des Leistungsbereichs Gefässe
        pub gefaesse: Option<i64>,
        /// Gynäkologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Gynäkologie
        pub gynaekologie: Option<i64>,
        /// Hals-Nasen-Ohren
        ///
        /// Anzahl der Fälle des Leistungsbereichs Hals-Nasen-Ohren
        pub hno: Option<i64>,
        /// Hämatologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Hämatologie
        pub haematologie: Option<i64>,
        /// Herz
        ///
        /// Anzahl der Fälle des Leistungsbereichs Herz
        pub herz: Option<i64>,
        /// Neugeborene
        ///
        /// Anzahl der Fälle des Leistungsbereichs Neugeborene
        pub neugeborene: Option<i64>,
        /// Neurologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Neurologie
        pub neurologie: Option<i64>,
        /// Orthopädie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Orthopädie
        pub orthopaedie: Option<i64>,
        /// (Radio-) Onkologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs (Radio-) Onkologie
        pub radio_onkologie: Option<i64>,
        /// Pneumologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Pneumologie
        pub pneumologie: Option<i64>,
        /// Urologie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Urologie
        pub urologie: Option<i64>,
        /// Viszeralchirurgie
        ///
        /// Anzahl der Fälle des Leistungsbereichs Viszeralchirurgie
        pub viszeralchirurgie: Option<i64>,
        /// Übrige Akutsomatik
        ///
        /// Anzahl der Fälle der übrigen Leistungsbereiche der Akutsomatik
        pub uebrige: Option<i64>,
        /// Fälle Psychiatrie
        ///
        /// Gesamtzahl der stationär behandelten psychiatrischen Fälle
        pub total_psych: Option<i64>,
        /// Affektive Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit einer affektiven Störung als Hauptdiagnose
        pub psych_affektiv: Option<i64>,
        /// Neurotische Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit neurotischer, Belastungs- oder somatoformer Störung als Hauptdiagnose
        pub psych_neurotisch: Option<i64>,
        /// Organische psychische Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit organischer oder symptomatischer psychischer Störung als Hauptdiagnose
        pub psych_organisch: Option<i64>,
        /// Verhaltensstörungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit psychischer oder Verhaltensstörung durch psychotrope Substanzen als Hauptdiagnose
        pub psych_psychisch: Option<i64>,
        /// Psychotische Störungen
        ///
        /// Anzahl der Psychiatrie-Fälle mit Schizophrenie, schizotyper oder wahnhafter Störung als Hauptdiagnose
        pub psych_schizophren: Option<i64>,
        /// Übrige Psychiatrie
        ///
        /// Anzahl der Psychiatrie-Fälle mit einer anderen psychiatrischen Diagnose
        pub psych_uebrige: Option<i64>,
        /// Fälle Rehabilitation
        ///
        /// Gesamtzahl der stationär durchgeführten Rehabilitationsbehandlungen
        pub total_reha: Option<i64>,
        /// Bewegungsapparat
        ///
        /// Anzahl der Reha-Fälle bei Krankheiten des Muskel-Skelett-Systems und des Bindegewebes
        pub reha_muskelskelett: Option<i64>,
        /// Unfälle
        ///
        /// Anzahl der Reha-Fälle nach Verletzung, Vergiftung oder bestimmten anderen Folgen äusserer Ursachen
        pub reha_verletzung: Option<i64>,
        /// Herz-Kreislaufsystem
        ///
        /// Anzahl der Reha-Fälle bei Krankheit des Herz-Kreislaufsystems
        pub reha_kreislauf: Option<i64>,
        /// Andere Symptome
        ///
        /// Anzahl der Reha-Fälle bei anderen Symptomen oder abnormen klinischen (Labor-)Befunden (wie neurologische)
        pub reha_labor: Option<i64>,
        /// Neubildungen
        ///
        /// Anzahl der onkologisch-internistischen Reha-Fälle
        pub reha_neubildungen: Option<i64>,
        /// Übrige Rehabilitation
        ///
        /// Anzahl der Reha-Fälle aus anderen Gründen
        pub reha_uebrige: Option<i64>,
        /// Geopunkt
        ///
        /// Standort des Spitals
        pub geopunkt: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Spital,
        AngebotAkutsomatik,
        AngebotPsychiatrie,
        AngebotRehabilitation,
        TotalBetriebsertrag,
        TotalBetriebsertrag1000,
        TotalErtragLeistung,
        ErtragLeistungserstellungInMioChf,
        UbrigerBetriebsertragInMioChf,
        TotalBetriebsaufwand,
        BetriebsaufwandInMioChf,
        TotalKostenPersonal,
        PersonalkostenInMioChf,
        TotalBedarfMedizinisch,
        MedizinischerBedarfInMioChf,
        UbrigerAufwandInMioChf,
        Fte,
        AnzMa,
        Bettenbetriebstage,
        CaseMix,
        AnzFaelleAlle,
        Pflegetage,
        AnzLzpf,
        AnzAllgemein,
        AnzKvgAllgklasse,
        DrgFaelle,
        AnzKvgFaelle,
        AnzUvgIvFaelle,
        Bs,
        Bl,
        AgSo,
        Restschweiz,
        Ausland,
        Maennlich,
        Weiblich,
        Jahre020,
        Jahre2140,
        Jahre4160,
        Jahre6180,
        JahreUeber80,
        TotalAkutsomatik,
        Basispaket,
        Gastroenterologie,
        Geburtshilfe,
        Gefaesse,
        Gynaekologie,
        Hno,
        Haematologie,
        Herz,
        Neugeborene,
        Neurologie,
        Orthopaedie,
        RadioOnkologie,
        Pneumologie,
        Urologie,
        Viszeralchirurgie,
        Uebrige,
        TotalPsych,
        PsychAffektiv,
        PsychNeurotisch,
        PsychOrganisch,
        PsychPsychisch,
        PsychSchizophren,
        PsychUebrige,
        TotalReha,
        RehaMuskelskelett,
        RehaVerletzung,
        RehaKreislauf,
        RehaLabor,
        RehaNeubildungen,
        RehaUebrige,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Spital => "spital",
                Field::AngebotAkutsomatik => "angebot_akutsomatik",
                Field::AngebotPsychiatrie => "angebot_psychiatrie",
                Field::AngebotRehabilitation => "angebot_rehabilitation",
                Field::TotalBetriebsertrag => "total_betriebsertrag",
                Field::TotalBetriebsertrag1000 => "total_betriebsertrag_1000",
                Field::TotalErtragLeistung => "total_ertrag_leistung",
                Field::ErtragLeistungserstellungInMioChf => "ertrag_leistungserstellung_in_mio_chf",
                Field::UbrigerBetriebsertragInMioChf => "ubriger_betriebsertrag_in_mio_chf",
                Field::TotalBetriebsaufwand => "total_betriebsaufwand",
                Field::BetriebsaufwandInMioChf => "betriebsaufwand_in_mio_chf",
                Field::TotalKostenPersonal => "total_kosten_personal",
                Field::PersonalkostenInMioChf => "personalkosten_in_mio_chf",
                Field::TotalBedarfMedizinisch => "total_bedarf_medizinisch",
                Field::MedizinischerBedarfInMioChf => "medizinischer_bedarf_in_mio_chf",
                Field::UbrigerAufwandInMioChf => "ubriger_aufwand_in_mio_chf",
                Field::Fte => "fte",
                Field::AnzMa => "anz_ma",
                Field::Bettenbetriebstage => "bettenbetriebstage",
                Field::CaseMix => "case_mix",
                Field::AnzFaelleAlle => "anz_faelle_alle",
                Field::Pflegetage => "pflegetage",
                Field::AnzLzpf => "anz_lzpf",
                Field::AnzAllgemein => "anz_allgemein",
                Field::AnzKvgAllgklasse => "anz_kvg_allgklasse",
                Field::DrgFaelle => "drg_faelle",
                Field::AnzKvgFaelle => "anz_kvg_faelle",
                Field::AnzUvgIvFaelle => "anz_uvg_iv_faelle",
                Field::Bs => "bs",
                Field::Bl => "bl",
                Field::AgSo => "ag_so",
                Field::Restschweiz => "restschweiz",
                Field::Ausland => "ausland",
                Field::Maennlich => "maennlich",
                Field::Weiblich => "weiblich",
                Field::Jahre020 => "jahre_0_20",
                Field::Jahre2140 => "jahre_21_40",
                Field::Jahre4160 => "jahre_41_60",
                Field::Jahre6180 => "jahre_61_80",
                Field::JahreUeber80 => "jahre_ueber80",
                Field::TotalAkutsomatik => "total_akutsomatik",
                Field::Basispaket => "basispaket",
                Field::Gastroenterologie => "gastroenterologie",
                Field::Geburtshilfe => "geburtshilfe",
                Field::Gefaesse => "gefaesse",
                Field::Gynaekologie => "gynaekologie",
                Field::Hno => "hno",
                Field::Haematologie => "haematologie",
                Field::Herz => "herz",
                Field::Neugeborene => "neugeborene",
                Field::Neurologie => "neurologie",
                Field::Orthopaedie => "orthopaedie",
                Field::RadioOnkologie => "radio_onkologie",
                Field::Pneumologie => "pneumologie",
                Field::Urologie => "urologie",
                Field::Viszeralchirurgie => "viszeralchirurgie",
                Field::Uebrige => "uebrige",
                Field::TotalPsych => "total_psych",
                Field::PsychAffektiv => "psych_affektiv",
                Field::PsychNeurotisch => "psych_neurotisch",
                Field::PsychOrganisch => "psych_organisch",
                Field::PsychPsychisch => "psych_psychisch",
                Field::PsychSchizophren => "psych_schizophren",
                Field::PsychUebrige => "psych_uebrige",
                Field::TotalReha => "total_reha",
                Field::RehaMuskelskelett => "reha_muskelskelett",
                Field::RehaVerletzung => "reha_verletzung",
                Field::RehaKreislauf => "reha_kreislauf",
                Field::RehaLabor => "reha_labor",
                Field::RehaNeubildungen => "reha_neubildungen",
                Field::RehaUebrige => "reha_uebrige",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100320/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grillstellen in Gew\u{e4}ssern\u{e4}he"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Koordinaten gew\u{e4}ssernaher Grillstellen in Basel-Stadt.</p>"]
pub mod grillstellen_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Name
        ///
        /// Name der Grillstelle
        pub name: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Name,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Name => "name",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100284/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Strassennamen"]
#[doc = ""]
#[doc = "<p>Der Datensatz beinhaltet die Namen aller Strassen im Kanton Basel-Stadt sowie kurze Erl\u{e4}uterungen zur Bedeutung der Strassennamen der Stadt Basel. Die Felder zu den Erkl\u{e4}rungen sind ausserhalb des Stadtgebietes leer.</p><p>Der Datensatz darf f\u{fc}r Open Street Map verwendet werden.<br></p>"]
pub mod strassennamen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id Strasse
        ///
        /// Eindeutiger Identifikator
        pub strassenid: Option<i64>,
        /// Strassenname
        ///
        /// Name der Strasse in Langschreibweise (z.B. Strasse statt Str.)
        pub strname: Option<String>,
        /// Erklärung erste Zeile
        ///
        /// Erklärung der ersten Zeile des Strassenschildes
        pub kurzek_ez: Option<String>,
        /// Erklärung zweite Zeile
        ///
        /// Erklärung der zweiten Zeile des Strassenschildes
        pub kurzek_zz: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Erstmals erwähnt
        ///
        /// Jahr der ersten Erwähnung des Strassennamens
        pub erst_erwae: Option<String>,
        /// Amtlich benannt
        ///
        /// Jahr der amtlichen Benennung der Strasse
        pub amtlich_be: Option<String>,
        /// Indextext
        ///
        /// Kurzschreibweise des Strassennamens (z.B. Str. statt Strasse)
        pub indextext: Option<String>,
        /// Kurztext
        ///
        /// Indextext der Strasse
        pub kurztext: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Strassenid,
        Strname,
        KurzekEz,
        KurzekZz,
        ErstErwae,
        AmtlichBe,
        Indextext,
        Kurztext,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Strassenid => "strassenid",
                Field::Strname => "strname",
                Field::KurzekEz => "kurzek_ez",
                Field::KurzekZz => "kurzek_zz",
                Field::ErstErwae => "erst_erwae",
                Field::AmtlichBe => "amtlich_be",
                Field::Indextext => "indextext",
                Field::Kurztext => "kurztext",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100189/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sanit\u{e4}re Anlagen"]
#[doc = ""]
#[doc = "\u{d6}ffentliche sanit\u{e4}re Anlagen der Gemeinden Basel, Riehen und Bettingen: WC Anlage, WC Anlage rollstuhlg\u{e4}ngig, nur Pissoir, Dusche, Anlage geschlossen (in Sanierung oder geschlossen)."]
pub mod sanitaere_anlagen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Bezeichnung
        pub bezeichnug: Option<String>,
        /// Strasse
        ///
        /// Adresse
        pub strasse: Option<String>,
        /// Eurokey-Schloss
        ///
        /// Eurokey ist ein Schlüsselsystem für Menschen mit Behinderung. Dieser Universalschlüssel öffnet den Zugang zu Aufzügen, Toiletten, Umkleideräumen und anderen Anlagen, die für Menschen mit Behinderung eingerichtet sind.
        pub eurokey: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        pub www_link: Option<String>,
        /// Gebühr
        pub gebuehr: Option<String>,
        /// Kategorie
        pub kategorie: Option<String>,
        /// Typ
        pub typ: Option<String>,
        /// Zusatz
        pub zusatz: Option<String>,
        /// Status
        pub status: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Bezeichnug,
        Strasse,
        Eurokey,
        Plz,
        Ort,
        WwwLink,
        Gebuehr,
        Kategorie,
        Typ,
        Zusatz,
        Status,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Bezeichnug => "bezeichnug",
                Field::Strasse => "strasse",
                Field::Eurokey => "eurokey",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::WwwLink => "www_link",
                Field::Gebuehr => "gebuehr",
                Field::Kategorie => "kategorie",
                Field::Typ => "typ",
                Field::Zusatz => "zusatz",
                Field::Status => "status",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100031/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "T\u{e4}gliche Klimadaten der NBCN-Station Basel-Binningen"]
#[doc = ""]
#[doc = "<p>Tagesdaten der NBCN-Station (Swiss National Basic Climatological Network) Basel-Binningen der MeteoSchweiz. Komplette, <a href=\"https://www.meteoschweiz.admin.ch/klima/klimawandel/entwicklung-temperatur-niederschlag-sonnenschein/homogene-messreihen-ab-1864/homogenisierung-von-klima-messreihen.html\" target=\"_blank\">nicht homogenisierte</a>\u{a0} Datenreihe der wichtigsten Tageswerte seit Messbeginn.</p><p> Methodischer Hinweis:<br>Die Berechnung des Tagesmittels der Lufttemperatur erfolgte je nach historischer Zeitperiode unterschiedlich. <br>Bis 1980 wurden die Temperaturwerte nur dreimal t\u{e4}glich erfasst, der Mittelwert basiert entsprechend auf diesen drei Ablesungen. Ab 1981 liegen Stundenmittel zugrunde und ab 2018 10min-Werte. Das t\u{e4}gliche Minimum und Maximum der Lufttemperatur wurde bis 1980 anhand von Minimum- bzw. Maximum-Thermometern erfasst.</p>"]
pub mod taegliche_klimadaten_der_nbcn_station_basel_binningen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Jahr
        pub jahr: Option<String>,
        /// Globalstrahlung in W/m2
        ///
        /// Tagesmittel
        pub gre000d0: Option<f64>,
        /// Gesamtschneemenge
        ///
        /// Morgenmessung von 6 UTC
        pub hto000d0: Option<f64>,
        /// Gesamtbewölkung
        ///
        /// Tagesmittel
        pub nto000d0: Option<f64>,
        /// Luftdruck in hPa
        ///
        /// Tagesmittel auf Stationshöhe (QFE)
        pub prestad0: Option<f64>,
        /// Niederschlag
        ///
        /// Tagessumme 6 UTC - 6 UTC Folgetag
        pub rre150d0: Option<f64>,
        /// Sonnenscheindauer
        ///
        /// Tagessumme
        pub sre000d0: Option<f64>,
        /// Tagesmittel Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200d0: Option<f64>,
        /// Tagesminimum Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200dn: Option<f64>,
        /// Tagesmaximum Lufttemperatur
        ///
        /// 2 m über Boden
        ///Die Berechnung erfolgte je nach historischer Zeitperiode unterschiedlich - weitere Hinweise sind im Informationstext zu finden.
        pub tre200dx: Option<f64>,
        /// Relative Luftfeuchtigkeit
        ///
        /// Tagesmittel, 2 m über Boden
        pub ure200d0: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        Jahr,
        Gre000d0,
        Hto000d0,
        Nto000d0,
        Prestad0,
        Rre150d0,
        Sre000d0,
        Tre200d0,
        Tre200dn,
        Tre200dx,
        Ure200d0,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Jahr => "jahr",
                Field::Gre000d0 => "gre000d0",
                Field::Hto000d0 => "hto000d0",
                Field::Nto000d0 => "nto000d0",
                Field::Prestad0 => "prestad0",
                Field::Rre150d0 => "rre150d0",
                Field::Sre000d0 => "sre000d0",
                Field::Tre200d0 => "tre200d0",
                Field::Tre200dn => "tre200dn",
                Field::Tre200dx => "tre200dx",
                Field::Ure200d0 => "ure200d0",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100254/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wahl der 100 Mitglieder des Grossen Rates vom 25.10.2020"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Einzeldaten der Grossratswahl vom 25. Oktober 2020.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod wahl_der_100_mitglieder_des_grossen_rates_vom_25_10_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        ///
        /// Jahr, in dem die Wahl stattgefunden hat
        pub wahljahr: Option<String>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub status: Option<String>,
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze Wahlkreis
        ///
        /// Anzahl Sitze, die für einen Wahlkreis zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listennummer
        ///
        /// Nummer der Liste
        pub listennummer: Option<String>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<String>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<i64>,
        /// Kumulation
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat auf einem unveränderten Wahlzettel mehrfach aufgeführt ist
        pub kumulation: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Alter am Jahresende 2020
        ///
        /// Alter, berechnet nach der Formel "2020 minus Jahrgang"
        pub alter: Option<i64>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus unveränderten Wahlzetteln
        pub stimmen_uvwz: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus veränderten Wahlzetteln
        pub stimmen_vwz: Option<i64>,
        /// Stimmen Total
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten. Die Summe dieser Stimmen über eine Partei ergibt nicht das Total der Parteistimmen, weil so die leeren Linien auf Parteilisten nicht mitgezählt werden.
        pub stimmen_total: Option<i64>,
        /// Rangfolge
        ///
        /// Rangfolge innerhalb einer Liste gemäss Anzahl Stimmen (bei Stimmengleichheit entscheidet das Los).
        pub rangfolge: Option<i64>,
        /// 00 Ohne
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer Liste ohne Bezeichnung
        pub x00_ohne: Option<i64>,
        /// 01 FDP
        ///
        /// FDP. Die Liberalen Basel-Stadt und Jungfreisinnige; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x01_fdp: Option<i64>,
        /// 02 PP
        ///
        /// PIRATEN - Piratenpartei beider Basel; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x02_pp: Option<i64>,
        /// 03 LDP
        ///
        /// LDP Liberal-Demokratische Partei Basel-Stadt und Jungliberale; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x03_ldp: Option<i64>,
        /// 04 EVP
        ///
        /// Evangelische Volkspartei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x04_evp: Option<i64>,
        /// 05 SP
        ///
        /// Sozialdemokratische Partei Basel-Stadt (SP) und JUSO; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x05_sp: Option<i64>,
        /// 07 CVP
        ///
        /// CVP Basel-Stadt und Junge CVP Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x07_cvp: Option<i64>,
        /// 08 GB
        ///
        /// Bündnis Grüne, BastA!, junges grünes bündnis; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x08_gb: Option<i64>,
        /// 10 GLP
        ///
        /// Grünliberale Partei Basel-Stadt; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x10_glp: Option<i64>,
        /// 12 SVP
        ///
        /// Schweizerische Volkspartei Basel-Stadt (SVP); Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x12_svp: Option<i64>,
        /// 13 FUK
        ///
        /// freistaat unteres kleinbasel f-u-k.ch; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x13_fuk: Option<i64>,
        /// 14 VA
        ///
        /// Volks-Aktion gegen zuviele Ausländer und Asylanten in unserer Heimat (VA) - Liste Ausländerstopp; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x14_va: Option<i64>,
        /// 16 AB
        ///
        /// Aktives Bettingen; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x16_ab: Option<String>,
        /// 19 BDV
        ///
        /// Bettinger Dorfvereinigung - BDV; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x19_bdv: Option<String>,
        /// 28 PB
        ///
        /// Parteiloser Bürger für eine Untersuchung der Coronamassnahmen; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x28_pb: Option<i64>,
        /// 29 KL
        ///
        /// Kommunistische Liste - Partei der Arbeit Schweiz; Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer veränderten Liste dieser Partei
        pub x29_kl: Option<i64>,
        /// Laufnummer
        ///
        /// Kandidaten-Laufnummer
        pub laufnummer: Option<i64>,
        /// Jahrgang numerisch
        ///
        /// Jahrgang in numerischem Format
        pub jahrgang_num: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Status,
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        Listennummer,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        PersonenId,
        Kumulation,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Alter,
        Anrede,
        Beruf,
        StimmenUvwz,
        StimmenVwz,
        StimmenTotal,
        Rangfolge,
        X00Ohne,
        X01Fdp,
        X02Pp,
        X03Ldp,
        X04Evp,
        X05Sp,
        X07Cvp,
        X08Gb,
        X10Glp,
        X12Svp,
        X13Fuk,
        X14Va,
        X16Ab,
        X19Bdv,
        X28Pb,
        X29Kl,
        Laufnummer,
        JahrgangNum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Status => "status",
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::Listennummer => "listennummer",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Alter => "alter",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::StimmenUvwz => "stimmen_uvwz",
                Field::StimmenVwz => "stimmen_vwz",
                Field::StimmenTotal => "stimmen_total",
                Field::Rangfolge => "rangfolge",
                Field::X00Ohne => "00_ohne",
                Field::X01Fdp => "01_fdp",
                Field::X02Pp => "02_pp",
                Field::X03Ldp => "03_ldp",
                Field::X04Evp => "04_evp",
                Field::X05Sp => "05_sp",
                Field::X07Cvp => "07_cvp",
                Field::X08Gb => "08_gb",
                Field::X10Glp => "10_glp",
                Field::X12Svp => "12_svp",
                Field::X13Fuk => "13_fuk",
                Field::X14Va => "14_va",
                Field::X16Ab => "16_ab",
                Field::X19Bdv => "19_bdv",
                Field::X28Pb => "28_pb",
                Field::X29Kl => "29_kl",
                Field::Laufnummer => "laufnummer",
                Field::JahrgangNum => "jahrgang_num",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100101/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Gesch\u{e4}fte"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz bietet eine umfassende \u{dc}bersicht \u{fc}ber Gesch\u{e4}fte, die im Grossen Rat des Kantons Basel-Stadt behandelt werden.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br><a href=\"https://grosserrat.bs.ch/\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_geschaefte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Beginn Geschäft
        ///
        /// Datum, an dem des Geschäft zum ersten mal traktandiert ist.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub beginn_ges: Option<Date>,
        /// Ende Geschäft
        ///
        /// Abschlussdatum des Geschäfts
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub ende_ges: Option<Date>,
        /// Laufnummer
        ///
        /// Laufnummer des Geschäfts
        pub laufnr_ges: Option<String>,
        /// Signatur
        ///
        /// Signatur des Geschäfts
        pub signatur_ges: Option<String>,
        /// Status
        ///
        /// Status des Geschäfts (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Geschäfts
        pub titel_ges: Option<String>,
        /// Department
        ///
        /// Falls der Urheber des Geschäfts der Regierungsrat ist, wird erfasst, welches Departement das Geschäft erfasst hat.
        pub departement_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Geschäfts
        pub ga_rr_gr: Option<String>,
        /// Link Geschäft
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Link Zuweisungen
        ///
        /// Link zum Datensatz "Grosser Rat: Zuweisungen". Gefiltert nach aktuellem Geschäft.
        pub url_zuweisungen: Option<String>,
        /// Link Dokumente
        ///
        /// Link zum Datensatz "Grosser Rat: Dokumente". Gefiltert nach aktuellem Geschäft.
        pub url_dokumente: Option<String>,
        /// Link Vorgänge
        ///
        /// Link zum Datensatz "Grosser Rat: Vorgänge von Geschäften". Gefiltert nach aktuellem Geschäft.
        pub url_vorgaenge: Option<String>,
        /// Anrede Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier die Anrede nach amtlichen Geschlecht festgehalten.
        pub anrede_urheber: Option<String>,
        /// Gremientyp Urheber
        ///
        /// Wenn Urheber ein Gremium ist, dann wird hier der Typ des Gremiums festgehalten (Kommission oder Regierungsrat).
        pub gremientyp_urheber: Option<String>,
        /// Name Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Nachname der Person festgehalten. Ansonsten der Name des Gremiums.
        pub name_urheber: Option<String>,
        /// Vorname/Gremienkurzname Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Vorname der Person festgehalten. Ansonsten der Kurzname des Gremiums.
        pub vorname_urheber: Option<String>,
        /// Name, Vorname Urheber
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Ganze Name der Person festgehalten.
        pub name_vorname_urheber: Option<String>,
        /// Partei Urheber abgekürzt
        ///
        /// Wenn Urheber eine Person und noch aktuell Grossratsmitglied ist, dann wird hier die Abkürzung der Parteizugehörigkeit festgehalten.
        pub partei_kname_urheber: Option<String>,
        /// Urheber grosserrat.bs.ch
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Link zum Grossratsmitglied auf der Webseite des Grossen Rates festgehalten.
        pub url_urheber: Option<String>,
        /// ID Urheber
        ///
        /// Individuelle Identifikationsnummer des Urhebers innerhalb der Datenbank des Grossen Rates.
        pub nr_urheber: Option<String>,
        /// Urheber data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach dem aktuellen Urheber.
        pub url_urheber_ratsmitgl: Option<String>,
        /// Anrede Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier die Anrede nach amtlichen Geschlecht festgehalten.
        pub anrede_miturheber: Option<String>,
        /// Gremientyp Miturheber
        ///
        /// Wenn Miturheber ein Gremium ist, dann wird hier der Typ des Gremiums festgehalten (Kommission oder Regierungsrat).
        pub gremientyp_miturheber: Option<String>,
        /// Name Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier der Nachname der Person festgehalten. Ansonsten der Name des Gremiums.
        pub name_miturheber: Option<String>,
        /// Vorname/Gremienkurzname Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier der Vorname der Person festgehalten. Ansonsten der Kurzname des Gremiums.
        pub vorname_miturheber: Option<String>,
        /// Name, Vorname Miturheber
        ///
        /// Wenn Miturheber eine Person ist, dann wird hier der Ganze Name der Person festgehalten.
        pub name_vorname_miturheber: Option<String>,
        /// Partei Miturheber abgekürzt
        ///
        /// Wenn Miturheber eine Person und noch aktuell Grossratsmitglied ist, dann wird hier die Abkürzung der Parteizugehörigkeit festgehalten.
        pub partei_kname_miturheber: Option<String>,
        /// Miturheber grosserrat.bs.ch
        ///
        /// Wenn Urheber eine Person ist, dann wird hier der Link zum Grossratsmitglied auf der Webseite des Grossen Rates festgehalten.
        pub url_miturheber: Option<String>,
        /// ID Miturheber
        ///
        /// Individuelle Identifikationsnummer des Miturhebers innerhalb der Datenbank des Grossen Rates.
        pub nr_miturheber: Option<String>,
        /// Miturheber data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach dem aktuellen Miturheber.
        pub url_miturheber_ratsmitgl: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        BeginnGes,
        EndeGes,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        DepartementGes,
        GaRrGr,
        UrlGes,
        UrlZuweisungen,
        UrlDokumente,
        UrlVorgaenge,
        AnredeUrheber,
        GremientypUrheber,
        NameUrheber,
        VornameUrheber,
        NameVornameUrheber,
        ParteiKnameUrheber,
        UrlUrheber,
        NrUrheber,
        UrlUrheberRatsmitgl,
        AnredeMiturheber,
        GremientypMiturheber,
        NameMiturheber,
        VornameMiturheber,
        NameVornameMiturheber,
        ParteiKnameMiturheber,
        UrlMiturheber,
        NrMiturheber,
        UrlMiturheberRatsmitgl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BeginnGes => "beginn_ges",
                Field::EndeGes => "ende_ges",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::DepartementGes => "departement_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlZuweisungen => "url_zuweisungen",
                Field::UrlDokumente => "url_dokumente",
                Field::UrlVorgaenge => "url_vorgaenge",
                Field::AnredeUrheber => "anrede_urheber",
                Field::GremientypUrheber => "gremientyp_urheber",
                Field::NameUrheber => "name_urheber",
                Field::VornameUrheber => "vorname_urheber",
                Field::NameVornameUrheber => "name_vorname_urheber",
                Field::ParteiKnameUrheber => "partei_kname_urheber",
                Field::UrlUrheber => "url_urheber",
                Field::NrUrheber => "nr_urheber",
                Field::UrlUrheberRatsmitgl => "url_urheber_ratsmitgl",
                Field::AnredeMiturheber => "anrede_miturheber",
                Field::GremientypMiturheber => "gremientyp_miturheber",
                Field::NameMiturheber => "name_miturheber",
                Field::VornameMiturheber => "vorname_miturheber",
                Field::NameVornameMiturheber => "name_vorname_miturheber",
                Field::ParteiKnameMiturheber => "partei_kname_miturheber",
                Field::UrlMiturheber => "url_miturheber",
                Field::NrMiturheber => "nr_miturheber",
                Field::UrlMiturheberRatsmitgl => "url_miturheber_ratsmitgl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100311/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): Tests Basel-Stadt"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Anzahl Tests auf SARS-CoV-2, welche an Personen mit Wohnsitz im Kanton Basel-Stadt durchgef\u{fc}hrt wurden sowie die entsprechenden Testresultate (positiv/negativ) und separiert nach PCR Test bzw. Antigen Schnelltest auf t\u{e4}glicher Basis. Die Angaben wurden t\u{e4}glich durch das Bundesamt f\u{fc}r Gesundheit (BAG) zur Verf\u{fc}gung gestellt im <a href=\"https://www.covid19.admin.ch\" target=\"_blank\">Covid-19 Situationsbericht</a>\u{a0}bzw. \u{fc}ber dessen <a href=\"https://www.covid19.admin.ch/api/data/context\" target=\"_blank\">API</a>.\u{a0}</p><p>Die Zahlen von Freitag, Samstag und Sonntag wurden durch das BAG jeweils am Montag aktualisiert.</p><p><b>Die Erhebung der Anzahl Tests auf SARS-CoV-2 wurde per 16. Januar 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.</b><br/></p><p>Die Zahlen f\u{fc}r alle Kantone sowie f\u{fc}r die gesamte Schweiz und das F\u{fc}rstentum Liechtenstein sind in diesem Datensatz zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100116\" target=\"_blank\">https://data.bs.ch/explore/dataset/100116</a></p>"]
pub mod coronavirus_covid_19_tests_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Falldatum, entspricht in der Regel dem Datum der Probeentnahme
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Negative Tests
        ///
        /// Anzahl negative Tests. Eine Person kann mehrfach negativ getestet werden.
        pub negative_tests: Option<i64>,
        /// Positive Tests
        ///
        /// Anzahl positive Tests. Eine Person kann mehrfach positiv getestet werden.
        pub positive_tests: Option<i64>,
        /// Total Tests
        ///
        /// Anzahl durchgeführte Tests total. Eine Person kann mehrfach getestet werden.
        pub total_tests: Option<i64>,
        /// Anteil positive Tests in Prozent
        ///
        /// Anteil Tests mit einem positiven Ergebnis am Total der Tests in Prozent.
        pub positivity_rate_percent: Option<f64>,
        /// Anteil positive Tests
        ///
        /// Anteil Tests mit einem positiven Ergebnis am Total der Tests.
        pub positivity_rate: Option<f64>,
        /// Wochentag
        ///
        /// Wochentag des Falldatums. Mo=1, Di=2, Mi=3, Do=4, Fr = 5, Sa = 6, So = 7
        pub dayofweek: Option<i64>,
        /// Wochentag Nummer
        ///
        /// Nummer des Wochentags (Montag=0, Sonntag=6)
        pub weekday_nr: Option<i64>,
        /// Woche
        ///
        /// Wochennummer
        pub woche: Option<i64>,
        /// Total Antigen Schnelltests
        ///
        /// Anzahl durchgeführte Antigen Schnelltests total. Eine Person kann mehrfach getestet werden.
        pub entries_antigen_schnelltest: Option<i64>,
        /// Total PCR Tests
        ///
        /// Anzahl durchgeführte PCR Tests total. Eine Person kann mehrfach getestet werden.
        pub entries_pcr: Option<i64>,
        /// Negative Antigen Schnelltests
        ///
        /// Anzahl negative Antigen Schnelltests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_neg_antigen_schnelltest: Option<i64>,
        /// Negative PCR Tests
        ///
        /// Anzahl negative PCR Tests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_neg_pcr: Option<i64>,
        /// Positive Antigen Schnelltests
        ///
        /// Anzahl positive Antigen Schnelltests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_pos_antigen_schnelltest: Option<i64>,
        /// Positive PCR Tests
        ///
        /// Anzahl positive PCR Tests. Eine Person kann mehrfach negativ getestet werden.
        pub entries_pos_pcr: Option<i64>,
        /// Anteil positive Antigen Schnelltests
        ///
        /// Anteil Antigen Schnelltests mit einem positiven Ergebnis am Total der Antigen Schnelltests.
        pub positivity_rate_antigen_schnelltest: Option<f64>,
        /// Anteil positive PCR Tests
        ///
        /// Anteil PCR Tests mit einem positiven Ergebnis am Total der PCR Tests.
        pub positivity_rate_pcr: Option<f64>,
        /// Anteil positive Antigen Schnelltests in Prozent
        ///
        /// Anteil Antigen Schnelltests mit einem positiven Ergebnis am Total der Antigen Schnelltests.
        pub positivity_rate_percent_antigen_schnelltest: Option<f64>,
        /// Anteil positive PCR Tests in Prozent
        ///
        /// Anteil PCR Tests mit einem positiven Ergebnis am Total der PCR Tests.
        pub positivity_rate_percent_pcr: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        NegativeTests,
        PositiveTests,
        TotalTests,
        PositivityRatePercent,
        PositivityRate,
        Dayofweek,
        WeekdayNr,
        Woche,
        EntriesAntigenSchnelltest,
        EntriesPcr,
        EntriesNegAntigenSchnelltest,
        EntriesNegPcr,
        EntriesPosAntigenSchnelltest,
        EntriesPosPcr,
        PositivityRateAntigenSchnelltest,
        PositivityRatePcr,
        PositivityRatePercentAntigenSchnelltest,
        PositivityRatePercentPcr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::NegativeTests => "negative_tests",
                Field::PositiveTests => "positive_tests",
                Field::TotalTests => "total_tests",
                Field::PositivityRatePercent => "positivity_rate_percent",
                Field::PositivityRate => "positivity_rate",
                Field::Dayofweek => "dayofweek",
                Field::WeekdayNr => "weekday_nr",
                Field::Woche => "woche",
                Field::EntriesAntigenSchnelltest => "entries_antigen_schnelltest",
                Field::EntriesPcr => "entries_pcr",
                Field::EntriesNegAntigenSchnelltest => "entries_neg_antigen_schnelltest",
                Field::EntriesNegPcr => "entries_neg_pcr",
                Field::EntriesPosAntigenSchnelltest => "entries_pos_antigen_schnelltest",
                Field::EntriesPosPcr => "entries_pos_pcr",
                Field::PositivityRateAntigenSchnelltest => "positivity_rate_antigen_schnelltest",
                Field::PositivityRatePcr => "positivity_rate_pcr",
                Field::PositivityRatePercentAntigenSchnelltest => {
                    "positivity_rate_percent_antigen_schnelltest"
                }
                Field::PositivityRatePercentPcr => "positivity_rate_percent_pcr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100094/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Veloabstellpl\u{e4}tze"]
#[doc = ""]
#[doc = "Der Datensatz beinhaltet alle Veloabstellpl\u{e4}tze auf \u{f6}ffentlichem Grund, die grossen Abstellanlagen bei den Bahnh\u{f6}fen, Velostationen, Bike+Ride-Anlagen und Cargovelo-Pl\u{e4}tze. Die Punkte befinden sich in der Mitte der Parkfelder."]
pub mod veloabstellplaetze {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Veloabstellplatz
        ///
        /// Eindeutiger Identifikator
        pub id_platz: Option<i64>,
        /// Typ
        ///
        /// Art des Abstellplatzes
        pub typ: Option<String>,
        /// Strasse
        ///
        /// Strassenname des Standort
        pub strasse: Option<String>,
        /// Tarif
        ///
        /// Tarif für Benutzung des Abstellplatzes
        pub tarif: Option<String>,
        /// Anzahl Velos
        ///
        /// Anzahl Stellplätze für Velos/Motorräder
        pub anzvelos: Option<i64>,
        /// Anschliessbar
        ///
        /// Vorrichtung für Anschliessung vorhanden
        pub anschliess: Option<String>,
        /// Gedeckt
        ///
        /// Dach vorhanden
        pub gedeckt: Option<String>,
        /// Zugänglichkeit
        pub zugang: Option<String>,
        /// Infos
        ///
        /// Internetadresse
        pub infos: Option<String>,
        /// Platz Cargovelos
        ///
        /// Gibt es Platz für Cargovelos
        pub cargovelo: Option<String>,
        /// Bike Ride
        ///
        /// Bike + Ride
        pub bikeride: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdPlatz,
        Typ,
        Strasse,
        Tarif,
        Anzvelos,
        Anschliess,
        Gedeckt,
        Zugang,
        Infos,
        Cargovelo,
        Bikeride,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdPlatz => "id_platz",
                Field::Typ => "typ",
                Field::Strasse => "strasse",
                Field::Tarif => "tarif",
                Field::Anzvelos => "anzvelos",
                Field::Anschliess => "anschliess",
                Field::Gedeckt => "gedeckt",
                Field::Zugang => "zugang",
                Field::Infos => "infos",
                Field::Cargovelo => "cargovelo",
                Field::Bikeride => "bikeride",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100241/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Velopumpen"]
#[doc = ""]
#[doc = "<p></p><p>Dieser Datensatz zeigt die von Veloh\u{e4}ndlern f\u{fc}r die \u{d6}ffentlichkeit verf\u{fc}gbaren Velopumpen.</p>"]
pub mod velopumpen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Velopumpe
        ///
        /// Eindeutiger Identifikator der Velopumpe
        pub id_pumpe: Option<i64>,
        /// Händler
        ///
        /// Händlername
        pub haendler: Option<String>,
        /// Strasse
        ///
        /// Strasse und Hausnummer
        pub strasse: Option<String>,
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        pub ort: Option<String>,
        /// Pumpentyp
        ///
        /// Kategorien unterschiedlicher Pumpentypen
        pub pumpe: Option<String>,
        /// Verfügbarkeit
        ///
        /// Kategorien unterschiedlicher Verfügbarkeit. Der Wert „7/24“ in den Daten entspricht im Modell dem wert „jederzeit“.
        pub verfuegbar: Option<String>,
        /// Link
        ///
        /// Webseite
        pub link: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdPumpe,
        Haendler,
        Strasse,
        Plz,
        Ort,
        Pumpe,
        Verfuegbar,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdPumpe => "id_pumpe",
                Field::Haendler => "haendler",
                Field::Strasse => "strasse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Pumpe => "pumpe",
                Field::Verfuegbar => "verfuegbar",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100213/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsberuhigte Zonen: Kernzone Verkehrskonzept Innenstadt"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet das Verkehrskonzept Innenstadt (VKI): Kernzone mit eingeschr\u{e4}nktem Motorfahrzeugverkehr.<br/>Die verkehrsberuhigten Zonen setzen sich aus Fussg\u{e4}ngerzonen, Begegnungszonen und Tempo 30-Zonen zusammen. Ebenso ist der Perimeter des Verkehrskonzepts Innenstadt mit der Kernzone mit eingeschr\u{e4}nktem Motorfahrzeugverkehr dargestellt.<br/>Weitere Daten zu \"Verkehrsberuhigte Zonen\": <a href=\"https://data.bs.ch/explore/?sort=modified&amp;q=tags=Verkehrsberuhigte+Zonen\">https://data.bs.ch/explore/?sort=modified&amp;q=tags=Verkehrsberuhigte+Zonen</a>"]
pub mod verkehrsberuhigte_zonen_kernzone_verkehrskonzept_innenstadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Objekt-ID
        ///
        /// Identifikationsnummer (für kantonsinterne Zwecke verwendet)
        pub objid: Option<String>,
        /// Objekt-ID
        ///
        /// Identifikationsnummer (für kantonsinterne Zwecke verwendet)
        pub objectid: Option<i64>,
        /// Name
        pub name: Option<String>,
        /// Infos
        pub infos: Option<String>,
        /// Zufahrt
        pub zufahrt: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Objectid,
        Name,
        Infos,
        Zufahrt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Objectid => "objectid",
                Field::Name => "name",
                Field::Infos => "infos",
                Field::Zufahrt => "zufahrt",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100253/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Strassen und Wege: Kantonsstrassen Riehen und Bettingen"]
#[doc = ""]
#[doc = "Dieser Datensatz ist Teil des kantonalen Geodatenmodells des Kantons Basel-Stadt \"Strassen und Wege\" und stellt die Kantonsstrassen Riehen und Bettingen dar. <br>Weitere Daten zu \"Strassen und Wege\":<a href=\"https://data.bs.ch/explore/?refine.tags=Strassen+und+Wege\">https://data.bs.ch/explore/?refine.tags=Strassen+und+Wege</a><br>\nDie Kantonsstrassen Riehen und Bettingen zeigen die Kantonsstrassen in Riehen und Bettingen."]
pub mod strassen_und_wege_kantonsstrassen_riehen_und_bettingen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_KS_Riehen_Bettingen
        ///
        /// Eindeutiger Identifikator der Kantonsstrassen in Riehen und Bettingen
        pub id_ksrb: Option<i64>,
        /// Gemeinde
        ///
        /// Gemeinden (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub gemeinde: Option<String>,
        /// Eigentum
        ///
        /// Eigentümer
        pub eigentum: Option<String>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdKsrb,
        Gemeinde,
        Eigentum,
        Strasse,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdKsrb => "id_ksrb",
                Field::Gemeinde => "gemeinde",
                Field::Eigentum => "eigentum",
                Field::Strasse => "strasse",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100249/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Nutzungsplan - Zonenplan Riehen:  \u{dc}berlagernde Festlegungen"]
#[doc = ""]
#[doc = "Der Zonenplan legt Ort, Art und Mass der Bodennutzung f\u{fc}r ein bestimmtes Gebiet parzellenscharf und grundeigent\u{fc}merverbindlich fest. Zonenplan Riehen gem\u{e4}ss Beschluss des Riehener Einwohnerrats vom 27.11.2014 + 24.09.2015 und Genehmigung des Regierungsrates Basel-Stadt vom 7. Dezember 2016. Der Datensatz enth\u{e4}lt den Zonenplan sowie die Perimeter der Bebauungspl\u{e4}ne, der Speziellen Nutzungsvorschriften und des Nutzungsplans Stettenfeld.<br>Weitere Daten zum Thema ?Nutzungsplanung?: <a href=\"https://data.bs.ch/explore/?refine.tags=Nutzungsplanung\">https://data.bs.ch/explore/?refine.tags=Nutzungsplanung</a>"]
pub mod nutzungsplan_zonenplan_riehen_ueberlagernde_festlegungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Überlagende_Festlegung
        ///
        /// Eindeutiger Identifikator
        pub idueberfes: Option<String>,
        /// Festlegung Abk.
        ///
        /// Kürzel der Art der Festlegung
        pub festueber: Option<String>,
        /// Festlegung
        ///
        /// Art der Festlegung
        pub festuebtxt: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Verbindlichkeit
        pub verbindli: Option<String>,
        /// Schutzzweck
        ///
        /// Schutzzweck von Natur- und Landschaftsschutzzonen
        pub schutzzwec: Option<String>,
        /// rekurshängig
        ///
        /// 1 (bzw. true) wenn ein Rekurs vorhanden ist. Wenn ein Rekurs hängig ist, enthält das Objekt die neue, geplante Ausprägung, entgegen dem Geschäftsstatus ist diese jedoch noch nicht in Kraft.
        pub rekurshaen: Option<String>,
        /// Bezeichnung
        ///
        /// Bezeichnung der Festlegung
        pub bezeichnng: Option<String>,
        /// Id_Geschäft
        ///
        /// Eindeutiger Identifikator
        pub idgeschae: Option<String>,
        /// Geschäftsstatus
        pub geschaesta: Option<String>,
        /// Datum Status
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        pub geolink: Option<String>,
        /// Geschäftsbezeichnung
        pub geschaebez: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idueberfes,
        Festueber,
        Festuebtxt,
        Verbindli,
        Schutzzwec,
        Rekurshaen,
        Bezeichnng,
        Idgeschae,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idueberfes => "idueberfes",
                Field::Festueber => "festueber",
                Field::Festuebtxt => "festuebtxt",
                Field::Verbindli => "verbindli",
                Field::Schutzzwec => "schutzzwec",
                Field::Rekurshaen => "rekurshaen",
                Field::Bezeichnng => "bezeichnng",
                Field::Idgeschae => "idgeschae",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100256/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Nutzungsplan - Zonenplan Bettingen:  \u{dc}berlagernde Festlegungen"]
#[doc = ""]
#[doc = "Zonenplan der Gemeinde Bettingen gem\u{e4}ss Beschluss der Einwohnergemeindeversammlung vom 2. Dezember 2008 und der Genehmigung des Bau- und Verkehrsdepartements vom 1.7.2009. Der Datensatz enth\u{e4}lt den Zonenplan und die Bebauungspl\u{e4}ne ist ein Teil des Geodatenmodelles des Kantons Basel-Stadt zum Thema ?Nutzungsplanung?.<br>Weitere Daten zum Thema ?Nutzungsplanung?: <a href=\"https://data.bs.ch/explore/?refine.tags=Nutzungsplanung\">https://data.bs.ch/explore/?refine.tags=Nutzungsplanung</a>"]
pub mod nutzungsplan_zonenplan_bettingen_ueberlagernde_festlegungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Überlagende_Festlegung
        ///
        /// Eindeutiger Identifikator
        pub idueberfes: Option<String>,
        /// Festlegung überlagernd
        ///
        /// Art der Festlegung
        pub festueber: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Verbindlichkeit
        pub verbindli: Option<String>,
        /// rekurshängig
        ///
        /// 1 (bzw. true) wenn ein Rekurs vorhanden ist. Wenn ein Rekurs hängig ist, enthält das Objekt die neue, geplante Ausprägung, entgegen dem Geschäftsstatus ist diese jedoch noch nicht in Kraft.
        pub rekurshaen: Option<String>,
        /// Bezeichnung
        ///
        /// Bezeichnung der Festlegung
        pub bezeichnng: Option<String>,
        /// Id_Geschäft
        ///
        /// Eindeutiger Identifikator
        pub idgeschae: Option<String>,
        /// Geschäftsstatus
        pub geschaesta: Option<String>,
        /// Datum Status
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        pub geolink: Option<String>,
        /// Geschäftsbezeichnung
        pub geschaebez: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idueberfes,
        Festueber,
        Verbindli,
        Rekurshaen,
        Bezeichnng,
        Idgeschae,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idueberfes => "idueberfes",
                Field::Festueber => "festueber",
                Field::Verbindli => "verbindli",
                Field::Rekurshaen => "rekurshaen",
                Field::Bezeichnng => "bezeichnng",
                Field::Idgeschae => "idgeschae",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100257/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsberuhigte Zonen: Fussg\u{e4}ngerzone"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet die signalisierten Fussg\u{e4}ngerzonen.<br>Die verkehrsberuhigten Zonen setzen sich aus Fussg\u{e4}ngerzonen, Begegnungszonen und Tempo 30-Zonen zusammen. Ebenso ist der Perimeter des Verkehrskonzepts Innenstadt mit der Kernzone mit eingeschr\u{e4}nktem Motorfahrzeugverkehr dargestellt.<br>Weitere Daten zu \"Verkehrsberuhigte Zonen\": <a href=\"https://data.bs.ch/explore/?refine.tags=Verkehrsberuhigte+Zonen\">https://data.bs.ch/explore/?refine.tags=Verkehrsberuhigte+Zonen</a>"]
pub mod verkehrsberuhigte_zonen_fussgaengerzone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Fussgängerzone
        ///
        /// Eindeutiger Identifikator der Fussgängerzonen
        pub id_fussgae: Option<String>,
        /// Regime
        ///
        /// Regime der Zone
        pub regime: Option<String>,
        /// Regimenummer
        ///
        /// Nummer des Regimes
        pub regimenr: Option<String>,
        /// Name
        ///
        /// Name des Regimes
        pub name: Option<String>,
        /// Umsetzungsdatum
        ///
        /// Datum der Umsetzung
        pub umdatum: Option<String>,
        /// Umsetzungsjahr
        ///
        /// Jahr der Umsetzung
        pub umjahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdFussgae,
        Regime,
        Regimenr,
        Name,
        Umdatum,
        Umjahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdFussgae => "id_fussgae",
                Field::Regime => "regime",
                Field::Regimenr => "regimenr",
                Field::Name => "name",
                Field::Umdatum => "umdatum",
                Field::Umjahr => "umjahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100251/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte der Smiley-Geschwindigkeitsanzeigen"]
#[doc = ""]
#[doc = "Die Smiley-Geschwindigkeitsanzeigen dienen der Kantonspolizei Basel-Stadt zur Erh\u{f6}hung der Verkehrssicherheit an der betreffenden \u{d6}rtlichkeit. Die Wechselanzeige von der aktuell gefahrenen Geschwindigkeit und Smiley-Symbol (Lob oder Tadel) ohne Repression weist auf freundliche Weise auf ein allf\u{e4}lliges Fahrverhalten hin. Durch diese Selbstkontrolle soll das Fahrverhalten positiv beeinflusst, die vorgeschriebene Geschwindigkeit besser eingehalten und die Aufmerksamkeit der Verkehrsteilnehmenden erh\u{f6}ht werden. Mit den Ger\u{e4}ten k\u{f6}nnen zudem Verkehrsdaten anonym erfasst werden. Die Geschwindigkeitsanzeigen stehen nicht in einem Zusammenhang mit Ordnungsbussen oder einer strafrechtlichen Verfolgung."]
pub mod standorte_der_smiley_geschwindigkeitsanzeigen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Smiley
        ///
        /// Eindeutiger Identifikator (ID)
        pub id_smiley: Option<i64>,
        /// Id_Standort
        ///
        /// Identifikator des Standorts
        pub idstandort: Option<i64>,
        /// Strassennamen
        ///
        /// Strassenname des Standorts, an dem Smiley-Geschwindigkeitsanzeige platziert wird
        pub strname: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer des Standorts, an dem Smiley-Geschwindigkeitsanzeige aufgestellt wird, falls keine vorhanden Detailangabe zu Standort in Attribut «Hinweis»
        pub hausnr: Option<String>,
        /// Geschwindigkeit
        ///
        /// Signalisierte Geschwindigkeit (20 km/h, 30 km/h, 40 km/h, 50 km/h, 60 km/h, 80 km/h)
        pub geschwind: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung in Form des Strassenamens der anzufahrenden Strasse
        pub richtung: Option<String>,
        /// Hinweis
        ///
        /// Detailangaben zum Standort
        pub hinweis: Option<String>,
        /// Status
        pub status: Option<String>,
        /// Messbeginn
        ///
        /// Datum des Beginn Smiley-Geschwindigkeitsanzeigen-Betriebs
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbegin: Option<Date>,
        /// Messende
        ///
        /// Datum des Ende Smiley-Geschwindigkeitsanzeigen-Betriebs
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// OGD-Link-Einzelmessung
        ///
        /// Link zur Einzelmessung auf OGD
        pub ogdeinzel: Option<String>,
        /// OGD-Link-Analyse
        ///
        /// Link zur Analyse auf OGD
        pub odganalyse: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdSmiley,
        Idstandort,
        Strname,
        Hausnr,
        Geschwind,
        Richtung,
        Hinweis,
        Status,
        Messbegin,
        Messende,
        Ogdeinzel,
        Odganalyse,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdSmiley => "id_smiley",
                Field::Idstandort => "idstandort",
                Field::Strname => "strname",
                Field::Hausnr => "hausnr",
                Field::Geschwind => "geschwind",
                Field::Richtung => "richtung",
                Field::Hinweis => "hinweis",
                Field::Status => "status",
                Field::Messbegin => "messbegin",
                Field::Messende => "messende",
                Field::Ogdeinzel => "ogdeinzel",
                Field::Odganalyse => "odganalyse",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100286/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Strassen und Wege: Strassentypen und Wege"]
#[doc = ""]
#[doc = "Dieser Datensatz ist Teil des kantonalen Geodatenmodells des Kantons Basel-Stadt \"Strassen und Wege\" und stellt die Strassentypen und Wege dar. <br>Weitere Daten zu \"Strassen und Wege\": <a href=\"https://data.bs.ch/explore/?refine.tags=Strassen+und+Wege\"> https://data.bs.ch/explore/?refine.tags=Strassen+und+Wege</a><br>\nDie Strassentypen und Wege zeigen die Strassentypen (nach VSS - Schweizerischer Verband der Strassen- und Verkehrsfachleute) und Wege im Kanton Basel-Stadt. Darunter fallen verkehrsorientierte Strassen, siedlungsorientierte Strassen und Wege im Kanton."]
pub mod strassen_und_wege_strassentypen_und_wege {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Strassentyp/Weg
        ///
        /// Eindeutiger Identifikator der Strasse/Weg
        pub id_strweg: Option<i64>,
        /// Strassenname
        pub strname: Option<String>,
        /// Strassennetzhierarchie
        ///
        /// Kategorien unterschiedlicher Strassennetzhierarchien (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub snh: Option<String>,
        /// Strassennetzhierarchien Beschreibung
        pub strassennetzhierarchien_beschreibung: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinden (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub gemeinde: Option<String>,
        /// Kategorie
        ///
        /// Kategorien (siehe 9.4 Wertebereich in der Modellbeschreibung)
        pub kategorie: Option<String>,
        /// Weg
        ///
        /// Wege
        pub weg: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdStrweg,
        Strname,
        Snh,
        StrassennetzhierarchienBeschreibung,
        Gemeinde,
        Kategorie,
        Weg,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdStrweg => "id_strweg",
                Field::Strname => "strname",
                Field::Snh => "snh",
                Field::StrassennetzhierarchienBeschreibung => {
                    "strassennetzhierarchien_beschreibung"
                }
                Field::Gemeinde => "gemeinde",
                Field::Kategorie => "kategorie",
                Field::Weg => "weg",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100250/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rhein\u{fc}berwachungsstation: Umweltanalyse Wasserphase"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die Analysedaten aus der binationalen Rhein\u{fc}berwachungsstation (R\u{dc}S) in Weil am Rhein (Rhein-Kilometer 171,37) seit Bestehen der Station im Jahr 1993 aus der Matrix Wasser.</p><p>Der Rhein wird aktuell auf 670 Schadstoffe untersucht, 420 davon t\u{e4}glich. Der Unterhalt der Anlage und die Analytik werden durch das Amt f\u{fc}r Umwelt und Energie des Kantons Basel-Stadt (AUE) geleistet. Auftraggeber sind die Landesanstalt f\u{fc}r Umwelt, Messungen und Naturschutz Baden-W\u{fc}rttemberg (LUBW) und das schweizerische Bundesamt f\u{fc}r Umwelt (BAFU).</p><p>Weitere Informationen: <a href=\"http://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html\" target=\"_blank\">http://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html</a></p><p>Die Daten einzelner Jahre ab dem Jahr 1993 k\u{f6}nnen heruntergeladen werden unter der URL mit dem Muster https://data-bs.ch/umweltlabor/gew_rhein_rues_wasser_[JAHR].csv, also zum Beispiel f\u{fc}r das Jahr 2020 hier: <a href=\"https://data-bs.ch/umweltlabor/gew_rhein_rues_wasser_2020.csv\" target=\"_blank\">https://data-bs.ch/umweltlabor/gew_rhein_rues_wasser_2020.csv</a></p>"]
pub mod rheinueberwachungsstation_umweltanalyse_wasserphase {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Probentyp
        ///
        /// Unterscheidet zwischen Matrix Wasser und Feststoff (Schwebstoff)
        pub probentyp: Option<String>,
        /// Probenahmestelle
        ///
        /// Ort, an dem die Probe entnommen wurde.
        pub probenahmestelle: Option<String>,
        /// Geo Point
        ///
        /// Koordinaten der Probeentnahmestelle.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub x_coord: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Probeentnahmestelle in EPSG:2056.
        pub y_coord: Option<String>,
        /// Probenahmedatum
        ///
        /// Datum, an welchem die Probe entnommen wurde.
        pub probenahmedatum: Option<String>,
        /// Entnahmezeit
        ///
        /// Uhrzeit, zu der die Probe entnommen wurde.
        pub entnahmezeit: Option<String>,
        /// Probenahmedauer
        ///
        /// Dauer der Probenahme. Dauer codiert nach Konvention der Internationalen Kommission zum Schutz des Rheins (IKSR) 1M =24h; 14M=336h; 28M=672; 1M14 24h Mischprobe alle 14Tage; Sammelprobe=Dauer variabel abhängig von Schwebstoffanteil. MS steht für Mischung Stahl, MK für Mischung Kunststoff. E steht für Einzelmessung, M für Mischprobenentnahme.
        pub probenahmedauer: Option<String>,
        /// Reihenfolge
        ///
        /// Sortierfolge für Auswertungen.
        pub reihenfolge: Option<String>,
        /// Gruppe
        ///
        /// Gruppe der gemessenen Stoffe.
        pub gruppe: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff.
        pub parameter: Option<String>,
        /// Bestimmungsgrenze
        ///
        /// Minimal bestimmbare Konzentration des gemessenen Stoffes.
        pub bg: Option<f64>,
        /// Wert
        ///
        /// Gemessener Wert.
        pub wert: Option<String>,
        /// Wert numerisch
        ///
        /// Gemessener Wert als Dezimalzahl. Werte, die unterhalb der Bestimmungsgrenze liegen (z. B. <0,25) werden nicht angegeben.
        pub wert_num: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird.
        pub einheit: Option<String>,
        /// Auftragsnummer
        ///
        /// Nummer des Auftrags.
        pub auftragnr: Option<String>,
        /// Probennummer
        ///
        /// Nummer der Probe.
        pub probennr: Option<String>,
        /// Resultatnummer
        ///
        /// Nummer des Resultats.
        pub resultatnummer: Option<String>,
        /// Automatische Auswertung
        ///
        /// Angabe, ob eine automatische Auswertung erfolgte oder nicht. Automatische Auswertung heisst, dass die Integration des Peaks von einem Algorhytmus erledigt wurde und nur bei ausserordentlich hohen Werten manuell nachkontrolliert wird.
        ///Sofern für einen Parameter zwei Resultate (einmal mit automatische Auswertung TRUE und einmal mit FALSE) angegeben sind, ist dasjenige mit automatische Auswertung TRUE vorzuziehen.
        pub automatische_auswertung: Option<String>,
        /// CAS-Bezeichnung
        ///
        /// ID des chemischen Stoffs, siehe https://de.wikipedia.org/wiki/CAS-Nummer.
        pub cas_bezeichnung: Option<String>,
        /// BAFU-Bezeichnung
        ///
        /// Bezeichnung gemäss Bundesamt für Umwelt BAFU.
        pub bafu_bezeichnung: Option<String>,
        /// Allgemeine Parametergruppe
        ///
        /// Gruppe der Parameter.
        pub allgemeine_parametergruppe: Option<String>,
        /// Probenahmedatum_date
        ///
        /// Datum der Probenahme.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub probenahmedatum_date: Option<Date>,
        /// Probenahmejahr
        ///
        /// Jahr der Probeentnahme.
        pub probenahmejahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Probentyp,
        Probenahmestelle,
        XCoord,
        YCoord,
        Probenahmedatum,
        Entnahmezeit,
        Probenahmedauer,
        Reihenfolge,
        Gruppe,
        Parameter,
        Bg,
        Wert,
        WertNum,
        Einheit,
        Auftragnr,
        Probennr,
        Resultatnummer,
        AutomatischeAuswertung,
        CasBezeichnung,
        BafuBezeichnung,
        AllgemeineParametergruppe,
        ProbenahmedatumDate,
        Probenahmejahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Probentyp => "probentyp",
                Field::Probenahmestelle => "probenahmestelle",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
                Field::Probenahmedatum => "probenahmedatum",
                Field::Entnahmezeit => "entnahmezeit",
                Field::Probenahmedauer => "probenahmedauer",
                Field::Reihenfolge => "reihenfolge",
                Field::Gruppe => "gruppe",
                Field::Parameter => "parameter",
                Field::Bg => "bg",
                Field::Wert => "wert",
                Field::WertNum => "wert_num",
                Field::Einheit => "einheit",
                Field::Auftragnr => "auftragnr",
                Field::Probennr => "probennr",
                Field::Resultatnummer => "resultatnummer",
                Field::AutomatischeAuswertung => "automatische_auswertung",
                Field::CasBezeichnung => "cas_bezeichnung",
                Field::BafuBezeichnung => "bafu_bezeichnung",
                Field::AllgemeineParametergruppe => "allgemeine_parametergruppe",
                Field::ProbenahmedatumDate => "probenahmedatum_date",
                Field::Probenahmejahr => "probenahmejahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100069/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Transformation Areal Rosental: Gemessene \u{dc}berschreitungen der Interventionswerte"]
#[doc = ""]
#[doc = "<p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten im Rahmen der \u{ab}Transformation <a href=\"https://rosentalmitte.ch/\" target=\"_blank\">Rosental Mitte</a>\u{bb} \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft <a href=\"https://data.bs.ch/pages/rosental-dashboard/\" target=\"_blank\">(Dashboard)</a>.\u{a0}</p><div><br/></div>"]
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_gemessene_ueberschreitungen_der_interventionswerte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        pub datum: Option<String>,
        /// Standort
        pub standort: Option<String>,
        /// Parameter
        pub parameter: Option<String>,
        /// Messwert [µg/m3]
        pub messwert_ug_m3: Option<f64>,
        /// Interventionswert [µg/m3]
        pub interventionswert_ug_m3: Option<f64>,
        /// Info / Massnahmen
        pub info_massnahmen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Standort,
        Parameter,
        MesswertUgM3,
        InterventionswertUgM3,
        InfoMassnahmen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::MesswertUgM3 => "messwert_ug_m3",
                Field::InterventionswertUgM3 => "interventionswert_ug_m3",
                Field::InfoMassnahmen => "info_massnahmen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100295/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Schulstandorte (Gemeinde Basel)"]
#[doc = ""]
#[doc = "Die Karte zeigt die Schulstandorte (Kinderg\u{e4}rten, Primar-, Sekundarschule, Gymnasium, Zentrum f\u{fc}r Br\u{fc}ckenangebote, Allgemeine Gewerbeschule, Fachmaturit\u{e4}tsschule, Spezialangebote sowie Tagesstrukturen, Sportpl\u{e4}tze, Turnhallen ausserhalb von Schulstandorten und Schwimmhallen) der Gemeinde Basel."]
pub mod schulstandorte_gemeinde_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Schulstandort
        ///
        /// Bezeichnung des Schulstandorts
        pub schulstand: Option<String>,
        /// Schultyp
        ///
        /// Art des Schulhauses
        pub schultyp: Option<String>,
        /// Adresse
        pub name: Option<String>,
        /// Funktion
        ///
        /// Funktion der Schule
        pub funktion: Option<String>,
        /// Strasse
        ///
        /// Strassenname des Schulhauses
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer des Schulhauses
        pub hausnummer: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl des Schulhauses
        pub plz: Option<String>,
        /// Ortschaft
        ///
        /// Ortschaftsname des Schulhauses
        pub ortschaft: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// Fax
        pub fax: Option<String>,
        /// Link
        ///
        /// Internetadresse des Schulhauses
        pub link: Option<String>,
        /// PDF-Report
        ///
        /// PDF-Report des Schulhauses
        pub pdf_report: Option<String>,
        /// Geometrie
        ///
        /// Punktgeometrie
        pub geometrie: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Schulstand,
        Schultyp,
        Name,
        Funktion,
        Strasse,
        Hausnummer,
        Plz,
        Ortschaft,
        Telefon,
        Fax,
        Link,
        PdfReport,
        Geometrie,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schulstand => "schulstand",
                Field::Schultyp => "schultyp",
                Field::Name => "name",
                Field::Funktion => "funktion",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ortschaft => "ortschaft",
                Field::Telefon => "telefon",
                Field::Fax => "fax",
                Field::Link => "link",
                Field::PdfReport => "pdf_report",
                Field::Geometrie => "geometrie",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100029/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gew\u{e4}sserschutzkarte: Gew\u{e4}sserschutzbereiche"]
#[doc = ""]
#[doc = "Die Gew\u{e4}sserschutzkarte ist das zentrale planerische Instrument f\u{fc}r den praktischen Vollzug des Grundwasserschutzes. Dargestellt sind die Gew\u{e4}sserschutzbereiche und die Grundwasserschutzzonen."]
pub mod gewaesserschutzkarte_gewaesserschutzbereiche {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_GSBereich
        ///
        /// Eindeutiger Identifikator des ÖREB Fachsystems
        pub idgbereich: Option<String>,
        /// Typ
        ///
        /// Typ des Gewässerschutzbereichs (siehe 9.9 Wertebereich in der Modellbeschreibung)
        pub typ: Option<String>,
        /// Kantonale-Typ-Bezeichnung
        pub kantypbez: Option<String>,
        /// Typ-Beschreibung
        pub typ_beschreibung: Option<String>,
        /// Rechtsdokumente
        ///
        /// Link zu den Rechtsdokumenten
        pub geolink: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idgbereich,
        Typ,
        Kantypbez,
        TypBeschreibung,
        Geolink,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idgbereich => "idgbereich",
                Field::Typ => "typ",
                Field::Kantypbez => "kantypbez",
                Field::TypBeschreibung => "typ_beschreibung",
                Field::Geolink => "geolink",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100291/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Schulstandorte (Gemeinden Riehen und Bettingen)"]
#[doc = ""]
#[doc = "Schulstandorte der Primarstufe (Gemeinden Riehen und Bettingen)"]
pub mod schulstandorte_gemeinden_riehen_und_bettingen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_SCHULE
        pub id_schule: Option<i64>,
        /// Schulstandort
        pub standort: Option<String>,
        /// Schultyp
        pub typ: Option<String>,
        /// Name der Schule
        pub name: Option<String>,
        /// Telefon Kontaktperson 1
        pub telefon1: Option<String>,
        /// Telefon Kontaktperson 2
        pub telefon2: Option<String>,
        /// Strasse
        pub strasse: Option<String>,
        /// Hausnummer
        pub hausnummer: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// Ortschaft
        pub ort: Option<String>,
        /// Fax
        pub fax: Option<String>,
        /// Link
        pub link: Option<String>,
        /// Geometrie
        pub geometrie: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdSchule,
        Standort,
        Typ,
        Name,
        Telefon1,
        Telefon2,
        Strasse,
        Hausnummer,
        Plz,
        Ort,
        Fax,
        Link,
        Geometrie,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdSchule => "id_schule",
                Field::Standort => "standort",
                Field::Typ => "typ",
                Field::Name => "name",
                Field::Telefon1 => "telefon1",
                Field::Telefon2 => "telefon2",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Fax => "fax",
                Field::Link => "link",
                Field::Geometrie => "geometrie",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100030/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): Fallzahlen Basel-Stadt"]
#[doc = ""]
#[doc = "<div><div>Anzahl F\u{e4}lle der Coronavirus-Krankheit (COVID-19) in Basel-Stadt. Die Daten wurden zu Beginn der Pandemie durch Mitarbeiter der Fachstelle OGD Basel-Stadt von Hand aus \u{f6}ffentlich zug\u{e4}nglichen offiziellen Quellen eingetippt. Sp\u{e4}ter wurden die Daten aus den Bulletins des Gesundheitsdepartements Basel-Stadt automatisiert ausgelesen. Mittlerweile stammen die Angaben direkt von den medizinischen Diensten des Gesundheitsdepartements Basel-Stadt.</div><div><br/></div><div>Die Quellenangabe der jeweiligen Zahlen sind direkt der Tabelle zu entnehmen.\u{a0}</div><div><br/></div></div><div>Die offiziellen Daten aller Kantone und des F\u{fc}rstentums Liechtenstein (FL) sind hier zu finden:\u{a0}</div><ul><li>Interaktives Dashboard der Zahlen aller Kantone:\u{a0}<a href=\"https://data.bs.ch/pages/covid-19-dashboard/\">https://data.bs.ch/pages/covid-19-dashboard/</a></li><li>Alle Kantone und FL in einem File: <a href=\"https://github.com/openZH/covid_19/blob/master/COVID19_Fallzahlen_CH_total_v2.csv\" target=\"_blank\">https://github.com/openZH/covid_19/blob/master/COVID19_Fallzahlen_CH_total_v2.csv</a></li><li>Ein File pro Kanton (z.T. sind in den einzelnen Files zus\u{e4}tzliche Spalten vorhanden gegen\u{fc}ber dem gesamtschweizerischen File): <a href=\"https://github.com/openZH/covid_19/tree/master/fallzahlen_kanton_total_csv_v2\" target=\"_blank\">https://github.com/openZH/covid_19/tree/master/fallzahlen_kanton_total_csv_v2</a><a href=\"https://github.com/openZH/covid_19/tree/master/fallzahlen_kanton_total_csv_v2\" target=\"_blank\"></a></li></ul><p>Informationen zu den durchgef\u{fc}hrten Tests auf t\u{e4}glicher Basis gem\u{e4}ss Bundesamt f\u{fc}r Gesundheit (BAG) finden sich neu in diesem Datensatz: <a href=\"https://data.bs.ch/explore/dataset/100094/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100094/table/</a></p><p>Daten zu Todesf\u{e4}llen von Personen mit SARS-CoV-2 mit Wohnsitz in Basel-Stadt sind in diesem Datensatz zu finden: <a href=\"https://data.bs.ch/explore/dataset/100076\" target=\"_blank\">https://data.bs.ch/explore/dataset/100076</a><a \"=\"\" href=\"https://data.bs.ch/explore/dataset/100076\" target=\"_blank\"></a></p><p>Daten zu den 7- und 14-Tages Inzidenzen sowie den Fallzahlen pro Gemeinde (Basel, Riehen, Bettingen) sind in diesem Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100108\" target=\"_blank\">https://data.bs.ch/explore/dataset/100108</a></p><p><b>\u{c4}nderungsprotokoll:</b></p><ul><li>Ab dem 5.11.2020 wurden keine Angaben mehr zu positiv getesteten Personen mit Wohnsitz ausserhalb des Kantons Basel-Stadt gemacht. Dies, weil die Tests mittlerweile durch eine gr\u{f6}ssere Anzahl Laboratorien durchgef\u{fc}hrt wurden und nicht mehr alle Resultate der ausserkantonalen und internationalen F\u{e4}lle dem kantons\u{e4}rztlichen Dienst Basel-Stadt gemeldet wurden.</li><li><span>Ab 18.6.2022 wurden am Samstag und Sonntag keine neuen Daten in diesen Datensatz publiziert.\u{a0}</span></li><li><span>Ab 1. Februar 2023 wurden die Daten jeweils am Dienstag und am Freitag aktualisiert.</span></li><li><span>Ab 4. April 2023 werden die Daten jeweils am Dienstag aktualisiert. Die Daten werden somit einmal w\u{f6}chentlich aktualisiert.</span></li><li><span>Die Erhebung der Fallzahlen wurde per 5. Juli 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.</span>\u{a0}Aktualisierungsintervall von \"DAILY\" auf \"NEVER\" ge\u{e4}ndert.</li></ul><p><br/></p>"]
pub mod coronavirus_covid_19_fallzahlen_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datenstand
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Kanton
        pub abbreviation_canton_and_fl: Option<String>,
        /// Aktive Fälle (ehemals Isolierte)
        ///
        /// Ab dem 1.4.22 gelten Personen bis zum 5. Tag nach dem Tag des positiven Tests als "aktive Fälle". Frühere Definition: Mit dem neuen Coronavirus infizierte Personen, welche isoliert sind
        pub current_isolated: Option<i64>,
        /// Kontaktpersonen in Quarantäne
        ///
        /// Personen, welche sich in Quarantäne befinden, weil sie in engem Kontakt zu einem Infizierten Fall waren
        pub current_quarantined: Option<i64>,
        /// Reiserückkehrer in Quarantäne
        ///
        /// Personen, welche sich aufgrund einer Einreise aus einem Gebiet mit erhöhtem Ansteckungsrisiko gemäss BAG in Quarantäne befinden
        pub current_quarantined_riskareatravel: Option<i64>,
        /// In Quarantäne total
        ///
        /// Total der Personen in Quarantäne.
        pub current_quarantined_total: Option<i64>,
        /// Fälle mit Wohnsitz BS
        ///
        /// Anzahl in Basel-Stadt auf das neue Coronavirus positiv getestete Personen mit Wohnsitz in Basel-Stadt (kumuliert)
        pub ncumul_conf: Option<f64>,
        /// Fälle mit Wohnsitz ausserhalb BS
        ///
        /// Anzahl in Basel-Stadt auf Coronavirus positiv getestete Personen mit Wohnsitz ausserhalb Basel-Stadt insgesamt (kumuliert)
        pub ncumul_confirmed_non_resident: Option<i64>,
        /// Differenz Fälle mit Wohnsitz BS
        ///
        /// Neu gemeldete Fälle mit Wohnsitz in Basel-Stadt gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_conf: Option<i64>,
        /// Differenz Fälle mit Wohnsitz ausserhalb BS
        ///
        /// Neu gemeldete Fälle mit Wohnsitz ausserhalb des Kantons Basel-Stadt gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_confirmed_non_resident: Option<i64>,
        /// Hospitalisierte
        ///
        /// In Basel-Stadt hospitalisierte Personen mit COVID-19 Erkrankung (inkl. Fälle auf Intensivstationen)
        pub current_hosp: Option<i64>,
        /// Hospitalisierte mit Wohnsitz BS
        ///
        /// Anzahl zum aktuellen Zeitpunkt an COVID-19 erkrankte in Basel-Stadt hospitalisierte Personen mit Wohnsitz in Basel-Stadt (inkl. Fälle auf Intensivstationen)
        pub current_hosp_resident: Option<i64>,
        /// Hospitalisierte mit Wohnsitz ausserhalb BS
        ///
        /// Anzahl zum aktuellen Zeitpunkt an COVID-19 erkrankte in Basel-Stadt hospitalisierte Personen mit Wohnsitz ausserhalb Basel-Stadt (inkl. Fälle auf Intensivstationen)
        pub current_hosp_non_resident: Option<i64>,
        /// Neu Hospitalisierte
        ///
        /// Seit letzter Meldung neu hinzugekommene COVID-19 Fälle im Spital
        pub new_hosp: Option<i64>,
        /// Fälle auf Intensivstation
        ///
        /// An COVID-19 Erkrankte in Intensivstationen Basel-Städtischer Spitäler
        pub current_icu: Option<i64>,
        /// Intubierte
        ///
        /// Anzahl aktuell intubierte COVID-19 Fälle in Spitälern Basel-Stadt
        pub current_vent: Option<i64>,
        /// Genesene
        ///
        /// Anzahl genesene Personen mit Wohnsitz im Kanton Basel-Stadt insgesamt (kumuliert). Definition ab dem 1.4.22: Personen gelten ab dem 6. Tag nach positivem Testresultat als genesen. Ursprüngliche Definition: Als genesen gilt, wer 10 Tage nach einem positiven Covid-19-Test resp. 10 Tage nach den ersten Symptomen mindestens 48 Stunden symptomfrei war.
        pub ncumul_released: Option<i64>,
        /// Differenz Genesene
        ///
        /// Neu gemeldete Genesene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_released: Option<i64>,
        /// Verstorbene
        ///
        /// Anzahl mit COVID-19 Erkrankung verstorbene Personen mit Wohnsitz in Basel-Stadt, kumuliert
        pub ncumul_deceased: Option<i64>,
        /// Differenz Verstorbene
        ///
        /// Neu gemeldete Gestorbene gegenüber der letzten Meldung (i.d.R. gegenüber dem Vortag)
        pub ndiff_deceased: Option<i64>,
        /// Quelle
        ///
        /// Datenquelle(n)
        pub source: Option<String>,
        /// Datum
        ///
        /// Datum der Datenveröffentlichung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Zeit
        ///
        /// Zeit der Datenveröffentlichung
        pub time: Option<String>,
        /// Woche
        ///
        /// Nummer der Kalenderwoche
        pub week: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        AbbreviationCantonAndFl,
        CurrentIsolated,
        CurrentQuarantined,
        CurrentQuarantinedRiskareatravel,
        CurrentQuarantinedTotal,
        NcumulConf,
        NcumulConfirmedNonResident,
        NdiffConf,
        NdiffConfirmedNonResident,
        CurrentHosp,
        CurrentHospResident,
        CurrentHospNonResident,
        NewHosp,
        CurrentIcu,
        CurrentVent,
        NcumulReleased,
        NdiffReleased,
        NcumulDeceased,
        NdiffDeceased,
        Source,
        Date,
        Time,
        Week,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::AbbreviationCantonAndFl => "abbreviation_canton_and_fl",
                Field::CurrentIsolated => "current_isolated",
                Field::CurrentQuarantined => "current_quarantined",
                Field::CurrentQuarantinedRiskareatravel => "current_quarantined_riskareatravel",
                Field::CurrentQuarantinedTotal => "current_quarantined_total",
                Field::NcumulConf => "ncumul_conf",
                Field::NcumulConfirmedNonResident => "ncumul_confirmed_non_resident",
                Field::NdiffConf => "ndiff_conf",
                Field::NdiffConfirmedNonResident => "ndiff_confirmed_non_resident",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentHospResident => "current_hosp_resident",
                Field::CurrentHospNonResident => "current_hosp_non_resident",
                Field::NewHosp => "new_hosp",
                Field::CurrentIcu => "current_icu",
                Field::CurrentVent => "current_vent",
                Field::NcumulReleased => "ncumul_released",
                Field::NdiffReleased => "ndiff_released",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::NdiffDeceased => "ndiff_deceased",
                Field::Source => "source",
                Field::Date => "date",
                Field::Time => "time",
                Field::Week => "week",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100073/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gew\u{e4}sserschutzkarte: Grundwasserschutzzonen"]
#[doc = ""]
#[doc = "Die Grundwasserschutzzonen S1-S3 sind das wichtigste Instrument, Fassungs-, Anreicherungsanlagen und das Grundwasser unmittelbar vor seiner Nutzung als Trinkwasser vor Beeintr\u{e4}chtigungen zu sch\u{fc}tzen."]
pub mod gewaesserschutzkarte_grundwasserschutzzonen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_GWSZone
        ///
        /// Eindeutiger Identifikator des ÖREB Fachsystems
        pub idgwszone: Option<String>,
        /// Typ
        ///
        /// Typ der Schutzzone (siehe 9.9 Wertebereich in der Modellbeschreibung)
        pub typ: Option<String>,
        /// Kantonale-Typ-Bezeichnung
        pub kantypbez: Option<String>,
        /// Typ-Beschreibung
        pub typ_beschreibung: Option<String>,
        /// Ist altrechtlich
        ///
        /// Angabe aus dem Bundesmodells, informiert ob rechtsgültige Objekte nicht mehr den heutigen gesetzl. Anforderungen entsprechen
        pub altrecht: Option<String>,
        /// Bemerkungen
        pub bemerkung: Option<String>,
        /// Id_Geschaeft
        ///
        /// Eindeutiger Identifikator des ÖREB Fachsystems
        pub idgeschaef: Option<String>,
        /// Geschäftsstatus
        ///
        /// Der Geschäftsstatus gibt den letzten publizierten Status eines Geschäfts wieder (siehe 9.9 Wertebereich in der Modellbeschreibung)
        pub geschaesta: Option<String>,
        /// Datum_Status
        ///
        /// Datum des Statuswechsels
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        ///
        /// Eindeutige Verbindung zur Rechtsvorschrift
        pub geolink: Option<String>,
        /// Geschaeftsbezeichnung
        ///
        /// Bezeichnung des Geschäfts
        pub geschaebez: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idgwszone,
        Typ,
        Kantypbez,
        TypBeschreibung,
        Altrecht,
        Bemerkung,
        Idgeschaef,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idgwszone => "idgwszone",
                Field::Typ => "typ",
                Field::Kantypbez => "kantypbez",
                Field::TypBeschreibung => "typ_beschreibung",
                Field::Altrecht => "altrecht",
                Field::Bemerkung => "bemerkung",
                Field::Idgeschaef => "idgeschaef",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100292/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abfuhrzonen (Gemeinde Basel)"]
#[doc = ""]
#[doc = "Abfuhrzonen der Stadtreinigung (Tiefbauamt) f\u{fc}r die Stadt Basel. Beinhaltet die Fl\u{e4}chen der Abfuhrzonen (A bis H) der Stadt Basel."]
pub mod abfuhrzonen_gemeinde_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ZONE
        pub zone: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Zone,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zone => "zone",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100095/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verbotszonen geteilte Mikromobilit\u{e4}t: Sperr- und Parkverbotszonen"]
#[doc = ""]
#[doc = "Der Datensatz zeigt jene Zonen, die das Amt f\u{fc}r Mobilit\u{e4}t f\u{fc}r die Sharing-Anbieter der Mikromobilit\u{e4}t (z. B. Velo, E-Scooter etc.) in Basel definiert. Es sind dies Zonen, in denen die Fahrzeuge nicht abgemeldet werden d\u{fc}rfen (Parkverbotszonen) und Zonen, in denen die Fahrzeuge nicht durchfahren d\u{fc}rfen (Sperrzonen). Die Anbieter sind frei, selber zus\u{e4}tzliche Parkverbots- und Sperrzonen zu definieren."]
pub mod verbotszonen_geteilte_mikromobilitaet_sperr_und_parkverbotszonen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Verbotszone
        ///
        /// Eindeutiger Identifikator der Verbotszone
        pub id_verbot: Option<i64>,
        /// Name
        ///
        /// Bezeichnung der Verbotszone
        pub name: Option<String>,
        /// Regulierungsart
        ///
        /// Art der Verbotszone
        pub regart: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdVerbot,
        Name,
        Regart,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdVerbot => "id_verbot",
                Field::Name => "name",
                Field::Regart => "regart",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100332/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Feinstaubmessungen Naturhistorisches Museum Basel"]
#[doc = ""]
#[doc = "<p>Im Rahmen der Sonderausstellung ERDE AM LIMIT\u{a0}(20.11.2020 bis 3.7.2022) wurden mit Hilfe eines Mikrosensors Feinstaub (PM2.5) vom Dach des <a href=\"https://www.nmbs.ch/\" target=\"_blank\">Naturhistorischen Museums Basel</a> gemessen. Hier werden die unvalidierten Daten von Feinstaub PM2.5 zur Verf\u{fc}gung gestellt.</p>"]
pub mod feinstaubmessungen_naturhistorisches_museum_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel des Messbeginns
        #[serde(with = "time::serde::iso8601::option")]
        pub anfangszeit: Option<OffsetDateTime>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm25: Option<f64>,
        /// Zeitstempel als String
        pub zeitstempel_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Anfangszeit,
        Pm25,
        ZeitstempelText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Anfangszeit => "anfangszeit",
                Field::Pm25 => "pm25",
                Field::ZeitstempelText => "zeitstempel_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100100/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Tigerm\u{fc}ckenbek\u{e4}mpfung: Bek\u{e4}mpfungszone"]
#[doc = ""]
#[doc = "Das Monitoring der Tigerm\u{fc}cken basiert auf 3 Standpfeilern: a) Aktives Monitoring mittels Fallennetzwerk und regelm\u{e4}ssigen Kontrollen der Fallen b) Passives Monitoring aufgrund von Meldungen aus der Bev\u{f6}lkerung c) Nachuntersuchungen bei Bedarf"]
pub mod tigermueckenbekaempfung_bekaempfungszone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID Bekämpfungszone
        ///
        /// Eindeutiger Identifikator
        pub id_bekam: Option<i64>,
        /// URL
        ///
        /// URL zur Infoseite
        pub url: Option<String>,
        /// Merkblatt
        ///
        /// URL zum Merkblatt
        pub merkblatt: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdBekam,
        Url,
        Merkblatt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdBekam => "id_bekam",
                Field::Url => "url",
                Field::Merkblatt => "merkblatt",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100305/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Secondhand-Angebote / Wiederverwendungsstellen"]
#[doc = ""]
#[doc = "Dieser Datensatz enth\u{e4}lt die Standorte verschiedener\nSecondhand-Waren in der Region Basel, die entweder verkauft oder kostenlos\nweitergegeben werden. Diese Standorte k\u{f6}nnen Secondhand-L\u{e4}den, Brockenh\u{e4}user,\nBuchhandlungen, B\u{fc}cherschr\u{e4}nke, Lebensmittelverteilschr\u{e4}nke oder\nElektrofachgesch\u{e4}fte umfassen. Bei einigen Standorten sind zus\u{e4}tzliche\nInformationen wie Telefonnummern und Links zu ihren Internetseiten verf\u{fc}gbar."]
pub mod secondhand_angebote_wiederverwendungsstellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_wiederv: Option<i64>,
        /// Kategorie
        ///
        /// Kategorie der Wiederverwendungsstelle
        pub kategorie: Option<String>,
        /// Name
        pub name: Option<String>,
        /// Beschreibung
        pub beschreibu: Option<String>,
        /// Adresse
        pub adresse: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Gemeinde
        pub ortschaft: Option<String>,
        /// Telefon
        pub telefon: Option<String>,
        /// Link
        pub link: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdWiederv,
        Kategorie,
        Name,
        Beschreibu,
        Adresse,
        Plz,
        Ortschaft,
        Telefon,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdWiederv => "id_wiederv",
                Field::Kategorie => "kategorie",
                Field::Name => "name",
                Field::Beschreibu => "beschreibu",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ortschaft => "ortschaft",
                Field::Telefon => "telefon",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100363/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kitas und Tagesheime"]
#[doc = ""]
#[doc = "\u{ab}Kitas\u{bb}, \u{ab}Kindertagesst\u{e4}tten\u{bb} oder \u{ab}Tagesheime\u{bb} sind Einrichtungen, in denen Kinder regelm\u{e4}ssig tags\u{fc}ber durch qualifizierte Fachpersonen und in geeigneten R\u{e4}umlichkeiten betreut werden.\n\u{ab}Tagesfamilien\u{bb} sind Familien, in denen Kinder gegen Entgelt und regelm\u{e4}ssig in geeigneten R\u{e4}umlichkeiten betreut werden."]
pub mod kitas_und_tagesheime {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_tk: Option<i64>,
        /// Standortname
        ///
        /// Bezeichnung des Standortes
        pub std_name: Option<String>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
        /// Hausnummer
        pub haus_nr: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        ///
        /// Gemeinde
        pub ort: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// Homepage
        ///
        /// Internetadresse
        pub homepage: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdTk,
        StdName,
        Strasse,
        HausNr,
        Plz,
        Ort,
        Telefon,
        Homepage,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdTk => "id_tk",
                Field::StdName => "std_name",
                Field::Strasse => "strasse",
                Field::HausNr => "haus_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::Homepage => "homepage",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100341/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Live-Abstimmungsergebnisse"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Abstimmungen des Grossen Rates Basel-Stadt, einzeln f\u{fc}r jedes Ratsmitglied und jede Abstimmung. An Sitzungstagen werden die Daten in Echtzeit aktualisiert.\u{a0}</p><p>Abstimmungen an Sitzungen, welche w\u{e4}hrend der Coronavirus-Ausnahmesituation 2020/2021 im Kongresscenter Basel abgehalten wurden, sind nun auch in diesem Datensatz vorhanden.\u{a0}</p><p>Die Daten k\u{f6}nnen auch als Website und PDF Datei hier eingesehen werden:\u{a0}</p><ul><li>Aktuelle Sitzung:\u{a0}<a href=\"https://grosserrat.bs.ch/ratsbetrieb/tagesordnung/abstimmungsergebnisse\" target=\"_blank\">https://grosserrat.bs.ch/ratsbetrieb/tagesordnung/abstimmungsergebnisse</a><a href=\"http://abstimmungen.grosserrat-basel.ch/index_aktuell.php\" target=\"_blank\"></a></li><li>Vergangene Sitzungen (Archiv):\u{a0}<a href=\"http://abstimmungen.grosserrat-basel.ch/index_archiv.php\" target=\"_blank\">http://abstimmungen.grosserrat-basel.ch/index_archiv.php</a><a href=\"http://abstimmungen.grosserrat-basel.ch/index_archiv.php\" target=\"_blank\"></a></li></ul><p>Bitte beachten Sie, dass f\u{fc}r das offizielle Abstimmungsergebnis das jeweilige Sitzungsprotokoll des Grossen Rates massgeblich ist (elektronische Fassung:\u{a0}<a href=\"https://ratsprotokolle.grosserrat.bs.ch\" target=\"_blank\">https://ratsprotokolle.grosserrat.bs.ch</a>)</p><p>\u{c4}nderungsprotokoll:<br>5. April 2024: Der Parlamentsdienst nutzt seit dem September 2023 ein neues Abstimmungssystem. Dies f\u{fc}hrt zu einigen \u{c4}nderungen bei den Daten, die geliefert werden. Die Daten konnten mit folgenden Spalten erg\u{e4}nzt werden: Signatur Gesch\u{e4}ft, Signatur Dokument, Erweiterte Abstimmungsnummer, Anrede der abstimmenden Person und Funktion der abstimmenden Person. Des Weiteren haben sich die Abstimmungstypen ge\u{e4}ndert.<br>Die Abstimmungstypen vor dem September 2023: Abstimmung, Schlussabstimmung, Antrag, offene Wahl, R\u{fc}ckweisung, Eventualabstimmung, Eintreten, Ordnungsantrag, ung\u{fc}ltig<br>Die Abstimmungstypen nach dem September 2023: Anwesenheit, Ad Hoc einfaches Mehr, Ad Hoc 2/3 Mehr, Eventual Abstimmung, Schlussabstimmung, Quorum erfassen</p>"]
pub mod grosser_rat_live_abstimmungsergebnisse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Zeit
        ///
        /// Uhrzeit
        pub zeit: Option<String>,
        /// Traktandum
        ///
        /// Nummer des Traktandums, falls vorhanden, gemäss Tagesordnung (Traktandenliste)
        pub traktandum: Option<i64>,
        /// Subtraktandum
        ///
        /// Nummer des Subtraktandums, falls vorhanden,  gemäss Tagesordnung (Traktandenliste)
        pub subtraktandum: Option<i64>,
        /// Geschäft
        ///
        /// Titel des Geschäfts
        pub geschaeft: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Geschäfts
        pub signatur_ges: Option<String>,
        /// Geschäft auf grosserrat.bs.ch
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach dem Geschäft.
        pub url_geschaeft_ods: Option<String>,
        /// Signatur Dokument
        ///
        /// Signatur des Dokuments
        pub signatur_dok: Option<String>,
        /// Abstimmungsnummer
        ///
        /// Laufende Nummerierung der Abstimmungen an einem Sitzungstag
        pub abst_nr: Option<String>,
        /// Typ
        ///
        /// Abstimmungstyp (ab September 2023 gibt es neue Typen)
        pub typ: Option<String>,
        /// Ja-Stimmen
        ///
        /// Anzahl Grossratsmitglieder, welche mit "Ja" abgestimmt haben
        pub anz_j: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Grossratsmitglieder, welche mit "Nein" abgestimmt haben
        pub anz_n: Option<i64>,
        /// Enthaltungen
        ///
        /// Anzahl Grossratsmitglieder, welche sich der Stimme enthalten haben
        pub anz_e: Option<i64>,
        /// Abwesende
        ///
        /// Anzahl Grossratsmitglieder, welche bei der Abstimmung nicht anwesend waren
        pub anz_a: Option<i64>,
        /// Präsidiumsstimmen
        ///
        /// Anzahl Stimmen der Ratspräsidentin oder des Ratspräsidenten (= maximal 1)
        pub anz_p: Option<i64>,
        /// Sitz Nr.
        ///
        /// Nummer des Sitzes des Grossratsmitglieds
        pub sitz_nr: Option<i64>,
        /// Anrede
        ///
        /// Anrede des Grossratsmitglieds
        pub mitglied_anrede: Option<String>,
        /// Nachname
        ///
        /// Nachname des Grossratsmitglieds
        pub mitglied_nachname: Option<String>,
        /// Vorname
        ///
        /// Vorname des Grossratsmitglieds
        pub mitglied_vorname: Option<String>,
        /// Name
        ///
        /// Vor- und Nachname des Grossratsmitglieds
        pub mitglied_name: Option<String>,
        /// Fraktion
        ///
        /// Fraktion des Grossratsmitglieds
        pub fraktion: Option<String>,
        /// Name und Fraktion
        ///
        /// Name und Fraktionszugehörigkeit des Grossratsmitglieds
        pub mitglied_name_fraktion: Option<String>,
        /// Funktion
        ///
        /// Funktion des Grossratsmitglieds (Mitglied, Präsident/in, Statthalter/in)
        pub mitglied_funktion: Option<String>,
        /// Entscheid Mitglied
        ///
        /// Stimmverhalten des Grossratsmitglieds (Ja, Nein, Enthaltung, Abwesend, Präsidium)
        pub entscheid_mitglied: Option<String>,
        /// ID Ratsmitglied
        ///
        /// Individuelle Identifikationsnummer des Grossratsmitglied innerhalb der Datenbank des Grossen Rates.
        pub gr_uni_nr: Option<String>,
        /// Ratsmitglied auf grosserrat.bs.ch
        ///
        /// Link zum Grossratsmitglied auf der Webseite des Grossen Rates
        pub gr_url: Option<String>,
        /// Ratsmitglied auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach Grossratsmitglied.
        pub gr_url_ods: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitstempel_text: Option<OffsetDateTime>,
        /// Datenstand
        ///
        /// Datum und Uhrzeit des Datenexports
        #[serde(with = "time::serde::iso8601::option")]
        pub datenstand_text: Option<OffsetDateTime>,
        /// Erweiterte Abstimmungsnummer
        ///
        /// Besteht aus [Abstimmungsnummer]-[Datum]-[Uhrzeit]
        pub anr: Option<String>,
        /// Abstimmungsdokument auf grosserrat.bs.ch
        ///
        /// Link zum Dokument der Abstimmung auf der Webseite des Grossen Rates
        pub url_abstimmung_dok: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Zeit,
        Traktandum,
        Subtraktandum,
        Geschaeft,
        SignaturGes,
        UrlGes,
        UrlGeschaeftOds,
        SignaturDok,
        AbstNr,
        Typ,
        AnzJ,
        AnzN,
        AnzE,
        AnzA,
        AnzP,
        SitzNr,
        MitgliedAnrede,
        MitgliedNachname,
        MitgliedVorname,
        MitgliedName,
        Fraktion,
        MitgliedNameFraktion,
        MitgliedFunktion,
        EntscheidMitglied,
        GrUniNr,
        GrUrl,
        GrUrlOds,
        ZeitstempelText,
        DatenstandText,
        Anr,
        UrlAbstimmungDok,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Zeit => "zeit",
                Field::Traktandum => "traktandum",
                Field::Subtraktandum => "subtraktandum",
                Field::Geschaeft => "geschaeft",
                Field::SignaturGes => "signatur_ges",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
                Field::SignaturDok => "signatur_dok",
                Field::AbstNr => "abst_nr",
                Field::Typ => "typ",
                Field::AnzJ => "anz_j",
                Field::AnzN => "anz_n",
                Field::AnzE => "anz_e",
                Field::AnzA => "anz_a",
                Field::AnzP => "anz_p",
                Field::SitzNr => "sitz_nr",
                Field::MitgliedAnrede => "mitglied_anrede",
                Field::MitgliedNachname => "mitglied_nachname",
                Field::MitgliedVorname => "mitglied_vorname",
                Field::MitgliedName => "mitglied_name",
                Field::Fraktion => "fraktion",
                Field::MitgliedNameFraktion => "mitglied_name_fraktion",
                Field::MitgliedFunktion => "mitglied_funktion",
                Field::EntscheidMitglied => "entscheid_mitglied",
                Field::GrUniNr => "gr_uni_nr",
                Field::GrUrl => "gr_url",
                Field::GrUrlOds => "gr_url_ods",
                Field::ZeitstempelText => "zeitstempel_text",
                Field::DatenstandText => "datenstand_text",
                Field::Anr => "anr",
                Field::UrlAbstimmungDok => "url_abstimmung_dok",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100186/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Vorhersagen Rhein: Wasserstand und Abfluss"]
#[doc = ""]
#[doc = "<p>Hydrologischen Vorhersagen (Wasserstand und Abfluss) f\u{fc}r die Station \"Rhein - Basel, Rheinhalle\".</p><p>Die Vorhersagen basieren\u{a0} auf den Meteo-Modellen ICON-CH1-EPS, ICON-CH2-EPS und IFS. Am Anfang der Zeitreihen stehen 24 Std. Messwerte, anschliessend fangen die Prognosen an.\u{a0}</p><p>Bei den ICON-Modellen wird der Kontroll-Lauf in den Spalten \"Wasserstand\" und \"Abflussmenge\" ausgewiesen. Der Kontroll-Lauf ist die\u{a0}hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage.</p><p>Stationsinfo: Die Station befindet sich auf der Kleinbasler Seite auf H\u{f6}he des Birs-Zuflusses.</p><p>Weitere Informationen sind hier zu finden: <a href=\"https://www.hydrodaten.admin.ch/de/2289.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/2289.html</a><a href=\"https://www.hydrodaten.admin.ch/de/2289.html\" target=\"_blank\"></a></p><p><b>\u{c4}nderungsprotokoll:</b></p><p><b>30.05.2024:</b>\u{a0}F\u{fc}r die numerische Vorhersage wurde das Wettermodell COSMO mit dem neuen Wettermodell ICON (Icosahedral Nonhydrostatic Weather and Climate Model) ersetzt.\u{a0}Mehr Infos dazu finden Sie hier:\u{a0}<a href=\"https://www.meteoschweiz.admin.ch/ueber-uns/forschung-und-zusammenarbeit/projekte/2023/icon-22.html\" target=\"_blank\">https://www.meteoschweiz.admin.ch/ueber-uns/forschung-und-zusammenarbeit/projekte/2023/icon-22.html</a></p>"]
pub mod vorhersagen_rhein_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wasserstand
        ///
        /// Pegelstand in Meter über Meer. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub wasserstand: Option<f64>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmeter pro Sekunde. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub abfluss: Option<f64>,
        /// Methode
        ///
        /// Das verwendete Meteo-Modell
        pub methode: Option<String>,
        /// Zeitstempel Ausgabe
        ///
        /// Datum und Uhrzeit der Veröffentlichung
        #[serde(with = "time::serde::iso8601::option")]
        pub ausgegeben_an: Option<OffsetDateTime>,
        /// Zeitstempel Meteolauf
        ///
        /// Datum und Uhrzeit des Meteo-Laufs (der Zeitpunkt, zu dem die meteorologischen Vorhersagen erstellt wurden, die dann als Grundlage für das Modell zur Berechnung der hydrologischen Vorhersagen verwendet wird)
        #[serde(with = "time::serde::iso8601::option")]
        pub meteolauf: Option<OffsetDateTime>,
        /// Zeitstempel Gemessene Werte
        ///
        /// Datum und Uhrzeit, bis zu dem die Werte gemessen wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub gemessene_werten_bis: Option<OffsetDateTime>,
        /// Wasserstand Minimum
        ///
        /// Minimum (0%-Quantil) des Pegelstands in Meter über Meer
        pub h_min: Option<f64>,
        /// Wasserstand 25%-Quantil
        ///
        /// 25%-Quantil des Pegelstands in Meter über Meer
        pub h_p25: Option<f64>,
        /// Wasserstand Median
        ///
        /// Median (50%-Quantil) des Pegelstands in Meter über Meer
        pub h_p50: Option<f64>,
        /// Wasserstand 75%-Quantil
        ///
        /// 75%-Quantil des Pegelstands in Meter über Meer
        pub h_p75: Option<f64>,
        /// Wasserstand Maximum
        ///
        /// Maximum (100%-Quantil) des Pegelstands in Meter über Meer
        pub h_max: Option<f64>,
        /// Abflussmenge Minimum
        ///
        /// Minimum (0%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_min: Option<f64>,
        /// Abflussmenge 25%-Quantil
        ///
        /// 25%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p25: Option<f64>,
        /// Abflussmenge Median
        ///
        /// Median (50%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p50: Option<f64>,
        /// Abflussmenge 75%-Quantil
        ///
        /// 75%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p75: Option<f64>,
        /// Abflussmenge Maximum
        ///
        /// Maximum (100%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_max: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Wasserstand,
        Abfluss,
        Methode,
        AusgegebenAn,
        Meteolauf,
        GemesseneWertenBis,
        HMin,
        HP25,
        HP50,
        HP75,
        HMax,
        QMin,
        QP25,
        QP50,
        QP75,
        QMax,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Wasserstand => "wasserstand",
                Field::Abfluss => "abfluss",
                Field::Methode => "methode",
                Field::AusgegebenAn => "ausgegeben_an",
                Field::Meteolauf => "meteolauf",
                Field::GemesseneWertenBis => "gemessene_werten_bis",
                Field::HMin => "h_min",
                Field::HP25 => "h_p25",
                Field::HP50 => "h_p50",
                Field::HP75 => "h_p75",
                Field::HMax => "h_max",
                Field::QMin => "q_min",
                Field::QP25 => "q_p25",
                Field::QP50 => "q_p50",
                Field::QP75 => "q_p75",
                Field::QMax => "q_max",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100271/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Transformation Areal Rosental: Fl\u{fc}chtige Schadstoffe"]
#[doc = ""]
#[doc = "<p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten im Rahmen der \u{ab}Transformation <a href=\"https://rosentalmitte.ch/\" target=\"_blank\">Rosental Mitte</a>\u{bb} \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft <a href=\"https://data.bs.ch/pages/rosental-dashboard/\" target=\"_blank\">(Dashboard)</a>.\u{a0}</p><p>\u{c4}nderungsprotokoll:<br>23.4.2024: Die Messstation ROSEN 3 wurde verschoben. Alte geografische Breiten- und L\u{e4}ngengrade 47.567827676637364, 7.603804744961502. Neue Breiten- und L\u{e4}gengrade\u{a0}47.567997530870265, 7.60479830196066.<br></p><div><br></div>"]
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_fluechtige_schadstoffe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messbeginn
        ///
        /// Beginn der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Ende der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Standort
        ///
        /// Name des Standorts
        pub standort: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff
        pub parameter: Option<String>,
        /// Messwert
        ///
        /// Gemessener Wert
        pub messwert: Option<f64>,
        /// Messwert 3 Dezimalstellen
        pub messwert_3_dezimalstellen: Option<f64>,
        /// Interventionswert
        pub interventionswert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub interventionswert_3_dez: Option<f64>,
        /// Warnwert
        pub warnwert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub warnwert_3_dez: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird
        pub einheit: Option<String>,
        /// Messmethode
        pub messmethode: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Messbeginn,
        Messende,
        Standort,
        Parameter,
        Messwert,
        Messwert3Dezimalstellen,
        Interventionswert,
        Interventionswert3Dez,
        Warnwert,
        Warnwert3Dez,
        Einheit,
        Messmethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::Messwert => "messwert",
                Field::Messwert3Dezimalstellen => "messwert_3_dezimalstellen",
                Field::Interventionswert => "interventionswert",
                Field::Interventionswert3Dez => "interventionswert_3_dez",
                Field::Warnwert => "warnwert",
                Field::Warnwert3Dez => "warnwert_3_dez",
                Field::Einheit => "einheit",
                Field::Messmethode => "messmethode",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100273/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Birs Temperatur, Wasserstand und Abfluss"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt den Wasserstand, die Abflussmenge und die Temperatur der Birs bei \"Hofmatt\" in M\u{fc}nchenstein etwa auf H\u{f6}he der Br\u{fc}cke \"Baselstrasse\" \u{fc}ber die Birs. Es liegen aktuelle Werte alle 5 Minuten vor. Die Messungen werden im Auftrag des Bundesamts f\u{fc}r Umwelt durchgef\u{fc}hrt (siehe <a href=\"https://www.hydrodaten.admin.ch/de/2106.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/2106.html</a>).</p>"]
pub mod birs_temperatur_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmetern pro Sekunde
        pub abfluss: Option<f64>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
        /// Temperatur
        ///
        /// Temperatur in Grad Celsius
        pub temperatur: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Abfluss,
        Pegel,
        Temperatur,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Abfluss => "abfluss",
                Field::Pegel => "pegel",
                Field::Temperatur => "temperatur",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100236/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smart Climate Feinstaubmessungen"]
#[doc = ""]
#[doc = "<p>Im Rahmen des Projektes <a href=\"https://smartregiobasel.ch/de/projekte/smart-climate-plug-and-sense\" target=\"_blank\">\u{ab}Smart Climate\u{bb} von Smart Regio Basel (https://smartregiobasel.ch/de/projekte/smart-climate-plug-and-sense)</a> wurden in der ersten Projektphase an zehn Standorten in der Region Basel Luftdaten mit Mikrosensoren gemessen. Das Lufthygieneamt beider Basel, das Amt f\u{fc}r Umwelt und Energie des Kantons Basel-Stadt, der Basler Wetterdienstleister meteoblue AG, die IWB sowie die Sensirion AG schlossen sich zusammen, um in diesem Pilotprojekt den Einsatz von kosteneffizienten Sensoren zur Erfassung des \u{ab}regionalen Mikroklimas\u{bb} zu testen. Hier werden die unvalidierten Daten von Feinstaub PM2.5 zur Verf\u{fc}gung gestellt.\u{a0}Die erste Projektphase wurde Ende 2021 ausgewertet und basierend auf den Ergebnissen das Messnetz verkleinert. Ab Fr\u{fc}hling 2022 werden die Messstationen \u{ab}Erlenparkweg 55\u{bb}, \u{ab}Feldbergstrasse\u{bb}, \u{ab}NABEL Binningen\u{bb}, \u{ab}St. Johanns-Platz\u{bb} und \u{ab}Z\u{fc}rcherstrasse 148 (Breite) weiter betrieben. Die Stationen \u{ab}Goldbachweg\u{bb}, \u{ab}Grenzacherstrasse\u{bb}, \u{ab}Laufenstrasse\u{bb}, \u{ab}Rennweg 89\u{bb} und \u{ab}TS Hochbergerstrasse 162\u{bb} wurden sukzessive ausser Betrieb genommen. Die Daten aus der ersten Projektphase stehen hier nach wie vor zur Verf\u{fc}gung.\u{a0}</p><p>Informationen zu den Standorten der Sensoren sind im Datensatz \u{ab}Standorte Feinstaub Mess-Stationen Smart Climate Luftqualit\u{e4}t\u{bb} ersichtlich:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100084\" target=\"_blank\">https://data.bs.ch/explore/dataset/100084</a>\u{a0}\u{a0}</p>"]
pub mod smart_climate_feinstaubmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitstempel: Option<OffsetDateTime>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm_2_5: Option<f64>,
        /// Station Name
        pub name: Option<String>,
        /// Station Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Station ID
        pub id: Option<String>,
        pub station: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Zeitstempel,
        Pm25,
        Name,
        Id,
        Station,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zeitstempel => "zeitstempel",
                Field::Pm25 => "pm_2_5",
                Field::Name => "name",
                Field::Id => "id",
                Field::Station => "station",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100081/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smart Climate Schallpegelmessungen"]
#[doc = ""]
#[doc = "<p>Im Rahmen des Projektes \u{ab}Smart Climate\u{bb} von\nSmart Regio Basel (<a href=\"https://smartregiobasel.ch/de/projekte/smart-climate-plug-and-sense\" target=\"_blank\">https://smartregiobasel.ch/de/projekte/smart-climate-plug-and-sense</a>)\nwerden an verschiedenen Standorten in der Region Basel Schallpegeldaten mit\nLoRa-Sensoren gemessen. Das Lufthygieneamt beider Basel, das Amt f\u{fc}r Umwelt und\nEnergie des Kantons Basel-Stadt, der Basler Wetterdienstleister meteoblue AG,\ndie IWB sowie die Sensirion AG schlossen sich zusammen, um in diesem\nPilotprojekt den Einsatz von kosteneffizienten Sensoren zur Erfassung des\n\u{ab}regionalen Mikroklimas\u{bb} zu testen. Hier werden die unvalidierten\nSchallpegeldaten (Leq) zur Verf\u{fc}gung gestellt.</p>"]
pub mod smart_climate_schallpegelmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station
        ///
        /// Name der Station
        pub station_id: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wert
        ///
        /// Gemessene Lautstärke in Dezibel
        pub value: Option<f64>,
        /// Geopunkt
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geographische Breite
        pub latitude: Option<f64>,
        /// Geographische Länge
        pub longitude: Option<f64>,
        /// EUI
        ///
        /// ID der Mess-Station
        pub eui: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        StationId,
        Timestamp,
        Value,
        Latitude,
        Longitude,
        Eui,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::Timestamp => "timestamp",
                Field::Value => "value",
                Field::Latitude => "latitude",
                Field::Longitude => "longitude",
                Field::Eui => "eui",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100087/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rhein Wasserstand Klingentalf\u{e4}hre"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt den Wasserstand des Rheins in Basel auf der Grossbasler Seite auf H\u{f6}he der Klingentalf\u{e4}hre. Es liegen aktuelle Werte alle 5 Minuten vor. Die Messungen werden im Auftrag des Bundesamts f\u{fc}r Umwelt durchgef\u{fc}hrt (siehe <a href=\"https://www.hydrodaten.admin.ch/de/2615.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/2615.html</a>).</p>"]
pub mod rhein_wasserstand_klingentalfaehre {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Pegel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Pegel => "pegel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100243/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Strassenverkehrsunf\u{e4}lle"]
#[doc = ""]
#[doc = "Die Strassenverkehrsunf\u{e4}lle im Kanton Basel-Stadt seit 2011 werden nach Unfalltyp und Unfallschweregrad kategorisiert dargestellt. Die Daten werden j\u{e4}hrlich aktualisiert."]
pub mod strassenverkehrsunfaelle {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Eindeutiger Identifikator des Unfalls
        ///
        /// Eindeutiger Identifikator des Unfalls aus der MISTRA-Applikation Verkehrsunfälle.
        pub id_unfall: Option<i64>,
        /// Beschreibung zum Unfalltyp
        ///
        /// Der Unfalltyp bezeichnet den Verkehrsvorgang bzw. die Konfliktsituation, welche massgebend für die Entstehung des Unfalls ist.
        pub typ: Option<String>,
        /// Beschreibung der Unfallschwerekategorie
        ///
        /// Beschreibung der Unfallschwerekategorie.
        pub schwere: Option<String>,
        /// Unfalljahr
        ///
        /// Unfalljahr in dem sich der Unfall ereignet hat.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr: Option<Date>,
        /// Unfallmonat
        ///
        /// Unfallmonat in dem sich der Unfall ereignet hat.
        pub monat: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag an dem sich der Unfall ereignet hat.
        pub wochentag: Option<String>,
        /// Unfallstunde
        ///
        /// Beschreibung der Unfallstunde, in der sich der Unfall ereignet hat.
        pub stunde: Option<i64>,
        /// Strassenart
        ///
        /// Art der Strasse auf der sich der Unfall ereignet hat.
        pub strasseart: Option<String>,
        /// Fussgängerbeteiligung
        ///
        /// War ein Fussgänger am Unfall beteiligt
        pub fussgg_bet: Option<String>,
        /// Fahrradbeteiligung
        ///
        /// War ein Fahrrad am Unfall beteiligt
        pub fahrrd_bet: Option<String>,
        /// Motorradbeteiligung
        ///
        /// War ein Motorrad am Unfall beteiligt
        pub motord_bet: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdUnfall,
        Typ,
        Schwere,
        Jahr,
        Monat,
        Wochentag,
        Stunde,
        Strasseart,
        FussggBet,
        FahrrdBet,
        MotordBet,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdUnfall => "id_unfall",
                Field::Typ => "typ",
                Field::Schwere => "schwere",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Wochentag => "wochentag",
                Field::Stunde => "stunde",
                Field::Strasseart => "strasseart",
                Field::FussggBet => "fussgg_bet",
                Field::FahrrdBet => "fahrrd_bet",
                Field::MotordBet => "motord_bet",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100120/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rheinmesswerte kontinuierlich"]
#[doc = ""]
#[doc = "<p>Kontinuierlich gemessene Parameter der <a href=\"https://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html\" target=\"_blank\">Rhein\u{fc}berwachungsstation Weil am Rhein</a>\u{a0}(RUES), jeweils gemittelt \u{fc}ber 15 Minuten. Werte werden alle 15 Minuten wie von den Sensoren gemessen als Rohdaten publiziert. J\u{e4}hrlich werden die Daten manuell plausibilisiert und als Stundenwerte ver\u{f6}ffentlicht.\u{a0}</p><p>Standort: Rheinkilometer 171.37km</p><p>Koordinaten: <a href=\"https://www.google.ch/maps/place/47%C2%B036\'04.7%22N+7%C2%B035\'41.5%22E\" target=\"_blank\">E 7.594868 N 47.601299</a>\u{a0}bzw. E 7\u{b0} 35\u{2018} 39.55\u{201c} N 47\u{b0} 36\u{2018} 4.68\u{201c} bzw. 611740 / 272310</p><p>Tr\u{e4}ger: Schweizerische Eidgenossenschaft; Bundesamt f\u{fc}r Umwelt (BAFU), Land Baden-W\u{fc}rttemberg; Ministerium f\u{fc}r Umwelt, Klima und Energiewirtschaft / Landesanstalt f\u{fc}r Umwelt, Messungen und Naturschutz Baden-W\u{fc}rttemberg (LUBW)</p><p>Messbetrieb / Unterhalt: <a href=\"https://www.aue.bs.ch\" target=\"_blank\">Amt f\u{fc}r Umwelt und Energie Basel-Stadt (AUE-BS)</a></p>"]
pub mod rheinmesswerte_kontinuierlich {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Startzeitpunkt
        ///
        /// Start der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub startzeitpunkt: Option<OffsetDateTime>,
        /// Start_text
        ///
        /// Start der Messung
        pub start_text: Option<String>,
        /// Endezeitpunkt
        ///
        /// Ende der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub endezeitpunkt: Option<OffsetDateTime>,
        /// Ende_text
        ///
        /// Ende der Messung
        pub ende_text: Option<String>,
        /// Elektrische Leitfähigkeit [µS/cm]
        ///
        /// Elektrische Leitfähigkeit Strang S3 in µS/cm, Koordinaten 611740 / 272310
        pub rus_w_o_s3_lf: Option<f64>,
        /// Sauerstoffgehalt [mg/L]
        ///
        /// Sauerstoffgehalt Strang S3 in mg/L
        pub rus_w_o_s3_o2: Option<f64>,
        /// pH-Wert
        ///
        /// pH-Wert Strang S3
        pub rus_w_o_s3_ph: Option<f64>,
        /// Temperatur [°C]
        ///
        /// Temperatur Strang S3 in °C
        pub rus_w_o_s3_te: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Startzeitpunkt,
        StartText,
        Endezeitpunkt,
        EndeText,
        RusWOS3Lf,
        RusWOS3O2,
        RusWOS3Ph,
        RusWOS3Te,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Startzeitpunkt => "startzeitpunkt",
                Field::StartText => "start_text",
                Field::Endezeitpunkt => "endezeitpunkt",
                Field::EndeText => "ende_text",
                Field::RusWOS3Lf => "rus_w_o_s3_lf",
                Field::RusWOS3O2 => "rus_w_o_s3_o2",
                Field::RusWOS3Ph => "rus_w_o_s3_ph",
                Field::RusWOS3Te => "rus_w_o_s3_te",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100046/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Solarkataster: Dachkanten"]
#[doc = ""]
#[doc = "Die Klasse Dachkante ist ein wesentlicher Bestandteil des Geodatenmodells (KGDM) \u{ab}Solarkataster\u{bb} und beschreibt die Dachkanten der Geb\u{e4}ude, die in der Klasse Solarpotenzial erfasst sind. \n<br> S\u{e4}mtliche Datens\u{e4}tze zu dem Produkt \"Solarkataster\": <a href=\"https://data.bs.ch/explore/?refine.tags=solarkataster\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=solarkataster</a>\n<br>Diese Dachkanten repr\u{e4}sentieren die \u{dc}bergangsbereiche zwischen den Dachfl\u{e4}chen und den Geb\u{e4}udefassaden und dienen als visuelle Referenz zur Unterst\u{fc}tzung der Analyse und Bewertung des Solarpotenzials.\n<br>Die Klasse Dachkante ist besonders n\u{fc}tzlich f\u{fc}r Fachleute, die sich mit der Planung und Bewertung von Solaranlagen besch\u{e4}ftigen. Sie dient als Grundlage f\u{fc}r detaillierte Analysen und Entscheidungsprozesse in der solartechnischen Nutzung von Geb\u{e4}uden."]
pub mod solarkataster_dachkanten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Dachkante
        ///
        /// Identifikator der Dachkante
        pub id_dkante: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdDkante,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdDkante => "id_dkante",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100383/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Luftqualit\u{e4}t des Vortages"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Maximalwerte (O3) und Mittelwerte (NO2, PM 2.5) des Vortages f\u{fc}r die verschiedenen Messwerte als Vergleichswerte f\u{fc}r die Echtzeitdaten.<br/>Die Echtzeitdaten sind unter folgendem Datensatz zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100093/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100093/table/</a>\u{a0}\u{a0}</p><p>Das\u{a0}<a href=\"https://www.baselland.ch/politik-und-behorden/direktionen/bau-und-umweltschutzdirektion/lufthygiene\" target=\"_blank\">Lufthygieneamt beider Basel</a>\u{a0}(LHA) testet im Projekt \u{ab}Smarte Strasse\u{bb} kosteneffiziente Mikrosensoren auf ihre Genauigkeit und Zuverl\u{e4}ssigkeit. Der installierte Sensor vom Typ \u{ab}Nubo\u{bb} der Firma Sensirion AG ist in der Lage, die Konzentration verschiedener Schadstoffe in der Luft in Echtzeit zu ermitteln. Gemessen werden die Gehalte der Gase Stickstoffdioxid (NO2) und Ozon (O3), sowie die feinere Fraktion des Feinstaubs \u{ab}PM2.5\u{bb}. Die Belastungen mit Stickstoffdioxid und Feinstaub werden haupts\u{e4}chlich durch den motorisierten Verkehr und durch Heizungen verursacht. Ozon wird in der Atmosph\u{e4}re aus den Vorl\u{e4}uferschadstoffen Stickstoffdioxid und fl\u{fc}chtigen organischen Stoffen (VOC) unter Sonneneinwirkung gebildet. Parallel wurden drei \u{ab}Nubo\u{bb}- Sensoren an den permanenten Messstationen des LHA am St. Johanns-Platz, an der Feldbergastrasse und auf der Autobahn A2 in der Hard installiert und gegen die Referenzmessger\u{e4}te des LHA verglichen. Diese Werte stehen ebenfalls auf OGD zur Verf\u{fc}gung:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100178\" target=\"_blank\">https://data.bs.ch/explore/dataset/100178</a><br/>Weitere Informationen zur Luftqualit\u{e4}t in der Region Basel sind auf\u{a0}<a href=\"https://www.luftqualitaet.ch/\" target=\"_blank\">www.luftqualitaet.ch</a>\u{a0}verf\u{fc}gbar. Hintergrundinformationen zu Ozon und Feinstaub auf den Webseiten\u{a0}<a href=\"https://www.ozon-info.ch/\" target=\"_blank\">www.ozon-info.ch</a>\u{a0}und\u{a0}<a href=\"https://www.feinstaub.ch/\" target=\"_blank\">www.feinstaub.ch</a>. Angaben zu den gesundheitlichen Auswirkungen der Luftverschmutzung auf der Webseite\u{a0}<a href=\"https://www.swisstph.ch/de/projects/ludok/healtheffects/\" target=\"_blank\">https://www.swisstph.ch/de/projects/ludok/healtheffects/</a>.</p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><span style=\"font-weight: bolder;\">Hinweis:<br/>Die Luft-Sensoren an der Gundeldingerstrasse wurden am 29.6.23 abmontiert. Seit Anfang/Mitte Juni wurden keine Daten mehr erhoben.</span><br/></p>"]
pub mod smarte_strasse_luftqualitaet_des_vortages {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel = Anfangszeit des 30 minütigen Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// G107 NO2
        ///
        /// Tagesmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_no2: Option<f64>,
        /// G107 O3
        ///
        /// Tageshöchstwert O3 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_03: Option<f64>,
        /// G107 PM2.5
        ///
        /// Tagesmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_pm25: Option<f64>,
        /// G125 NO2
        ///
        /// Tagesmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_no2: Option<f64>,
        /// G125 O3
        ///
        /// Tageshöchstwert O3 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_o3: Option<f64>,
        /// G125 PM2.5
        ///
        /// Tagesmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_pm25: Option<f64>,
        /// G131 NO2
        ///
        /// Tagesmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_no2: Option<f64>,
        /// G131 O3
        ///
        /// Tageshöchstwert O3 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_o3: Option<f64>,
        /// G131 PM2.5
        ///
        /// Tagesmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_pm25: Option<f64>,
        pub timestamp_text: Option<String>,
        /// Anfangszeit
        pub anfangszeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        G107No2,
        G10703,
        G107Pm25,
        G125No2,
        G125O3,
        G125Pm25,
        G131No2,
        G131O3,
        G131Pm25,
        TimestampText,
        Anfangszeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::G107No2 => "g107_no2",
                Field::G10703 => "g107_03",
                Field::G107Pm25 => "g107_pm25",
                Field::G125No2 => "g125_no2",
                Field::G125O3 => "g125_o3",
                Field::G125Pm25 => "g125_pm25",
                Field::G131No2 => "g131_no2",
                Field::G131O3 => "g131_o3",
                Field::G131Pm25 => "g131_pm25",
                Field::TimestampText => "timestamp_text",
                Field::Anfangszeit => "anfangszeit",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100174/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Reproduktionszahl (Re)"]
#[doc = ""]
#[doc = "<p>Gesch\u{e4}tzte t\u{e4}gliche effektive Reproduktionszahl f\u{fc}r die Schweiz, die Schweizer Grossregionen sowie die Schweizer Kantone. Die effektive Reproduktionszahl ist ein Mass daf\u{fc}r, wie viele Personen eine infizierte Person durchschnittlich ansteckt. Die Werte wurden t\u{e4}glich von der ETH Z\u{fc}rich berechnet. Die Originaldaten sind auf <a href=\"https://github.com/covid-19-Re/dailyRe-Data\" target=\"_blank\">https://github.com/covid-19-Re/dailyRe-Data</a> sowie <a href=\"https://github.com/covid-19-Re/dailyRe-Data/blob/master/CHE-estimates.csv\" target=\"_blank\">https://github.com/covid-19-Re/dailyRe-Data/blob/master/CHE-estimates.csv</a> verf\u{fc}gbar.</p><p>Die gesch\u{e4}tzte effektive Reproduktionszahl bildet aufgrund der Infektionsdynamik (Inkubationszeit, Meldeverzug, etc.) schweizweit das Infektionsgeschehen erst mit einer zeitlichen Verz\u{f6}gerung von 10-13 Tagen ab. Auf kantonaler Ebene betr\u{e4}gt die zeitliche Verz\u{f6}gerung 14-17 Tage.\u{a0}</p><p>Weitere Informationen zur Interpretation der effektiven Reproduktionszahl finden sich bei der Swiss National Covid-19 Task Force: <a href=\"https://sciencetaskforce.ch/reproduktionszahl\" target=\"_blank\">https://sciencetaskforce.ch/reproduktionszahl</a>\u{a0}</p><p>Details und Quellenangaben zur verwendeten Methodik finden sich auf dem Covid-19-Dashboard der ETH Z\u{fc}rich: <a href=\"https://ibz-shiny.ethz.ch/covid-19-re-international\" target=\"_blank\">https://ibz-shiny.ethz.ch/covid-19-re-international</a>\u{a0}</p><div><br/></div>"]
pub mod coronavirus_covid_19_reproduktionszahl_re {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Land
        ///
        /// Das Land, für welches die Werte geschätzt wurden
        pub country: Option<String>,
        /// Region
        ///
        /// Das Land, die Grossregion bzw. der Kanton, für welche/n die Werte geschätzt wurden
        pub region: Option<String>,
        /// Datenquelle
        ///
        /// Quelle aus der die verwendeten Daten stammen
        pub source: Option<String>,
        /// Datentyp
        ///
        /// Art der für die Schätzung verwendeten Daten
        pub data_type: Option<String>,
        /// Schätzmethode
        ///
        /// Die bei der Schätzung verwendete Methodik
        pub estimate_type: Option<String>,
        /// Datum
        ///
        /// Datum, für welches die effektive Reproduktionszahl berechnet wurde. Da sich die effektive Reproduktionszahl erst mit zeitlichem Verzug berechnen lässt, liegt der letzte verfügbare Schätzwert in der Vergangenheit
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Mittlere effektive Reproduktionszahl
        ///
        /// Die mittlere geschätzte effektive Reproduktionszahl
        pub median_r_mean: Option<f64>,
        /// Obere Grenze der effektiven Reproduktionszahl
        ///
        /// Die obere Grenze des 95%-Vertrauensintervalls der mittleren geschätzten effektiven Reproduktionszahl
        pub median_r_highhpd: Option<f64>,
        /// Untere Grenze der effektiven Reproduktionszahl
        ///
        /// Die untere Grenze des 95%-Vertrauensintervalls der mittleren geschätzten effektiven Reproduktionszahl
        pub median_r_lowhpd: Option<f64>,
        /// Land (Iso Code)
        ///
        /// Iso Code des Landes, für welches die Werte geschätzt wurden
        pub countryiso3: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Country,
        Region,
        Source,
        DataType,
        EstimateType,
        Date,
        MedianRMean,
        MedianRHighhpd,
        MedianRLowhpd,
        Countryiso3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Country => "country",
                Field::Region => "region",
                Field::Source => "source",
                Field::DataType => "data_type",
                Field::EstimateType => "estimate_type",
                Field::Date => "date",
                Field::MedianRMean => "median_r_mean",
                Field::MedianRHighhpd => "median_r_highhpd",
                Field::MedianRLowhpd => "median_r_lowhpd",
                Field::Countryiso3 => "countryiso3",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100110/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Zu- und Wegfahrten, Parkplatzauslastung"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Anzahl Zu- und Wegfahrten sowie die mittlere Parkplatzauslastung f\u{fc}r die beiden Zonen \u{ab}blau\u{bb} und \u{ab}gelb\u{bb}.</p><p><b>Die Detektion freier Parkpl\u{e4}tze mittels Kamera befindet sich noch in der Testphase. Aus diesem Grund sind die Werte mit Vorsicht zu geniessen und k\u{f6}nnen von den tats\u{e4}chlichen Zust\u{e4}nden abweichen.</b></p><p>Zus\u{e4}tzlich relevante Datens\u{e4}tze f\u{fc}r die Parkplatzbelegung:</p><ul><li><a href=\"https://data.bs.ch/explore/dataset/100160/\" target=\"_blank\">Parkplatzbelegung</a></li><li><a href=\"https://data.bs.ch/explore/dataset/100176/\" target=\"_blank\">Parkplatz-Zonen</a><br/></li></ul><p>Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</p><ul><li>Weitere Informationen zum Projekt\u{a0}\u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b style=\"font-family\">Hinweis:<br/>Die Parkplatz-Kamera an der Gundeldingerstrasse wurde am Dienstag 4.10.2022 abmontiert. Es werden keine Daten mehr erhoben.</b><br/></p>"]
pub mod smarte_strasse_zu_und_wegfahrten_parkplatzauslastung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// von
        ///
        /// Start der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub from: Option<OffsetDateTime>,
        /// bis
        ///
        /// Ende der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub to: Option<OffsetDateTime>,
        /// Typ
        ///
        /// Parklatztyp
        pub r#type: Option<String>,
        /// Summe Zufahrten
        pub sum_inflow: Option<f64>,
        /// Summe Wegfahrten
        pub sum_outflow: Option<f64>,
        /// Auslastung (Mittelwert in %)
        ///
        /// Durchschnittliche Auslastung
        pub avg_occupancy_abs: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        From,
        To,
        RType,
        SumInflow,
        SumOutflow,
        AvgOccupancyAbs,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::From => "from",
                Field::To => "to",
                Field::RType => "type",
                Field::SumInflow => "sum_inflow",
                Field::SumOutflow => "sum_outflow",
                Field::AvgOccupancyAbs => "avg_occupancy_abs",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100171/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Aktuelle Temperaturen der Gartenb\u{e4}der"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz enth\u{e4}lt die aktuellen Wassertemperaturen in den Gartenb\u{e4}dern</p><p style=\"font-family: sans-serif;\">Die Temperaturdaten werden alle 15 Minuten aktualisiert, indem ein automatisiertes Programm die neuesten Werte von der Webseite\u{a0}<a href=\"https://www.ed-baeder.ch/\" target=\"_blank\">https://www.ed-baeder.ch/</a>\u{a0}abruft. Auf dieser Webseite findet man auch sonstige Meldungen zu den Gartenb\u{e4}dern.</p><p style=\"font-family: sans-serif;\">Falls ein Gartenbad geschlossen ist oder keine Temperaturmessung verf\u{fc}gbar ist, wird f\u{fc}r diesen Zeitraum kein Wert im Datensatz vermerkt.</p><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weiterf\u{fc}hrende Links:</span></p><p style=\"font-family: sans-serif;\">Weitere Informationen zu den Gartenb\u{e4}dern:\u{a0}<a href=\"https://www.jfs.bs.ch/fuer-sportlerinnen-und-sportler/sportanlagen/gartenbaeder.html\" target=\"_blank\">https://www.jfs.bs.ch/fuer-sportlerinnen-und-sportler/sportanlagen/gartenbaeder.html</a></p><p style=\"font-family: sans-serif;\">Zeitreihe der Temperaturen der Gartenb\u{e4}der als Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100384\" target=\"_blank\">https://data.bs.ch/explore/dataset/100384</a></p><p style=\"font-family: sans-serif;\">Diese und weitere Sportanlagen als Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100151\" target=\"_blank\">https://data.bs.ch/explore/dataset/100151</a></p>"]
pub mod aktuelle_temperaturen_der_gartenbaeder {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        ///
        /// Name des Bads
        pub name: Option<String>,
        /// Temperatur
        ///
        /// Temperatur des Wassers
        pub temperatur: Option<i64>,
        /// Zeit
        ///
        /// Zeitpunkt, an dem die Daten gescraped wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitpunkt_job: Option<OffsetDateTime>,
        /// Koordinaten
        ///
        /// Punktkoordinate des Bads
        pub koordinaten: Option<GeoPoint2d>,
        /// URL Sportanlage
        ///
        /// Link zum Datensatz "Sport- und Bewegungsanlagen"
        pub url_sportanlage: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
        Temperatur,
        ZeitpunktJob,
        UrlSportanlage,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Temperatur => "temperatur",
                Field::ZeitpunktJob => "zeitpunkt_job",
                Field::UrlSportanlage => "url_sportanlage",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100388/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Luftqualit\u{e4}t Station St. Johannplatz"]
#[doc = ""]
#[doc = "<p>Standortbeschreibung:\u{a0}Die Messstation befindet sich in Basel auf dem St.Johannplatz, einem kleinen Park am Rande der Altstadt. Sie wird lokal beeinflusst durch eine m\u{e4}ssig befahrene Strasse und Parkplatzsuchverkehr. 500m n\u{f6}rdlich verl\u{e4}uft eine stark befahrene Strasse und in dieser Richtung liegt auch ein Teil der Chemischen Industrie. Die Station Basel St.Johannplatz gibt die Belastung wieder, wie sie als Hintergrund \u{fc}berall in der Stadt Basel anzutreffen ist.</p>Lage: Stadtzentrum in Park, offene Bebauung<p>Koordinaten: 2610790 / 1268370 bzw.\u{a0}N 47\u{b0} 33.957 E 7\u{b0} 34.921; 260 m \u{fc}. M.Geografische Lage: Juranordfuss</p><p>Siedlungsgr\u{f6}sse: 166\'600 Einwohner</p><p>Verkehr, DTV (% LKW): &lt; 9\'100 / 32\'000 (8%)</p><p>Strassenabstand: 2 m / 500</p>"]
pub mod luftqualitaet_station_st_johannplatz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        pub timestamp_text: Option<String>,
        /// PM10 (Stundenmittelwerte)
        pub pm10_stundenmittelwerte_ug_m3: Option<f64>,
        /// PM2.5 (Stundenmittelwerte)
        pub pm2_5_stundenmittelwerte_ug_m3: Option<f64>,
        /// O3 (Stundenmittelwerte)
        pub o3_stundenmittelwerte_ug_m3: Option<f64>,
        /// NO2 (Stundenmittelwerte)
        pub no2_stundenmittelwerte_ug_m3: Option<f64>,
        /// Standort
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        Pm10StundenmittelwerteUgM3,
        Pm25StundenmittelwerteUgM3,
        O3StundenmittelwerteUgM3,
        No2StundenmittelwerteUgM3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::Pm10StundenmittelwerteUgM3 => "pm10_stundenmittelwerte_ug_m3",
                Field::Pm25StundenmittelwerteUgM3 => "pm2_5_stundenmittelwerte_ug_m3",
                Field::O3StundenmittelwerteUgM3 => "o3_stundenmittelwerte_ug_m3",
                Field::No2StundenmittelwerteUgM3 => "no2_stundenmittelwerte_ug_m3",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100049/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Briefliche Stimmbeteiligung"]
#[doc = ""]
#[doc = "<div>Dieser Datensatz zeigt die briefliche Stimmbeteiligung der Urneng\u{e4}nge f\u{fc}r die Stadt Basel. Vor Urneng\u{e4}ngen informiert die Staatskanzlei regelm\u{e4}ssig \u{fc}ber den Stand der Stimmbeteiligung per brieflicher Abgabe.</div><div><br/></div><div>Die effektive Stimm-/Wahlbeteiligung inkl. pers\u{f6}nlicher Stimmabgabe an der Urne steht erst nach der Ausz\u{e4}hlung am Abstimmungssontag fest und wird ebenfalls auf diesem Datenportal zur Verf\u{fc}gung gestellt (<a href=\"https://data.bs.ch/explore/?sort=modified&amp;refine.publisher=Staatskanzlei&amp;q=%22Kennzahlen+der+Abstimmung%22+OR+%22Wahl+der+100%22+OR+%22Wahlgangs%22\" target=\"_blank\">Kennzahlen Wahlen/Abstimmungen</a>).\u{a0}</div><div><br/></div>"]
pub mod briefliche_stimmbeteiligung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Tag
        ///
        /// Wochentag an dem die Stimmbeteiligung erhoben wurde
        pub tag: Option<String>,
        /// Datum
        ///
        /// Datum an dem die Stimmbeteiligung erhoben wurde.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Eingang pro Tag
        ///
        /// Erhaltene Briefeingänge an diesem Tag
        pub eingang_pro_tag: Option<i64>,
        /// Eingang kumuliert
        ///
        /// Total erhaltene Briefeingänge bis zu diesem Datum
        pub eingang_kumuliert: Option<i64>,
        /// Stimmbeteiligung (%)
        ///
        /// Prozentualer Anteil der von Stimmberechtigten bereits abgegebenen Stimmzettel
        pub stimmbeteiligung: Option<f64>,
        /// Datum Urnengang
        ///
        /// Datum des Urnengangs
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_urnengang: Option<Date>,
        /// Tage bis Urnengang
        ///
        /// Verbleibende Tage bis zum Urnengang
        pub tage_bis_urnengang: Option<i64>,
        /// Abstimmungen
        ///
        /// Ja: Urnengang mit Abstimmung; Nein: Urnengang ohne Abstimmung
        pub abstimmungen: Option<String>,
        /// Wahlen
        ///
        /// Ja: Urnengang mit Wahlen; Nein: Urnengang ohne Wahlen
        pub wahlen: Option<String>,
        /// Art der Wahl(-en)
        pub wahlen_typ: Option<String>,
        /// Datum Urnengang (Rohtext)
        ///
        /// Datum des Urnengangs in YYYY-MM-DD-Format
        pub datum_urnengang_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Tag,
        Datum,
        EingangProTag,
        EingangKumuliert,
        Stimmbeteiligung,
        DatumUrnengang,
        TageBisUrnengang,
        Abstimmungen,
        Wahlen,
        WahlenTyp,
        DatumUrnengangText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Tag => "tag",
                Field::Datum => "datum",
                Field::EingangProTag => "eingang_pro_tag",
                Field::EingangKumuliert => "eingang_kumuliert",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::DatumUrnengang => "datum_urnengang",
                Field::TageBisUrnengang => "tage_bis_urnengang",
                Field::Abstimmungen => "abstimmungen",
                Field::Wahlen => "wahlen",
                Field::WahlenTyp => "wahlen_typ",
                Field::DatumUrnengangText => "datum_urnengang_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100223/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Luftqualit\u{e4}t"]
#[doc = ""]
#[doc = "<p>Das <a href=\"https://www.baselland.ch/politik-und-behorden/direktionen/bau-und-umweltschutzdirektion/lufthygiene\" target=\"_blank\">Lufthygieneamt beider Basel</a> (LHA) testet im Projekt \u{ab}Smarte Strasse\u{bb} kosteneffiziente Mikrosensoren auf ihre Genauigkeit und Zuverl\u{e4}ssigkeit. Der installierte Sensor vom Typ \u{ab}Nubo\u{bb} der Firma Sensirion AG ist in der Lage, die Konzentration verschiedener Schadstoffe in der Luft in Echtzeit zu ermitteln. Gemessen werden die Gehalte der Gase Stickstoffdioxid (NO2) und Ozon (O3), sowie die feinere Fraktion des Feinstaubs \u{ab}PM2.5\u{bb}. Die Belastungen mit Stickstoffdioxid und Feinstaub werden haupts\u{e4}chlich durch den motorisierten Verkehr und durch Heizungen verursacht. Ozon wird in der Atmosph\u{e4}re aus den Vorl\u{e4}uferschadstoffen Stickstoffdioxid und fl\u{fc}chtigen organischen Stoffen (VOC) unter Sonneneinwirkung gebildet. Parallel wurden drei \u{ab}Nubo\u{bb}- Sensoren an den permanenten Messstationen des LHA am St. Johanns-Platz, an der Feldbergastrasse und auf der Autobahn A2 in der Hard installiert und gegen die Referenzmessger\u{e4}te des LHA verglichen. Diese Werte stehen ebenfalls auf OGD zur Verf\u{fc}gung:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100178\" target=\"_blank\">https://data.bs.ch/explore/dataset/100178</a><br/>Weitere Informationen zur Luftqualit\u{e4}t in der Region Basel sind auf <a href=\"https://www.luftqualitaet.ch\" target=\"_blank\">www.luftqualitaet.ch</a>\n verf\u{fc}gbar. Hintergrundinformationen zu Ozon und Feinstaub auf den Webseiten <a href=\"https://www.ozon-info.ch\" target=\"_blank\">www.ozon-info.ch</a> und <a href=\"https://www.feinstaub.ch\" target=\"_blank\">www.feinstaub.ch</a>. Angaben zu den gesundheitlichen Auswirkungen der Luftverschmutzung auf der Webseite\u{a0}<a href=\"https://www.swisstph.ch/de/projects/ludok/healtheffects/\" target=\"_blank\">https://www.swisstph.ch/de/projects/ludok/healtheffects/</a>.</p><p>Die Maximalwerte (O3) und Mittelwerte (NO2, PM 2.5) des Vortages\u{a0}sind unter folgendem Datensatz zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100174/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100174/table/</a>\u{a0}</p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b>Hinweis:<br/>Die Luft-Sensoren an der Gundeldingerstrasse wurden am 29.6.23 abmontiert. Seit Anfang/Mitte Juni wurden keine Daten mehr erhoben.</b><br/></p>"]
pub mod smarte_strasse_luftqualitaet {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel = Anfangszeit des 30 minütigen Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// G107 NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_no2: Option<f64>,
        /// G107 O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_03: Option<f64>,
        /// G107 PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 107
        pub g107_pm25: Option<f64>,
        /// G125 NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_no2: Option<f64>,
        /// G125 O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_o3: Option<f64>,
        /// G125 PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 125
        pub g125_pm25: Option<f64>,
        /// G131 NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_no2: Option<f64>,
        /// G131 O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_o3: Option<f64>,
        /// G131 PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Gundeldingerstrasse 131
        pub g131_pm25: Option<f64>,
        pub timestamp_text: Option<String>,
        /// Anfangszeit
        pub anfangszeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        G107No2,
        G10703,
        G107Pm25,
        G125No2,
        G125O3,
        G125Pm25,
        G131No2,
        G131O3,
        G131Pm25,
        TimestampText,
        Anfangszeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::G107No2 => "g107_no2",
                Field::G10703 => "g107_03",
                Field::G107Pm25 => "g107_pm25",
                Field::G125No2 => "g125_no2",
                Field::G125O3 => "g125_o3",
                Field::G125Pm25 => "g125_pm25",
                Field::G131No2 => "g131_no2",
                Field::G131O3 => "g131_o3",
                Field::G131Pm25 => "g131_pm25",
                Field::TimestampText => "timestamp_text",
                Field::Anfangszeit => "anfangszeit",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100093/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Baustellen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt umfassende Informationen zu aktuellen und bevorstehende Baustellen (Baubewilligung erteilt) auf \u{f6}ffentlichem Grund im Kanton Basel-Stadt. Er enth\u{e4}lt Informationen wie z. B. an welcher Strasse sich die Baustelle befindet, die Beschreibung des Projektes, m\u{f6}gliche Zusatzinformationen, Links zum Projekt und zu Anwohnerinformationen. Die Fallnummer der Allmendbewilligung und der Link zum OGD-Datensatz mit den Allmendbewilligungen sind ebenfalls im Datensatz aufgef\u{fc}hrt.</p><p>Dieser Datensatz ist maschinenlesbar und barrierefrei.\u{a0}</p><p>\n</p><p>\nDiese Daten werden vom Tiefbauamt des Kantons Basel-Stadt zur Verf\u{fc}gung gestellt. Die Baustellen finden Sie auch auf einer interaktiven Karte unter <a href=\"https://baustellen.bs.ch\" target=\"_blank\">https://baustellen.bs.ch</a>.\u{a0}</p><p></p><p></p>"]
pub mod baustellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Strasse - Projektname
        ///
        /// Das ist die Strasse auf dem das Projekt stattfindet.
        pub projekt_name: Option<String>,
        /// Beschreibung
        pub projekt_beschrieb: Option<String>,
        /// Zusatzinformationen
        pub projekt_info: Option<String>,
        /// Weblink Projekt
        ///
        /// Link zum Projekt
        pub projekt_link: Option<String>,
        /// Baubeginn
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_von: Option<Date>,
        /// Bauende
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_bis: Option<Date>,
        /// Dokument 1
        ///
        /// Dokument mit Anwohnerinformationen
        pub dokument1: Option<String>,
        /// Dokument 2
        ///
        /// Dokument mit Anwohnerinformationen
        pub dokument2: Option<String>,
        /// Dokument 3
        ///
        /// Dokument mit Anwohnerinformationen
        pub dokument3: Option<String>,
        /// Fallnummer Allmendbewilligung
        pub id: Option<i64>,
        /// Weblink Allmendbewilligung
        ///
        /// Link zum OGD-Datensatz mit den Allmendbewilligungen
        pub allmendbewilligungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ProjektName,
        ProjektBeschrieb,
        ProjektInfo,
        ProjektLink,
        DatumVon,
        DatumBis,
        Dokument1,
        Dokument2,
        Dokument3,
        Id,
        Allmendbewilligungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ProjektName => "projekt_name",
                Field::ProjektBeschrieb => "projekt_beschrieb",
                Field::ProjektInfo => "projekt_info",
                Field::ProjektLink => "projekt_link",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::Dokument1 => "dokument1",
                Field::Dokument2 => "dokument2",
                Field::Dokument3 => "dokument3",
                Field::Id => "id",
                Field::Allmendbewilligungen => "allmendbewilligungen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100335/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Fahrzeugdurchfahrten"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt alle Durchfahrten von Fahrzeugen mit der dazugeh\u{f6}rigen Zeitangabe.</p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren (inkl. dem Schallsensor, der die Fahrzeugdurchfahrten z\u{e4}hlt):\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze aus dem Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b>Hinweis: Die Sensoren an der Gundeldingerstrasse wurden am 29.6.23 abmontiert. Es werden keine Daten mehr erhoben.</b><br/></p><p>\u{c4}nderungsprotokoll: <br/>29.06.2023 - Aktualisierungsintervall von \"CONT\" auf \"NEVER\" ge\u{e4}ndert.<br/></p>"]
pub mod smarte_strasse_fahrzeugdurchfahrten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit bei Durchfahrt
        #[serde(with = "time::serde::iso8601::option")]
        pub localdatetime: Option<OffsetDateTime>,
        /// Fahrzeugklasse
        ///
        /// Klassifizierung des Fahrzeugs bei Durchfahrt
        pub classification: Option<String>,
        pub timestamp_text: Option<String>,
        /// Klassifizierungsindex
        ///
        /// Index für die Fahrzeuge
        pub classificationindex: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Localdatetime,
        Classification,
        TimestampText,
        Classificationindex,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Localdatetime => "localdatetime",
                Field::Classification => "classification",
                Field::TimestampText => "timestamp_text",
                Field::Classificationindex => "classificationindex",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100172/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte der \u{f6}ffentlichen Parkh\u{e4}user Basel"]
#[doc = ""]
#[doc = "<p>Standorte der \u{f6}ffentlichen Parkh\u{e4}user Basel, wie sie in <a href=\"https://parkendd.de/map.html#Basel\" target=\"_blank\">ParkenDD</a> verwendet werden.</p>"]
pub mod standorte_der_oeffentlichen_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub title: Option<String>,
        pub address: Option<String>,
        pub id: Option<String>,
        pub lot_type: Option<String>,
        /// Name
        ///
        /// Name des Parkhauses
        pub name: Option<String>,
        pub id2: Option<String>,
        pub total: Option<i64>,
        pub link: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
        /// coords.lat
        pub coords_lat: Option<f64>,
        /// coords.lng
        pub coords_lng: Option<f64>,
        #[serde(with = "time::serde::iso8601::option")]
        pub published: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Title,
        Address,
        Id,
        LotType,
        Name,
        Id2,
        Total,
        Link,
        CoordsLat,
        CoordsLng,
        Published,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Title => "title",
                Field::Address => "address",
                Field::Id => "id",
                Field::LotType => "lot_type",
                Field::Name => "name",
                Field::Id2 => "id2",
                Field::Total => "total",
                Field::Link => "link",
                Field::CoordsLat => "coords_lat",
                Field::CoordsLng => "coords_lng",
                Field::Published => "published",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100044/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Luftqualit\u{e4}t Station Feldbergstrasse"]
#[doc = ""]
#[doc = "<p>Standortbeschreibung: Die Messstation befindet sich in Basel direkt an der Kreuzung Feldbergstrasse / Hammerstrasse. Sie liegt in einer schlecht durchl\u{fc}fteten Strassenschlucht mit hohem Verkehrsaufkommen und oft stehendem Kolonnenverkehr. Die Station Basel Feldbergstrasse ist ein Ort mit sehr hoher lokaler Belastung innerhalb der Stadt Basel.</p><p>Lage: Stadtzentrum an Strasse, geschlossene Bebauung</p><p>Koordinaten: 2611747 / 1268491 bzw. N 47\u{b0} 34.021 E 7\u{b0} 35.684; 255 m \u{fc}. M.</p><p>Geografische Lage: Juranordfuss</p><p>Siedlungsgr\u{f6}sse: 166\'600 Einwohner</p><p>Verkehr, DTV (% LKW): 21\'900 (3%)</p><p>Strassenabstand: 2 m</p>"]
pub mod luftqualitaet_station_feldbergstrasse {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        pub timestamp_text: Option<String>,
        pub pm10_stundenmittelwerte_ug_m3: Option<f64>,
        pub pm2_5_stundenmittelwerte_ug_m3: Option<f64>,
        pub no2_stundenmittelwerte_ug_m3: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        Pm10StundenmittelwerteUgM3,
        Pm25StundenmittelwerteUgM3,
        No2StundenmittelwerteUgM3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::Pm10StundenmittelwerteUgM3 => "pm10_stundenmittelwerte_ug_m3",
                Field::Pm25StundenmittelwerteUgM3 => "pm2_5_stundenmittelwerte_ug_m3",
                Field::No2StundenmittelwerteUgM3 => "no2_stundenmittelwerte_ug_m3",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100050/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Transformation Areal Rosental: Online Sensor Feinstaub"]
#[doc = ""]
#[doc = "<p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten im Rahmen der \u{ab}Transformation <a href=\"https://rosentalmitte.ch/\" target=\"_blank\">Rosental Mitte</a>\u{bb} \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft <a href=\"https://data.bs.ch/pages/rosental-dashboard/\" target=\"_blank\">(Dashboard)</a>.\u{a0}</p><p>\u{c4}nderungsprotokoll:<br>23.4.2024: Die Messstation ROSEN 3 wurde verschoben. Alte geografische Breiten- und L\u{e4}ngengrade 47.567827676637364, 7.603804744961502. Neue Breiten- und L\u{e4}gengrade\u{a0}47.567997530870265, 7.60479830196066.<br></p><div><br></div>"]
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_online_sensor_feinstaub {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Station Name
        pub station: Option<String>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm_2_5: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Station,
        Pm25,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Station => "station",
                Field::Pm25 => "pm_2_5",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100275/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Zeitreihe der Temperaturen der Gartenb\u{e4}der"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz enth\u{e4}lt eine kontinuierliche Aufzeichnung der Wassertemperaturen in den Gartenb\u{e4}dern, beginnend ab dem 16. August 2024.</p><p style=\"font-family: sans-serif;\">Die Temperaturdaten werden alle 15 Minuten aktualisiert, indem ein automatisiertes Programm die neuesten Werte von der Webseite\u{a0}<a href=\"https://www.ed-baeder.ch/\" target=\"_blank\">https://www.ed-baeder.ch/</a>\u{a0}abruft. Auf dieser Webseite findet man auch sonstige Meldungen zu den Gartenb\u{e4}dern.</p><p style=\"font-family: sans-serif;\">Falls ein Gartenbad geschlossen ist oder keine Temperaturmessung verf\u{fc}gbar ist, wird f\u{fc}r diesen Zeitraum kein Wert im Datensatz vermerkt.</p><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weiterf\u{fc}hrende Links:</span></p><p style=\"font-family: sans-serif;\">Weitere Informationen zu den Gartenb\u{e4}dern:\u{a0}<a href=\"https://www.jfs.bs.ch/fuer-sportlerinnen-und-sportler/sportanlagen/gartenbaeder.html\" target=\"_blank\">https://www.jfs.bs.ch/fuer-sportlerinnen-und-sportler/sportanlagen/gartenbaeder.html</a></p><p style=\"font-family: sans-serif;\">Aktuelle Temperaturen der Gartenb\u{e4}der als Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100384/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100384/</a></p><p style=\"font-family: sans-serif;\">Diese und weitere Sportanlagen als Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100151\" target=\"_blank\">https://data.bs.ch/explore/dataset/100151</a></p>"]
pub mod zeitreihe_der_temperaturen_der_gartenbaeder {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        ///
        /// Name des Bads
        pub name: Option<String>,
        /// Temperatur
        ///
        /// Temperatur des Wassers
        pub temperatur: Option<i64>,
        /// Zeit
        ///
        /// Zeitpunkt, an dem die Daten gescraped wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub zeitpunkt_job: Option<OffsetDateTime>,
        /// Koordinaten
        ///
        /// Punktkoordinate des Bads
        pub koordinaten: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
        Temperatur,
        ZeitpunktJob,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Temperatur => "temperatur",
                Field::ZeitpunktJob => "zeitpunkt_job",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100384/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "OGD Datens\u{e4}tze"]
#[doc = ""]
#[doc = "Metadaten zu den im vorliegenden Datenportal publizierten OGD Datens\u{e4}tzen."]
pub mod ogd_datensaetze {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Dataset identifier
        pub dataset_identifier: Option<String>,
        /// Federated dataset
        pub federated_dataset: Option<String>,
        /// Title
        pub title: Option<String>,
        /// Description
        pub description: Option<String>,
        /// Themes
        pub themes: Option<String>,
        /// Keywords
        pub keywords: Option<String>,
        /// License
        pub license: Option<String>,
        /// Language
        pub language: Option<String>,
        /// Timezone
        pub timezone: Option<String>,
        /// Modified
        #[serde(with = "time::serde::iso8601::option")]
        pub modified: Option<OffsetDateTime>,
        /// Data processed
        #[serde(with = "time::serde::iso8601::option")]
        pub data_processed: Option<OffsetDateTime>,
        /// Metadata processed
        #[serde(with = "time::serde::iso8601::option")]
        pub metadata_processed: Option<OffsetDateTime>,
        /// Publisher
        pub publisher: Option<String>,
        /// Reference
        pub reference: Option<String>,
        /// Attributions
        pub attributions: Option<String>,
        /// Created
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub created: Option<Date>,
        /// Issued
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub issued: Option<Date>,
        /// Creator
        pub creator: Option<String>,
        /// Contributor
        pub contributor: Option<String>,
        /// Contact name
        pub contact_name: Option<String>,
        /// Contact email
        pub contact_email: Option<String>,
        /// Accrual periodicity
        pub accrual_periodicity: Option<String>,
        /// Spatial
        pub spatial: Option<String>,
        /// Temporal
        pub temporal: Option<String>,
        /// Granularity
        pub granularity: Option<String>,
        /// Data quality
        pub data_quality: Option<String>,
        /// Publisher type
        pub publisher_type: Option<String>,
        /// Conforms to
        pub conforms_to: Option<String>,
        /// Temporal coverage start date
        #[serde(with = "time::serde::iso8601::option")]
        pub temporal_coverage_start_date: Option<OffsetDateTime>,
        /// Temporal coverage end date
        #[serde(with = "time::serde::iso8601::option")]
        pub temporal_coverage_end_date: Option<OffsetDateTime>,
        /// Rights
        pub rights: Option<String>,
        /// RML Mapping
        pub rml_mapping: Option<String>,
        /// Publizierende Organisation
        pub publizierende_organisation: Option<String>,
        /// Geodaten Modellbeschreibung
        pub geodaten_modellbeschreibung: Option<String>,
        /// Tags
        pub tags: Option<String>,
        /// Number of records
        pub number_of_records: Option<i64>,
        /// Size of records in the dataset (in bytes)
        pub size_of_records_in_the_dataset_in_bytes: Option<i64>,
        /// Reuse count
        pub reuse_count: Option<i64>,
        /// API call count
        pub api_call_count: Option<i64>,
        /// Download count
        pub download_count: Option<i64>,
        /// Attachments download count
        pub attachments_download_count: Option<i64>,
        /// File fields download count
        pub file_fields_download_count: Option<i64>,
        /// Popularity score
        pub popularity_score: Option<f64>,
        /// Visibility (domain or restricted)
        pub visibility_domain_or_restricted: Option<String>,
        /// Published
        pub published: Option<String>,
        /// Publishing properties
        pub publishing_properties: Option<String>,
        /// Update frequency
        pub update_frequency: Option<String>,
        /// Domain
        pub domain0: Option<String>,
        /// Access Rights
        pub access_rights: Option<String>,
        pub url_dataset: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        DatasetIdentifier,
        FederatedDataset,
        Title,
        Description,
        Themes,
        Keywords,
        License,
        Language,
        Timezone,
        Modified,
        DataProcessed,
        MetadataProcessed,
        Publisher,
        Reference,
        Attributions,
        Created,
        Issued,
        Creator,
        Contributor,
        ContactName,
        ContactEmail,
        AccrualPeriodicity,
        Spatial,
        Temporal,
        Granularity,
        DataQuality,
        PublisherType,
        ConformsTo,
        TemporalCoverageStartDate,
        TemporalCoverageEndDate,
        Rights,
        RmlMapping,
        PublizierendeOrganisation,
        GeodatenModellbeschreibung,
        Tags,
        NumberOfRecords,
        SizeOfRecordsInTheDatasetInBytes,
        ReuseCount,
        ApiCallCount,
        DownloadCount,
        AttachmentsDownloadCount,
        FileFieldsDownloadCount,
        PopularityScore,
        VisibilityDomainOrRestricted,
        Published,
        PublishingProperties,
        UpdateFrequency,
        Domain0,
        AccessRights,
        UrlDataset,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatasetIdentifier => "dataset_identifier",
                Field::FederatedDataset => "federated_dataset",
                Field::Title => "title",
                Field::Description => "description",
                Field::Themes => "themes",
                Field::Keywords => "keywords",
                Field::License => "license",
                Field::Language => "language",
                Field::Timezone => "timezone",
                Field::Modified => "modified",
                Field::DataProcessed => "data_processed",
                Field::MetadataProcessed => "metadata_processed",
                Field::Publisher => "publisher",
                Field::Reference => "reference",
                Field::Attributions => "attributions",
                Field::Created => "created",
                Field::Issued => "issued",
                Field::Creator => "creator",
                Field::Contributor => "contributor",
                Field::ContactName => "contact_name",
                Field::ContactEmail => "contact_email",
                Field::AccrualPeriodicity => "accrual_periodicity",
                Field::Spatial => "spatial",
                Field::Temporal => "temporal",
                Field::Granularity => "granularity",
                Field::DataQuality => "data_quality",
                Field::PublisherType => "publisher_type",
                Field::ConformsTo => "conforms_to",
                Field::TemporalCoverageStartDate => "temporal_coverage_start_date",
                Field::TemporalCoverageEndDate => "temporal_coverage_end_date",
                Field::Rights => "rights",
                Field::RmlMapping => "rml_mapping",
                Field::PublizierendeOrganisation => "publizierende_organisation",
                Field::GeodatenModellbeschreibung => "geodaten_modellbeschreibung",
                Field::Tags => "tags",
                Field::NumberOfRecords => "number_of_records",
                Field::SizeOfRecordsInTheDatasetInBytes => {
                    "size_of_records_in_the_dataset_in_bytes"
                }
                Field::ReuseCount => "reuse_count",
                Field::ApiCallCount => "api_call_count",
                Field::DownloadCount => "download_count",
                Field::AttachmentsDownloadCount => "attachments_download_count",
                Field::FileFieldsDownloadCount => "file_fields_download_count",
                Field::PopularityScore => "popularity_score",
                Field::VisibilityDomainOrRestricted => "visibility_domain_or_restricted",
                Field::Published => "published",
                Field::PublishingProperties => "publishing_properties",
                Field::UpdateFrequency => "update_frequency",
                Field::Domain0 => "domain0",
                Field::AccessRights => "access_rights",
                Field::UrlDataset => "url_dataset",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100057/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wahl eines Mitglieds des Gerichts f\u{fc}r f\u{fc}rsorgerische Unterbringungen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate des 1. Wahlgangs der Wahl eines Mitglieds des Gerichts f\u{fc}r f\u{fc}rsorgerische Unterbringung vom 9. Mai 2021.\u{a0}</p>"]
pub mod wahl_eines_mitglieds_des_gerichts_fuer_fuersorgerische_unterbringungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<i64>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub resultats_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anz_sitze: Option<i64>,
        /// Kandidaten-Nr
        pub kandidat_nr: Option<i64>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub name_ganz: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewaehlt: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Wahlzettel
        ///
        /// Anzahl eingelegte Wahlzettel
        pub eingelegte: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leere Wahlzettel
        pub leere: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültige Wahlzettel
        pub ungueltige: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub gueltige: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub anz_briefliche: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total
        pub stimmber_total: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmber_maen: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmber_fraue: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Stimmen + leere Stimmen)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub ant_brieflich: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ResultatsTyp,
        Datum,
        AnzSitze,
        KandidatNr,
        NameGanz,
        Name,
        Vorname,
        Gemeinde,
        Stimmen,
        Vereinzelte,
        Gewaehlt,
        Stimmrechtsausweise,
        Eingelegte,
        Leere,
        Ungueltige,
        Gueltige,
        AnzBriefliche,
        StimmberTotal,
        StimmberMaen,
        StimmberFraue,
        AbsolutesMehr,
        Stimmbeteiligung,
        AntBrieflich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ResultatsTyp => "resultats_typ",
                Field::Datum => "datum",
                Field::AnzSitze => "anz_sitze",
                Field::KandidatNr => "kandidat_nr",
                Field::NameGanz => "name_ganz",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Vereinzelte => "vereinzelte",
                Field::Gewaehlt => "gewaehlt",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Eingelegte => "eingelegte",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::AnzBriefliche => "anz_briefliche",
                Field::StimmberTotal => "stimmber_total",
                Field::StimmberMaen => "stimmber_maen",
                Field::StimmberFraue => "stimmber_fraue",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AntBrieflich => "ant_brieflich",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100132/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte Mess-Stationen Smart Climate Feinstaubmessungen"]
#[doc = ""]
#[doc = "<p>Standorte der Mess-Stationen f\u{fc}r Feinstaub f\u{fc}r den Datensatz \u{ab}Smart Climate Feinstaubmessungen\u{bb} <a href=\"https://data.bs.ch/explore/dataset/100081\" target=\"_blank\">https://data.bs.ch/explore/dataset/100081</a>.</p>"]
pub mod standorte_mess_stationen_smart_climate_feinstaubmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// ID
        pub id: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
        Id,
        Titel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Id => "id",
                Field::Titel => "titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100084/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wahl von f\u{fc}nf Pr\u{e4}sidentinnen oder Pr\u{e4}sidenten des Appellationsgerichts"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Schlussresultate des 1. Wahlgangs der Wahl von f\u{fc}nf Pr\u{e4}sidentinnen oder Pr\u{e4}sidenten des Appellationsgerichts Basel-Stadt vom 9. Mai 2021.\u{a0}</p>"]
pub mod wahl_von_fuenf_praesidentinnen_oder_praesidenten_des_appellationsgerichts {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name der Wahl
        pub wahl_titel: Option<String>,
        /// Wahlgang
        ///
        /// 1. oder 2. Wahlgang
        pub wahlgang: Option<i64>,
        /// Status
        ///
        /// Zwischenresultat oder Schlussresultat
        pub resultats_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind
        pub anz_sitze: Option<i64>,
        /// Kandidaten-Nr
        pub kandidat_nr: Option<i64>,
        /// Ganzer Name
        ///
        /// Name in der Form "Nachname, Vorname"
        pub name_ganz: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen
        pub stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl Stimmen, welche auf nicht kandidierende Kandidatinnen und Kandidaten entfielen
        pub vereinzelte: Option<i64>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist oder nicht
        pub gewaehlt: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmrechtsausweise: Option<i64>,
        /// Eingelegte Wahlzettel
        ///
        /// Anzahl eingelegte Wahlzettel
        pub eingelegte: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leere Wahlzettel
        pub leere: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültige Wahlzettel
        pub ungueltige: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub gueltige: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub anz_briefliche: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total
        pub stimmber_total: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl stimmberechtigter Männer
        pub stimmber_maen: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl stimmberechtigter Frauen
        pub stimmber_fraue: Option<i64>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Stimmen + leere Stimmen)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<f64>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub ant_brieflich: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahlTitel,
        Wahlgang,
        ResultatsTyp,
        Datum,
        AnzSitze,
        KandidatNr,
        NameGanz,
        Name,
        Vorname,
        Gemeinde,
        Stimmen,
        Vereinzelte,
        Gewaehlt,
        Stimmrechtsausweise,
        Eingelegte,
        Leere,
        Ungueltige,
        Gueltige,
        AnzBriefliche,
        StimmberTotal,
        StimmberMaen,
        StimmberFraue,
        AbsolutesMehr,
        Stimmbeteiligung,
        AntBrieflich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahlTitel => "wahl_titel",
                Field::Wahlgang => "wahlgang",
                Field::ResultatsTyp => "resultats_typ",
                Field::Datum => "datum",
                Field::AnzSitze => "anz_sitze",
                Field::KandidatNr => "kandidat_nr",
                Field::NameGanz => "name_ganz",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Gemeinde => "gemeinde",
                Field::Stimmen => "stimmen",
                Field::Vereinzelte => "vereinzelte",
                Field::Gewaehlt => "gewaehlt",
                Field::Stimmrechtsausweise => "stimmrechtsausweise",
                Field::Eingelegte => "eingelegte",
                Field::Leere => "leere",
                Field::Ungueltige => "ungueltige",
                Field::Gueltige => "gueltige",
                Field::AnzBriefliche => "anz_briefliche",
                Field::StimmberTotal => "stimmber_total",
                Field::StimmberMaen => "stimmber_maen",
                Field::StimmberFraue => "stimmber_fraue",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AntBrieflich => "ant_brieflich",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100131/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Regierungspr\u{e4}sidiumswahl 20. Oktober 2024"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">F\u{fc}r die Gesamterneuerungswahl des Regierungspr\u{e4}sidiums vom 20. Oktober 2024 kandidieren drei Personen.</p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">Dieser Datensatz zeigt die Kandidierenden des ersten Wahlgangs nach Geschlecht, Jahrgang und Beruf.</p>"]
pub mod kandidierende_der_regierungspraesidiumswahl_20_oktober_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100387/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sammlung Europa"]
#[doc = ""]
#[doc = "<div><font color=\"#404040\" face=\"Helvetica, sans-serif\">Das Museum der Kulturen Basel (MKB) ist das gr\u{f6}sste ethnologische Museum der Schweiz und eines der bedeutendsten seiner Art in Europa. Seine Sammlung geniesst Weltruf und z\u{e4}hlt mehr als 340 000 Objekte. Rund 75 000 Objekte dieser Sammlung geh\u{f6}ren zur Abteilung Europa. Sie wurden seit 1904 bis heute aus allen Teilen des Kontinents zusammengetragen.</font></div><div><font color=\"#404040\" face=\"Helvetica, sans-serif\"><br/></font></div><div><font color=\"#404040\" face=\"Helvetica, sans-serif\">Die publizierten Daten sind mehrheitlich unbereinigt. Sowohl bei der erstmaligen Katalogisierung der Objekte, wie auch bei der Abschrift in die Datenbank gab es Inkonsistenzen, Fehler und Auslassungen. Darin enthaltene Terminologien k\u{f6}nnen inzwischen unzutreffend, veraltet oder rassistisch beleidigend sein.\u{a0}</font></div><div><font color=\"#404040\" face=\"Helvetica, sans-serif\"><br/></font></div><div><font color=\"#404040\" face=\"Helvetica, sans-serif\">Der Code zur Datenbereinigung ist hier (https://github.com/opendatabs/data-processing/blob/master/mkb_sammlung_europa/etl.py) zu finden. Gerne nehmen wir Erg\u{e4}nzungen dazu via Pull Request an.\u{a0}<br/></font></div><div><br/></div>"]
pub mod sammlung_europa {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Inventarnummer
        ///
        /// Die Inventarnummer besteht aus einem Präfix und einer Laufnummer. Unterschiedliche Präfixe deuten auf unterschiedliche Unter-Sammlungen hin. Standard ist VI, weil Europa die sechste Abteilung des Museums ist.
        pub inventarnummer: Option<String>,
        /// Einlaufnummer
        ///
        /// Die Einlaufnummer besteht aus Suffix-Underline-Laufnummer. Sie nummeriert jeweils die Gruppe von Objekten, die zusammen ins Museum gekommen sind.
        pub einlaufnummer: Option<String>,
        /// Kurzbezeichnung
        ///
        /// Kurzbezeichnung ist die möglichst allgemeine Bezeichnung des Objekts.
        pub kurzbezeichnung: Option<String>,
        /// Titel
        ///
        /// Der Titel ist eine präzisere Bezeichnung, eine einheimische Bezeichnung oder der Werktitel (kann fehlen).
        pub titel: Option<String>,
        /// Datierung
        ///
        /// Das geschätzte oder dokumentierte Jahr der Herstellung des Objekts (in der Regel sehr ungenau, fehlt häufig)
        pub datierung: Option<String>,
        /// Material & Technik
        ///
        /// Angaben dazu, wie und/oder aus welchem Material das Objekt geschaffen wurde.
        pub material_technik: Option<String>,
        /// Herkunft
        ///
        /// Geografische Herkunft des Objekts (nur eine von möglicherweise mehrfachen Herkunftsangaben)
        pub herkunft: Option<String>,
        /// Einlieferer*in, Erwerbungsart, Jahr der Einlieferung
        ///
        /// Der/die Einlieferer*in brachte die Objekte ins Museum bzw. bezahlte dafür. Erwerbungsart ist in der Regel Kauf (dann bezahlte das Museum und als Einlieferer erscheint der aktuelle Kurator) oder Geschenk, teils auch Legat oder Tausch. Leider teilweise auch «unbekannt, alter Bestand».
        pub einlauf_info: Option<String>,
        /// Masse
        ///
        /// Masse des Objekts
        pub masse: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Inventarnummer,
        Einlaufnummer,
        Kurzbezeichnung,
        Titel,
        Datierung,
        MaterialTechnik,
        Herkunft,
        EinlaufInfo,
        Masse,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Inventarnummer => "inventarnummer",
                Field::Einlaufnummer => "einlaufnummer",
                Field::Kurzbezeichnung => "kurzbezeichnung",
                Field::Titel => "titel",
                Field::Datierung => "datierung",
                Field::MaterialTechnik => "material_technik",
                Field::Herkunft => "herkunft",
                Field::EinlaufInfo => "einlauf_info",
                Field::Masse => "masse",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100148/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 27. November 2022 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 27. November 2022 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_27_november_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Gegenvorschlag Stimmen ohne gültige Antwort
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Stichfrage Stimmen ohne gültige Antwort
        pub sti_oga_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        InitOgaAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        GegeOgaAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        StiOgaAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::InitOgaAnz => "init_oga_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100239/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidaturen f\u{fc}r Gerichtspr\u{e4}sidienwahlen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt Informationen zu den Kandidaturen f\u{fc}r alle Gerichtspr\u{e4}sidienwahlen seit 2024<br></p>"]
pub mod kandidaturen_fuer_gerichtspraesidienwahlen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Name der Wahl
        pub titel: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zu vergeben sind.
        pub anzahl_sitze: Option<f64>,
        /// Listen-Nr.
        ///
        /// Listennummer
        pub listennr: Option<i64>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Kandidierenden-Nr.
        ///
        /// Kandidierendennummer
        pub zeilennummer: Option<i64>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        pub bisher: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Geburtsjahr der kandidierenden Person
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatzliche_angaben: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Titel,
        Datum,
        AnzahlSitze,
        Listennr,
        Listenbezeichnung,
        Zeilennummer,
        Name,
        Vorname,
        Bisher,
        Geschlecht,
        Jahrgang,
        ZusatzlicheAngaben,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Titel => "titel",
                Field::Datum => "datum",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::Listennr => "listennr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Zeilennummer => "zeilennummer",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Bisher => "bisher",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::ZusatzlicheAngaben => "zusatzliche_angaben",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100379/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Tests nach Nachweismethode"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Anzahl Tests auf SARS-CoV-2 f\u{fc}r jeden Kanton, die gesamte Schweiz und das F\u{fc}rstentum Liechtenstein sowie die entsprechenden Testresultate (positiv/negativ) auf t\u{e4}glicher Basis. Die Angaben werden t\u{e4}glich durch das Bundesamt f\u{fc}r Gesundheit (BAG) zur Verf\u{fc}gung gestellt im <a href=\"https://www.covid19.admin.ch/\" target=\"_blank\">Covid-19 Situationsbericht </a>bzw. \u{fc}ber dessen <a href=\"https://www.covid19.admin.ch/api/data/context\" target=\"_blank\">API</a>.</p>"]
pub mod coronavirus_covid_19_tests_nach_nachweismethode {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Falldatum, entspricht in der Regel dem Datum der Probeentnahme
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Region
        ///
        /// Wohnkanton, falls unbekannt: Kanton des Testcenters. Zusätzlich sind die aggregierten Einheiten CH, FL und CHFL vorhanden.
        pub georegion: Option<String>,
        /// Tests Total
        ///
        /// Anzahl durchgeführte Tests. Eine Person kann mehrfach getestet werden.
        pub entries: Option<i64>,
        /// Bevölkerungszahl
        ///
        /// Anzahl EinwohnerInnen der vorliegenden Region, wie sie vom BAG zur Inzidenzberechnung verwendet wird.
        pub pop: Option<i64>,
        /// Wochentag ID
        ///
        /// ID des Wochentags. 0 = Montag, 1 = Dienstag, etc.
        pub dayofweek: Option<i64>,
        /// Wochentag
        ///
        /// Wochentag auf Deutsch
        pub wochentag: Option<String>,
        /// Wochennummer
        pub week: Option<i64>,
        pub offset_last7d: Option<i64>,
        pub offset_last14d: Option<i64>,
        pub offset_last28d: Option<i64>,
        pub sumdelta7d: Option<f64>,
        pub inzdelta7d: Option<f64>,
        pub type_variant: Option<String>,
        pub entries_letzter_stand: Option<i64>,
        pub entries_neu_gemeldet: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Georegion,
        Entries,
        Pop,
        Dayofweek,
        Wochentag,
        Week,
        OffsetLast7d,
        OffsetLast14d,
        OffsetLast28d,
        Sumdelta7d,
        Inzdelta7d,
        TypeVariant,
        EntriesLetzterStand,
        EntriesNeuGemeldet,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Georegion => "georegion",
                Field::Entries => "entries",
                Field::Pop => "pop",
                Field::Dayofweek => "dayofweek",
                Field::Wochentag => "wochentag",
                Field::Week => "week",
                Field::OffsetLast7d => "offset_last7d",
                Field::OffsetLast14d => "offset_last14d",
                Field::OffsetLast28d => "offset_last28d",
                Field::Sumdelta7d => "sumdelta7d",
                Field::Inzdelta7d => "inzdelta7d",
                Field::TypeVariant => "type_variant",
                Field::EntriesLetzterStand => "entries_letzter_stand",
                Field::EntriesNeuGemeldet => "entries_neu_gemeldet",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100116/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 28. November 2021 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 28. November 2021 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_28_november_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100161/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 15. Mai 2022 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 15. Mai 2022 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_15_mai_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100194/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 3. M\u{e4}rz 2024"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 3. M\u{e4}rz 2024 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100340/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 26. November 2023"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 26. November 2023\u{a0}f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_26_november_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmender
        ///
        /// Anzahl elektronisch Stimmender: Anzahl pro Art der Vorlage
        pub anz_elektr_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100328/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 7. M\u{e4}rz 2021"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 7. M\u{e4}rz 2021 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_7_maerz_2021 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        AbstIdTitel,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100118/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 12. M\u{e4}rz 2023 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 12. M\u{e4}rz 2023 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_12_maerz_2023_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100279/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung 7. M\u{e4}rz 2021 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 7. M\u{e4}rz 2021 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_7_maerz_2021_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        pub abst_typ: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        WahllokId,
        GemeinId,
        GemeinName,
        AbstTyp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::AbstTyp => "abst_typ",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100117/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 3. M\u{e4}rz 2024 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 3. M\u{e4}rz 2024 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_3_maerz_2024_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100339/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 13. Februar 2022 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 13. Februar 2022 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.\u{a0}</p>"]
pub mod abstimmung_vom_13_februar_2022_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100168/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Nationalratswahlen 2023"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate der Nationalratswahl vom 22. Oktober 2023.<o:p></o:p></p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_nationalratswahlen_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Listen-Nr
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// HLV-Nr
        ///
        /// Nummer der Hauptlistenverbindung
        pub hlv_nr: Option<String>,
        /// HLV-Bezeichnung
        ///
        /// Name der Hauptlistenverbindung
        pub hlv_bezeichnung: Option<String>,
        /// ULV-Nr
        ///
        /// Nummer der Unterlistenverbindung
        pub ulv_nr: Option<String>,
        /// ULV-Bezeichnung
        ///
        /// Name der Unterlistenverbindung
        pub ulv_bezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Kumulation
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat auf einem unveränderten Wahlzettel mehrfach aufgeführt ist
        pub kumulation: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus unveränderten Wahlzetteln
        pub stimmen_unveranderte_wahlzettel: Option<i64>,
        /// Stimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen aus veränderten Wahlzetteln
        pub stimmen_veranderte_wahlzettel: Option<i64>,
        /// Stimmen Total aus Wahlzettel
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten. Die Summe dieser Stimmen über eine Partei ergibt nicht das Total der Parteistimmen, weil so die leeren Linien auf Parteilisten nicht mitgezählt werden.
        pub stimmen_total_aus_wahlzettel: Option<i64>,
        /// 01 FDP
        pub x01_fdp: Option<i64>,
        /// 03 LDP
        pub x03_ldp: Option<i64>,
        /// 04 EVP
        pub x04_evp: Option<i64>,
        /// 05 SP
        pub x05_sp: Option<i64>,
        /// 09 EDU
        pub x09_edu: Option<i64>,
        /// 10 GLP
        pub x10_glp: Option<i64>,
        /// 12 SVP
        pub x12_svp: Option<i64>,
        /// 14 VA
        pub x14_va: Option<i64>,
        /// 18 JSVP
        pub x18_jsvp: Option<i64>,
        /// 21 jgb
        pub x21_jgb: Option<i64>,
        /// 23 JLB
        pub x23_jlb: Option<i64>,
        /// 25 JGLP
        pub x25_jglp: Option<i64>,
        /// 00 OHNE
        ///
        /// Anzahl Stimmen für eine Kandidatin oder einen Kandidaten aus einer Liste ohne Bezeichnung
        pub x00_ohne: Option<i64>,
        /// Rangfolge
        ///
        /// Rangfolge innerhalb einer Liste gemäss Anzahl Stimmen (bei Stimmengleichheit entscheidet das Los).
        pub rangfolge: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_der_gultigen_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// 06 JFDP
        pub x06_jfdp: Option<i64>,
        /// 07 Mitte
        pub x07_mitte: Option<i64>,
        /// 08 BGB
        pub x08_bgb: Option<i64>,
        /// 11 PdA
        pub x11_pda: Option<i64>,
        /// 17 Basta-rm
        pub x17_basta_rm: Option<i64>,
        /// 20 JUSO
        pub x20_juso: Option<i64>,
        /// 22 JMITTE
        pub x22_jmitte: Option<i64>,
        /// 24 SP60+
        pub x24_sp60: Option<i64>,
        /// 26 FDP+
        pub x26_fdp: Option<i64>,
        /// 27 BastA-jA
        pub x27_basta_ja: Option<i64>,
        /// 28 MV
        pub x28_mv: Option<i64>,
        /// 30 SVP-Gew
        pub x30_svp_gew: Option<i64>,
        /// 31 SVP60+
        pub x31_svp60: Option<i64>,
        /// 32 GLP-K-U
        pub x32_glp_k_u: Option<i64>,
        /// 33 GLP-B
        pub x33_glp_b: Option<i64>,
        /// 34 LDP-Gew
        pub x34_ldp_gew: Option<i64>,
        /// 35 GLP-R-E
        pub x35_glp_r_e: Option<i64>,
        /// 36 Mitte60+
        pub x36_mitte60: Option<i64>,
        /// 37 GLP-KMU
        pub x37_glp_kmu: Option<i64>,
        /// 38 GLP-I
        pub x38_glp_i: Option<i64>,
        pub jahrgang_num: Option<i64>,
        /// Alter am Jahresende 2023
        ///
        /// Alter, berechnet nach der Formel "2023 minus Jahrgang"
        pub alter_am_jahresende_2023: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ListenNr,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        HlvNr,
        HlvBezeichnung,
        UlvNr,
        UlvBezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        KandidatenNr,
        PersonenId,
        Kumulation,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        StimmenUnveranderteWahlzettel,
        StimmenVeranderteWahlzettel,
        StimmenTotalAusWahlzettel,
        X01Fdp,
        X03Ldp,
        X04Evp,
        X05Sp,
        X09Edu,
        X10Glp,
        X12Svp,
        X14Va,
        X18Jsvp,
        X21Jgb,
        X23Jlb,
        X25Jglp,
        X00Ohne,
        Rangfolge,
        TotalDerGultigenWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        X06Jfdp,
        X07Mitte,
        X08Bgb,
        X11Pda,
        X17BastaRm,
        X20Juso,
        X22Jmitte,
        X24Sp60,
        X26Fdp,
        X27BastaJa,
        X28Mv,
        X30SvpGew,
        X31Svp60,
        X32GlpKU,
        X33GlpB,
        X34LdpGew,
        X35GlpRE,
        X36Mitte60,
        X37GlpKmu,
        X38GlpI,
        JahrgangNum,
        AlterAmJahresende2023,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ListenNr => "listen_nr",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::HlvNr => "hlv_nr",
                Field::HlvBezeichnung => "hlv_bezeichnung",
                Field::UlvNr => "ulv_nr",
                Field::UlvBezeichnung => "ulv_bezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Kumulation => "kumulation",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::StimmenUnveranderteWahlzettel => "stimmen_unveranderte_wahlzettel",
                Field::StimmenVeranderteWahlzettel => "stimmen_veranderte_wahlzettel",
                Field::StimmenTotalAusWahlzettel => "stimmen_total_aus_wahlzettel",
                Field::X01Fdp => "01_fdp",
                Field::X03Ldp => "03_ldp",
                Field::X04Evp => "04_evp",
                Field::X05Sp => "05_sp",
                Field::X09Edu => "09_edu",
                Field::X10Glp => "10_glp",
                Field::X12Svp => "12_svp",
                Field::X14Va => "14_va",
                Field::X18Jsvp => "18_jsvp",
                Field::X21Jgb => "21_jgb",
                Field::X23Jlb => "23_jlb",
                Field::X25Jglp => "25_jglp",
                Field::X00Ohne => "00_ohne",
                Field::Rangfolge => "rangfolge",
                Field::TotalDerGultigenWahlzettel => "total_der_gultigen_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::X06Jfdp => "06_jfdp",
                Field::X07Mitte => "07_mitte",
                Field::X08Bgb => "08_bgb",
                Field::X11Pda => "11_pda",
                Field::X17BastaRm => "17_basta_rm",
                Field::X20Juso => "20_juso",
                Field::X22Jmitte => "22_jmitte",
                Field::X24Sp60 => "24_sp60",
                Field::X26Fdp => "26_fdp",
                Field::X27BastaJa => "27_basta_ja",
                Field::X28Mv => "28_mv",
                Field::X30SvpGew => "30_svp_gew",
                Field::X31Svp60 => "31_svp60",
                Field::X32GlpKU => "32_glp_k_u",
                Field::X33GlpB => "33_glp_b",
                Field::X34LdpGew => "34_ldp_gew",
                Field::X35GlpRE => "35_glp_r_e",
                Field::X36Mitte60 => "36_mitte60",
                Field::X37GlpKmu => "37_glp_kmu",
                Field::X38GlpI => "38_glp_i",
                Field::JahrgangNum => "jahrgang_num",
                Field::AlterAmJahresende2023 => "alter_am_jahresende_2023",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100281/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Sensoren"]
#[doc = ""]
#[doc = "<p>Im Rahmen des Projekts\u{a0}\u{ab}Smarte Strasse\u{bb} wurden Sensoren an verschiedenen Standorten angebracht.\u{a0}</p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul>"]
pub mod smarte_strasse_sensoren {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Was wird gemessen?
        pub was_wird_gemessen: Option<String>,
        /// Verantwortlich
        pub verantwortlich: Option<String>,
        /// QR-Code-Nr.
        pub qrc_nr: Option<f64>,
        /// Zu den Messwerten
        pub zu_den_messwerten: Option<String>,
        /// Foto
        pub foto: Option<String>,
        /// Geo Point
        pub geo_point: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WasWirdGemessen,
        Verantwortlich,
        QrcNr,
        ZuDenMesswerten,
        Foto,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WasWirdGemessen => "was_wird_gemessen",
                Field::Verantwortlich => "verantwortlich",
                Field::QrcNr => "qrc_nr",
                Field::ZuDenMesswerten => "zu_den_messwerten",
                Field::Foto => "foto",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100114/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Ersatzwahl Regierungsrat 3. M\u{e4}rz 2024"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Resultate des ersten Wahlgangs der Regierungsrats-Ersatzwahl vom 3. M\u{e4}rz 2024. Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden. "]
pub mod resultate_der_ersatzwahl_regierungsrat_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1)
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        ///
        /// Spalte, damit bei Grafik "Vereinzelte" abgebildet werden kann
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100337/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Gremien"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt Gremien im Grossen Rat des Kantons Basel-Stadt.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch/\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_gremien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Aktiv
        ///
        /// Aktives durch den Grossen Rat gewähltes Gremium
        pub ist_aktuelles_gremium: Option<String>,
        /// Kurzname
        ///
        /// Kurzname des Gremiums
        pub kurzname: Option<String>,
        /// Name
        ///
        /// Name des Gremiums
        pub name: Option<String>,
        /// Gremientyp
        ///
        /// Typ des Gremiums (Kommission, Fraktion, Parlament)
        pub gremientyp: Option<String>,
        /// ID Gremium
        ///
        /// Individuelle Identifikationsnummer des Gremiums innerhalb der Datenbank des Grossen Rates.
        pub uni_nr: Option<String>,
        /// Gremiumsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Mitgliedschaften in Gremien". Gefiltert nach aktuellem Gremium.
        pub url_mitgliedschaften: Option<String>,
        /// Urheber von
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach Geschäften, bei denen das aktuelle Gremium als Urheber gilt.
        pub url_urheber: Option<String>,
        /// Zugewiesene Geschäfte data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Zuweisungen". Gefiltert nach Zuweisungen, die an das aktuelle Gremium gemacht wurden.
        pub url_zugew_geschaefte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IstAktuellesGremium,
        Kurzname,
        Name,
        Gremientyp,
        UniNr,
        UrlMitgliedschaften,
        UrlUrheber,
        UrlZugewGeschaefte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IstAktuellesGremium => "ist_aktuelles_gremium",
                Field::Kurzname => "kurzname",
                Field::Name => "name",
                Field::Gremientyp => "gremientyp",
                Field::UniNr => "uni_nr",
                Field::UrlMitgliedschaften => "url_mitgliedschaften",
                Field::UrlUrheber => "url_urheber",
                Field::UrlZugewGeschaefte => "url_zugew_geschaefte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100310/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Ersatzwahl Regierungsrat 3. M\u{e4}rz 2024"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">F\u{fc}r die Ersatzwahl eines Mitglieds des Regierungsrat vom 3. M\u{e4}rz 2024 kandidieren vier Personen.</p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">Dieser Datensatz zeigt die Kandidierenden des ersten Wahlgangs nach Geschlecht, Jahrgang und Beruf.</p>"]
pub mod kandidierende_der_ersatzwahl_regierungsrat_3_maerz_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub zusatz: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Zusatz,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Zusatz => "zusatz",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100333/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Ein- und Ausfahrten \u{f6}ffentlicher Parkh\u{e4}user Basel"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Anzahl Ein- und Ausfahrten pro Stunde in bzw. aus \u{f6}ffentlichen Parkh\u{e4}usern Basel. Die Daten werden j\u{e4}hrlich erg\u{e4}nzt. Aus technischen Gr\u{fc}nden sind die Daten des Parkhauses City erst ab 2021 vorhanden.\u{a0}<br></p><p>Im Parkhaus St. Jakob werden manchmal bei Grossanl\u{e4}ssen keine Ein- und Ausfahrten gez\u{e4}hlt. Diese Metriken sind f\u{fc}r dieses Parkhaus deshalb mit Vorsicht zu analysieren.\u{a0}<br></p>"]
pub mod ein_und_ausfahrten_oeffentlicher_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Start des Messintervalls von 1 h
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Parkhaus
        ///
        /// Name des Parkhauses
        pub title: Option<String>,
        /// Zeitstempel wie vom Quellsystem geliefert in lokaler Zeitzone. Falls leer, so wurde diese Zeile nachträglich hinzugefügt, um Lücken in der Zeitreihe zu vermeiden.
        pub timestamp_text: Option<String>,
        /// Einfahrten
        ///
        /// Anzahl Einfahrten im Messintervall
        pub einfahrten: Option<i64>,
        /// Ausfahrten
        ///
        /// Anzahl Ausfahrten im Messintervall
        pub ausfahrten: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Title,
        TimestampText,
        Einfahrten,
        Ausfahrten,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Title => "title",
                Field::TimestampText => "timestamp_text",
                Field::Einfahrten => "einfahrten",
                Field::Ausfahrten => "ausfahrten",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100198/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmung vom 9. Juni 2024 Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmung vom 9. Juni 2024 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im <a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">https://www.kantonsblatt.ch/#!/search/publications</a>) des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod abstimmung_vom_9_juni_2024_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        AbstTyp,
        AbstIdTitel,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100369/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Massentests an Schulen der Sekundarstufe II"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der SARS-CoV-2-Tests, welche an Sch\u{fc}ler:innen und Lehrpersonen in baselst\u{e4}dtischen Schulen der Sekundarstufe II durchgef\u{fc}hrt wurden. An dieser Schulstufe werden Einzeltests durchgef\u{fc}hrt. Weitere Informationen zum Coronavirus in Basel-Stadt:\u{a0}<a href=\"https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co\" target=\"_blank\">https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co</a></p><p>Dieser Datensatz wird seit Ende Februar 2022 nicht mehr aktualisiert. Seit Mitte M\u{e4}rz 2022 werden die Daten zu Tests in Basler Schulen in einem neuen Datensatz ver\u{f6}ffentlich:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100183\" target=\"_blank\">https://data.bs.ch/explore/dataset/100183</a></p>"]
pub mod coronavirus_covid_19_massentests_an_schulen_der_sekundarstufe_ii {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<String>,
        /// Resultat
        ///
        /// Zeigt an, ob ein SARS-CoV-2-Test positiv oder negativ ausgefallen ist
        pub result: Option<String>,
        /// Pos./neg. getestete SUS pro Woche
        ///
        /// Anzahl positiv resp. negativ getesteter Schülerinnen, Schüler und Lehrpersonen pro Woche
        pub count: Option<i64>,
        /// Getestete SUS pro Woche
        ///
        /// Anzahl getesteter Schülerinnen, Schüler und Lehrpersonen pro Woche
        pub counttotal: Option<i64>,
        /// Positivitätsrate
        ///
        /// Zeigt den Prozentsatz der Tests, die positiv auf SARS-CoV-2 getestet wurden
        pub positivityratepercent: Option<f64>,
        /// Schulen
        ///
        /// Anzahl Schulen der Sekundarstufe II, deren Schülerinnen, Schüler und Lehrpersonen getestet wurden
        pub schoolcount: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
        Schoolcount,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
                Field::Schoolcount => "schoolcount",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100153/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gesundheitsversorgung (GSV): Pflegeheimbewohnende"]
#[doc = ""]
#[doc = "Wichtige Kennzahlen zu den Pflegeheimbewohnenden im Kanton Basel-Stadt. Dieser Datensatz fliesst zum Teil in Form eines Dashboard in den online Bericht des Bereiches Gesundheitsversorgung (GSV) des Gesundheitsdepartement Basel-Stadt.Die Kennzahlen werden per Stichtag Anfangs Jahr erhoben."]
pub mod gesundheitsversorgung_gsv_pflegeheimbewohnende {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<f64>,
        /// BewohnerInnen Total
        ///
        /// Anzahl der Pflegeheimbewohnenden
        pub bewohner: Option<i64>,
        /// Anzahl Frauen
        ///
        /// Anzahl Frauen in Pflegeheimen
        pub anzahl_frauen: Option<i64>,
        /// Anteil Frauen
        ///
        /// Anteil der Frauen aller Pflegeheimbewohnenden
        pub anteil_frauen: Option<f64>,
        /// Anzahl Männer
        ///
        /// Anzahl der Männer in Pflegeheimen
        pub anzahl_maenner: Option<i64>,
        /// Anteil Männer
        ///
        /// Anteil der Männer aller Pflegeheimbewohnenden
        pub anteil_maenner: Option<f64>,
        /// Durchschnittsalter PflegeheimbewohnerInnen
        ///
        /// Durchschnittsalter aller Pflegeheimbewohnenden
        pub mean_alter_bewohner: Option<f64>,
        /// Durchschnittsalter Frauen
        ///
        /// Durchschnittsalter aller Pflegeheimbewohnerinnen
        pub mean_alter_frauen: Option<f64>,
        /// Durchschnittsalter Männer
        ///
        /// Durchschnittsalter aller Pflegeheimbewohner
        pub mean_alter_maenner: Option<f64>,
        /// Anzahl verstorbene Pflegeheimbewohnende
        ///
        /// Anzahl der verstorbenen Pflegeheimbewohnenden
        pub verstorben_bewohner: Option<i64>,
        /// Durchschnittliche Aufenthaltsdauer
        ///
        /// Durchschnittliche Aufenthaltsdauer In Jahren aller Bewohnende in Pflegeheimen. Bezieht sich auf die PflegeheimbewohnerInnen, die im jeweiligen Jahr verstorben sind.
        pub alos: Option<f64>,
        /// Durchschnittliche Aufenthaltsdauer Frauen
        ///
        /// Durchschnittliche Aufenthaltsdauer in Jahren der Frauen. Bezieht sich auf die Pflegeheimbewohnerinnen, die im jeweiligen Jahr verstorben sind.
        pub alos_frauen: Option<f64>,
        /// Durchschnittliche Aufenthaltsdauer Männer
        ///
        /// Durchschnittliche Aufenthaltsdauer in Jahren der Männer. Bezieht sich auf die Pflegeheimbewohner, die im jeweiligen Jahr verstorben sind.
        pub alos_maenner: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Id,
        Bewohner,
        AnzahlFrauen,
        AnteilFrauen,
        AnzahlMaenner,
        AnteilMaenner,
        MeanAlterBewohner,
        MeanAlterFrauen,
        MeanAlterMaenner,
        VerstorbenBewohner,
        Alos,
        AlosFrauen,
        AlosMaenner,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Id => "id",
                Field::Bewohner => "bewohner",
                Field::AnzahlFrauen => "anzahl_frauen",
                Field::AnteilFrauen => "anteil_frauen",
                Field::AnzahlMaenner => "anzahl_maenner",
                Field::AnteilMaenner => "anteil_maenner",
                Field::MeanAlterBewohner => "mean_alter_bewohner",
                Field::MeanAlterFrauen => "mean_alter_frauen",
                Field::MeanAlterMaenner => "mean_alter_maenner",
                Field::VerstorbenBewohner => "verstorben_bewohner",
                Field::Alos => "alos",
                Field::AlosFrauen => "alos_frauen",
                Field::AlosMaenner => "alos_maenner",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100319/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen zu den Basler Wohnvierteln und Landgemeinden"]
#[doc = ""]
#[doc = "Ausgew\u{e4}hlte statistische Kennzahlen der 19 Wohnviertel der Stadt Basel sowie der zwei Gemeinden Riehen und Bettingen seit 2015. Aufgrund einer ver\u{e4}nderten Datenlage k\u{f6}nnen die Indikatoren 3 (Religionszugeh\u{f6}rigkeit) und 18 (Arbeitslosenquote) ab der Ausgabe 2020 nicht mehr dargestellt werden. Die Berechnungsmethode f\u{fc}r die Sozialhilfequote wurde 2022 f\u{fc}r die Jahre ab 2017 r\u{fc}ckwirkend angepasst. Zur Definition: <a href=\"https://statistik.bs.ch/files/faltblatt/Erlaeuterungen-Quartierradar.pdf\" target=\"_blank\">https://statistik.bs.ch/files/faltblatt/Erlaeuterungen-Quartierradar.pdf</a>."]
pub mod kennzahlen_zu_den_basler_wohnvierteln_und_landgemeinden {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationsjahr
        ///
        /// Jahr, in dem der Wert publiziert wurde
        pub publikationsjahr: Option<String>,
        /// Wohnviertel ID
        ///
        /// Nummer des Wohnviertels (1-19) bzw. der Landgemeinde (20 und 30)
        pub wohnviertel_id: Option<i64>,
        /// Wohnviertel Name
        ///
        /// Name des Wohnviertels bzw. der Landgemeinde
        pub wohnviertel_name: Option<String>,
        /// Altersquotient
        ///
        /// Verhältnis der Anzahl über 64-Jähriger zur Anzahl 20- bis 64-Jähriger (Personen im erwerbsfähigen Alter). Quelle: Kantonale Bevölkerungsstatistik
        pub altersquotient: Option<f64>,
        /// Jugendquotient
        ///
        /// Verhältnis der Anzahl unter 20-Jähriger zur Anzahl 20- bis 64-Jähriger (Personen im erwerbsfähigen Alter). Quelle: Kantonale Bevölkerungsstatistik
        pub jugendquotient: Option<f64>,
        /// Anteil Personen ohne Religionszugehörigkeit
        ///
        /// Anteil Personen ohne Religionszugehörigkeit an der gesamten Wohnbevölkerung des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_personen_ohne_religionszugehoerigkeit: Option<f64>,
        /// Anteil Personen in Einpersonenhaushalten
        ///
        /// Anteil der Personen in Einpersonenhaushalten an der Wohnbevölkerung in Privathaushalten des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_personen_in_einpersonenhaushalten: Option<f64>,
        /// Anteil Sesshafte
        ///
        /// Anteil der seit mindestens 10 Jahren am gleichen Wohnsitz wohnenden Personen des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_sesshafte: Option<f64>,
        /// Baujahr der Wohngebäude
        ///
        /// Mittleres Baujahr der Wohngebäude des Wohnviertels (ungewichtetes arithmetisches Mittel). Quelle: Kantonale Baustatistik
        pub baujahr_der_wohngebaeude: Option<f64>,
        /// Anteil Einfamilienhäuser
        ///
        /// Anteil der Einfamilienhäuser an allen bewohnbaren Gebäuden des Wohnviertels. Quelle: Kantonale Baustatistik
        pub anteil_einfamilienhaeuser: Option<f64>,
        /// Gymnasialquote
        ///
        /// Anteil der Schülerinnen und Schüler der öffentlichen Sekundarschule Basel-Stadt im Leistungszug P mit hohen Anforderungen («Progymnasium») an allen Sek-Lernenden der 10. und 11. Schulstufe. Quelle: Kantonale Bildungsstatistik
        pub gymnasialquote: Option<f64>,
        /// Anteil Sozialhilfeempfänger
        ///
        /// Anteil der im Jahresverlauf unterstützten Sozialhilfeempfänger an der Wohnbevölkerung des Wohnviertels. Quelle: Kantonale Sozialhilfestatistik
        pub anteil_sozialhilfeempfaenger: Option<f64>,
        /// Anteil Ausländer
        ///
        /// Anteil der ausländischen Wohnbevölkerung an der gesamten Wohnbevölkerung des Wohnviertels. Quelle: Kantonale Bevölkerungsstatistik
        pub anteil_auslaender: Option<f64>,
        /// Anteil Grünflächen
        ///
        /// Anteil der Grünfläche an der gesamten Fläche des Wohnviertels. Quelle: Grundbuch- und Vermessungsamt Basel-Stadt
        pub anteil_gruenflaechen: Option<f64>,
        /// Fläche pro Wohnung
        ///
        /// Mittlere Fläche der Wohnungen im Wohnviertel (ungewichtetes arithmetisches Mittel) in m². Quelle: Kantonale Baustatistik
        pub flaeche_pro_wohnung: Option<f64>,
        /// Wohnfläche pro Person
        ///
        /// Mittlere verfügbare Wohnfläche pro Einwohner im Wohnviertel (ungewichtetes arithmetisches Mittel) in m². Quelle: Kantonale Bau- und Bevölkerungsstatistik
        pub wohnflaeche_pro_person: Option<f64>,
        /// Vermögenssteuer pro Veranlagung
        ///
        /// Mittlere Vermögenssteuer der steuerpflichtigen Personen im Wohnviertel (ungewichtetes arithmetisches Mittel der ordentlichen Steuerveranlagungen) in Fr. Quelle: Steuerstatistik Basel-Stadt
        pub vermoegenssteuer_pro_veranlagung: Option<f64>,
        /// Einkommenssteuer pro Veranlagung
        ///
        /// Mittlere Einkommenssteuer der steuerpflichtigen Personen im Wohnviertel (ungewichtetes arithmetisches Mittel der ordentlichen Steuerveranlagungen) in Fr. Quelle: Steuerstatistik Basel-Stadt
        pub einkommenssteuer_pro_veranlagung: Option<f64>,
        /// Erwerbstätigenquote
        ///
        /// Anteil der erwerbstätigen Wohnbevölkerung an der gesamten erwerbsfähigen Wohnbevölkerung (16 bis 64 Jahre). Quelle: Bundesamt für Statistik, Strukturerhebung. Hochrechnungen auf Basis einer Stichprobe von rund 5 000 Personen im Jahr. Aufgrund der Grösse wird Bettingen zusammen mit Riehen ausgewertet, was zum gleichen Rangwert der beiden Gemeinden führt.
        pub erwerbstaetigenquote: Option<f64>,
        /// Arbeitsplätze pro Einwohner
        ///
        /// Anzahl Arbeitsplätze (Beschäftigtenzahl in Vollzeitäquivalenten) an der gesamten Wohnbevölkerung des Wohnviertels. Quelle: Bundesamt für Statistik, STATENT
        pub arbeitsplaetze_pro_einwohner: Option<f64>,
        /// Arbeitslosenquote
        ///
        /// Anteil als arbeitslos gemeldeter Personen am Total der Erwerbspersonen. Quelle: SECO (Anzahl Arbeitslose) und Bundesamt für Statistik, Strukturerhebung (Erwerbspersonen aus den Jahren 2010-2014, Hochrechnungen auf Basis einer Stichprobe von rund 5 000 Personen im Jahr). Aufgrund der Grösse wird Bettingen zusammen mit Riehen ausgewertet, was zum gleichen Rangwert der beiden Gemeinden führt.
        pub arbeitslosenquote: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Publikationsjahr,
        WohnviertelId,
        WohnviertelName,
        Altersquotient,
        Jugendquotient,
        AnteilPersonenOhneReligionszugehoerigkeit,
        AnteilPersonenInEinpersonenhaushalten,
        AnteilSesshafte,
        BaujahrDerWohngebaeude,
        AnteilEinfamilienhaeuser,
        Gymnasialquote,
        AnteilSozialhilfeempfaenger,
        AnteilAuslaender,
        AnteilGruenflaechen,
        FlaecheProWohnung,
        WohnflaecheProPerson,
        VermoegenssteuerProVeranlagung,
        EinkommenssteuerProVeranlagung,
        Erwerbstaetigenquote,
        ArbeitsplaetzeProEinwohner,
        Arbeitslosenquote,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Publikationsjahr => "publikationsjahr",
                Field::WohnviertelId => "wohnviertel_id",
                Field::WohnviertelName => "wohnviertel_name",
                Field::Altersquotient => "altersquotient",
                Field::Jugendquotient => "jugendquotient",
                Field::AnteilPersonenOhneReligionszugehoerigkeit => {
                    "anteil_personen_ohne_religionszugehoerigkeit"
                }
                Field::AnteilPersonenInEinpersonenhaushalten => {
                    "anteil_personen_in_einpersonenhaushalten"
                }
                Field::AnteilSesshafte => "anteil_sesshafte",
                Field::BaujahrDerWohngebaeude => "baujahr_der_wohngebaeude",
                Field::AnteilEinfamilienhaeuser => "anteil_einfamilienhaeuser",
                Field::Gymnasialquote => "gymnasialquote",
                Field::AnteilSozialhilfeempfaenger => "anteil_sozialhilfeempfaenger",
                Field::AnteilAuslaender => "anteil_auslaender",
                Field::AnteilGruenflaechen => "anteil_gruenflaechen",
                Field::FlaecheProWohnung => "flaeche_pro_wohnung",
                Field::WohnflaecheProPerson => "wohnflaeche_pro_person",
                Field::VermoegenssteuerProVeranlagung => "vermoegenssteuer_pro_veranlagung",
                Field::EinkommenssteuerProVeranlagung => "einkommenssteuer_pro_veranlagung",
                Field::Erwerbstaetigenquote => "erwerbstaetigenquote",
                Field::ArbeitsplaetzeProEinwohner => "arbeitsplaetze_pro_einwohner",
                Field::Arbeitslosenquote => "arbeitslosenquote",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100011/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Sitzungskalender"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Termine der Sitzungen des Grossen Rates Basel-Stadt.\u{a0}</p>"]
pub mod grosser_rat_sitzungskalender {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Sitzungstyp
        ///
        /// Beschreibung der Sitzung
        pub summary: Option<String>,
        /// Start
        ///
        /// Datum und Uhrzeit, zu der die Sitzung beginnt
        #[serde(with = "time::serde::iso8601::option")]
        pub dtstart: Option<OffsetDateTime>,
        /// Ende
        ///
        /// Datum und Uhrzeit, zu der die Sitzung endet
        #[serde(with = "time::serde::iso8601::option")]
        pub dtend: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Summary,
        Dtstart,
        Dtend,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Summary => "summary",
                Field::Dtstart => "dtstart",
                Field::Dtend => "dtend",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100188/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Positiv getestete Minderj\u{e4}hrige in 3-Jahresklassen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die minderj\u{e4}hrigen Personen, welche positiv auf SARS-CoV-2 getestet wurden in 3-Jahresklassen. Die erste Klasse (0 bis 3 Jahre) enth\u{e4}lt 4 Jahre. Es werden ausschliesslich Personen mit Wohnsitz im Kanton Basel-Stadt gezeigt. Als \u{ab}Datum Testresultat\u{bb} gilt das Datum, an welchem das Testresultat vorlag.</p><p>Weitere Datens\u{e4}tze zu Covid-19:</p><p>Fallzahlen Basel-Stadt:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100073\" target=\"_blank\">https://data.bs.ch/explore/dataset/100073</a></p><p>Tests Basel-Stadt:<a href=\"https://data.bs.ch/explore/dataset/100094\" target=\"_blank\">https://data.bs.ch/explore/dataset/100094</a></p><p>Todesf\u{e4}lle Basel-Stadt nach Alter und Geschlecht:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100076\" target=\"_blank\">https://data.bs.ch/explore/dataset/100076</a></p><p>Covid-19 Dashboard:\u{a0}<a href=\"https://data.bs.ch/pages/covid-19-dashboard\" target=\"_blank\">https://data.bs.ch/pages/covid-19-dashboard</a><a href=\"https://data.bs.ch/pages/covid-19-dashboard\" target=\"_blank\"></a></p><p><span style=\"font-weight: bolder;\">\u{c4}nderungsprotokoll:</span></p><ul><li>Die Erhebung der Werte wurde per 19. Juni 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.\u{a0}Aktualisierungsintervall von \"DAILY\" auf \"NEVER\" ge\u{e4}ndert.</li></ul><p><br/></p>"]
pub mod coronavirus_covid_19_positiv_getestete_minderjaehrige_in_3_jahresklassen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Testresultat
        ///
        /// Datum, an dem das Testresultat vorlag
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub test_datum: Option<Date>,
        /// Altersklasse
        ///
        /// 3-Jahresklassen der Minderjährigen, wobei die erste Klasse (0 bis 3 Jahre) 4 Jahre umfasst
        pub pers_alter: Option<String>,
        /// Anzahl Personen
        ///
        /// Anzahl Personen in der jeweiligen Subgruppe
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TestDatum,
        PersAlter,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TestDatum => "test_datum",
                Field::PersAlter => "pers_alter",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100152/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 12. M\u{e4}rz 2023"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 12. M\u{e4}rz 2023 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_12_maerz_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100280/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Baumkronenbedeckung"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die gesamte durch B\u{e4}ume beschattete Fl\u{e4}che (Baumkronenbedeckung) im Kanton Basel-Stadt in verschiedenen Jahren. Der Kanton Basel-Stadt erhebt durch Laserabtastung der Oberfl\u{e4}che (LiDAR) Daten zur Baumkronenbedeckung (durch B\u{e4}ume beschattete Fl\u{e4}che) \u{fc}ber die gesamte Kantonsfl\u{e4}che. Die von LiDAR abgeleitete Baumkronenbedeckung und Kennzahlen wurden f\u{fc}r 2012 und 2021 berechnet. Die Nachf\u{fc}hrung wird in Zukunft alle drei Jahre stattfinden (2024 und 2027), so dass die Entwicklung der Baumkronendeckung in Basel genau verfolgt werden kann.</p><p>Der Flug f\u{fc}r die Erhebung neuer Daten in 2024 hat bereits stattgefunden, die Daten zu den B\u{e4}umen werden ausgewertet und im Herbst publiziert. In Zukunft werden, f\u{fc}r ein genaues Monitoring, alle 3 Jahre neue Daten erhoben.</p><p>Die Stadtg\u{e4}rtnerei stellt der interessierten \u{d6}ffentlichkeit dieses digitale Wissen zur Verf\u{fc}gung: <a href=\"https://www.stadtgaertnerei.bs.ch/stadtgruen/stadtbaeume/baumkronenbedeckung.html\" target=\"_blank\">Stadtg\u{e4}rtnerei des Kantons Basel-Stadt - Baumkronenbedeckung (https://www.stadtgaertnerei.bs.ch/stadtgruen/stadtbaeume/baumkronenbedeckung.html)</a>\n</p><p>\n\nMan kann die LiDAR-Daten in Form einer png- und pgw-Datei in der Tabellenansicht herunterladen. Eine PGW-Datei ist eine Weltdatei, die Georeferenzierungsdaten f\u{fc}r ein zugeh\u{f6}riges Bild im PNG-Format enth\u{e4}lt, um dessen genaue Positionierung auf einer Karte zu erm\u{f6}glichen.</p><p>Hier finden Sie die URLs zu den Zip-Dateien, die beide Dateien enthalten:<br> \n<a href=\"https://data-bs.ch/stata/stadtgaertnerei/Baumkronenbedeckung_2012.zip\" target=\"_blank\">https://data-bs.ch/stata/stadtgaertnerei/Baumkronenbedeckung_2012.zip</a><br><a href=\"https://data-bs.ch/stata/stadtgaertnerei/Baumkronenbedeckung_2021.zip\" target=\"_blank\">https://data-bs.ch/stata/stadtgaertnerei/Baumkronenbedeckung_2021.zip</a></p><p>Auf der Website des Tiefbauamts k\u{f6}nnen Sie die Daten mit dem GeoViewer betrachten: <a href=\"https://tiefbauamt-bs.ch/geoviewer/lidar\" target=\"_blank\">https://tiefbauamt-bs.ch/geoviewer/lidar</a></p><p>Detailinformationen zur LiDAR-Technologie finden Sie hier: <a href=\"https://www.swisstopo.admin.ch/de/lidar-daten-swisstopo\" target=\"_blank\">https://www.swisstopo.admin.ch/de/lidar-daten-swisstopo</a> </p>"]
pub mod baumkronenbedeckung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// URL Bild
        ///
        /// Downloadlink zum Bild der Baumkronenbedeckung im png-Format.
        pub url_png: Option<String>,
        /// URL Weltdatei
        ///
        /// Downloadlink zur Weltdatei im png-Format. Eine Weltdatei enthält Georeferenzierungsdaten für ein zugehöriges Bild (hier im PNG-Format), um dessen genaue Positionierung auf einer Karte zu ermöglichen.
        pub url_pgw: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        UrlPng,
        UrlPgw,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::UrlPng => "url_png",
                Field::UrlPgw => "url_pgw",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100357/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Nationalratswahlen 2023: Ver\u{e4}nderte Wahlzettel"]
#[doc = ""]
#[doc = "<p>Bei den Nationalratswahlen im Kanton Basel-Stadt am 22. Oktober 2023 kandidierten 122 Personen auf 32 Listen (<a href=\"https://data.bs.ch/explore/dataset/100316\" target=\"_blank\">verf\u{fc}gbar unter https://data.bs.ch/explore/dataset/100316</a>) f\u{fc}r insgesamt vier zu vergebende Sitze.</p><p> Es gingen insgesamt 56 235 g\u{fc}ltigen Wahlzettel ein, von denen 29 637 Wahlzettel ver\u{e4}ndert wurden. Dieser Datensatz zeigt diese 29 637 Wahlzettel und jegliche Details dazu.\u{a0}</p><p>Die Wahlergebnisse sind in einem separaten Datensatz (<a href=\"https://data.bs.ch/explore/dataset/100281\" target=\"_blank\">https://data.bs.ch/explore/dataset/100281</a><a href=\"https://data.bs.ch/explore/dataset/100281\" target=\"_blank\"></a>\u{a0}und <a href=\"https://data.bs.ch/explore/dataset/100297\" target=\"_blank\">https://data.bs.ch/explore/dataset/100297</a>) einsehbar, der die Verteilung der Stimmen und die gew\u{e4}hlten Vertreter detailliert darstellt.</p><p>Das Statistische Amt hat zu diesem Datensatz einen Dossier-Artikel verfasst, der hier einsehbar ist: <a href=\"https://data-bs.ch/stata/wahlen_abstimmungen/wahlen/nr/wahlzettel_2023/6-wahlen.pdf\" target=\"_blank\">https://data-bs.ch/stata/wahlen_abstimmungen/wahlen/nr/wahlzettel_2023/6-wahlen.pdf\u{a0}</a></p>"]
pub mod nationalratswahlen_2023_veraenderte_wahlzettel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Column 1
        pub column_1: Option<i64>,
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Wahlkreis
        pub wahlkreis: Option<String>,
        /// Stimmmedium
        ///
        /// Beschreibt, ob der Wahlzettel in physischer oder elektronischer Form abgegeben wurde.
        pub wahlzettel_type: Option<String>,
        /// Listennummer
        pub listen_nr: Option<String>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        pub parteibezeichnung: Option<String>,
        /// 1. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der ersten Stimme
        pub kandidat_1: Option<String>,
        /// 1. Stimme - Name
        ///
        /// Ganzer Name der ersten Stimme
        pub kandidat_1_name: Option<String>,
        /// 2. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der zweiten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_2: Option<String>,
        /// 2. Stimme - Name
        ///
        /// Ganzer Name der zweiten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_2_name: Option<String>,
        /// 3. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der dritten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_3: Option<String>,
        /// 3. Stimme - Name
        ///
        /// Ganzer Name der dritten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_3_name: Option<String>,
        /// 4. Stimme - Kand.-Nr.
        ///
        /// Kandidierenden Nr. der vierten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_4: Option<String>,
        /// 4. Stimme - Name
        ///
        /// Ganzer Name der vierten Stimme (NULL bedeutet keine Stimme)
        pub kandidat_4_name: Option<String>,
        /// Veränderungsart
        ///
        /// p = panaschiert; k = kumuliert
        pub wahlzettel_typ: Option<String>,
        /// Listenverbindungen
        pub listenverbindungen: Option<String>,
        /// Unterlistenverbindungen
        pub unterlistenverbindungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Column1,
        Wahljahr,
        Wahlkreis,
        WahlzettelType,
        ListenNr,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        Kandidat1,
        Kandidat1Name,
        Kandidat2,
        Kandidat2Name,
        Kandidat3,
        Kandidat3Name,
        Kandidat4,
        Kandidat4Name,
        WahlzettelTyp,
        Listenverbindungen,
        Unterlistenverbindungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Column1 => "column_1",
                Field::Wahljahr => "wahljahr",
                Field::Wahlkreis => "wahlkreis",
                Field::WahlzettelType => "wahlzettel_type",
                Field::ListenNr => "listen_nr",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::Kandidat1 => "kandidat_1",
                Field::Kandidat1Name => "kandidat_1_name",
                Field::Kandidat2 => "kandidat_2",
                Field::Kandidat2Name => "kandidat_2_name",
                Field::Kandidat3 => "kandidat_3",
                Field::Kandidat3Name => "kandidat_3_name",
                Field::Kandidat4 => "kandidat_4",
                Field::Kandidat4Name => "kandidat_4_name",
                Field::WahlzettelTyp => "wahlzettel_typ",
                Field::Listenverbindungen => "listenverbindungen",
                Field::Unterlistenverbindungen => "unterlistenverbindungen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100331/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Nationalratswahlen 2023: Kandidierende aus Basel-Stadt"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">F\u{fc}r die Nationalratswahlen vom 22. Oktober 2023 kandidieren 122 Personen auf insgesamt 32 Listen f\u{fc}r den Kanton Basel-Stadt. Insgesamt werden vier Sitze im Nationalrat gew\u{e4}hlt.</p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">Dieser Datensatz zeigt die Kandidierenden aus dem Kanton Basel-Stadt nach Geschlecht, Jahrgang und Beruf sowie alle Listen und ihre Haupt- und Unterlistenverbindungen.</p>"]
pub mod nationalratswahlen_2023_kandidierende_aus_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenkurzbezeichnung
        ///
        /// Abkürzung der Liste
        pub listenkurzbezeichnung: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Listenverbindungen mit
        ///
        /// Hauptlistenverbindungen
        pub hlv_mit: Option<String>,
        /// Filter nach Listenverbindung
        ///
        /// Mit dem Klick auf den Link wird der Datensatz nach allen Listen gefiltert, die in der gleichen Hauptlistenverbindung sind.
        pub hlv_link: Option<String>,
        /// Unterlistenverbindungen mit
        ///
        /// Unterlistenverbindungen
        pub ulv_mit: Option<String>,
        /// Filter nach Unterlistenverbindung
        ///
        /// Mit dem Klick auf den Link wird der Datensatz nach allen Listen gefiltert, die in der gleichen Unterlistenverbindung sind.
        pub ulv_link: Option<String>,
        /// Kandidierenden-Nr.
        ///
        /// Nummer der Kandidatur
        pub kand_nr: Option<String>,
        /// Bisher
        ///
        /// War die kandidierende Person bisher im Nationalrat?
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e), Pronomen etc.
        pub kurzbeschrieb: Option<String>,
        /// Wohnhaft in
        pub wh_in: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenkurzbezeichnung,
        Listenbezeichnung,
        HlvMit,
        HlvLink,
        UlvMit,
        UlvLink,
        KandNr,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Kurzbeschrieb,
        WhIn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenkurzbezeichnung => "listenkurzbezeichnung",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::HlvMit => "hlv_mit",
                Field::HlvLink => "hlv_link",
                Field::UlvMit => "ulv_mit",
                Field::UlvLink => "ulv_link",
                Field::KandNr => "kand_nr",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Kurzbeschrieb => "kurzbeschrieb",
                Field::WhIn => "wh_in",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100316/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "St\u{e4}nderatswahlen 2023: Kandidierende aus Basel-Stadt"]
#[doc = ""]
#[doc = "<p style=\"margin: 0cm 0cm 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">F\u{fc}r die St\u{e4}nderatswahlen vom 22. Oktober 2023 kandidieren vier Personen\u{a0} f\u{fc}r den Kanton Basel-Stadt. Insgesamt wird 1 Sitz im St\u{e4}nderat gew\u{e4}hlt.<o:p></o:p></span></p><p style=\"margin: 0cm 0cm 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Dieser Datensatz zeigt die Kandidierenden aus dem Kanton\nBasel-Stadt nach Geschlecht, Jahrgang und Beruf sowie die jeweiligen Listen.<o:p></o:p></span></p><p style=\"font-family: sans-serif;\">\n\n\n\n</p><p class=\"MsoNormal\"><o:p>\u{a0}</o:p></p>"]
pub mod staenderatswahlen_2023_kandidierende_aus_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Listen-Nr.
        ///
        /// Nummer der Liste
        pub listen_nr: Option<String>,
        /// Listenbezeichnung
        pub listenbezeichnung: Option<String>,
        /// Bisher
        ///
        /// War die kandidierende Person bisher im Ständerat?
        pub bisher: Option<String>,
        /// Ganzer Name
        ///
        /// Ganzer Name der kandidierenden Person
        pub name_vorname: Option<String>,
        /// Name
        ///
        /// Nachname der kandidierenden Person
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname der kandidierenden Person
        pub vorname: Option<String>,
        /// Geschlecht
        ///
        /// amtliches Geschlecht der kandidierenden Person
        pub geschlecht: Option<String>,
        /// Jahrgang
        ///
        /// Jahr, in welchem die kandidierende Person geboren wurde
        pub jahrgang: Option<String>,
        /// zusätzliche Angaben
        ///
        /// Informationen zu der kandidierenden Person wie akademische(r) Titel, Beruf(e) etc.
        pub kurzbeschrieb: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ListenNr,
        Listenbezeichnung,
        Bisher,
        NameVorname,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Kurzbeschrieb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ListenNr => "listen_nr",
                Field::Listenbezeichnung => "listenbezeichnung",
                Field::Bisher => "bisher",
                Field::NameVorname => "name_vorname",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Kurzbeschrieb => "kurzbeschrieb",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100317/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wahllokale Kanton Basel-Stadt"]
#[doc = ""]
#[doc = "<p>In diesem Datensatz sind die Wahllokale des Kantons Basel-Stadt aufgef\u{fc}hrt, zusammen mit Informationen zu den entsprechenden Wahllokal-IDs, Gemeinde-IDs und den zugeh\u{f6}rigen Gemeinden.<br/>Insgesamt enth\u{e4}lt der Datensatz Informationen zu verschiedenen Wahllokalen im Kanton Basel-Stadt, einschlie\u{df}lich der Angaben zu brieflichen, elektronischen und pers\u{f6}nlichen Stimmenden an den einzelnen Standorten.<br/></p>"]
pub mod wahllokale_kanton_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahllokal
        pub wahllok_name: Option<String>,
        /// Wahllokal-ID
        pub wahllok_id: Option<i64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WahllokName,
        WahllokId,
        GemeinId,
        GemeinName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WahllokName => "wahllok_name",
                Field::WahllokId => "wahllok_id",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100098/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Lebendgeborene seit 1901"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die j\u{e4}hrliche Anzahl Lebendgeburten nach demografischen Merkmalen des Kindes und der Mutter und nach Geschlecht des Kindes seit 1901."]
pub mod lebendgeborene_seit_1901 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// Total
        ///
        /// Total der Lebendgeborenen
        pub total: Option<i64>,
        /// Knaben
        ///
        /// Anzahl Knaben
        pub knaben: Option<i64>,
        /// Mädchen
        ///
        /// Anzahl Mädchen
        pub madchen: Option<i64>,
        /// Mutter verheiratet
        ///
        /// Anzahl der Mütter, die verheiratet sind
        pub mutter_verheiratet: Option<i64>,
        /// Mutter unverheiratet
        ///
        /// Anzahl der Mütter, die unverheiratet sind
        pub mutter_unverheiratet: Option<i64>,
        /// Kantonsbürger
        ///
        /// Anzahl der Lebendgeborenen, die Bürgerinnen und Bürger des Kantons Basel-Stadt sind
        pub kantonsburger: Option<i64>,
        /// Übrige Schweizer
        ///
        /// Anzahl der Lebendgeborenen, die Bürgerinnen und Bürger anderer Schweizer Kantone sind
        pub ubrige_schweiz: Option<i64>,
        /// Schweiz
        ///
        /// Anzahl der Lebendgeborenen mit Schweizer Staatsangehörigkeit
        pub schweiz: Option<i64>,
        /// Ausland
        ///
        /// Anzahl der Lebendgeborenen mit ausländischer Staatsangehörigkeit
        pub ausland: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Total,
        Knaben,
        Madchen,
        MutterVerheiratet,
        MutterUnverheiratet,
        Kantonsburger,
        UbrigeSchweiz,
        Schweiz,
        Ausland,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Total => "total",
                Field::Knaben => "knaben",
                Field::Madchen => "madchen",
                Field::MutterVerheiratet => "mutter_verheiratet",
                Field::MutterUnverheiratet => "mutter_unverheiratet",
                Field::Kantonsburger => "kantonsburger",
                Field::UbrigeSchweiz => "ubrige_schweiz",
                Field::Schweiz => "schweiz",
                Field::Ausland => "ausland",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100326/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Perimeter der Sch\u{fc}lerprognosen Basel-Stadt"]
#[doc = ""]
#[doc = "Die Karte zeigt Schulperimeter im Kanton Basel-Stadt. Die Perimeter werden zu Planungszwecken vom Erziehungsdepartement Basel-Stadt und von der Gemeinde Riehen verwendet. Insbesondere dienen sie als r\u{e4}umliche Grundlage f\u{fc}r die kleinr\u{e4}umigen Sch\u{fc}lerprognosen, die im Auftrag des Erziehungsdepartements Basel-Stadt und der Gemeinde Riehen erstellt werden. Die Perimeter dienen als Planungsgrundlage und nicht als effektive Einzugsgebiete."]
pub mod perimeter_der_schuelerprognosen_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Perimeter ID
        ///
        /// Laufnummer der Perimeter
        pub nummer: Option<i64>,
        /// Perimeter Name
        ///
        /// Räumliche Einheiten, die zu Planungszwecken vom Erziehungsdepartement Basel-Stadt und von der Gemeinde Riehen verwendet werden. Die Perimeter dienen als Planungsgrundlage und nicht als effektive Einzugsgebiete.
        pub zonen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Nummer,
        Zonen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Nummer => "nummer",
                Field::Zonen => "zonen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100124/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geschwindigkeitsklassen motorisierter Individualverkehr"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt die Geschwindigkeitsklassen des motorisierten Individualverkehrs. Die Daten werden vor der Ver\u{f6}ffentlichung nicht \u{fc}berpr\u{fc}ft oder erg\u{e4}nzt. Daher k\u{f6}nnen jederzeit Datenl\u{fc}cken oder falsche Messungen aufgrund technischer Probleme oder Verkehrsbehinderungen auftreten.</p><p>Aus Kostengr\u{fc}nden sind nur die Werte des aktuellen Jahres und der letzten zwei Jahre als Tabelle / Visualisierung sichtbar bzw. via API abgreifbar. Die vollst\u{e4}ndigen Daten ab dem Jahr 2014 k\u{f6}nnen hier heruntergeladen werden:\u{a0}<br><br>Leicht aufbereiteter Datensatz: <a href=\"https://data-bs.ch/mobilitaet/converted_MIV_Speed.csv\" target=\"_blank\">https://data-bs.ch/mobilitaet/converted_MIV_Speed.csv\u{a0}</a><br>Rohdaten: <a href=\"https://data-bs.ch/mobilitaet/MIV_Speed.csv\" target=\"_blank\">https://data-bs.ch/mobilitaet/MIV_Speed.csv</a><br><br>Die Daten einzelner Jahre ab dem Jahr 2014 k\u{f6}nnen heruntergeladen werden unter der URL mit dem Muster https://data-bs.ch/mobilitaet/[JAHR]_MIV_Speed.csv, als zum Beispiel f\u{fc}r das Jahr 2020 hier: <a href=\"https://data-bs.ch/mobilitaet/2020_MIV_Speed.csv\" target=\"_blank\">https://data-bs.ch/mobilitaet/2020_MIV_Speed.csv.</a></p>"]
pub mod geschwindigkeitsklassen_motorisierter_individualverkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Standort-ID
        pub zst_id: Option<String>,
        /// Standortname
        ///
        /// Name des Standorts
        pub sitename: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung des Fahrzeugs
        pub directionname: Option<String>,
        /// Spurnummer
        ///
        /// Nummer der Spur
        pub lanecode: Option<String>,
        /// Spurname
        ///
        /// Name der Spur
        pub lanename: Option<String>,
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Messbeginn Uhrzeit
        pub timefrom: Option<String>,
        /// Messende Uhrzeit
        pub timeto: Option<String>,
        /// Verkehrsart
        pub traffictype: Option<String>,
        /// Total
        pub total: Option<i64>,
        /// <20km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von weniger als 20 km/h fahren.
        pub x20: Option<i64>,
        /// 20-30km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 20-30km/h fahren.
        pub x20_30: Option<i64>,
        /// 30-40km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 30-40km/h fahren.
        pub x30_40: Option<i64>,
        /// 40-50km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 40-50km/h fahren.
        pub x40_50: Option<i64>,
        /// 50-60km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 50-60km/h fahren.
        pub x50_60: Option<i64>,
        /// 60-70km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 60-70km/h fahren.
        pub x60_70: Option<i64>,
        /// 70-80km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 70-80km/h fahren.
        pub x70_80: Option<i64>,
        /// 80-90km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 80-90km/h fahren.
        pub x80_90: Option<i64>,
        /// 90-100km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 90-100km/h fahren.
        pub x90_100: Option<i64>,
        /// 100-110km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 100-110km/h fahren.
        pub x100_110: Option<i64>,
        /// 110-120km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 110-120km/h fahren.
        pub x110_120: Option<i64>,
        /// 120-130km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von 120-130km/h fahren.
        pub x120_130: Option<i64>,
        /// >130km/h
        ///
        /// Anzahl der Fahrzeuge im motorisierten Individualverkehr, die mit einer Geschwindigkeit von über 130km/h fahren.
        pub x130: Option<i64>,
        /// Messbeginn Zeitpunkt
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimefrom: Option<OffsetDateTime>,
        /// Messende Zeitpunkt
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimeto: Option<OffsetDateTime>,
        /// Jahr
        pub year: Option<String>,
        /// Monat
        pub month: Option<String>,
        /// Tag
        pub day: Option<String>,
        /// Wochentag
        ///
        /// Die Wochentage sind von 0 bis 6 durchnummeriert mit Montag als Wochenanfang mit der Nummer 0.
        pub weekday: Option<String>,
        /// Stunde
        pub hourfrom: Option<String>,
        /// Tag des Jahres
        pub dayofyear: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ZstId,
        Sitename,
        Directionname,
        Lanecode,
        Lanename,
        Date,
        Timefrom,
        Timeto,
        Traffictype,
        Total,
        X20,
        X2030,
        X3040,
        X4050,
        X5060,
        X6070,
        X7080,
        X8090,
        X90100,
        X100110,
        X110120,
        X120130,
        X130,
        Datetimefrom,
        Datetimeto,
        Year,
        Month,
        Day,
        Weekday,
        Hourfrom,
        Dayofyear,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ZstId => "zst_id",
                Field::Sitename => "sitename",
                Field::Directionname => "directionname",
                Field::Lanecode => "lanecode",
                Field::Lanename => "lanename",
                Field::Date => "date",
                Field::Timefrom => "timefrom",
                Field::Timeto => "timeto",
                Field::Traffictype => "traffictype",
                Field::Total => "total",
                Field::X20 => "20",
                Field::X2030 => "20_30",
                Field::X3040 => "30_40",
                Field::X4050 => "40_50",
                Field::X5060 => "50_60",
                Field::X6070 => "60_70",
                Field::X7080 => "70_80",
                Field::X8090 => "80_90",
                Field::X90100 => "90_100",
                Field::X100110 => "100_110",
                Field::X110120 => "110_120",
                Field::X120130 => "120_130",
                Field::X130 => "130",
                Field::Datetimefrom => "datetimefrom",
                Field::Datetimeto => "datetimeto",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Hourfrom => "hourfrom",
                Field::Dayofyear => "dayofyear",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100356/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Transformation Areal Rosental: Baustellenbereich"]
#[doc = ""]
#[doc = "<p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten im Rahmen der \u{ab}Transformation <a href=\"https://rosentalmitte.ch\" target=\"_blank\">Rosental Mitte</a>\u{bb} \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft <a href=\"https://data.bs.ch/pages/rosental-dashboard/\" target=\"_blank\">(Dashboard)</a>.\u{a0}</p><div><br/></div>"]
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_baustellenbereich {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub n: Option<String>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        N,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::N => "n",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100296/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Steuerstatistik Basel-Stadt: Kennzahlen seit 1991 nach Gemeinde und Wohnviertel"]
#[doc = ""]
#[doc = "Zentrale Gr\u{f6}ssen der Steuerstatistik Basel-Stadt seit 1991 nach Gemeinde und Wohnviertel. Die Daten stammen aus den Steuerdaten der ordentlichen Veranlagung von ganzj\u{e4}hrig in Basel-Stadt steuerpflichtigen Personen (ohne Ausw\u{e4}rtige). Die Verm\u{f6}genssteuer 2000 wurde zusammen mit der Einkommenssteuer 1999 bezogen. In der Steuerperiode 2000 sind nur F\u{e4}lle mit Beginn der Steuerpflicht im Jahr 2000 aufgef\u{fc}hrt, da die Verm\u{f6}genssteuer 2001 wegen der Steuerharmonisierung erst zusammen mit der Einkommenssteuer 2001 bezogen worden ist."]
pub mod steuerstatistik_basel_stadt_kennzahlen_seit_1991_nach_gemeinde_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Steuerjahr
        ///
        /// Jahr, auf das sich die Veranlagung bezieht.
        pub steuerjahr: Option<String>,
        /// Wohnviertel
        ///
        /// Umfasst die Wohnviertel der Stadt Basel sowie die beiden Einwohnergemeinden Riehen und Bettingen.
        pub wohnviertel: Option<i64>,
        /// Wohnviertel Name
        pub wohnviertel_name: Option<String>,
        /// Anzahl Veranlagungen
        ///
        /// Ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub n: Option<i64>,
        /// Reineinkommen Mittelwert
        ///
        /// Mittelwert des Reineinkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reineinkommen_mittelwert: Option<i64>,
        /// Reineinkommen Median
        ///
        /// Median des Reineinkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reineinkommen_median: Option<i64>,
        /// Reineinkommen Gini-Koeffizient
        ///
        /// Gini-Koeffizient für das Reineinkommen; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt. Der Gini-Koeffizient ist eine statistische Masszahl zur Messung der Einkommens- oder Vermögensungleichheit in einer Gesellschaft. Er variiert zwischen 0 und 1, wobei 0 für absolute Gleichheit steht und 1 für maximale Ungleichheit.
        pub reineinkommen_ginik: Option<f64>,
        /// Steuerbares Einkommen Mittelwert
        ///
        /// Mittelwert des steuerbaren Einkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbar_mittelwert: Option<i64>,
        /// Steuerbares Einkommen Median
        ///
        /// Median des steuerbaren Einkommens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbar_median: Option<i64>,
        /// Ertrag Einkommenssteuer Mittelwert
        ///
        /// Mittelwert des Einkommenssteuerertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbetrag_ktgde_mittelwert: Option<i64>,
        /// Ertrag Einkommenssteuer Median
        ///
        /// Median des Einkommenssteuerertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub einkommen_steuerbetrag_ktgde_median: Option<i64>,
        /// Reinvermögen Mittelwert
        ///
        /// Mittelwert des Reinvermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reinvermoegen_mittelwert: Option<i64>,
        /// Reinvermögen Median
        ///
        /// Median des Reinvermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub reinvermoegen_median: Option<i64>,
        /// Reinvermögen Gini-Koeffizient
        ///
        /// Gini-Koeffizient für das Reinvermögen; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt. Der Gini-Koeffizient ist eine statistische Masszahl zur Messung der Einkommens- oder Vermögensungleichheit in einer Gesellschaft. Er variiert zwischen 0 und 1, wobei 0 für absolute Gleichheit steht und 1 für maximale Ungleichheit.
        pub reinvermoegen_ginik: Option<f64>,
        /// Steuerbares Vermögen Mittelwert
        ///
        /// Mittelwert des steuerbaren Vermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbar_mittelwert: Option<i64>,
        /// Steuerbares Vermögen Median
        ///
        /// Median des steuerbaren Vermögens in Fr.; ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbar_median: Option<i64>,
        /// Ertrag Vermögenssteuer Mittelwert
        ///
        /// Mittelwert des Vermögenssteuerertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbetrag_ktgde_mittelwert: Option<i64>,
        /// Ertrag Vermögenssteuer Median
        ///
        /// Median des Vermögenssteuertrags in Fr. (Kantons- und Gemeindesteuer); ordentliche Veranlagungen von natürlichen Personen in Basel-Stadt; Quelle: Steuerstatistik Basel-Stadt
        pub vermoegen_steuerbetrag_ktgde_median: Option<i64>,
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub steuerjahr_zahl: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Steuerjahr,
        Wohnviertel,
        WohnviertelName,
        N,
        ReineinkommenMittelwert,
        ReineinkommenMedian,
        ReineinkommenGinik,
        EinkommenSteuerbarMittelwert,
        EinkommenSteuerbarMedian,
        EinkommenSteuerbetragKtgdeMittelwert,
        EinkommenSteuerbetragKtgdeMedian,
        ReinvermoegenMittelwert,
        ReinvermoegenMedian,
        ReinvermoegenGinik,
        VermoegenSteuerbarMittelwert,
        VermoegenSteuerbarMedian,
        VermoegenSteuerbetragKtgdeMittelwert,
        VermoegenSteuerbetragKtgdeMedian,
        SteuerjahrZahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Steuerjahr => "steuerjahr",
                Field::Wohnviertel => "wohnviertel",
                Field::WohnviertelName => "wohnviertel_name",
                Field::N => "n",
                Field::ReineinkommenMittelwert => "reineinkommen_mittelwert",
                Field::ReineinkommenMedian => "reineinkommen_median",
                Field::ReineinkommenGinik => "reineinkommen_ginik",
                Field::EinkommenSteuerbarMittelwert => "einkommen_steuerbar_mittelwert",
                Field::EinkommenSteuerbarMedian => "einkommen_steuerbar_median",
                Field::EinkommenSteuerbetragKtgdeMittelwert => {
                    "einkommen_steuerbetrag_ktgde_mittelwert"
                }
                Field::EinkommenSteuerbetragKtgdeMedian => "einkommen_steuerbetrag_ktgde_median",
                Field::ReinvermoegenMittelwert => "reinvermoegen_mittelwert",
                Field::ReinvermoegenMedian => "reinvermoegen_median",
                Field::ReinvermoegenGinik => "reinvermoegen_ginik",
                Field::VermoegenSteuerbarMittelwert => "vermoegen_steuerbar_mittelwert",
                Field::VermoegenSteuerbarMedian => "vermoegen_steuerbar_median",
                Field::VermoegenSteuerbetragKtgdeMittelwert => {
                    "vermoegen_steuerbetrag_ktgde_mittelwert"
                }
                Field::VermoegenSteuerbetragKtgdeMedian => "vermoegen_steuerbetrag_ktgde_median",
                Field::SteuerjahrZahl => "steuerjahr_zahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100165/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Eingeb\u{fc}rgerte Ausl\u{e4}nderinnen und Ausl\u{e4}nder nach Geschlecht, Alter, Geburtsland und Staatsangeh\u{f6}rigkeit bei Gesuchsstellung"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die eingeb\u{fc}rgerten Ausl\u{e4}nderinnen und Ausl\u{e4}nder des Kantons Basel-Stadt nach Geschlecht, Alter, Geburtsland und Staatsangeh\u{f6}rigkeit bei der Gesuchstellung. Die Staatsangeh\u{f6}rigen aus Serbien, Montenegro und Kosovo werden bis zum Jahr 2014 unter \u{ab}Serbien, Montenegro und Kosovo\u{bb} zusammengefasst, seit dem Jahr 2015 k\u{f6}nnen sie separat ausgewiesen werden. Der Datensatz wird j\u{e4}hrlich aktualisiert. Ausl\u{e4}ndische Staatsangeh\u{f6}rige, die zehn Jahre in der Schweiz gelebt haben und eine Niederlassungsbewilligung C besitzen, k\u{f6}nnen sich um die ordentliche Einb\u{fc}rgerung bewerben. Die im Alter von 8 bis 18 in der Schweiz verbrachten Jahre z\u{e4}hlen doppelt. Unter bestimmten Voraussetzungen ist nach k\u{fc}rzerer Aufenthaltsdauer eine erleichterte Einb\u{fc}rgerung m\u{f6}glich, z. B. nach f\u{fc}nf Jahren Aufenthalt und drei Jahren Ehe mit einer Schweizerin bzw. einem Schweizer. Auch in der Schweiz geborene ausl\u{e4}ndische Staatsangeh\u{f6}rige der dritten Generation k\u{f6}nnen sich bis zum Alter von 25 Jahren erleichtert einb\u{fc}rgern lassen, falls ein Grosseltern- und ein Elternteil in der Schweiz gelebt haben. Bis 2017 galten teilweise andere Bestimmungen, die bei bis zu diesem Zeitpunkt eingereichten Einb\u{fc}rgerungsgesuchen zum Tragen kamen. Neben den ordentlichen und den erleichterten Einb\u{fc}rgerungen gibt es weitere Einb\u{fc}rgerungen (z. B. infolge Anerkennung der Vaterschaft, Adoption, Wiedereinb\u{fc}rgerung oder Feststellung der Schweizer Staatsangeh\u{f6}rigkeit), die hier ebenfalls ber\u{fc}cksichtigt werden."]
pub mod eingebuergerte_auslaenderinnen_und_auslaender_nach_geschlecht_alter_geburtsland_und_staatsangehoerigkeit_bei_gesuchsstellung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Einbürgerungsjahr
        pub jahr: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht der eingebürgerten Person (männlich oder weiblich)
        pub geschlecht: Option<String>,
        /// Alter
        ///
        /// Alter am Ende des Einbürgerungsjahres
        pub alter: Option<String>,
        /// Alter mit Nummerierung
        ///
        /// Alter (mit Nummerierung) am Ende des Einbürgerungsjahres
        pub alter_numm: Option<String>,
        /// Geburtsland
        ///
        /// Geburtsland (Ausland oder Schweiz)
        pub geburtsland: Option<String>,
        /// Staatsangehörigkeit bei Gesuchstellung
        ///
        /// Staatsangehörigkeit bei der Gesuchstellung
        pub ehem_staaatsangehorigkeit: Option<String>,
        /// Anzahl Eingebürgerte
        pub anzahl_eingeburgerte: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Geschlecht,
        Alter,
        AlterNumm,
        Geburtsland,
        EhemStaaatsangehorigkeit,
        AnzahlEingeburgerte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Geschlecht => "geschlecht",
                Field::Alter => "alter",
                Field::AlterNumm => "alter_numm",
                Field::Geburtsland => "geburtsland",
                Field::EhemStaaatsangehorigkeit => "ehem_staaatsangehorigkeit",
                Field::AnzahlEingeburgerte => "anzahl_eingeburgerte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100321/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Schutzsuchende im Kanton Basel-Stadt nach Geschlecht, Altersklasse, Staatsangeh\u{f6}rigkeit, Zuzugs- und Wegzugsmonat"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Schutzsuchenden im Kanton Basel-Stadt nach Geschlecht, Altersgruppe, Staatsangeh\u{f6}rigkeit, Zuzugs- und Wegzugsmonat. Er wird monatlich aktualisiert."]
pub mod schutzsuchende_im_kanton_basel_stadt_nach_geschlecht_altersklasse_staatsangehoerigkeit_zuzugs_und_wegzugsmonat {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Personen-ID
        ///
        /// Personenbezogene Laufnummer
        pub laufnummer: Option<i64>,
        /// Jahr
        ///
        /// Jahr des Bevölkerungsbestand
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat des Bevölkerungsbestand
        pub monat: Option<i64>,
        /// Schutzstatus
        pub schutzstatus: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht der Schutzsuchenden (W: Weiblich, M: Männlich)
        pub geschlecht: Option<String>,
        /// Altersgruppen
        ///
        /// Schutzsuchende nach Altersgruppen
        pub altersgruppen: Option<String>,
        /// Weggezogen
        ///
        /// 0: Schutzsuchende sind noch im Bevölkerungsbestand, 1: Schutzsuchende sind nicht mehr im Bevölkerungsbestand (entweder aufgrund von Wegzug, Wechsel des Status, Todesfall, Registerbereinigung etc.)
        pub weggezogen: Option<i64>,
        /// Wegzugsjahr
        ///
        /// Jahr des Wegzugs (entweder aufgrund von Wegzug, Wechsel des Status, Todesfall, Registerbereinigung etc.)
        pub wegzugsjahr: Option<String>,
        /// Wegzugsmonat
        ///
        /// Monat des Wegzugs (entweder aufgrund von Wegzug, Wechsel des Status, Todesfall, Registerbereinigung etc.)
        pub wegzugsmonat: Option<i64>,
        /// Zuzugsjahr
        ///
        /// Jahr des Zuzugs (aufgrund von Zuzug oder Wechsel des Status)
        pub zuzugsjahr: Option<String>,
        /// Zuzugsmonat
        ///
        /// Monat des Zuzugs (aufgrund von Zuzug oder Wechsel des Status)
        pub zuzugsmonat: Option<i64>,
        /// Value_gender_BFS
        pub value_gender_bfs: Option<i64>,
        /// Name_gender_BFS
        pub name_gender_bfs: Option<String>,
        /// Monat und Jahr
        pub monat_und_jahr: Option<String>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit der Schutzsuchenden
        pub staatsangehoerigkeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Laufnummer,
        Jahr,
        Monat,
        Schutzstatus,
        Geschlecht,
        Altersgruppen,
        Weggezogen,
        Wegzugsjahr,
        Wegzugsmonat,
        Zuzugsjahr,
        Zuzugsmonat,
        ValueGenderBfs,
        NameGenderBfs,
        MonatUndJahr,
        Staatsangehoerigkeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Laufnummer => "laufnummer",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Schutzstatus => "schutzstatus",
                Field::Geschlecht => "geschlecht",
                Field::Altersgruppen => "altersgruppen",
                Field::Weggezogen => "weggezogen",
                Field::Wegzugsjahr => "wegzugsjahr",
                Field::Wegzugsmonat => "wegzugsmonat",
                Field::Zuzugsjahr => "zuzugsjahr",
                Field::Zuzugsmonat => "zuzugsmonat",
                Field::ValueGenderBfs => "value_gender_bfs",
                Field::NameGenderBfs => "name_gender_bfs",
                Field::MonatUndJahr => "monat_und_jahr",
                Field::Staatsangehoerigkeit => "staatsangehoerigkeit",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100225/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Sanierung Areal Walkeweg"]
#[doc = ""]
#[doc = "<div>Immobilien Basel-Stadt (IBS) erstellt auf dem Familiengarten Areal Walkeweg Nord in Basel eine Neubebauung mit Wohneigentum und Schule. Bereiche des Neubauprojektes sind im Kataster der belasteten Standorte des Kantons Basel-Stadt gef\u{fc}hrt. Es handelt sich dabei um eine ehemalige Kiesentnahmestelle (ab ca. 1892), welche in Etappen ab 1917 sukzessive wieder mit Abfall aufgef\u{fc}llt wurde. Im Rahmen des Projekts ist eine Totalsanierung mit Bodenaustausch am Standort vorgesehen.</div><div>Neben beh\u{f6}rdlichen Auflagen und Schutzmassnahmen, welche w\u{e4}hrend den baulichen Massnahmen im Untergrund eine Belastung der Umgebung (Schutz der Umwelt und Allgemeinbev\u{f6}lkerung) mindern sollen, sieht das Lufthygieneamt beider Basel (LHA) vor, w\u{e4}hrend der relevanten baulichen Eingriffe die Immissionen mittels Messungen der Luft zu \u{fc}berwachen. Auf Basis der Ergebnisse der technischen Untersuchung des Areals wurde in erster Linie die Staubdeposition (mittels Bergerhoff-Methode) und fl\u{fc}chtige organische Stoffe (mittels Passivsammler) als zu \u{fc}berwachende Parameter ausgew\u{e4}hlt.\u{a0}</div><div>F\u{fc}r die vorliegende \u{dc}berwachung wurden Warn- und Interventionswerte festgelegt. Die Interventionswerte beruhen auf beh\u{f6}rdlichen Grenzwerten und toxikologischen Studien. Der Warnwert wurde bei jeweils 50 % des Interventionswertes festgelegt.</div><div><br/></div><div>\u{c4}nderungsprotokoll:<br/>27.06.2023 - Aktualisierungsintervall von \"MONTHLY\" auf \"NEVER\" ge\u{e4}ndert.</div><div>\n</div>"]
pub mod ueberwachung_luftqualitaet_sanierung_areal_walkeweg {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messbeginn
        ///
        /// Beginn der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Ende der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Standort
        ///
        /// Name des Standorts
        pub standort: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff
        pub parameter: Option<String>,
        /// Messwert
        ///
        /// Gemessener Wert
        pub messwert: Option<f64>,
        /// Interventionswert
        pub interventionswert: Option<f64>,
        /// Warnwert
        pub warnwert: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird
        pub einheit: Option<String>,
        /// Messmethode
        pub messmethode: Option<String>,
        /// Koordinaten des Standorts
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Messbeginn,
        Messende,
        Standort,
        Parameter,
        Messwert,
        Interventionswert,
        Warnwert,
        Einheit,
        Messmethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::Messwert => "messwert",
                Field::Interventionswert => "interventionswert",
                Field::Warnwert => "warnwert",
                Field::Einheit => "einheit",
                Field::Messmethode => "messmethode",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100158/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der St\u{e4}nderatswahlen 2023"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate der St\u{e4}nderatswahl vom 22. Oktober 2023.<o:p></o:p></p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_staenderatswahlen_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Alter am Jahresende 2023
        ///
        /// Alter, berechnet nach der Formel "2023 minus Jahrgang"
        pub alter_am_jahresende_2023: Option<i64>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1)
        pub column_44: Option<i64>,
        pub jahrgang_num: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngestempelteWahlzettel,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        AlterAmJahresende2023,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        Column44,
        JahrgangNum,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::AlterAmJahresende2023 => "alter_am_jahresende_2023",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::Column44 => "column_44",
                Field::JahrgangNum => "jahrgang_num",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100282/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Erweiterte Daten zu Impfungen nach Altersgruppe"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die SARS-CoV-2-Impfungen, welche an Personen mit Wohnsitz im Kanton Basel-Stadt verabreicht wurden nach Altersklasse.\u{a0}</p><p>Anmerkung: Die geimpften Personen wohnen im Kanton Basel-Stadt, m\u{fc}ssen aber nicht zwingend auch im Kanton Basel-Stadt geimpft worden sein. Aus diesem Grund unterscheiden sich die hier publizierten Zahlen auch von jenen im <a href=\"https://data.bs.ch/explore/dataset/100111\" target=\"_blank\">Datensatz mit den im Kanton Basel-Stadt verabreichten Impfungen</a>.\u{a0}</p><p>Dieser Datensatz wurde mit verschiedenen Variablen aus diesem Datensatz (<a href=\"https://data.bs.ch/explore/dataset/100128\" target=\"_blank\">https://data.bs.ch/explore/dataset/100128</a>) erg\u{e4}nzt, um die Anteile der geimpften Personen nach Altersklasse f\u{fc}r die Visualisierungen berechnen zu k\u{f6}nnen. Die rohen Werte zu den geimpften Personen nach Altersklasse finden Sie in diesem Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100135\" target=\"_blank\">https://data.bs.ch/explore/dataset/100135</a><a href=\"https://data.bs.ch/explore/dataset/100135\" target=\"_blank\"></a></p><p>Ab 2. Juli 2021 werden auch geimpfte Personen in der Altersklasse von 12 bis 15 Jahren gezeigt. 12- bis 15-J\u{e4}hrige konnten sich ab 28. Juni 2021 impfen lassen. Die impfberechtigte Bev\u{f6}lkerung wurde entsprechend ab dem 28. Juni um die 12- bis 15-j\u{e4}hrigen Personen erg\u{e4}nzt.\u{a0}</p><p>\nAb 5. August 2021 k\u{f6}nnen dritte Impfungen in den Daten enthalten sein. Initial sind ausschliesslich immundefiziente Personen oder Personen mit Stammzellentransplantation zu einer dritten Impfung berechtigt.</p><p>Die Meldepflicht der COVID-Impfungen via VMDL Plattform des Bundes wurde per 1. Juli 2023 aufgehoben. Nach diesem Datum wurden Impfungen deshalb nicht mehr systematisch erfasst. Der vorliegende Datensatz zeigt deshalb Impfungen nur bis 1. Juli 2023.<br></p><p> \n</p>"]
pub mod coronavirus_covid_19_erweiterte_daten_zu_impfungen_nach_altersgruppe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Impfdatum
        ///
        /// Datum der Impfung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub vacc_day: Option<Date>,
        /// Altersgruppe
        ///
        /// Altersgruppe in Jahren. Impfberechtigte Bevölkerung: Personen ab 16 Jahre.
        pub age_group: Option<String>,
        /// Impftyp
        ///
        /// 1: Erste Impfung; 2: Zweite Impfung einer Person; -1: Anzahl ausschliesslich mit erster Dosis geimpfter Personen
        pub vacc_count: Option<i64>,
        /// Impftyp Beschreibung
        ///
        /// Beschreibung des Impftyps in Klartext
        pub vacc_count_description: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Impfungen pro Tag, Altersgruppe und Impftyp
        pub count: Option<i64>,
        /// Anzahl Kumuliert
        ///
        /// Kumulierte Anzahl Impfungen pro Altersgruppe und Impftyp seit Beginn der Impfkampagne
        pub count_cum: Option<i64>,
        /// Bevölkerungzahl der Altersgruppe
        ///
        /// Anzahl Personen wohnhaft in BS der angegebenen Altersgruppe per Ende 2020
        pub total_pop: Option<i64>,
        /// Anteil der Geimpften
        ///
        /// Quotient der kumulierten Anzahl Impfungen durch die Anzahl EinwohnerInnen der angegebenen Altersgruppe in %
        pub count_cum_percentage_of_total_pop: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        VaccDay,
        AgeGroup,
        VaccCount,
        VaccCountDescription,
        Count,
        CountCum,
        TotalPop,
        CountCumPercentageOfTotalPop,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::VaccDay => "vacc_day",
                Field::AgeGroup => "age_group",
                Field::VaccCount => "vacc_count",
                Field::VaccCountDescription => "vacc_count_description",
                Field::Count => "count",
                Field::CountCum => "count_cum",
                Field::TotalPop => "total_pop",
                Field::CountCumPercentageOfTotalPop => "count_cum_percentage_of_total_pop",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100137/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Massentests an Schulen der Primar- und Sekundarstufe I"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die auf SARS-CoV-2 getesteten Klassen-Pools aus baselst\u{e4}dtischen Schulen der Primarstufe und der Sekundarstufe I. Es wird jeweils die Anzahl getesteter Pools sowie die Test-Positivit\u{e4}tsrate pro Woche angegeben. Weitere Informationen zum Coronavirus im Kanton Basel-Stadt:\u{a0}<a href=\"https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co\" target=\"_blank\">https://www.bs.ch/gd/md/gesundheitsschutz/uebertragbarekrankheiten/grippe-corona-und-co</a></p><p>Dieser Datensatz wird seit Ende Februar 2022 nicht mehr aktualisiert. Seit Mitte M\u{e4}rz 2022 werden die Daten zu Tests in Basler Schulen in einem neuen Datensatz ver\u{f6}ffentlich:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100183\" target=\"_blank\">https://data.bs.ch/explore/dataset/100183</a></p>"]
pub mod coronavirus_covid_19_massentests_an_schulen_der_primar_und_sekundarstufe_i {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Woche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub firstdayofweek: Option<Date>,
        /// Kalenderwoche
        ///
        /// Nr. der Woche im Jahr
        pub weekofyear: Option<i64>,
        /// Resultat
        ///
        /// Zeigt an, ob ein Pool positiv oder negativ auf SARS-CoV-2 getestet wurde
        pub result: Option<String>,
        /// Klassen pro Woche pos./neg.
        ///
        /// Anzahl positiv resp. negativ getesteter Klassen-Pools in einer Woche
        pub count: Option<i64>,
        /// Klassen pro Woche total
        ///
        /// Anzahl in einer Woche getesteter Klassen-Pools total
        pub counttotal: Option<i64>,
        /// Klassen-Positivitätsrate
        ///
        /// Zeigt den Prozentsatz der positiv auf SARS-CoV-2 getesteten Klassen-Pools
        pub positivityratepercent: Option<f64>,
        /// Getestete SchülerInnen
        ///
        /// Anzahl in den Klassen-Pools einer Woche getesteter Schülerinnen und Schüler
        pub countsamples: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Firstdayofweek,
        Weekofyear,
        Result,
        Count,
        Counttotal,
        Positivityratepercent,
        Countsamples,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Firstdayofweek => "firstdayofweek",
                Field::Weekofyear => "weekofyear",
                Field::Result => "result",
                Field::Count => "count",
                Field::Counttotal => "counttotal",
                Field::Positivityratepercent => "positivityratepercent",
                Field::Countsamples => "countsamples",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100145/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gefahrenstufen f\u{fc}r Hochwasser"]
#[doc = ""]
#[doc = "<p style=\'margin-bottom: 11px; font-size: 1.1em; line-height: 1.5; color: rgb(69, 69, 69); font-family: \"Frutiger Neue Regular\", Arial, sans-serif;\'><span style=\'font-family: \"Frutiger Neue Bold\", Arial, sans-serif; font-size: 15.4px;\'>Entsprechend den Bestimmungen der Alarmierungsverordnung verwendet das BAFU f\u{fc}r die Warnung vor Hochwasser eine f\u{fc}nfstufige Gefahrenskala. Die Gefahrenstufen geben Auskunft \u{fc}ber die Intensit\u{e4}t des Ereignisses, die m\u{f6}glichen Auswirkungen und Verhaltensempfehlungen.</span><br/></p><p style=\'margin-bottom: 11px; font-size: 1.1em; line-height: 1.5; color: rgb(69, 69, 69); font-family: \"Frutiger Neue Regular\", Arial, sans-serif;\'>Die Schwellenwerte, die die Gefahrenstufen abgrenzen, werden ausgehend vom vorhandenen Wissen \u{fc}ber das Verhalten des jeweiligen Fliessgew\u{e4}ssers festgelegt (Pegel, ab dem das Gew\u{e4}sser \u{fc}ber die Ufer tritt, ab dem erste Sch\u{e4}den eintreten usw.). Diese Schwellenwerte entsprechen in etwa der J\u{e4}hrlichkeit von Hochwasserereignissen, also einer Wiederkehrperiode von durchschnittlich 2, 10, 30 oder 100 Jahren.</p><ul style=\'line-height: 1.5; margin: 1.5em 0px 0px; padding: 0px 0px 0px 0.4em; list-style-type: square; color: rgb(69, 69, 69); font-family: \"Frutiger Neue Regular\", Arial, sans-serif;\'><li style=\"font-size: 1.1em; line-height: 1.5; margin-left: 0.8em;\">Die\u{a0}<span style=\'font-family: \"Frutiger Neue Bold\", Arial, sans-serif;\'>Gefahrenstufe 1 </span>entspricht ungef\u{e4}hr einer Abflussmenge, die unter dem Wert liegt, der im Durchschnitt einmal in 2 Jahren erreicht wird.</li><li style=\"font-size: 1.1em; line-height: 1.5; margin-left: 0.8em;\">Die\u{a0}<span style=\'font-family: \"Frutiger Neue Bold\", Arial, sans-serif;\'>Gefahrenstufe 2 </span>entspricht ungef\u{e4}hr einer Abflussmenge, die durchschnittlich einmal innerhalb von 2 bis 10 Jahren auftritt.</li><li style=\"font-size: 1.1em; line-height: 1.5; margin-left: 0.8em;\">Die\u{a0}<span style=\'font-family: \"Frutiger Neue Bold\", Arial, sans-serif;\'>Gefahrenstufe 3 </span>entspricht ungef\u{e4}hr einer Abflussmenge, die im Durchschnitt einmal innerhalb von 10 bis 30 Jahren auftritt.</li><li style=\"font-size: 1.1em; line-height: 1.5; margin-left: 0.8em;\">Die\u{a0}<span style=\'font-family: \"Frutiger Neue Bold\", Arial, sans-serif;\'>Gefahrenstufe 4 </span>entspricht ungef\u{e4}hr einer Abflussmenge, die im Durchschnitt einmal innerhalb von 30 bis 100 Jahren auftritt.</li><li style=\"font-size: 1.1em; line-height: 1.5; margin-left: 0.8em;\">Die\u{a0}<span style=\'font-family: \"Frutiger Neue Bold\", Arial, sans-serif;\'>Gefahrenstufe 5 </span>entspricht ungef\u{e4}hr einer Abflussmenge, die im Durchschnitt h\u{f6}chstens einmal in 100 Jahren auftritt.</li></ul><p style=\"font-size: 1.1em; line-height: 1.5; margin-left: 0.8em;\"><br/></p><p style=\"line-height: 1.5; margin-left: 0.8em;\"><span style=\"font-size: 15.4px;\">F\u{fc}r weitere Informationen siehe\u{a0}</span><a href=\"https://www.hydrodaten.admin.ch/de/die-5-gefahrenstufen-fur-hochwasser.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/die-5-gefahrenstufen-fur-hochwasser.html</a><span style=\"font-size: 15.4px;\">\u{a0}</span><br/></p>"]
pub mod gefahrenstufen_fuer_hochwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id
        pub station_id: Option<String>,
        /// Station
        ///
        ///
        pub station_name: Option<String>,
        /// Gefahrenstufe 1
        ///
        /// Gefahrenstufe 1 (m3/s)
        pub gefahrenstufe_1: Option<String>,
        /// Gefahrenstufe 2
        ///
        /// Gefahrenstufe 2 (m3/s)
        pub gefahrenstufe_2: Option<String>,
        /// Gefahrenstufe 3
        ///
        /// Gefahrenstufe 3 (m3/s)
        pub gefahrenstufe_3: Option<String>,
        /// Gefahrenstufe 4
        ///
        /// Gefahrenstufe 4 (m3/s)
        pub gefahrenstufe_4: Option<String>,
        /// Gefahrenstufe 5
        ///
        /// Gefahrenstufe 5 (m3/s)
        pub gefahrenstufe_5: Option<String>,
        /// Grenze 1
        ///
        /// Obergrenze der Gefahrenstufe 1
        pub wl1: Option<i64>,
        /// Grenze 2
        ///
        /// Obergrenze der Gefahrenstufe 2
        pub wl2: Option<i64>,
        /// Grenze 3
        ///
        /// Obergrenze der Gefahrenstufe 3
        pub wl3: Option<i64>,
        /// Grenze 4
        ///
        /// Obergrenze der Gefahrenstufe 4
        pub wl4: Option<i64>,
        /// Link
        pub link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        StationId,
        StationName,
        Gefahrenstufe1,
        Gefahrenstufe2,
        Gefahrenstufe3,
        Gefahrenstufe4,
        Gefahrenstufe5,
        Wl1,
        Wl2,
        Wl3,
        Wl4,
        Link,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StationId => "station_id",
                Field::StationName => "station_name",
                Field::Gefahrenstufe1 => "gefahrenstufe_1",
                Field::Gefahrenstufe2 => "gefahrenstufe_2",
                Field::Gefahrenstufe3 => "gefahrenstufe_3",
                Field::Gefahrenstufe4 => "gefahrenstufe_4",
                Field::Gefahrenstufe5 => "gefahrenstufe_5",
                Field::Wl1 => "wl1",
                Field::Wl2 => "wl2",
                Field::Wl3 => "wl3",
                Field::Wl4 => "wl4",
                Field::Link => "link",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100244/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der B\u{fc}rgergemeinderatswahlen 2023 auf Listenebene"]
#[doc = ""]
#[doc = "<p>Der vorliegende Datensatz beinhaltet Resultate der B\u{fc}rgergemeinderatswahlen Basel 2023 auf Listenebene. Weitere Informationen zu den Wahlen sind hier zu finden:\u{a0}<a href=\"https://bgbasel.ch/de/politische-organe/buergergemeinderat/wahlen2023.html\" target=\"_blank\">https://bgbasel.ch/de/politische-organe/buergergemeinderat/wahlen2023.html</a></p>"]
pub mod resultate_der_buergergemeinderatswahlen_2023_auf_listenebene {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze Wahlkreis
        ///
        /// Anzahl Sitze, die für einen Wahlkreis zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<i64>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<i64>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub wahlkreisbezeichnung: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Unveränderte Wahlzettel
        ///
        /// Anzahl unveränderter Wahlzettel
        pub unveranderte_wahlzettel: Option<i64>,
        /// Veränderte Wahlzettel mit Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel mit Listenbezeichnung (leere Linien zählen als Parteistimmen)
        pub veranderte_wahlzettel_mit_bezeichnung: Option<i64>,
        /// Veränderte Wahlzettel ohne Bezeichnung
        ///
        /// Anzahl veränderter Wahlzettel ohne Listenbezeichnung (leere Linien werden nicht gezählt)
        pub veranderte_wahlzettel_ohne_bezeichnung: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Partei-ID
        ///
        /// ID der Partei
        pub partei_id: Option<i64>,
        /// Parteikurzbezeichnung
        pub parteikurzbezeichnung: Option<String>,
        /// Parteibezeichnung
        ///
        /// Name der Partei
        pub parteibezeichnung: Option<String>,
        /// Anzahl Sitze Liste
        ///
        /// Anzahl Sitze einer Liste in einem Wahlkreis
        pub anzahl_sitze_liste: Option<i64>,
        /// Unveränderte Wahlzettel Liste
        ///
        /// Anzahl unveränderte Wahlzettel einer Liste in einem Wahlkreis
        pub unveranderte_wahlzettel_liste: Option<i64>,
        /// Veränderte Wahlzettel Liste
        ///
        /// Anzahl veränderte Wahlzettel einer Liste in einem Wahlkreis
        pub veranderte_wahlzettel_liste: Option<i64>,
        /// Kandidatenstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Stimmen aller Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub kandidatenstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen unveränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus unveränderten Wahlzetteln
        pub zusatzstimmen_unveranderte_wahlzettel: Option<i64>,
        /// Kandidatenstimmen veränderte Wahlzettel
        ///
        /// Anzahl Stimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub kandidatenstimmen_veranderte_wahlzettel: Option<i64>,
        /// Zusatzstimmen veränderte Wahlzettel
        ///
        /// Anzahl Zusatzstimmen für alle Kandidatinnen und Kandidaten einer Liste aus veränderten Wahlzetteln
        pub zusatzstimmen_veranderte_wahlzettel: Option<String>,
        /// Ungestempelte Wahlzettel
        ///
        /// Anzahl ungestempelter Wahlzettel
        pub ungestempelte_wahlzettel: Option<i64>,
        /// Listen-Nr
        pub listen_nr: Option<String>,
        /// Kandidatenstimmen
        ///
        /// Anzahl Stimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub kandidatenstimmen: Option<i64>,
        /// Zusatzstimmen
        ///
        /// Anzahl Zusatzstimmen total für alle Kandidatinnen und Kandidaten einer Liste
        pub zusatzstimmen: Option<String>,
        /// Parteistimmen
        ///
        /// Anzahl Stimmen total für einer Liste
        pub parteistimmen: Option<i64>,
        /// Anteil an Summe in %
        ///
        /// Prozentsatz des Anteils an der Summe der Stimmen für eine Liste
        pub anteil_an_summe_in: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        Wahlkreisbezeichnung,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        UnveranderteWahlzettel,
        VeranderteWahlzettelMitBezeichnung,
        VeranderteWahlzettelOhneBezeichnung,
        LeereStimmen,
        ParteiId,
        Parteikurzbezeichnung,
        Parteibezeichnung,
        AnzahlSitzeListe,
        UnveranderteWahlzettelListe,
        VeranderteWahlzettelListe,
        KandidatenstimmenUnveranderteWahlzettel,
        ZusatzstimmenUnveranderteWahlzettel,
        KandidatenstimmenVeranderteWahlzettel,
        ZusatzstimmenVeranderteWahlzettel,
        UngestempelteWahlzettel,
        ListenNr,
        Kandidatenstimmen,
        Zusatzstimmen,
        Parteistimmen,
        AnteilAnSummeIn,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::Wahlkreisbezeichnung => "wahlkreisbezeichnung",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::UnveranderteWahlzettel => "unveranderte_wahlzettel",
                Field::VeranderteWahlzettelMitBezeichnung => {
                    "veranderte_wahlzettel_mit_bezeichnung"
                }
                Field::VeranderteWahlzettelOhneBezeichnung => {
                    "veranderte_wahlzettel_ohne_bezeichnung"
                }
                Field::LeereStimmen => "leere_stimmen",
                Field::ParteiId => "partei_id",
                Field::Parteikurzbezeichnung => "parteikurzbezeichnung",
                Field::Parteibezeichnung => "parteibezeichnung",
                Field::AnzahlSitzeListe => "anzahl_sitze_liste",
                Field::UnveranderteWahlzettelListe => "unveranderte_wahlzettel_liste",
                Field::VeranderteWahlzettelListe => "veranderte_wahlzettel_liste",
                Field::KandidatenstimmenUnveranderteWahlzettel => {
                    "kandidatenstimmen_unveranderte_wahlzettel"
                }
                Field::ZusatzstimmenUnveranderteWahlzettel => {
                    "zusatzstimmen_unveranderte_wahlzettel"
                }
                Field::KandidatenstimmenVeranderteWahlzettel => {
                    "kandidatenstimmen_veranderte_wahlzettel"
                }
                Field::ZusatzstimmenVeranderteWahlzettel => "zusatzstimmen_veranderte_wahlzettel",
                Field::UngestempelteWahlzettel => "ungestempelte_wahlzettel",
                Field::ListenNr => "listen_nr",
                Field::Kandidatenstimmen => "kandidatenstimmen",
                Field::Zusatzstimmen => "zusatzstimmen",
                Field::Parteistimmen => "parteistimmen",
                Field::AnteilAnSummeIn => "anteil_an_summe_in",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100301/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Impfungen nach Altersgruppe"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die SARS-CoV-2-Impfungen, welche an Personen mit Wohnsitz im Kanton Basel-Stadt verabreicht wurden nach Altersklasse.\u{a0}</p><p>Anmerkung: Die geimpften Personen wohnen im Kanton Basel-Stadt, m\u{fc}ssen aber nicht zwingend auch im Kanton Basel-Stadt geimpft worden sein. Aus diesem Grund unterscheiden sich die hier publizierten Zahlen auch von jenen im <a href=\"https://data.bs.ch/explore/dataset/100111\" target=\"_blank\">Datensatz mit den im Kanton Basel-Stadt verabreichten Impfungen</a>.\u{a0}</p><p>Ab 2. Juli 2021 werden auch geimpfte Personen in der Altersklasse von 12 bis 15 Jahren gezeigt. 12- bis 15-J\u{e4}hrige konnten sich ab 28. Juni 2021 impfen lassen.</p><p>\nAb 5. August 2021 k\u{f6}nnen dritte Impfungen in den Daten enthalten sein. Initial sind ausschliesslich immundefiziente Personen oder Personen mit Stammzellentransplantation zu einer dritten Impfung berechtigt.\u{a0}</p><p>Die Meldepflicht der COVID-Impfungen via VMDL Plattform des Bundes wurde per 1. Juli 2023 aufgehoben. Nach diesem Datum wurden Impfungen deshalb nicht mehr systematisch erfasst. Der vorliegende Datensatz zeigt deshalb Impfungen nur bis 1. Juli 2023.<br></p><p> </p>"]
pub mod coronavirus_covid_19_impfungen_nach_altersgruppe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Impfdatum
        ///
        /// Datum der Impfung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub vacc_day: Option<Date>,
        /// Altersgruppe
        pub age_group: Option<String>,
        /// Impftyp
        ///
        /// 1: Erste Impfung; 2: Zweite Impfung einer Person
        pub vacc_count: Option<i64>,
        /// Anzahl
        ///
        /// Anzahl Impfungen pro Tag, Altersgruppe und Impftyp
        pub count: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        VaccDay,
        AgeGroup,
        VaccCount,
        Count,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::VaccDay => "vacc_day",
                Field::AgeGroup => "age_group",
                Field::VaccCount => "vacc_count",
                Field::Count => "count",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100135/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Mitgliedschaften in Gremien"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Mitgliedschaften in Gremien der Ratsmitglieder des Grossen Rates des Kantons Basel-Stadt.</p><p style=\"font-family: sans-serif;\">Funktionen in Gremien werden als separate Mitgliedschaft eingetragen, damit gelesen werden kann in welchem Zeitraum eine Ratsmitglied einer besonderen Funktion nachging.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_mitgliedschaften_in_gremien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kurzname Gremium
        ///
        /// Kurzname des zugehörigen Gremiums
        pub kurzname_gre: Option<String>,
        /// Name Gremium
        ///
        /// Name des zugehörigen Gremiums
        pub name_gre: Option<String>,
        /// Gremientyp
        ///
        /// Typ des Gremiums (Kommission, Fraktion, Parlament)
        pub gremientyp: Option<String>,
        /// ID Gremium
        ///
        /// Individuelle Identifikationsnummer des Gremiums innerhalb der Datenbank des Grossen Rates.
        pub uni_nr_gre: Option<String>,
        /// Gremien data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Gremien". Gefiltert nach aktuellem Gremium.
        pub url_gremium: Option<String>,
        /// Beginn Gremiumsmitgliedschaft
        ///
        /// Startdatum der Mitgliedschaft im Gremium
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub beginn_mit: Option<Date>,
        /// Ende Gremiumsmitgliedschaft
        ///
        /// Enddatum der Mitgliedschaft im Gremium
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub ende_mit: Option<Date>,
        /// Funktion
        ///
        /// Funktion des Gremiumsmitglieds
        pub funktion_adr: Option<String>,
        /// Anrede
        ///
        /// Anrede des Gremiumsmitglieds nach amtlichem Geschlecht
        pub anrede: Option<String>,
        /// Name Ratsmitglied
        ///
        /// Nachname des Gremiumsmitglieds
        pub name_adr: Option<String>,
        /// Vorname Ratsmitglied
        ///
        /// Vorname des Gremiumsmitglieds
        pub vorname_adr: Option<String>,
        /// Name, Vorname
        ///
        /// Name und Vorname des Gremiumsmitglieds
        pub name_vorname: Option<String>,
        /// Partei abgekürzt
        ///
        /// Abkürzung der Parteizugehörigkeit des Gremiumsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei_kname: Option<String>,
        /// Ratsmitglied grosserrat.bs.ch
        ///
        /// Link zum Gremiumsmitglied auf der Webseite des Grossen Rates
        pub url_adr: Option<String>,
        /// ID Ratsmitglied
        ///
        /// Individuelle Identifikationsnummer des Gremiumsmitglieds innerhalb der Datenbank des Grossen Rates.
        pub uni_nr_adr: Option<String>,
        /// Grossratsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Ratsmitgliedschaften". Gefiltert nach aktuellem Gremiumsmitglied.
        pub url_ratsmitgliedschaften: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        KurznameGre,
        NameGre,
        Gremientyp,
        UniNrGre,
        UrlGremium,
        BeginnMit,
        EndeMit,
        FunktionAdr,
        Anrede,
        NameAdr,
        VornameAdr,
        NameVorname,
        ParteiKname,
        UrlAdr,
        UniNrAdr,
        UrlRatsmitgliedschaften,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::KurznameGre => "kurzname_gre",
                Field::NameGre => "name_gre",
                Field::Gremientyp => "gremientyp",
                Field::UniNrGre => "uni_nr_gre",
                Field::UrlGremium => "url_gremium",
                Field::BeginnMit => "beginn_mit",
                Field::EndeMit => "ende_mit",
                Field::FunktionAdr => "funktion_adr",
                Field::Anrede => "anrede",
                Field::NameAdr => "name_adr",
                Field::VornameAdr => "vorname_adr",
                Field::NameVorname => "name_vorname",
                Field::ParteiKname => "partei_kname",
                Field::UrlAdr => "url_adr",
                Field::UniNrAdr => "uni_nr_adr",
                Field::UrlRatsmitgliedschaften => "url_ratsmitgliedschaften",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100308/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Entwicklungszusammenarbeit: Unterst\u{fc}tzte Projekte"]
#[doc = ""]
#[doc = "<p>Basel engagiert sich f\u{fc}r die Verbesserung der Lebensumst\u{e4}nde der \u{c4}rmsten dieser Welt. F\u{fc}r Projekte der ausl\u{e4}ndischen Entwicklungszusammenarbeit stellt der Kanton j\u{e4}hrlich 2 Mio. Franken bereit. Mit den finanziellen Beitr\u{e4}gen sollen die Entwicklungschancen der Bev\u{f6}lkerung in den \u{e4}rmsten L\u{e4}ndern der Welt oder in speziell benachteiligten Regionen nachhaltig verbessert werden. Die Entwicklungszusammenarbeit des Kantons Basel-Stadt engagiert sich ausschliesslich im Rahmen von Projekten im Ausland, wobei thematische Schwerpunkte im Fokus stehen (medizinische Versorgung, Landwirtschaft, Bildung, Gewerbef\u{f6}rderung etc.).</p>\n<p>Die <a href=\"https://www.marketing.bs.ch/Aussenbeziehungen/eza/kommission.html\" target=\"_blank\">Kommission f\u{fc}r Entwicklungszusammenarbeit</a> (<a href=\"https://www.marketing.bs.ch/Aussenbeziehungen/eza/kommission.html\" target=\"_blank\">https://www.marketing.bs.ch/Aussenbeziehungen/eza/kommission.html</a>) trifft sich zwei Mal j\u{e4}hrlich zur Auswahl von Projekten. Bei der Beurteilung von Projektantr\u{e4}gen orientiert sich die Kommission an einem Kriterienkatalog (Qualit\u{e4}t, Relevanz, Effektivit\u{e4}t, Wirkung, Nachhaltigkeit, Transparenz der Finanzierung, ethische Aspekte). Es wird darauf geachtet, dass bei der Vergabe der Mittel ein gewisser Turnus angewendet wird und Hilfswerke, welche in der Region domiziliert sind, besonders ber\u{fc}cksichtigt werden.</p>\n<p>Die Regierungsratsbeschl\u{fc}sse zur Auswahl der zu unterst\u{fc}tzenden Projekte werden jeweils ver\u{f6}ffentlicht unter: <a href=\"https://www.regierungsrat.bs.ch/geschaefte/regierungsratsbeschluesse.html\" target=\"_blank\">https://www.regierungsrat.bs.ch/geschaefte/regierungsratsbeschluesse.html</a> (Stichwort: Entwicklungszusammenarbeit)</p>"]
pub mod entwicklungszusammenarbeit_unterstuetzte_projekte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Das Jahr, in dem das Projekt finanziell unterstützt wird.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr: Option<Date>,
        /// Projekt-Titel
        ///
        /// Der Name des geförderten Entwicklungsprojekts.
        pub projekt_titel: Option<String>,
        /// Staat
        ///
        /// Das Land, in dem das Projekt durchgeführt wird.
        pub staat: Option<String>,
        /// Organisation
        ///
        /// Die Hilfsorganisation oder Institution, die das Projekt durchführt und um finanzielle Unterstützung bittet.
        pub organisation: Option<String>,
        /// Betrag-Entscheid
        ///
        /// Der finanzielle Beitrag, der von der Kommission für das Projekt genehmigt wurde.
        pub betrag_entscheid: Option<String>,
        /// Projektbeschrieb
        ///
        /// Eine kurze Zusammenfassung der Ziele und Aktivitäten des Projekts.
        pub projektbeschrieb: Option<String>,
        /// Region
        ///
        /// Die spezifische Region innerhalb des Staates, in der das Projekt stattfindet.
        pub region: Option<String>,
        /// Sachgebiet
        ///
        /// Das Hauptthema oder der Schwerpunkt des Projekts (z.B. medizinische Versorgung, Bildung).
        pub sachgebiet: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        ProjektTitel,
        Staat,
        Organisation,
        BetragEntscheid,
        Projektbeschrieb,
        Region,
        Sachgebiet,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::ProjektTitel => "projekt_titel",
                Field::Staat => "staat",
                Field::Organisation => "organisation",
                Field::BetragEntscheid => "betrag_entscheid",
                Field::Projektbeschrieb => "projektbeschrieb",
                Field::Region => "region",
                Field::Sachgebiet => "sachgebiet",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100380/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Resultate der Wahl eines zus\u{e4}tzl. Strafgerichtspr\u{e4}sidiums 18. August 2024"]
#[doc = ""]
#[doc = "<p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate der Wahl\u{a0}eines zus\u{e4}tzlichen Strafgerichtspr\u{e4}sidiums vom 18. August 2024.</p><p style=\"font-family: sans-serif;\"></p><p class=\"MsoNormal\" style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im <a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">www.kantonsblatt.ch</a>) des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod resultate_der_wahl_eines_zusaetzl_strafgerichtspraesidiums_18_august_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahlbezeichnung
        ///
        /// Titel der Wahl
        pub wahlbezeichnung: Option<String>,
        /// Amtsdauer
        ///
        /// Anzahl Jahre, auf welche die Mitglieder gewählt werden
        pub amtsdauer: Option<String>,
        /// Wahltermin
        ///
        /// Datum der Wahl
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wahltermin: Option<Date>,
        /// Anzahl Sitze
        ///
        /// Anzahl Sitze, die zur Verfügung stehen
        pub anzahl_sitze: Option<i64>,
        /// Wahlkreis-Nr.
        ///
        /// Nummer des Wahlkreises
        pub wahlkreis_nr: Option<String>,
        /// Wahlkreis-Code
        ///
        /// Code des Wahlkreises
        pub wahlkreis_code: Option<String>,
        /// Wahlkreisbezeichnung
        ///
        /// Name des Wahlkreises
        pub bezeichnung_wahlkreis: Option<String>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Männer
        pub stimmberechtigte_manner: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl in einem Wahlkreis stimmberechtigter Frauen
        pub stimmberechtigte_frauen: Option<i64>,
        /// Stimmberechtigte
        ///
        /// Anzahl Stimmberechtigter total in einem Wahlkreis
        pub stimmberechtigte: Option<i64>,
        /// Stimmberechtigte Auslandschweizer
        ///
        /// Anzahl stimmberechtigter Auslandschweizer
        pub stimmberechtigte_auslandschweizer: Option<i64>,
        /// Wahlzettel
        ///
        /// Anzahl Wahlzettel
        pub wahlzettel: Option<i64>,
        /// Briefliche Stimmabgaben
        ///
        /// Anzahl brieflich eingelegter Wahlzettel
        pub briefliche_stimmabgaben: Option<i64>,
        /// Ungültige Wahlzettel
        ///
        /// Anzahl ungültiger Wahlzettel
        pub ungultige_wahlzettel: Option<i64>,
        /// Leere Wahlzettel
        ///
        /// Anzahl leer eingelegter Wahlzettel
        pub leere_wahlzettel: Option<i64>,
        /// Leere Stimmen
        ///
        /// Anzahl leerer Stimmen
        pub leere_stimmen: Option<i64>,
        /// Ungültige Stimmen
        ///
        /// Anzahl ungültiger Stimmen
        pub ungultige_stimmen: Option<i64>,
        /// Vereinzelte Stimmen
        ///
        /// Anzahl vereinzelter Stimmen
        pub vereinzelte_stimmen: Option<i64>,
        /// Kandidaten-Nr
        pub kandidaten_nr: Option<String>,
        /// Personen-ID
        ///
        /// Laufnummer einer Person
        pub personen_id: Option<String>,
        /// Bisher
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat in der abgelaufenen Legislatur im Parlament vertreten war oder nicht
        pub bisher: Option<String>,
        /// Gewählt
        ///
        /// Angabe, ob eine Kandidatin oder ein Kandidat gewählt ist
        pub gewahlt: Option<String>,
        /// Ganzer Name
        ///
        /// Nachname und Vorname, mit Komma getrennt
        pub ganzer_name: Option<String>,
        /// Name
        ///
        /// Nachname
        pub name: Option<String>,
        /// Vorname
        pub vorname: Option<String>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Jahrgang
        pub jahrgang: Option<String>,
        /// Anrede
        pub anrede: Option<String>,
        /// Beruf
        ///
        /// Beruf gemäss Wahlzettel
        pub beruf: Option<String>,
        /// Heimatort
        pub heimatort: Option<String>,
        /// Stimmen
        ///
        /// Anzahl Stimmen total für eine Kandidatin oder einen Kandidaten.
        pub stimmen: Option<i64>,
        /// Gültige Wahlzettel
        ///
        /// Anzahl gültige Wahlzettel
        pub total_gultige_wahlzettel: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anteil der eingelegten Wahlzettel am Total der Stimmberechtigten
        pub stimmbeteiligung: Option<String>,
        /// Anteil brieflich Wählende
        ///
        /// Anteil der brieflich eingelegten Wahlzettel am Total der eingelegten Wahlzettel
        pub anteil_brieflich_wahlende: Option<String>,
        /// Absolutes Mehr
        ///
        /// berechnet nach der Formel: (Ganzzahl((gültige Wahlzettel + leere Wahlzettel)/2 + 1). Für zweiten Wahlgang nicht vorhanden.
        pub absolutes_mehr: Option<i64>,
        /// Vereinzelte
        pub vereinzelte: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahlbezeichnung,
        Amtsdauer,
        Wahltermin,
        AnzahlSitze,
        WahlkreisNr,
        WahlkreisCode,
        BezeichnungWahlkreis,
        StimmberechtigteManner,
        StimmberechtigteFrauen,
        Stimmberechtigte,
        StimmberechtigteAuslandschweizer,
        Wahlzettel,
        BrieflicheStimmabgaben,
        UngultigeWahlzettel,
        LeereWahlzettel,
        LeereStimmen,
        UngultigeStimmen,
        VereinzelteStimmen,
        KandidatenNr,
        PersonenId,
        Bisher,
        Gewahlt,
        GanzerName,
        Name,
        Vorname,
        Geschlecht,
        Jahrgang,
        Anrede,
        Beruf,
        Heimatort,
        Stimmen,
        TotalGultigeWahlzettel,
        Stimmbeteiligung,
        AnteilBrieflichWahlende,
        AbsolutesMehr,
        Vereinzelte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahlbezeichnung => "wahlbezeichnung",
                Field::Amtsdauer => "amtsdauer",
                Field::Wahltermin => "wahltermin",
                Field::AnzahlSitze => "anzahl_sitze",
                Field::WahlkreisNr => "wahlkreis_nr",
                Field::WahlkreisCode => "wahlkreis_code",
                Field::BezeichnungWahlkreis => "bezeichnung_wahlkreis",
                Field::StimmberechtigteManner => "stimmberechtigte_manner",
                Field::StimmberechtigteFrauen => "stimmberechtigte_frauen",
                Field::Stimmberechtigte => "stimmberechtigte",
                Field::StimmberechtigteAuslandschweizer => "stimmberechtigte_auslandschweizer",
                Field::Wahlzettel => "wahlzettel",
                Field::BrieflicheStimmabgaben => "briefliche_stimmabgaben",
                Field::UngultigeWahlzettel => "ungultige_wahlzettel",
                Field::LeereWahlzettel => "leere_wahlzettel",
                Field::LeereStimmen => "leere_stimmen",
                Field::UngultigeStimmen => "ungultige_stimmen",
                Field::VereinzelteStimmen => "vereinzelte_stimmen",
                Field::KandidatenNr => "kandidaten_nr",
                Field::PersonenId => "personen_id",
                Field::Bisher => "bisher",
                Field::Gewahlt => "gewahlt",
                Field::GanzerName => "ganzer_name",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::Geschlecht => "geschlecht",
                Field::Jahrgang => "jahrgang",
                Field::Anrede => "anrede",
                Field::Beruf => "beruf",
                Field::Heimatort => "heimatort",
                Field::Stimmen => "stimmen",
                Field::TotalGultigeWahlzettel => "total_gultige_wahlzettel",
                Field::Stimmbeteiligung => "stimmbeteiligung",
                Field::AnteilBrieflichWahlende => "anteil_brieflich_wahlende",
                Field::AbsolutesMehr => "absolutes_mehr",
                Field::Vereinzelte => "vereinzelte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100381/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Positiv getestete Personen nach Alter und Geschlecht"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Personen, welche positiv auf SARS-CoV-2 getestet wurden nach Geschlecht und Altersklasse. Es werden ausschliesslich Personen mit Wohnsitz im Kanton Basel-Stadt gezeigt. Als \u{ab}Datum Testresultat\u{bb} gilt das Datum, an welchem das Testresultat vorlag.</p>\n<p>Weitere Datens\u{e4}tze zu\nCovid-19:</p>\n<p>Fallzahlen Basel-Stadt: <a href=\"https://data.bs.ch/explore/dataset/100073/table\">https://data.bs.ch/explore/dataset/100073/table</a></p>\n<p>Tests Basel-Stadt:<a href=\"https://data.bs.ch/explore/dataset/100094/table\" target=\"_blank\">https://data.bs.ch/explore/dataset/100094/table</a></p>\n<p>Todesf\u{e4}lle Basel-Stadt nach Alter und Geschlecht: <a href=\"https://data.bs.ch/explore/dataset/100076/table\" target=\"_blank\">https://data.bs.ch/explore/dataset/100076/table</a>\n</p>\n<p>Covid-19 Dashboard: <a href=\"https://data.bs.ch/pages/covid-19-dashboard\" target=\"_blank\">https://data.bs.ch/pages/covid-19-dashboard</a><a href=\"https://data.bs.ch/pages/covid-19-dashboard\"></a></p><p></p><ul style=\"box-sizing: border-box; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"></ul><p></p><p><b style=\"box-sizing: border-box; font-weight: bolder;\">\u{c4}nderungsprotokoll:</b></p><p></p><ul><li>Die Erhebung der Werte wurde per 30. Juni 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.\u{a0}Aktualisierungsintervall von \"DAILY\" auf \"NEVER\" ge\u{e4}ndert.</li></ul>"]
pub mod coronavirus_covid_19_positiv_getestete_personen_nach_alter_und_geschlecht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Testresultat
        ///
        /// Datum, an dem das Testresultat vorlag
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub test_datum: Option<Date>,
        /// Altersklasse
        ///
        /// 10-Jahresklassen, wobei die letzte Altersklasse gegen oben offen ist
        pub pers_alter: Option<String>,
        /// Geschlecht
        ///
        /// F = weiblich, M = männlich
        pub geschlecht: Option<String>,
        /// Anzahl Personen
        ///
        /// Anzahl Personen in der jeweilige Subgruppe
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TestDatum,
        PersAlter,
        Geschlecht,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TestDatum => "test_datum",
                Field::PersAlter => "pers_alter",
                Field::Geschlecht => "geschlecht",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100105/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geschwindigkeitsmonitoring: Kennzahlen pro Mess-Standort"]
#[doc = ""]
#[doc = "<p>In diesem Datensatz werden zu jeder Messung (ein Messger\u{e4}t an einem Standort) die Kennzahlen V50, V85, Anzahl Fahrzeuge und \u{dc}bertretungsquote pro Richtung angegeben. Die einzelnen Fahrten finden Sie im Datensatz Einzelmessungen (<a href=\"https://data.bs.ch/explore/dataset/100097/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100097</a>)</p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Bei den dargestellten\nDaten handelt es sich ausschliesslich um statistische Erhebungen. Diese stehen\nnicht in einem Zusammenhang mit Ordnungsbussen oder einer strafrechtlichen\nVerfolgung. Die statistischen Geschwindigkeitsmessungen dienen der\nKantonspolizei Basel-Stadt zur \u{dc}berpr\u{fc}fung der Geschwindigkeit sowie der\nVerkehrssicherheit (z.B. Sicherheit an Fussg\u{e4}ngerstreifen) an der betreffenden\n\u{d6}rtlichkeit. Die Ergebnisse dienen zur Entscheidung, an welchen \u{d6}rtlichkeiten\nHandlungsbedarf in Form von Geschwindigkeitskontrollen besteht. Jedes\nStatistikger\u{e4}t besitzt eine einzige Punktgeometrie und ist meist mit zwei\nRichtungen versehen (Richtung 1 und 2).<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Hinweis: Die\nMessungen sind nicht zwingend repr\u{e4}sentativ f\u{fc}r das ganze Jahr und m\u{fc}ssen im\nKontext des Erhebungsdatums betrachtet werden. Dar\u{fc}ber hinaus wurden gewisse\nMessungen w\u{e4}hrend einer ausserordentlichen Verkehrsf\u{fc}hrung (z.B.\nUmleitungsverkehr infolge von Baustellent\u{e4}tigkeiten etc.) erhoben.\nManipulationen an Ger\u{e4}ten k\u{f6}nnen zu fehlerhaften Messungen f\u{fc}hren.<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"font-family: sans-serif; margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; line-height: normal;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Zum Geschwindigkeitsmonitoring sind folgende Datens\u{e4}tze vorhanden:<o:p></o:p></span></p><ul><li>Einzelmessungen ab 2024:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100097\" target=\"_blank\">https://data.bs.ch/explore/dataset/100097</a></li><li>Einzelmessungen von 2021 bis 2023:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100358\" target=\"_blank\">https://data.bs.ch/explore/dataset/100358</a><br></li><li>Einzelmessungen bis 2020:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100200\" target=\"_blank\">https://data.bs.ch/explore/dataset/100200</a></li><li>Kennzahlen pro Mess-Standort (dieser Datensatz):\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100112\" target=\"_blank\">https://data.bs.ch/explore/dataset/100112</a></li></ul><p>Die Mess-Standorte werden auch auf dem Geoportal Basel-Stadt publiziert:\u{a0}<a href=\"https://map.geo.bs.ch/s/geschwindigkeit\" target=\"_blank\">https://map.geo.bs.ch/s/geschwindigkeit</a></p>"]
pub mod geschwindigkeitsmonitoring_kennzahlen_pro_mess_standort {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub id: Option<i64>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<i64>,
        /// Richtung 1
        ///
        /// Fahrtrichtung 1
        pub richtung_1: Option<String>,
        /// Fahrzeuge Richtung 1
        ///
        /// Anzahl gemessene Fahrzeuge in Richtung 1 während einer Messung
        pub fzg_1: Option<f64>,
        /// V50 Richtung 1
        ///
        /// Höchstgeschwindigkeit in Richtung 1, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50_1: Option<f64>,
        /// V85 Richtung 1
        ///
        /// Höchstgeschwindigkeit in Richtung 1, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85_1: Option<f64>,
        /// Übertretungsquote Richtung 1
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit in Richtung 1 überschritten haben
        pub ue_quote_1: Option<f64>,
        /// Richtung 2
        ///
        /// Fahrtrichtung 2
        pub richtung_2: Option<String>,
        /// Fahrzeuge Richtung 2
        ///
        /// Anzahl gemessene Fahrzeuge in Richtung 2 während einer Messung
        pub fzg_2: Option<f64>,
        /// V50 Richtung 2
        ///
        /// Höchstgeschwindigkeit in Richtung 2, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50_2: Option<f64>,
        /// V85 Richtung 2
        ///
        /// Höchstgeschwindigkeit in Richtung 1, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85_2: Option<f64>,
        /// Übertretungsquote Richtung 2
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit in Richtung 2 überschritten haben
        pub ue_quote_2: Option<f64>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Einzelmessungen
        ///
        /// Link zum Datensatz "Geschwindigkeitsmonitoring: Einzelmessungen"
        pub link_zu_einzelmessungen: Option<String>,
        /// Messbeginn Jahr
        ///
        /// Jahr des Messbeginns
        pub messbeginn_jahr: Option<String>,
        /// Einzelmessungen Datensatz ID
        ///
        /// Datensatz ID, in welchem die Einzelmessungen abgelegt sind
        pub dataset_id: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Messbeginn,
        Messende,
        Strasse,
        StrasseNr,
        Ort,
        Zone,
        Richtung1,
        Fzg1,
        V501,
        V851,
        UeQuote1,
        Richtung2,
        Fzg2,
        V502,
        V852,
        UeQuote2,
        LinkZuEinzelmessungen,
        MessbeginnJahr,
        DatasetId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Ort => "ort",
                Field::Zone => "zone",
                Field::Richtung1 => "richtung_1",
                Field::Fzg1 => "fzg_1",
                Field::V501 => "v50_1",
                Field::V851 => "v85_1",
                Field::UeQuote1 => "ue_quote_1",
                Field::Richtung2 => "richtung_2",
                Field::Fzg2 => "fzg_2",
                Field::V502 => "v50_2",
                Field::V852 => "v85_2",
                Field::UeQuote2 => "ue_quote_2",
                Field::LinkZuEinzelmessungen => "link_zu_einzelmessungen",
                Field::MessbeginnJahr => "messbeginn_jahr",
                Field::DatasetId => "dataset_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100112/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Witterung"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt f\u{fc}r die Messstation Basel-Binningen am Observatorium St. Margarethen f\u{fc}r jeden Monat die in Bezug auf Temperatur, Niederschlag und Bew\u{f6}lkung registrierten Witterungserscheinungen seit 1921.Methodischer Hinweis:Daten von 1921 bis 1940 stammen von der astronomisch-meteorologischen Anstalt im Bernoullianum."]
pub mod witterung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Monat und Jahr
        ///
        /// Monat und Jahr, in dem der Wert registriert wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Jahr
        ///
        /// Jahreszahl
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monatsname
        pub monat: Option<String>,
        /// Frosttag
        ///
        /// Anzahl Tage mit Minimaltemperatur unter 0° Celsius
        pub frosttag: Option<i64>,
        /// Eistag
        ///
        /// Anzahl Tage mit Maximaltemperatur unter 0° Celsius
        pub eistag: Option<i64>,
        /// Sommertag
        ///
        /// Anzahl Tage mit Maximaltemperatur über 25° Celsius
        pub sommertag: Option<i64>,
        /// Hitzetag
        ///
        /// Anzahl Tage mit Maximaltemperatur über 30° Celsius
        pub hitzetag: Option<i64>,
        /// Ohne Sonne
        ///
        /// Anzahl Tage mit 0 Sonnenstunden
        pub sonnenlos: Option<i64>,
        /// Regen (0,1 mm)
        ///
        /// Anzahl Tage mit mindestens 0,1 mm Niederschlag
        pub regen1: Option<i64>,
        /// Regen (0,3 mm)
        ///
        /// Anzahl Tage mit mindestens 0,3 mm Niederschlag
        pub regen2: Option<i64>,
        /// Regen (1,0 mm)
        ///
        /// Anzahl Tage mit mindestens 1,0 mm Niederschlag
        pub regen3: Option<i64>,
        /// Schneefall
        ///
        /// Anzahl Tage mit Schneefall
        pub schneefall: Option<i64>,
        /// Schneedecke
        ///
        /// Anzahl Tage mit geschlossener Schneedecke
        pub schneedecke: Option<i64>,
        /// Reif
        ///
        /// Anzahl Tage mit Reif
        pub reif: Option<i64>,
        /// Nebel
        ///
        /// Anzahl Tage mit Nebel
        pub nebel: Option<i64>,
        /// Gewitter
        ///
        /// Anzahl Tage mit Nah- oder Ferngewitter
        pub gewitter1: Option<i64>,
        /// Nahgewitter
        ///
        /// Anzahl Tage mit Nahgewitter (<15 km Entfernung)
        pub gewitter2: Option<f64>,
        /// Hagel
        ///
        /// Anzahl Tage mit Hagel
        pub hagel: Option<i64>,
        /// Heller Tag
        ///
        /// Anzahl Tage mit höchstens 20% Bewölkung
        pub hell: Option<i64>,
        /// Trüber Tag
        ///
        /// Anzahl Tage mit mindestens 80% Bewölkung
        pub trueb: Option<i64>,
        /// Wind (> 15 m/sec)
        ///
        /// Anzahl Tage mit Windgeschwindigkeiten über 15 m/sec
        pub wind1: Option<i64>,
        /// Wind (> 26 m/sec)
        ///
        /// Anzahl Tage mit Windgeschwindigkeiten über 26 m/sec
        pub wind2: Option<i64>,
        /// Heiztage
        ///
        /// Anzahl Tage, an denen die Heizgrenze von 12 °C unterschritten wird.
        pub heiztage: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Jahr,
        Monat,
        Frosttag,
        Eistag,
        Sommertag,
        Hitzetag,
        Sonnenlos,
        Regen1,
        Regen2,
        Regen3,
        Schneefall,
        Schneedecke,
        Reif,
        Nebel,
        Gewitter1,
        Gewitter2,
        Hagel,
        Hell,
        Trueb,
        Wind1,
        Wind2,
        Heiztage,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Frosttag => "frosttag",
                Field::Eistag => "eistag",
                Field::Sommertag => "sommertag",
                Field::Hitzetag => "hitzetag",
                Field::Sonnenlos => "sonnenlos",
                Field::Regen1 => "regen1",
                Field::Regen2 => "regen2",
                Field::Regen3 => "regen3",
                Field::Schneefall => "schneefall",
                Field::Schneedecke => "schneedecke",
                Field::Reif => "reif",
                Field::Nebel => "nebel",
                Field::Gewitter1 => "gewitter1",
                Field::Gewitter2 => "gewitter2",
                Field::Hagel => "hagel",
                Field::Hell => "hell",
                Field::Trueb => "trueb",
                Field::Wind1 => "wind1",
                Field::Wind2 => "wind2",
                Field::Heiztage => "heiztage",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100227/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Aufrufe der Microsites"]
#[doc = ""]
#[doc = "<p>Im Rahmen des Projekts\u{a0}\u{ab}Smarte Strasse\u{bb} wurden Sensoren an verschiedenen Standorten angebracht.\u{a0}Um\ndie Transparenz zu erh\u{f6}hen, werden im Projekt \u{ab}Smarte Strasse\u{bb} die Sensoren sowie die Daten,\ndie damit erfasst werden, vor Ort mit Piktogrammen und QR-Codes leicht verst\u{e4}ndlich sichtbar\ngemacht.<br/>Der vorliegende Datensatz zeigt die Anzahl der Seitenaufrufe der Microsites, die \u{fc}ber die QR-Codes auf der Infotafel zug\u{e4}nglich sind. Jeder Seitenaufruf \u{fc}ber den QR-Code generiert eine Datenabfrage. Mit der Anzahl an Datenabfragen kann man bestimmen, wie oft eine Seite aufgerufen worden ist.</p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul>"]
pub mod smarte_strasse_aufrufe_der_microsites {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Identifikationsnummer
        ///
        /// Willkürliche Identifikationsnummer
        pub id: Option<i64>,
        /// Zeitstempel
        ///
        /// Gibt das Datum der Datenaufzeichnung an.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub timestamp: Option<Date>,
        /// Dataset-ID
        ///
        /// Link zu den Daten, die auf der Microsite abgebildet werden.
        pub dataset_id: Option<String>,
        /// API-Suchanfrage
        ///
        /// Abfrage zum Suchen nach den Daten auf der Microsite. Wenn die Microsite aufgerufen wird, dann werden die Daten aus dem Datensatz auf der Microsite abgebildet. Es entsteht eine Datenabfrage. Die Anzahl an Datenabfragen kann man messen.
        pub api: Option<String>,
        /// Anzahl Anfragen
        ///
        /// Anzahl der Suchanfragen auf der Microsite.
        pub nhits: Option<i64>,
        /// Sensor
        pub sensor: Option<String>,
        /// Microsite
        ///
        /// Link zu der Microsite
        pub microsite: Option<String>,
        /// Geo Point des Sensors
        pub geo_point: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Timestamp,
        DatasetId,
        Api,
        Nhits,
        Sensor,
        Microsite,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Timestamp => "timestamp",
                Field::DatasetId => "dataset_id",
                Field::Api => "api",
                Field::Nhits => "nhits",
                Field::Sensor => "sensor",
                Field::Microsite => "microsite",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100306/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geschwindigkeitsmonitoring: Einzelmessungen bis 2020"]
#[doc = ""]
#[doc = "<p></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Einzelmessungen des\nGeschwindigkeitsmonitorings der Kantonspolizei Basel-Stadt bis zum Jahr 2020 (Zeitpunkt des Beginns der Messung).\u{a0}<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Bei den dargestellten\nDaten handelt es sich ausschliesslich um statistische Erhebungen. Diese stehen\nnicht in einem Zusammenhang mit Ordnungsbussen oder einer strafrechtlichen\nVerfolgung. Die statistischen Geschwindigkeitsmessungen dienen der Kantonspolizei\nBasel-Stadt zur \u{dc}berpr\u{fc}fung der Geschwindigkeit sowie der Verkehrssicherheit\n(z.B. Sicherheit an Fussg\u{e4}ngerstreifen) an der betreffenden \u{d6}rtlichkeit. Die\nErgebnisse dienen zur Entscheidung, an welchen \u{d6}rtlichkeiten Handlungsbedarf in\nForm von Geschwindigkeitskontrollen besteht. Jedes Statistikger\u{e4}t besitzt eine\neinzige Punktgeometrie und ist meist mit zwei Richtungen versehen (Richtung 1\nund 2).<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Hinweis: Die\nMessungen sind nicht zwingend repr\u{e4}sentativ f\u{fc}r das ganze Jahr und m\u{fc}ssen im\nKontext des Erhebungsdatums betrachtet werden. Dar\u{fc}ber hinaus wurden gewisse\nMessungen w\u{e4}hrend einer ausserordentlichen Verkehrsf\u{fc}hrung (z.B.\nUmleitungsverkehr infolge von Baustellent\u{e4}tigkeiten etc.) erhoben.\nManipulationen an Ger\u{e4}ten k\u{f6}nnen zu fehlerhaften Messungen f\u{fc}hren.<o:p></o:p></span></p><p>\n\n\n\n\n\n</p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Zum\nGeschwindigkeitsmonitoring sind folgende Datens\u{e4}tze vorhanden:<o:p></o:p></span></p><ul><li>Einzelmessungen ab 2024:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100097\" target=\"_blank\">https://data.bs.ch/explore/dataset/100097</a></li><li>Einzelmessungen von 2021 bis 2023:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100358\" target=\"_blank\">https://data.bs.ch/explore/dataset/100358</a><br></li><li>Einzelmessungen bis 2020 (dieser Datensatz):\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100200\" target=\"_blank\">https://data.bs.ch/explore/dataset/100200</a></li><li>Kennzahlen pro Mess-Standort:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100112\" target=\"_blank\">https://data.bs.ch/explore/dataset/100112</a>\u{a0}</li></ul>Aufgrund der grossen Datenmenge kann es vorkommen, dass der Datensatz nicht vollst\u{e4}ndig heruntergeladen werden kann. Falls dieses Problem auftritt, kann man den vollst\u{e4}ndigen Datensatz und die Einzelmessungen der Messstationen hier herunterladen:<p></p><ul><li>vollst\u{e4}ndiger Datensatz:\u{a0}<a href=\"https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/all_data/geschwindigkeitsmonitoring_data.csv\">https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/all_data/geschwindigkeitsmonitoring_data.csv</a></li><li>Einzelmessungen der Messstationen:\u{a0}<a href=\"https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/data/\">https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/data/</a></li></ul><p>Die Mess-Standorte werden auch auf dem Geoportal Basel-Stadt publiziert:\u{a0}<a \"=\"\" href=\"https://map.geo.bs.ch/s/geschwindigkeit\" target=\"_blank\">https://map.geo.bs.ch/s/geschwindigkeit</a></p>"]
pub mod geschwindigkeitsmonitoring_einzelmessungen_bis_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Timestamp
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit in km/h
        pub geschwindigkeit: Option<f64>,
        /// Zeit
        ///
        /// Uhrzeit (hh:mm:ss) einer gemessenen Fahrt
        pub zeit: Option<String>,
        /// Datum
        pub datum: Option<String>,
        /// Datum und Zeit
        ///
        /// Datum und Uhrzeit als Text formatiert
        pub datum_zeit: Option<String>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<f64>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Übertretungsquote
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit überschritten haben
        pub ue_quote: Option<f64>,
        /// Geschwindigkeit V50
        ///
        /// Höchstgeschwindigkeit, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50: Option<f64>,
        /// Geschwindigkeit V85
        ///
        /// Höchstgeschwindigkeit, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85: Option<f64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge während einer Messung
        pub fzg: Option<i64>,
        /// Fahrzeuglänge
        ///
        /// Vom Radar gemessene Fahrzeuglänge
        pub fahrzeuglange: Option<f64>,
        /// Kennzahlen pro Mess-Standort
        ///
        /// Link zum nach der aktuellen Messung gefilterten Datensatz "Kennzahlen pro Mess-Standort"
        pub link_zu_messung: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        MessungId,
        RichtungId,
        Geschwindigkeit,
        Zeit,
        Datum,
        DatumZeit,
        Messbeginn,
        Messende,
        Zone,
        Ort,
        Richtung,
        UeQuote,
        V50,
        V85,
        Strasse,
        StrasseNr,
        Fzg,
        Fahrzeuglange,
        LinkZuMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::MessungId => "messung_id",
                Field::RichtungId => "richtung_id",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Zeit => "zeit",
                Field::Datum => "datum",
                Field::DatumZeit => "datum_zeit",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Zone => "zone",
                Field::Ort => "ort",
                Field::Richtung => "richtung",
                Field::UeQuote => "ue_quote",
                Field::V50 => "v50",
                Field::V85 => "v85",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Fzg => "fzg",
                Field::Fahrzeuglange => "fahrzeuglange",
                Field::LinkZuMessung => "link_zu_messung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100200/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Fahrgastzahlen BVB"]
#[doc = ""]
#[doc = "<div>Die Daten umfassen die w\u{f6}chentlichen Fahrgastzahlen der Basler Verkehrsbetriebe (BVB) von 2020 bis 2023. Ab 2024 werden monatliche Werte erfasst. Sie beruhen auf Messungen mit dem automatischen Fahrgastz\u{e4}hlsystem und anschliessender Hochrechnung, und zwar f\u{fc}r das gesamte Liniennetz der BVB. Tramlinien: 1, 2, 3, 6, 8, 14, 15, 16, 21; Buslinien: 30, 31, 32, 33, 34, 35, 36, 38, 42, 45, 46, 48, 50, Tramersatzverkehr.</div><div><br></div><div>Nicht enthalten sind hingegen die Fahrgastzahlen der SBB, BLT oder ausl\u{e4}ndischer Transportunternehmen.</div><div><br>Die Daten werden jeweils am 10. jeden Monats resp. am darauffolgenden Werktag aktualisiert.</div><div><br>In Ausnahmef\u{e4}llen kann es aus technischen Gr\u{fc}nden zu Verz\u{f6}gerungen im Prozess der Bereitstellung und Auswertung von Z\u{e4}hldaten kommen. Nachtr\u{e4}glich verf\u{fc}gbare Messdaten werden in der hier vorliegenden Auswertung ber\u{fc}cksichtigt, was in diesem Fall zu r\u{fc}ckwirkenden Korrekturen f\u{fc}hren kann.</div><div><br></div><div>\u{c4}nderungsprotokoll: </div><div>02.02.2024: Die Auswertungen auf Wochenbasis werden eingestellt und nur noch die Zeitreihe der Monatswerte werden fortgef\u{fc}hrt.<br></div>"]
pub mod fahrgastzahlen_bvb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Startdatum Kalenderwoche/Monat
        ///
        /// Das Attribut 'Startdatum Kalenderwoche/Monat' gibt den Anfang des Zeitraums an, für den die Fahrgastzahlen erfasst wurden, entweder den ersten Tag der Woche oder den ersten Tag des Monats entsprechend der Granularität.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub startdatum_kalenderwoche_monat: Option<Date>,
        /// Fahrgäste (Einsteiger)
        ///
        /// Anzahl Fahrgäste, welche in einer Woche ein Verkehrsmittel der BVB genutzt haben.
        pub fahrgaeste_einsteiger: Option<i64>,
        /// Kalenderwoche
        pub kalenderwoche: Option<i64>,
        /// Granularität
        ///
        /// Das Attribut 'Granularität' bestimmt, ob die Fahrgastdaten auf wöchentlicher oder monatlicher Basis erfasst wurden, um die zeitliche Detailgenauigkeit der Daten zu definieren.
        pub granularitat: Option<String>,
        /// Datum der Monatswerte
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_der_monatswerte: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        StartdatumKalenderwocheMonat,
        FahrgaesteEinsteiger,
        Kalenderwoche,
        Granularitat,
        DatumDerMonatswerte,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::StartdatumKalenderwocheMonat => "startdatum_kalenderwoche_monat",
                Field::FahrgaesteEinsteiger => "fahrgaeste_einsteiger",
                Field::Kalenderwoche => "kalenderwoche",
                Field::Granularitat => "granularitat",
                Field::DatumDerMonatswerte => "datum_der_monatswerte",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100075/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Bev\u{f6}lkerungsszenarien Basel-Stadt 2024-2045"]
#[doc = ""]
#[doc = "Die Bev\u{f6}lkerungsszenarien liefern kleinr\u{e4}umige Ergebnisse auf der Ebene Wahlkreise der Stadt Basel sowie gemeinsam f\u{fc}r die Gemeinden Riehen und Bettingen. Neben der absoluten Bev\u{f6}lkerungsentwicklung stellen die Szenarien auch die Entwicklung der Bev\u{f6}lkerungsstruktur bis 2045 dar: Die Bev\u{f6}lkerung wird nach Alter, Geschlecht und Staatsangeh\u{f6}rigkeit (Schweiz und Ausland) ausgewiesen. Auch stehen verschiedene demografische Komponenten wie Geburten und Sterbef\u{e4}lle, Einb\u{fc}rgerungen oder Wanderungsbewegungen zur Verf\u{fc}gung. Aufgrund von Meldeverz\u{f6}gerungen werden die Nullj\u{e4}hrigen in Datenjahren der Vergangenheit geringf\u{fc}gig untersch\u{e4}tzt."]
pub mod bevoelkerungsszenarien_basel_stadt_2024_2045 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Alter
        ///
        /// Für das Jahr 2019 Alter 0= Geburtsjahrgang 2019, usw.
        pub alter: Option<i64>,
        /// Wahlkreis
        ///
        /// Die Stadt Basel hat 3 Wahlkreise, die Landgemeinden bilden eigene Wahlkreise
        pub geo: Option<String>,
        /// Geschlecht
        ///
        /// Geschlecht (Mann oder Frau)
        pub geschlecht: Option<String>,
        /// Herkunft
        ///
        /// Schweiz oder Ausland; Doppelbürger unter Schweiz erfasst
        pub herkunft: Option<String>,
        /// Jahr
        ///
        /// Datenjahr
        pub jahr: Option<String>,
        /// Einwohnerzahl
        ///
        /// Anzahl Personen im angegebenen Datenjahr
        pub bestand_hist: Option<i64>,
        /// Einwohnerzahl hoch
        ///
        /// Anzahl Personen im hohen Szenario
        pub bestand_hoch: Option<f64>,
        /// Einwohnerzahl  mittel
        ///
        /// Anzahl Personen im mittleren Szenario
        pub bestand_mittel: Option<f64>,
        /// Einwohnerzahl tief
        ///
        /// Anzahl Personen im tiefen Szenario
        pub bestand_tief: Option<f64>,
        /// Geburtenzahl
        ///
        /// Anzahl Geburten im angegebenen Datenjahr
        pub geb_hist: Option<i64>,
        /// Geburtenzahl hoch
        ///
        /// Anzahl Geburten im hohen Szenario
        pub geb_hoch: Option<f64>,
        /// Geburtenzahl mittel
        ///
        /// Anzahl Geburten im mittleren Szenario
        pub geb_mittel: Option<f64>,
        /// Geburtenzahl tief
        ///
        /// Anzahl Geburten im tiefen Szenario
        pub geb_tief: Option<f64>,
        /// Todesfaelle
        ///
        /// Anzahl Gestorbene im angegebenen Datenjahr
        pub tod_hist: Option<i64>,
        /// Todesfalle hoch
        ///
        /// Anzahl Gestorbene im hohen Szenario
        pub tod_hoch: Option<f64>,
        /// Todesfaelle mittel
        ///
        /// Anzahl Gestorbene im mittleren Szenario
        pub tod_mittel: Option<f64>,
        /// Todesfaelle tief
        ///
        /// Anzahl Gestorbene im tiefen Szenario
        pub tod_tief: Option<f64>,
        /// Saldo
        ///
        /// Differenz
        pub s_geb_tod_hist: Option<i64>,
        /// Geburtensaldo hoch
        ///
        /// Geburtensaldo hohes Szenario
        pub s_geb_tod_hoch: Option<f64>,
        /// Geburtensaldo mittel
        ///
        /// Geburtensaldo mittleres Szenario
        pub s_geb_tod_mittel: Option<f64>,
        /// Geburtensaldo tief
        ///
        /// Geburtensaldo tiefes Szenario
        pub s_geb_tod_tief: Option<f64>,
        /// Zuzüge
        ///
        /// Zuzüge interkantonal historisch
        pub zuz_hist: Option<i64>,
        /// Zuzüge hoch
        ///
        /// Zuzüge interkantonal hohes Szenario
        pub zuz_hoch: Option<f64>,
        /// Zuzüge mittel
        ///
        /// Zuzüge interkantonal mittleres Szenario
        pub zuz_mittel: Option<f64>,
        /// Zuzüge tief
        ///
        /// Zuzüge interkantonal tiefes Szenario
        pub zuz_tief: Option<f64>,
        /// Wegzüge
        ///
        /// Wegzüge interkantonal historisch
        pub wegz_hist: Option<i64>,
        /// Wegzüge hoch
        ///
        /// Wegzüge interkantonal hohes Szenario
        pub wegz_hoch: Option<f64>,
        /// Wegzüge mittel
        ///
        /// Wegzüge interkantonal mittleres Szenario
        pub wegz_mittel: Option<f64>,
        /// Wegzüge tief
        ///
        /// Wegzüge interkantonal tiefes Szenario
        pub wegz_tief: Option<f64>,
        /// Saldo Umzüge national
        ///
        /// Saldo interkantonale Wanderung historisch
        pub s_ink_hist: Option<i64>,
        /// Saldo Umzüge national hoch
        ///
        /// Saldo interkantonale Wanderung hohes Szenario
        pub s_ink_hoch: Option<f64>,
        /// Saldo Umzüge national mittel
        ///
        /// Saldo interkantonale Wanderung mittleres Szenario
        pub s_ink_mittel: Option<f64>,
        /// Saldo Umzüge national tief
        ///
        /// Saldo interkantonale Wanderung tiefes Szenario
        pub s_ink_tief: Option<f64>,
        /// Einwanderung
        ///
        /// Einwanderung international historisch
        pub einw_hist: Option<i64>,
        /// Einwanderung hoch
        ///
        /// Einwanderung international hohes Szenario
        pub einw_hoch: Option<f64>,
        /// Einwanderung  mittel
        ///
        /// Einwanderung international mittleres Szenario
        pub einw_mittel: Option<f64>,
        /// Einwanderung tief
        ///
        /// Einwanderung international tiefes Szenario
        pub einw_tief: Option<f64>,
        /// Auswanderung
        ///
        /// Auswanderung international historisch
        pub ausw_hist: Option<i64>,
        /// Auswanderung hoch
        ///
        /// Auswanderung international hohes Szenario
        pub ausw_hoch: Option<f64>,
        /// Auswanderung mittel
        ///
        /// Auswanderung international mittleres Szenario
        pub ausw_mittel: Option<f64>,
        /// Auswanderung tief
        ///
        /// Auswanderung international tiefes Szenario
        pub ausw_tief: Option<f64>,
        /// Saldo Umzüge international
        ///
        /// Saldo internationale Wanderung historisch
        pub s_int_hist: Option<i64>,
        /// Saldo Umzüge international hoch
        ///
        /// Saldo internationale Wanderung hohes Szenario
        pub s_int_hoch: Option<f64>,
        /// Saldo Umzüge international mittel
        ///
        /// Saldo internationale Wanderung mittleres Szenario
        pub s_int_mittel: Option<f64>,
        /// Saldo Umzüge international tief
        ///
        /// Saldo internationale Wanderung tiefes Szenario
        pub s_int_tief: Option<f64>,
        /// Umzüge total
        ///
        /// Saldo Wanderung total historisch
        pub s_wtotal_hist: Option<i64>,
        /// Umzüge total hoch
        ///
        /// Saldo Wanderung total hohes Szenario
        pub s_wtotal_hoch: Option<f64>,
        /// Umzüge total mittel
        ///
        /// Saldo Wanderung total mittleres Szenario
        pub s_wtotal_mittel: Option<f64>,
        /// Umzüge total tief
        ///
        /// Saldo Wanderung total tiefes Szenario
        pub s_wtotal_tief: Option<f64>,
        /// Kantonale Zuzüge
        ///
        /// Umzüge intrakantonal hin historisch
        pub uhin_hist: Option<i64>,
        /// Kantonale Zuzüge hoch
        ///
        /// Umzüge intrakantonal hin hohes Szenario
        pub uhin_hoch: Option<f64>,
        /// Kantonale Zuzüge mittel
        ///
        /// Umzüge intrakantonal hin mittleres Szenario
        pub uhin_mittel: Option<f64>,
        /// Kantonale Zuzüge tief
        ///
        /// Umzüge intrakantonal hin tiefes Szenario
        pub uhin_tief: Option<f64>,
        /// Kantonale Wegzüge
        ///
        /// Umzüge intrakantonal weg historisch
        pub uweg_hist: Option<i64>,
        /// Kantonale Wegzüge hoch
        ///
        /// Umzüge intrakantonal weg hohes Szenario
        pub uweg_hoch: Option<f64>,
        /// Kantonale Wegzüge mittel
        ///
        /// Umzüge intrakantonal weg mittleres Szenario
        pub uweg_mittel: Option<f64>,
        /// Kantonale Wegzüge tief
        ///
        /// Umzüge intrakantonal weg tiefes Szenario
        pub uweg_tief: Option<f64>,
        /// Saldo kantonale Umzüge
        ///
        /// Saldo Umzüge intrakantonal historisch
        pub s_umz_hist: Option<i64>,
        /// Saldo kantonale Umzüge hoch
        ///
        /// Saldo Umzüge intrakantonal hohes Szenario
        pub s_umz_hoch: Option<f64>,
        /// Saldo kantonale Umzüge mittel
        ///
        /// Saldo Umzüge intrakantonal mittleres Szenario
        pub s_umz_mittel: Option<f64>,
        /// Saldo kantonale Umzüge tief
        ///
        /// Saldo Umzüge intrakantonal tiefes Szenario
        pub s_umz_tief: Option<f64>,
        /// Einbürgerungen
        ///
        /// Einbürgerungen historisch
        pub einb_hist: Option<i64>,
        /// Einbürgerungen hoch
        ///
        /// Einbürgerungen hohes Szenario
        pub einb_hoch: Option<f64>,
        /// Einbürgerungen mittel
        ///
        /// Einbürgerungen mittleres Szenario
        pub einb_mittel: Option<f64>,
        /// Einbürgerungen tief
        ///
        /// Einbürgerungen tiefes Szenario
        pub einb_tief: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Alter,
        Geo,
        Geschlecht,
        Herkunft,
        Jahr,
        BestandHist,
        BestandHoch,
        BestandMittel,
        BestandTief,
        GebHist,
        GebHoch,
        GebMittel,
        GebTief,
        TodHist,
        TodHoch,
        TodMittel,
        TodTief,
        SGebTodHist,
        SGebTodHoch,
        SGebTodMittel,
        SGebTodTief,
        ZuzHist,
        ZuzHoch,
        ZuzMittel,
        ZuzTief,
        WegzHist,
        WegzHoch,
        WegzMittel,
        WegzTief,
        SInkHist,
        SInkHoch,
        SInkMittel,
        SInkTief,
        EinwHist,
        EinwHoch,
        EinwMittel,
        EinwTief,
        AuswHist,
        AuswHoch,
        AuswMittel,
        AuswTief,
        SIntHist,
        SIntHoch,
        SIntMittel,
        SIntTief,
        SWtotalHist,
        SWtotalHoch,
        SWtotalMittel,
        SWtotalTief,
        UhinHist,
        UhinHoch,
        UhinMittel,
        UhinTief,
        UwegHist,
        UwegHoch,
        UwegMittel,
        UwegTief,
        SUmzHist,
        SUmzHoch,
        SUmzMittel,
        SUmzTief,
        EinbHist,
        EinbHoch,
        EinbMittel,
        EinbTief,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Alter => "alter",
                Field::Geo => "geo",
                Field::Geschlecht => "geschlecht",
                Field::Herkunft => "herkunft",
                Field::Jahr => "jahr",
                Field::BestandHist => "bestand_hist",
                Field::BestandHoch => "bestand_hoch",
                Field::BestandMittel => "bestand_mittel",
                Field::BestandTief => "bestand_tief",
                Field::GebHist => "geb_hist",
                Field::GebHoch => "geb_hoch",
                Field::GebMittel => "geb_mittel",
                Field::GebTief => "geb_tief",
                Field::TodHist => "tod_hist",
                Field::TodHoch => "tod_hoch",
                Field::TodMittel => "tod_mittel",
                Field::TodTief => "tod_tief",
                Field::SGebTodHist => "s_geb_tod_hist",
                Field::SGebTodHoch => "s_geb_tod_hoch",
                Field::SGebTodMittel => "s_geb_tod_mittel",
                Field::SGebTodTief => "s_geb_tod_tief",
                Field::ZuzHist => "zuz_hist",
                Field::ZuzHoch => "zuz_hoch",
                Field::ZuzMittel => "zuz_mittel",
                Field::ZuzTief => "zuz_tief",
                Field::WegzHist => "wegz_hist",
                Field::WegzHoch => "wegz_hoch",
                Field::WegzMittel => "wegz_mittel",
                Field::WegzTief => "wegz_tief",
                Field::SInkHist => "s_ink_hist",
                Field::SInkHoch => "s_ink_hoch",
                Field::SInkMittel => "s_ink_mittel",
                Field::SInkTief => "s_ink_tief",
                Field::EinwHist => "einw_hist",
                Field::EinwHoch => "einw_hoch",
                Field::EinwMittel => "einw_mittel",
                Field::EinwTief => "einw_tief",
                Field::AuswHist => "ausw_hist",
                Field::AuswHoch => "ausw_hoch",
                Field::AuswMittel => "ausw_mittel",
                Field::AuswTief => "ausw_tief",
                Field::SIntHist => "s_int_hist",
                Field::SIntHoch => "s_int_hoch",
                Field::SIntMittel => "s_int_mittel",
                Field::SIntTief => "s_int_tief",
                Field::SWtotalHist => "s_wtotal_hist",
                Field::SWtotalHoch => "s_wtotal_hoch",
                Field::SWtotalMittel => "s_wtotal_mittel",
                Field::SWtotalTief => "s_wtotal_tief",
                Field::UhinHist => "uhin_hist",
                Field::UhinHoch => "uhin_hoch",
                Field::UhinMittel => "uhin_mittel",
                Field::UhinTief => "uhin_tief",
                Field::UwegHist => "uweg_hist",
                Field::UwegHoch => "uweg_hoch",
                Field::UwegMittel => "uweg_mittel",
                Field::UwegTief => "uweg_tief",
                Field::SUmzHist => "s_umz_hist",
                Field::SUmzHoch => "s_umz_hoch",
                Field::SUmzMittel => "s_umz_mittel",
                Field::SUmzTief => "s_umz_tief",
                Field::EinbHist => "einb_hist",
                Field::EinbHoch => "einb_hoch",
                Field::EinbMittel => "einb_mittel",
                Field::EinbTief => "einb_tief",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100007/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geborene nach Geschlecht, Staatsangeh\u{f6}rigkeit, Wohnviertel und Geburtsdatum"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Geborenen im Kanton Basel-Stadt nach Geschlecht, Staatsangeh\u{f6}rigkeit, Wohnviertel und Geburtsdatum. Die Daten werden t\u{e4}glich aktualisiert, wobei nur Geburten ber\u{fc}cksichtigt werden, die mindestens 15 Tage zur\u{fc}ckliegen. Aufgrund von Nachmeldungen kann es jederzeit zu \u{c4}nderungen bei bereits ver\u{f6}ffentlichten Werten kommen. In den Daten des laufenden Jahres und bis ca. Juli auch in jenen des zur\u{fc}ckliegenden Jahres sind ausser den Lebendgeborenen auch die Totgeborenen ber\u{fc}cksichtigt, weil die Angabe zur Lebensf\u{e4}higkeit jeweils erst im Juli des Folgejahres verf\u{fc}gbar ist. In weiter zur\u{fc}ckliegenden Jahren sind nur die Lebendgeborenen ber\u{fc}cksichtigt. Auch die Angabe zur Anzahl Kinder, die zusammen geboren wurden (Mehrlingsgeburten) ist jeweils erst ca. im Juli des Folgejahrs verf\u{fc}gbar. <br><br>Die hier ver\u{f6}ffentlichten Werte k\u{f6}nnen aus methodischen Gr\u{fc}nden von denjenigen in der <a href=\"https://statistik.bs.ch/unterthema/3\" target=\"_blank\">kantonalen \u{f6}ffentlichen Statistik (https://statistik.bs.ch/unterthema/3)</a> abweichen: In Letzterer werden nachtr\u{e4}glich gemeldete Geburten w\u{e4}hrend vier Monaten gesammelt, danach gelten die Zahlen als definitiv. Sp\u{e4}ter eintreffende Meldungen werden im letzten noch nicht abgeschlossenen Monat gez\u{e4}hlt. In diesem Datensatz werden sie im Monat des Geburtsdatums gez\u{e4}hlt.<br><br>Aus Gr\u{fc}nden des Pers\u{f6}nlichkeitsschutzes k\u{f6}nnen im <a href=\"https://data.bs.ch/explore/dataset/100092/\" target=\"_blank\">monatlichen Datensatz (https://data.bs.ch/explore/dataset/100092/)</a> mehr Attribute ver\u{f6}ffentlicht werden als im vorliegenden Datensatz."]
pub mod geborene_nach_geschlecht_staatsangehoerigkeit_wohnviertel_und_geburtsdatum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geburtsdatum
        ///
        /// Tag der Geburt
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub geburts_datum: Option<Date>,
        /// Jahr
        ///
        /// Geburtsjahr
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Geburtsmonat
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Laufnummer der Woche im Jahr
        pub woche_in_jahr: Option<i64>,
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Geburtswoche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_wochenstart_geburtsdatum: Option<Date>,
        /// Tag in Jahr
        ///
        /// Laufnummer des Tages im Jahr
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Geschlecht
        ///
        /// M=männlich, W=weiblich
        pub geschlecht: Option<String>,
        /// Anzahl Kinder
        ///
        /// Anzahl Kinder, welche zusammen geboren wurden (Mehrlingsgeburten)
        pub anzahl_kinder: Option<i64>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit des Neugeborenen (Schweiz/Ausland)
        pub nationalitaet: Option<String>,
        /// Wohnviertel
        pub wohnviertel_name: Option<String>,
        /// Laufnummer
        pub id: Option<String>,
        /// Wohnviertel ID
        pub wohnviertel_id: Option<i64>,
        /// Value_gender_BFS
        pub value_gender_bfs: Option<i64>,
        /// Name_gender_BFS
        pub name_gender_bfs: Option<String>,
        /// Value_citizenship_BFS
        pub value_citizenship_bfs: Option<i64>,
        /// Name_citizenship_BFS
        pub name_citizenship_bfs: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GeburtsDatum,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartGeburtsdatum,
        TagInJahr,
        Wochentag,
        Geschlecht,
        AnzahlKinder,
        Nationalitaet,
        WohnviertelName,
        Id,
        WohnviertelId,
        ValueGenderBfs,
        NameGenderBfs,
        ValueCitizenshipBfs,
        NameCitizenshipBfs,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GeburtsDatum => "geburts_datum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartGeburtsdatum => "datum_wochenstart_geburtsdatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::Geschlecht => "geschlecht",
                Field::AnzahlKinder => "anzahl_kinder",
                Field::Nationalitaet => "nationalitaet",
                Field::WohnviertelName => "wohnviertel_name",
                Field::Id => "id",
                Field::WohnviertelId => "wohnviertel_id",
                Field::ValueGenderBfs => "value_gender_bfs",
                Field::NameGenderBfs => "name_gender_bfs",
                Field::ValueCitizenshipBfs => "value_citizenship_bfs",
                Field::NameCitizenshipBfs => "name_citizenship_bfs",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100092/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnungen (Geb\u{e4}ude- und Wohnungsregister GWR)"]
#[doc = ""]
#[doc = "Wohnungen gem\u{e4}ss Geb\u{e4}ude- und Wohnungsregister (GWR). <br><br>Eine Wohnung ist eine Gesamtheit von R\u{e4}umen, die f\u{fc}r eine Wohnnutzung geeignet sind, eine bauliche Einheit bilden, einen Zugang entweder von aussen oder von einem gemeinsam mit anderen Wohnungen genutzten Bereich innerhalb des Geb\u{e4}udes haben, \u{fc}ber eine Kocheinrichtung (oder mindestens der technischen Installation f\u{fc}r den Einbau einer Kocheinrichtung) verf\u{fc}gen und keine Fahrnis darstellen.<br><br>Einen \u{dc}berblick \u{fc}ber die im Register gef\u{fc}hrten Merkmal gibt folgendes Dokument: <a href=\"https://www.housing-stat.ch/files/881-2200.pdf\" target=\"_blank\">https://www.housing-stat.ch/files/881-2200.pdf (Merkmalskatalog 4.2)</a> bzw. online unter <a href=\"https://www.housing-stat.ch/de/help/42.html\" target=\"_blank\">https://www.housing-stat.ch/de/help/42.html (Online-Merkmalskatalog 4.2)</a><br><br>Die rechtliche Grundlage stellt die entsprechende eidgen\u{f6}ssische Gesetzgebung dar: <a href=\"https://www.fedlex.admin.ch/eli/cc/2017/376/de\" target=\"_blank\">https://www.fedlex.admin.ch/eli/cc/2017/376/de (Verordnung \u{fc}ber das eidgen\u{f6}ssische Geb\u{e4}ude- und Wohnungsregister (VGWR))</a><br><br>"]
pub mod wohnungen_gebaeude_und_wohnungsregister_gwr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// EGID
        ///
        /// Eidgenössischer Gebäudeidentifikator
        pub egid: Option<i64>,
        /// EWID
        ///
        /// Eidgenössischer Wohnungsidentifikator
        pub ewid: Option<i64>,
        /// EDID
        ///
        /// Eidgenössischer Eingangsidentifikator
        pub edid: Option<i64>,
        /// AWN
        ///
        /// Administrative Wohnungsnummer
        pub whgnr: Option<i64>,
        /// Physische Wohnungsnummer
        pub weinr: Option<String>,
        /// Stockwerk Code
        pub wstwk: Option<i64>,
        /// Stockwerk Bezeichnung
        pub wstwk_decoded: Option<String>,
        /// Lage auf dem Stockwerk
        pub wbez: Option<String>,
        /// Mehrgeschossige Wohnung Code
        pub wmehrg: Option<i64>,
        /// Mehrgeschossige Wohnung Bezeichnung
        pub wmehrg_decoded: Option<String>,
        /// Baujahr der Wohnung
        pub wbauj: Option<String>,
        /// Abbruchjahr der Wohnung
        pub wabbj: Option<String>,
        /// Wohnungsstatus Code
        pub wstat: Option<i64>,
        /// Wohnungsstatus Bezeichnung
        pub wstat_decoded: Option<String>,
        /// Wohnungsfläche (in m2)
        pub warea: Option<i64>,
        /// Anzahl Zimmer
        pub wazim: Option<i64>,
        /// Kocheinrichtung Code
        pub wkche: Option<i64>,
        /// Kocheinrichtung Bezeichnung
        pub wkche_decoded: Option<String>,
        /// Exportdatum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub wexpdat: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Egid,
        Ewid,
        Edid,
        Whgnr,
        Weinr,
        Wstwk,
        WstwkDecoded,
        Wbez,
        Wmehrg,
        WmehrgDecoded,
        Wbauj,
        Wabbj,
        Wstat,
        WstatDecoded,
        Warea,
        Wazim,
        Wkche,
        WkcheDecoded,
        Wexpdat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Egid => "egid",
                Field::Ewid => "ewid",
                Field::Edid => "edid",
                Field::Whgnr => "whgnr",
                Field::Weinr => "weinr",
                Field::Wstwk => "wstwk",
                Field::WstwkDecoded => "wstwk_decoded",
                Field::Wbez => "wbez",
                Field::Wmehrg => "wmehrg",
                Field::WmehrgDecoded => "wmehrg_decoded",
                Field::Wbauj => "wbauj",
                Field::Wabbj => "wabbj",
                Field::Wstat => "wstat",
                Field::WstatDecoded => "wstat_decoded",
                Field::Warea => "warea",
                Field::Wazim => "wazim",
                Field::Wkche => "wkche",
                Field::WkcheDecoded => "wkche_decoded",
                Field::Wexpdat => "wexpdat",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100232/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Statistiken der Smiley-Geschwindigkeitsanzeigen"]
#[doc = ""]
#[doc = "<p>Die Statistik der Smiley-Geschwindigkeitsanzeigen fasst die Daten \u{fc}ber die verschiedenen Phasen zusammen (Vormessung, Betrieb, Nachmessung). Die Smiley-Geschwindigkeitsanzeigen sind nicht geeicht und entsprechend k\u{f6}nnen die Werte von der tats\u{e4}chlich gefahrenen Geschwindigkeit abweichen.<br/></p>"]
pub mod statistiken_der_smiley_geschwindigkeitsanzeigen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zyklus
        ///
        /// Messzyklus (1, 2 oder 3)
        pub zyklus: Option<i64>,
        /// Phase
        ///
        /// Phase der Messung (Vormessung, Betrieb, Nachmessung oder Gesamt)
        pub phase: Option<String>,
        /// ID Standort
        ///
        /// Eindeutige Standortkennung
        pub idstandort: Option<i64>,
        /// Strassenname
        pub strassenname: Option<String>,
        /// Start Phase
        ///
        /// Beginn der jeweiligen Phase
        #[serde(with = "time::serde::iso8601::option")]
        pub messbeginn_phase: Option<OffsetDateTime>,
        /// Median-Tempo
        ///
        /// Geschwindigkeit, bei welcher die Hälfte der Fahrzeuge schneller und die andere Hälfte langsamer fährt.
        pub v_50: Option<f64>,
        /// Tempo-85%
        ///
        /// Geschwindigkeitswert, unter dem 85% der Fahrzeuge fahren. Dieser wird oft genutzt zur Bestimmung von Sicherheitsgrenzen.
        pub v_85: Option<f64>,
        /// Tempolimit
        ///
        /// Maximale erlaubte Geschwindigkeit
        pub geschwindigkeit: Option<f64>,
        /// Anzahl Messungen
        ///
        /// Gesamtanzahl der durchgeführten Geschwindigkeitsmessungen.
        pub anzahl_messungen: Option<i64>,
        /// Messdauer
        ///
        /// Die Gesamtdauer der Geschwindigkeitsmessung, angegeben in Stunden.
        pub messdauer_h: Option<f64>,
        /// Durchschnittlicher Tagesverkehr
        ///
        /// Durchschnittliche Anzahl Fahrzeuge, die täglich den Messbereich passieren.
        pub dtv: Option<f64>,
        /// Link Einzelmessungen
        ///
        /// URL zu detaillierten Einzeldaten der Geschwindigkeitsmessungen
        pub link_einzelmessungen: Option<String>,
        /// Geopunkt
        ///
        /// Geografische Koordinaten der Smiley-Geschwindigkeitsanzeige
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Zyklus,
        Phase,
        Idstandort,
        Strassenname,
        MessbeginnPhase,
        V50,
        V85,
        Geschwindigkeit,
        AnzahlMessungen,
        MessdauerH,
        Dtv,
        LinkEinzelmessungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Zyklus => "zyklus",
                Field::Phase => "phase",
                Field::Idstandort => "idstandort",
                Field::Strassenname => "strassenname",
                Field::MessbeginnPhase => "messbeginn_phase",
                Field::V50 => "v_50",
                Field::V85 => "v_85",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::AnzahlMessungen => "anzahl_messungen",
                Field::MessdauerH => "messdauer_h",
                Field::Dtv => "dtv",
                Field::LinkEinzelmessungen => "link_einzelmessungen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100277/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Vorhersagen Birs: Wasserstand und Abfluss"]
#[doc = ""]
#[doc = "<p>Hydrologische Vorhersagen (Wasserstand und Abfluss) f\u{fc}r die Station \"Birs - M\u{fc}nchenstein, Hofmatt\".\u{a0}</p><p style=\"font-family: sans-serif;\">Die Vorhersagen basieren\u{a0} auf den Meteo-Modellen ICON-CH1-EPS, ICON-CH2-EPS und IFS. Am Anfang der Zeitreihen stehen 24 Std. Messwerte, anschliessend fangen die Prognosen an.\u{a0}</p><p style=\"font-family: sans-serif;\">Bei den ICON-Modellen wird der Kontroll-Lauf in den Spalten \"Wasserstand\" und \"Abflussmenge\" ausgewiesen. Der Kontroll-Lauf ist die\u{a0}hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage.</p><p>Stationsinfo: Die Station befindet sich bei \"Hofmatt\" in M\u{fc}nchenstein etwa auf H\u{f6}he der Br\u{fc}cke \"Baselstrasse\" \u{fc}ber die Birs.</p><p>Weitere Informationen sind hier zu finden:\u{a0}<a href=\"https://www.hydrodaten.admin.ch/de/2106.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/2106.html</a><a href=\"https://www.hydrodaten.admin.ch/de/2106.html\" target=\"_blank\"></a></p><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">\u{c4}nderungsprotokoll:</span></p><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">30.05.2024:</span>\u{a0}F\u{fc}r die numerische Vorhersage wurde das Wettermodell COSMO mit dem neuen Wettermodell ICON (Icosahedral Nonhydrostatic Weather and Climate Model) ersetzt.\u{a0}Mehr Infos dazu finden Sie hier:\u{a0}<a href=\"https://www.meteoschweiz.admin.ch/ueber-uns/forschung-und-zusammenarbeit/projekte/2023/icon-22.html\" target=\"_blank\">https://www.meteoschweiz.admin.ch/ueber-uns/forschung-und-zusammenarbeit/projekte/2023/icon-22.html</a></p>"]
pub mod vorhersagen_birs_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Wasserstand
        ///
        /// Pegelstand in Meter über Meer. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub wasserstand: Option<f64>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmeter pro Sekunde. Bei den ICON-Modellen handelt es ich um die hydrologische Vorhersage basierend auf der meteorologischen Kontrollvorhersage (Kontroll-Lauf oder control run).
        pub abfluss: Option<f64>,
        /// Methode
        ///
        /// Das verwendete Meteo-Modell
        pub methode: Option<String>,
        /// Zeitstempel Ausgabe
        ///
        /// Datum und Uhrzeit der Veröffentlichung
        #[serde(with = "time::serde::iso8601::option")]
        pub ausgegeben_an: Option<OffsetDateTime>,
        /// Zeitstempel Meteolauf
        ///
        /// Datum und Uhrzeit des Meteo-Laufs (der Zeitpunkt, zu dem die meteorologischen Vorhersagen erstellt wurden, die dann als Grundlage für das Modell zur Berechnung der hydrologischen Vorhersagen verwendet wird)
        #[serde(with = "time::serde::iso8601::option")]
        pub meteolauf: Option<OffsetDateTime>,
        /// Zeitstempel Gemessene Werte
        ///
        /// Datum und Uhrzeit, bis zu dem die Werte gemessen wurden
        #[serde(with = "time::serde::iso8601::option")]
        pub gemessene_werten_bis: Option<OffsetDateTime>,
        /// Wasserstand Minimum
        ///
        /// Minimum (0%-Quantil) des Pegelstands in Meter über Meer
        pub h_min: Option<f64>,
        /// Wasserstand 25%-Quantil
        ///
        /// 25%-Quantil des Pegelstands in Meter über Meer
        pub h_p25: Option<f64>,
        /// Wasserstand Median
        ///
        /// Median (50%-Quantil) des Pegelstands in Meter über Meer
        pub h_p50: Option<f64>,
        /// Wasserstand 75%-Quantil
        ///
        /// 75%-Quantil des Pegelstands in Meter über Meer
        pub h_p75: Option<f64>,
        /// Wasserstand Maximum
        ///
        /// Maximum (100%-Quantil) des Pegelstands in Meter über Meer
        pub h_max: Option<f64>,
        /// Abflussmenge Minimum
        ///
        /// Minimum (0%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_min: Option<f64>,
        /// Abflussmenge 25%-Quantil
        ///
        /// 25%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p25: Option<f64>,
        /// Abflussmenge Median
        ///
        /// Median (50%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p50: Option<f64>,
        /// Abflussmenge 75%-Quantil
        ///
        /// 75%-Quantil der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_p75: Option<f64>,
        /// Abflussmenge Maximum
        ///
        /// Maximum (100%-Quantil) der abfliessenden Wassermenge in Kubikmeter pro Sekunde
        pub q_max: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Wasserstand,
        Abfluss,
        Methode,
        AusgegebenAn,
        Meteolauf,
        GemesseneWertenBis,
        HMin,
        HP25,
        HP50,
        HP75,
        HMax,
        QMin,
        QP25,
        QP50,
        QP75,
        QMax,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Wasserstand => "wasserstand",
                Field::Abfluss => "abfluss",
                Field::Methode => "methode",
                Field::AusgegebenAn => "ausgegeben_an",
                Field::Meteolauf => "meteolauf",
                Field::GemesseneWertenBis => "gemessene_werten_bis",
                Field::HMin => "h_min",
                Field::HP25 => "h_p25",
                Field::HP50 => "h_p50",
                Field::HP75 => "h_p75",
                Field::HMax => "h_max",
                Field::QMin => "q_min",
                Field::QP25 => "q_p25",
                Field::QP50 => "q_p50",
                Field::QP75 => "q_p75",
                Field::QMax => "q_max",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100272/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Effektiver und erwarteter t\u{e4}glicher Gasverbrauch"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet den t\u{e4}glichen Gasverbrauch sowie den mittels eines Modells berechneten, anhand des Kalendertages und der Witterung zu erwartenden Gasverbrauch.<br>Der t\u{e4}gliche Gasverbrauch ergibt sich als Summe des st\u{fc}ndlich ausgewiesenen Gasverbrauchs im OGD-Datensatz \"Gasverbrauch im Versorgungsgebiet der IWB\" (<a href=\"https://data.bs.ch/explore/dataset/100304/\">https://data.bs.ch/explore/dataset/100304/</a>). <br><br> F\u{fc}r die Modellevaluierung wurde der Datensatz in drei Teile unterteilt. Der Trainingsdatensatz dient zum Trainieren des Modells, der Tesdatensatz zur Bewertung der Modellleistung. Der Prognosedatensatz enth\u{e4}lt neue, unbekannte Daten zur Vorhersage durch das mit Training- und Testdaten trainierte Modell.<br><br>Mehr Informationen zu den gewonnenen Kentnissen findet man im Webartikel: <a href=\"https://charts.basleratlas.ch/energie/webartikel_gasverbrauch.html\">https://charts.basleratlas.ch/energie/webartikel_gasverbrauch.html</a><br><br>Der Code des Modells kann selber ausgef\u{fc}hrt und weiterentwickelt werden. Hierf\u{fc}r wird Renku verwendet. Renku ist eine Plattform, die verschiedene Werkzeuge f\u{fc}r reproduzierbare und kollaborative Datenanalyseprojekte b\u{fc}ndelt: <a href=\"https://renkulab.io/projects/statabs/reproducible-research/erwarteter-gasverbrauch-basel-stadt\">https://renkulab.io/projects/statabs/reproducible-research/erwarteter-gasverbrauch-basel-stadt</a>"]
pub mod effektiver_und_erwarteter_taeglicher_gasverbrauch {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub time: Option<Date>,
        /// Gasverbrauch effektiv
        ///
        /// Tägliche Summe des stündlichen Stromverbrauchs
        pub gasverbrauch: Option<f64>,
        /// Gasverbrauch erwartet
        ///
        /// Prognostizierter Wert, abhängig von Kalendertag (z.B. Ferien oder Wochentag) und Witterung
        pub forecast: Option<f64>,
        /// Differenz Gasverbrauch (effektiv - erwartet)
        ///
        /// Differenz Gasverbrauch effektiv abzüglich erwartet
        pub vgl_real_minus_forecast: Option<f64>,
        /// Prognoseintervall tief
        ///
        /// Untere Grenze des 95%-Prognoseintervalls für täglich erwarteten Gasverbrauch
        pub forecast_lowfi: Option<f64>,
        /// Prognoseintervall hoch
        ///
        /// Obere Grenze des 95%-Prognoseintervalls für täglich erwarteten Gasverbrauch
        pub forecast_highfi: Option<f64>,
        /// data split
        ///
        /// Für die Modellevaluierung wurde der Datensatz in drei Teile unterteilt. Der Trainingsdatensatz dient zum Trainieren (Train) des Modells, der Tesdatensatz (Test) zur Bewertung der Modellleistung. Der Prognosedatensatz (Prognose) enthält neue, unbekannte Daten zur Vorhersage durch das mit Training- und Testdaten (Train und Test) trainierte Modell.
        pub traintestorforecast: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Time,
        Gasverbrauch,
        Forecast,
        VglRealMinusForecast,
        ForecastLowfi,
        ForecastHighfi,
        Traintestorforecast,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Time => "time",
                Field::Gasverbrauch => "gasverbrauch",
                Field::Forecast => "forecast",
                Field::VglRealMinusForecast => "vgl_real_minus_forecast",
                Field::ForecastLowfi => "forecast_lowfi",
                Field::ForecastHighfi => "forecast_highfi",
                Field::Traintestorforecast => "traintestorforecast",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100353/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geborene nach Geschlecht, Staatsangeh\u{f6}rigkeit und Geburtsmonat"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Geborenen im Kanton Basel-Stadt nach Geschlecht, Staatsangeh\u{f6}rigkeit und Geburtsmonat sowie nach Alter, Staatsangeh\u{f6}rigkeit und Zivilstand der Eltern. Die Daten werden monatlich aktualisiert, wobei die Zahlen eines Monats jeweils am 16. Tag des n\u{e4}chsten Monats publiziert werden. Aufgrund von Nachmeldungen kann es jederzeit zu \u{c4}nderungen bei bereits ver\u{f6}ffentlichten Werten kommen. In den Daten der Jahre bis 2021 sind nur die Lebendgeborenen ber\u{fc}cksichtigt, in denjenigen der Jahre seit 2022 auch die Totgeborenen. Dies liegt daran, dass die Angabe zur Lebensf\u{e4}higkeit jeweils erst im Juli des Folgejahres verf\u{fc}gbar ist. Auch die Angaben zur Geburtenfolge und zum Zivilstand der Eltern sind jeweils erst im Juli des Folgejahres verf\u{fc}gbar. <br><br>Die hier ver\u{f6}ffentlichten Werte k\u{f6}nnen aus methodischen Gr\u{fc}nden von denjenigen in der <a href=\"https://statistik.bs.ch/unterthema/3\" target=\"_blank\">kantonalen \u{f6}ffentlichen Statistik (https://statistik.bs.ch/unterthema/3)</a> abweichen: In Letzterer werden nachtr\u{e4}glich gemeldete Geburten w\u{e4}hrend vier Monaten gesammelt, danach gelten die Zahlen als definitiv. Sp\u{e4}ter eintreffende Meldungen werden im letzten noch nicht abgeschlossenen Monat gez\u{e4}hlt. In diesem Datensatz werden sie im Monat des Geburtsdatums gez\u{e4}hlt. <br><br>Aus Gr\u{fc}nden des Pers\u{f6}nlichkeitsschutzes k\u{f6}nnen im <a href=\"https://data.bs.ch/explore/dataset/100092/\" target=\"_blank\">Datensatz mit dem Geburtsdatum (https://data.bs.ch/explore/dataset/100092/)</a> weniger Attribute ver\u{f6}ffentlicht werden als im vorliegenden Datensatz. <br><br>Eine leere Zelle bedeutet \u{ab}Wert unbekannt\u{bb}."]
pub mod geborene_nach_geschlecht_staatsangehoerigkeit_und_geburtsmonat {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Geburtsjahr
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Geburtsmonat
        pub monat: Option<i64>,
        /// Geschlecht
        ///
        /// M=männlich, W=weiblich
        pub geschlecht: Option<String>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit des Neugeborenen (Schweiz/Ausland)
        pub nationalitaet: Option<String>,
        /// Alter der Mutter
        ///
        /// Alter der Mutter bei Geburt des Kindes
        pub alter_mutter: Option<i64>,
        /// Alter des Vaters
        ///
        /// Alter des Vaters bei Geburt des Kindes
        pub alter_vater: Option<i64>,
        /// Staatsangehörigkeit der Mutter
        ///
        /// Staatsangehörigkeit der Mutter bei Geburt des Kindes (Schweiz/Ausland)
        pub nationalitaet_mutter: Option<String>,
        /// Staatsangehörigkeit des Vaters
        ///
        /// Staatsangehörigkeit des Vaters bei Geburt des Kindes (Schweiz/Ausland)
        pub nationalitaet_vater: Option<String>,
        /// Verheiratet
        ///
        /// Gibt an, ob die Eltern bei Geburt des Kindes verheiratet waren
        pub verheiratet: Option<String>,
        /// Geburtenfolge
        ///
        /// Anzahl gemeinsame Kinder des Elternpaares (einschl. des Geborenen und allfälliger gemeinsamer Kinder des Ehepaares vor der Eheschliessung); bei unverheirateten Paaren wird der Wert 0 angegeben.
        pub geburtenfolge: Option<i64>,
        /// Laufnummer
        pub id: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        Geschlecht,
        Nationalitaet,
        AlterMutter,
        AlterVater,
        NationalitaetMutter,
        NationalitaetVater,
        Verheiratet,
        Geburtenfolge,
        Id,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Geschlecht => "geschlecht",
                Field::Nationalitaet => "nationalitaet",
                Field::AlterMutter => "alter_mutter",
                Field::AlterVater => "alter_vater",
                Field::NationalitaetMutter => "nationalitaet_mutter",
                Field::NationalitaetVater => "nationalitaet_vater",
                Field::Verheiratet => "verheiratet",
                Field::Geburtenfolge => "geburtenfolge",
                Field::Id => "id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100099/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Geschlecht, Alter, Staatsangeh\u{f6}rigkeit und Wohnviertel"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Wohnbev\u{f6}lkerung des Kantons Basel-Stadt nach Geschlecht, Alter und Staatsangeh\u{f6}rigkeit (Schweiz/Ausland) auf der Ebene Wohnviertel. Die Daten werden j\u{e4}hrlich aktualisiert. <br>Die hier ver\u{f6}ffentlichten Werte der Jahre 1979 bis 2011 weichen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik ab: In Letzterer wurde bis zum Jahr 2011 die Bev\u{f6}lkerungszahl durch Fortschreibung ermittelt. Seit dem Jahr 2012 basiert sie direkt auf Auswertungen aus dem kantonalen Einwohnerregister. Die hier ver\u{f6}ffentlichten Werte hingegen basieren seit 1979 auf Auswertungen aus dem Einwohnerregister."]
pub mod wohnbevoelkerung_nach_geschlecht_alter_staatsangehoerigkeit_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Jahr
        pub jahr: Option<String>,
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// Wohnviertel-ID
        pub wohnviertel_id: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Geschlecht
        ///
        /// M=Männlich, W=Weiblich
        pub geschlecht: Option<String>,
        /// Alter
        ///
        /// Die Angabe des Alters beruht auf dem Geburtsjahr.
        pub person_alter: Option<i64>,
        /// Staatsangehoerigkeit
        ///
        /// CH=Schweiz, A=Ausland
        pub staatsangehoerigkeit: Option<String>,
        /// Value_gender_BFS
        pub value_gender_bfs: Option<i64>,
        /// Name_gender_BFS
        pub name_gender_bfs: Option<String>,
        /// Value_citizenship_BFS
        pub value_citizenship_bfs: Option<i64>,
        /// Name_citizenship_BFS
        pub name_citizenship_bfs: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Jahr,
        Wohnviertel,
        WohnviertelId,
        Gemeinde,
        Geschlecht,
        PersonAlter,
        Staatsangehoerigkeit,
        ValueGenderBfs,
        NameGenderBfs,
        ValueCitizenshipBfs,
        NameCitizenshipBfs,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Jahr => "jahr",
                Field::Wohnviertel => "wohnviertel",
                Field::WohnviertelId => "wohnviertel_id",
                Field::Gemeinde => "gemeinde",
                Field::Geschlecht => "geschlecht",
                Field::PersonAlter => "person_alter",
                Field::Staatsangehoerigkeit => "staatsangehoerigkeit",
                Field::ValueGenderBfs => "value_gender_bfs",
                Field::NameGenderBfs => "name_gender_bfs",
                Field::ValueCitizenshipBfs => "value_citizenship_bfs",
                Field::NameCitizenshipBfs => "name_citizenship_bfs",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100128/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Geschlecht und Staatsangeh\u{f6}rigkeit"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Wohnbev\u{f6}lkerung des Kantons Basel-Stadt nach Geschlecht und detaillierter Staatsangeh\u{f6}rigkeit auf der Ebene Gemeinde. Die Daten werden j\u{e4}hrlich aktualisiert.<br>Die hier ver\u{f6}ffentlichten Werte der Jahre 1979 bis 2011 weichen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik ab: In Letzterer wurde bis zum Jahr 2011 die Bev\u{f6}lkerungszahl durch Fortschreibung ermittelt. Seit dem Jahr 2012 basiert sie direkt auf Auswertungen aus dem kantonalen Einwohnerregister. Die hier ver\u{f6}ffentlichten Werte hingegen basieren seit 1979 auf Auswertungen aus dem Einwohnerregister."]
pub mod wohnbevoelkerung_nach_geschlecht_und_staatsangehoerigkeit {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Geschlecht
        ///
        /// M=Männlich, W=Weiblich
        pub geschlecht: Option<String>,
        /// Staatsangehoerigkeit
        pub staatsangehoerigkeit: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Gemeinde,
        Geschlecht,
        Staatsangehoerigkeit,
        Anzahl,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Gemeinde => "gemeinde",
                Field::Geschlecht => "geschlecht",
                Field::Staatsangehoerigkeit => "staatsangehoerigkeit",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100126/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kantonales Leistungsverzeichnis: Geb\u{fc}hren"]
#[doc = ""]
#[doc = "<p><b>Der Geb\u{fc}hrenkatalog enth\u{e4}lt die aktuellen Geb\u{fc}hren und Verweise auf die g\u{fc}ltigen Geb\u{fc}hrenordnungen im Kanton Basel-Stadt. Mit der Ver\u{f6}ffentlichung dieser Informationen entspricht die kantonale Verwaltung ihrer Informationspflicht gem\u{e4}ss dem f\u{fc}r Basel-Stadt verabschiedeten \u{ab}\u{d6}ffentlichkeitsprinzip\u{bb}, basierend auf dem Ratschlag des RR vom 07.09.2011.</b>\u{a0}</p><p>Die Ver\u{f6}ffentlichung des aktuellen Geb\u{fc}hrenkatalog auf dem kantonalen Datenportal <a href=\"https://data.bs.ch\" target=\"_blank\">https://data.bs.ch</a> als \u{ab}Open Government Data\u{bb} (OGD) erg\u{e4}nzt die bisherige Ver\u{f6}ffentlichung der Geb\u{fc}hren als Excel Datei auf der Webseite <a href=\"https://www.bs.ch/publikationen/fd/gebuehrendatenbank1.html\" target=\"_blank\">des Kanton Basel-Stadt</a>.\u{a0}</p><p>Das kantonale Datenportal f\u{fc}hrt stets die aktuellen und g\u{fc}ltigen Datens\u{e4}tze. Erg\u{e4}nzungen durch die Dienststellen werden ebenfalls automatisch nach einem Tag angezeigt. Das kantonale Datenportal ist als Informationsquelle und f\u{fc}r Auswertungen die neue \u{ab}Heimat\u{bb} des Geb\u{fc}hrenkatalogs.</p><p>Um die Daten lesbarer zu gestalten, wurden bisher als \u{ab}Geb\u{fc}hrenbl\u{f6}cke\u{bb} oder \u{ab}Sammelgeb\u{fc}hren\u{bb} ver\u{f6}ffentlichte Geb\u{fc}hren von den zust\u{e4}ndigen Dienststellen weiter aufgel\u{f6}st. Die Daten werden neu granular und damit lesbarer dargestellt. Auch die Informationen zu Geb\u{fc}hren aus anderen Kantonen (Benchmarks) wurden weiter erg\u{e4}nzt, damit die dargestellten Informationen vergleichbar und transparent sind.</p><u><b>Warum machen wir das?</b></u><p>Ein Legislaturziel ist es, einen \u{ab}niederschwelligen Service public\u{bb} anzubieten. Die Ver\u{f6}ffentlichung des Geb\u{fc}hrenkatalogs setzt den Ratschlag des RR vom 07.09.2011 um. Die Ver\u{f6}ffentlichung von Informationen erm\u{f6}glicht es Aussenstehenden, die Bedeutung und den Wert der Institutionen und Beh\u{f6}rden besser einzusch\u{e4}tzen.\u{a0}</p><p>S\u{e4}mtliche angezeigte Daten sind \u{f6}ffentlich. Siewerden hiermit allen Interessierten zug\u{e4}nglich gemacht und verletzen keine Pers\u{f6}nlichkeitsrechte, sind nicht sicherheitskritisch und unterliegen keinen Drittrechten (wie Copyrights).</p><u><b>Bitte geben Sie uns R\u{fc}ckmeldung!</b></u><p>Gerne nehmen wir Ihr gesch\u{e4}tztes Feedback und Anregungen entgegen, wie wir die Beschreibung und Auswertung aktueller Geb\u{fc}hren sinnvoll erweitern und anreichern k\u{f6}nnten, um diese \u{ab}auswertbarer\u{bb} zu machen. Entsprechende Vorschl\u{e4}ge werden auf Umsetzbarkeit gepr\u{fc}ft.\u{a0}</p><p>\u{dc}ber Ihre R\u{fc}ckmeldungen m\u{f6}chten wir verstehen, wer unsere Daten nutzt und wof\u{fc}r, damit wir die Qualit\u{e4}t und Quantit\u{e4}t der angebotenen Informationen weiter verbessern k\u{f6}nnen.</p><div><br/></div>"]
pub mod kantonales_leistungsverzeichnis_gebuehren {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Departement
        pub departement: Option<String>,
        /// Dienststelle
        pub diensstelle: Option<String>,
        /// Gegenstand der Gebühr
        ///
        /// Gegenstand/Name der Gebühr
        pub gegenstand_der_gebuhr: Option<String>,
        /// Rechtliche Grundlage
        ///
        /// Referenz auf die Rechtsgrundlagen der Gebühr.
        pub rechtliche_grundlage: Option<String>,
        /// Höhe der Gebühr(en) CHF
        ///
        /// Höhe der Einzelgebühr(en) in Franken oder Referenz zu Gebührenkatalog.
        pub hohe_der_gebuhr_en_chf: Option<String>,
        /// Benchmark
        ///
        /// Benchmark, derselben Gebühr in anderen Kantonen
        pub benchmark: Option<String>,
        /// Leistung
        ///
        /// Zugehörige Leistung
        pub leistung: Option<String>,
        /// Weitere Gliederung OE
        ///
        /// Wenn vorhanden, weitere Aufteilung der Organisationseinheit
        pub weiteregliederungoe: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Departement,
        Diensstelle,
        GegenstandDerGebuhr,
        RechtlicheGrundlage,
        HoheDerGebuhrEnChf,
        Benchmark,
        Leistung,
        Weiteregliederungoe,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Departement => "departement",
                Field::Diensstelle => "diensstelle",
                Field::GegenstandDerGebuhr => "gegenstand_der_gebuhr",
                Field::RechtlicheGrundlage => "rechtliche_grundlage",
                Field::HoheDerGebuhrEnChf => "hohe_der_gebuhr_en_chf",
                Field::Benchmark => "benchmark",
                Field::Leistung => "leistung",
                Field::Weiteregliederungoe => "weiteregliederungoe",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100325/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Treppen und Ausstiegsleitern an Gew\u{e4}ssern"]
#[doc = ""]
#[doc = "<p>Ein- und Ausstigsm\u{f6}glichkeiten in bzw. aus Rhein, Birs und Wiese, welche z.B. in der BachApp publiziert werden.\u{a0}</p>"]
pub mod treppen_und_ausstiegsleitern_an_gewaessern {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// TYP_BEZ
        ///
        /// Art des Ausstiegs
        pub typ_bez: Option<String>,
        /// Ausstiegsmöglichkeit
        pub ausstieg_moeglich: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TypBez,
        AusstiegMoeglich,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TypBez => "typ_bez",
                Field::AusstiegMoeglich => "ausstieg_moeglich",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100285/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sch\u{fc}lerprognose Basel"]
#[doc = ""]
#[doc = "Das Statistische Amt erstellt kleinr\u{e4}umige Prognosen zu den Sch\u{fc}lerzahlen in den \u{f6}ffentlichen Schulen der Stadt Basel. Die Sch\u{fc}lerzahlen werden f\u{fc}r die ersten 8 Schulstufen (Kindergarten und Primarschule), 15 Schulperimeter und 5 Schuljahre in die Zukunft prognostiziert. Die Perimeter dienen als Planungsgrundlage und nicht als effektive Einzugsgebiete. Die Prognosen werden im Auftrag des Erziehungsdepartements Basel-Stadt erstellt und j\u{e4}hrlich aktualisiert. Die Prognosezahlen ber\u{fc}cksichtigen keine Sch\u{fc}lerinnen und Sch\u{fc}ler, die aufgrund von k\u{fc}nftigen Arealentwicklungen in die Schulen eintreten werden. Die Sch\u{fc}lerinnen und Sch\u{fc}ler mit dem Schutzstatus S werden in diesem Datensatz nicht ausgewiesen."]
pub mod schuelerprognose_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Schuljahr
        ///
        /// Schuljahr August - Juli, Stichtag jeweils zu Schuljahresbeginn im September
        pub schuljahr: Option<String>,
        /// Perimeter ID
        pub nummer: Option<i64>,
        /// Perimeter
        ///
        /// Einteilung des Stadtgebiets in 15 Schulperimeter. Die Schülerinnen und Schüler werden nach ihrer Wohnadresse den Perimetern zugeordnet.
        pub perimeter: Option<String>,
        /// Schulstufe
        ///
        /// Einteilung gemäss HarmoS-Schulstufen. Schulstufen 1 und 2 bezeichnen die beiden Jahre im Kindergarten, die Schulstufen 3-6 die umgangssprachlich als Primarschuljahre 1-6 bezeichneten Schulstufen.
        pub schulstufe: Option<i64>,
        /// Schülerinnen und Schüler
        ///
        /// Schülerinnen und Schüler in öffentlichen Schulen von Basel, die in einem der Perimeter in Basel wohnhaft sind. Prognosejahre erkennt man am beistehenden Prognoseintervall. In den Prognosen nicht berücksichtigt sind künftige Arealentwicklungen.
        pub sus: Option<i64>,
        /// Unteres Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das untere Prognoseintervall bezeichnet die untere Grenze dieser Bandbreite.
        pub unteres_prognoseintervall: Option<String>,
        /// Oberes Prognoseintervall
        ///
        /// Das Prognoseintervall beschreibt die geschätzte Bandbreite, in welcher die tatsächliche Schülerzahl mit einer Wahrscheinlichkeit von 95% zu liegen kommen sollte. Das obere Prognoseintervall bezeichnet die obere Grenze dieser Bandbreite.
        pub oberes_prognoseintervall: Option<String>,
        /// Typ
        ///
        /// Ist-Wert oder Resultat der Prognose
        pub typ: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Perimeter ID
        pub perimeter_id: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Schuljahr,
        Nummer,
        Perimeter,
        Schulstufe,
        Sus,
        UnteresPrognoseintervall,
        OberesPrognoseintervall,
        Typ,
        PerimeterId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schuljahr => "schuljahr",
                Field::Nummer => "nummer",
                Field::Perimeter => "perimeter",
                Field::Schulstufe => "schulstufe",
                Field::Sus => "sus",
                Field::UnteresPrognoseintervall => "unteres_prognoseintervall",
                Field::OberesPrognoseintervall => "oberes_prognoseintervall",
                Field::Typ => "typ",
                Field::PerimeterId => "perimeter_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100121/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Velo-Fahrverbote (allgemein oder tempor\u{e4}r)"]
#[doc = ""]
#[doc = "Der Velostadtplan zeigt dir passende Routen zu deinem Ziel und liefert Ideen, wohin du mit deinem Velo besonders gut fahren kannst. Er ist die elektronische Version der faltbaren Papierkarte, die im Buchhandel, bei Basel Tourismus, Pro Velo und Veloplus erh\u{e4}ltlich ist."]
pub mod velo_fahrverbote_allgemein_oder_temporaer {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        pub objid: Option<String>,
        /// ID_VERBOT
        pub id_verbot: Option<i64>,
        /// GEOMETRY1_
        pub geometry1: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        IdVerbot,
        Geometry1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::IdVerbot => "id_verbot",
                Field::Geometry1 => "geometry1",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100035/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Elternberatung"]
#[doc = ""]
#[doc = "Elternberatung ist ein niederschwelliges Beratungsangebot f\u{fc}r Eltern mit kleinen Kindern ab Geburt bis zum Eintritt in den Kindergarten. Zentrale Aufgabe ist die Pr\u{e4}vention und Gesundheitsf\u{f6}rderung im Fr\u{fc}hbereich."]
pub mod elternberatung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id_el: Option<i64>,
        /// Standortname
        ///
        /// Bezeichnung des Standortes
        pub std_name: Option<String>,
        /// Strasse
        ///
        /// Strassename und Hausnummer
        pub strasse_nr: Option<String>,
        /// Postleitzahl
        ///
        /// 4 bis 5-stellige Postleitzahl
        pub plz: Option<i64>,
        /// Ort
        ///
        /// Gemeinde
        pub ort: Option<String>,
        /// Kanton
        ///
        /// Name des Kanton
        pub kanton: Option<String>,
        /// Telefon
        ///
        /// Telefonnummer
        pub telefon: Option<String>,
        /// Link Homepage
        ///
        /// Adresse der Website
        pub link_hp: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdEl,
        StdName,
        StrasseNr,
        Plz,
        Ort,
        Kanton,
        Telefon,
        LinkHp,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdEl => "id_el",
                Field::StdName => "std_name",
                Field::StrasseNr => "strasse_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Telefon => "telefon",
                Field::LinkHp => "link_hp",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100020/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Temperatur Grundwasser: Langj\u{e4}hrige Statistiken"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die absoluten extremalen Messwerte (kleinster Wert \u{201e}10YMin\u{201c} bzw. gr\u{f6}sster Wert \u{201e}10YMax\u{201c}) und den Mittelwert aller Messwerte (\u{201e}Mean\u{201c}) der Grundwassertemperaturen in \u{b0}C des kantonalen Grundwassermessnetzes und in der angegebenen Periode (startStatist bis endStatist, d.h. i. d. R. 10 Jahre).</p><p>Weitere Informationen: <a href=\"https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html\">https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html</a></p>"]
pub mod temperatur_grundwasser_langjaehrige_statistiken {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationId
        ///
        /// Identifikationsnummer
        pub stationid: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// 10YMin
        ///
        /// kleinster Messwert (nach 10 Jahren)
        pub x10ymin: Option<f64>,
        /// 10YMean
        ///
        /// Mittelwert aller Messwerte (nach 10 Jahren)
        pub x10ymean: Option<f64>,
        /// 10YMax
        ///
        /// grösster Messwert (nach 10 Jahren)
        pub x10ymax: Option<f64>,
        /// startStatist
        ///
        /// Start Messung
        pub startstatist: Option<String>,
        /// endStatist
        ///
        /// Ende Messung
        pub endstatist: Option<String>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_start_timestamp: Option<OffsetDateTime>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_end_timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Stationnr,
        Stationid,
        Stationname,
        Sensornr,
        Sensname,
        Lat,
        Lon,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        X10ymin,
        X10ymean,
        X10ymax,
        Startstatist,
        Endstatist,
        BohrkatasterLink,
        StatStartTimestamp,
        StatEndTimestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Stationnr => "stationnr",
                Field::Stationid => "stationid",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::X10ymin => "10ymin",
                Field::X10ymean => "10ymean",
                Field::X10ymax => "10ymax",
                Field::Startstatist => "startstatist",
                Field::Endstatist => "endstatist",
                Field::BohrkatasterLink => "bohrkataster_link",
                Field::StatStartTimestamp => "stat_start_timestamp",
                Field::StatEndTimestamp => "stat_end_timestamp",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100181/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmung vom 13. Februar 2022"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate der Volksabstimmungen vom 13. Februar 2022 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p><a href=\"https://data.bs.ch/explore/dataset/100071\"></a></p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im Kantonsblatt des Kantons Basel-Stadt publiziert werden.</p>"]
pub mod kennzahlen_der_abstimmung_vom_13_februar_2022 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<f64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage
        ///
        /// Stimmbeteiligung: Durchschnitt pro Art der Vorlage. Berechnet als Summe der abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen dieser Art, geteilt durch das Total der Stimmberechtigten
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage
        ///
        /// Anteil brieflich Stimmender: Durchschnitt pro Art der Vorlage. Berechnet als Summe der brieflich abgegebenen Stimmen pro Vorlage einer Art durch die Anzahl der Vorlagen einer Art, geteilt durch das Total der abgegebenen Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        pub abst_typ: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        GemeinName,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AbstTitel,
        AbstArt,
        AbstDatum,
        ResultArt,
        AbstId,
        AnteilJaStimmen,
        GemeinId,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        StimmberAnzM,
        StimmberAnzF,
        AbstTyp,
        AbstIdTitel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::GemeinName => "gemein_name",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AbstTitel => "abst_titel",
                Field::AbstArt => "abst_art",
                Field::AbstDatum => "abst_datum",
                Field::ResultArt => "result_art",
                Field::AbstId => "abst_id",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::GemeinId => "gemein_id",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::AbstTyp => "abst_typ",
                Field::AbstIdTitel => "abst_id_titel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100169/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Entsorgungsstellen"]
#[doc = ""]
#[doc = "Der Bev\u{f6}lkerung werden die verschiedenen Entsorgungsstellen f\u{fc}r ihre Abf\u{e4}lle und Wertstoffe angezeigt. Sie erhalten zudem die Informationen, was, wann und wie sie diese entsorgen k\u{f6}nnen."]
pub mod entsorgungsstellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_ENTSORG
        pub id_entsorg: Option<i64>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// NAME
        pub name: Option<String>,
        /// BESCHREIBU
        pub beschreibu: Option<String>,
        /// ADRESSE
        pub adresse: Option<String>,
        /// PLZ
        pub plz: Option<String>,
        /// ORTSCHAFT
        pub ortschaft: Option<String>,
        /// TELEFON
        pub telefon: Option<String>,
        /// OEFFNUNGSZ
        pub oeffnungsz: Option<String>,
        /// LINK
        pub www_link: Option<String>,
        /// ZUSTAENDIG
        pub zustaendig: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdEntsorg,
        Kategorie,
        Name,
        Beschreibu,
        Adresse,
        Plz,
        Ortschaft,
        Telefon,
        Oeffnungsz,
        WwwLink,
        Zustaendig,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdEntsorg => "id_entsorg",
                Field::Kategorie => "kategorie",
                Field::Name => "name",
                Field::Beschreibu => "beschreibu",
                Field::Adresse => "adresse",
                Field::Plz => "plz",
                Field::Ortschaft => "ortschaft",
                Field::Telefon => "telefon",
                Field::Oeffnungsz => "oeffnungsz",
                Field::WwwLink => "www_link",
                Field::Zustaendig => "zustaendig",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100021/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Hundesignalisation: Orte mit Leinenpflicht oder Hundeverbot"]
#[doc = ""]
#[doc = "Der Plan zeigt \u{d6}rtlichkeiten, an welchen eine Leinenpflicht oder ein Hundeverbot gilt."]
pub mod hundesignalisation_orte_mit_leinenpflicht_oder_hundeverbot {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Eindeutiger Identifikator
        pub id: Option<i64>,
        /// Einschränkung
        ///
        /// Beschreibung der Einschränkung
        pub einschraen: Option<String>,
        /// Einschränkungsnummer
        ///
        /// Identifikator der Art der Einschränkung
        pub einschrnr: Option<i64>,
        /// Datum von
        ///
        /// Startdatum der Einschränkung
        #[serde(with = "time::serde::iso8601::option")]
        pub datumvon: Option<OffsetDateTime>,
        /// Datum bis
        ///
        /// Enddatum der Einschränkung
        #[serde(with = "time::serde::iso8601::option")]
        pub datumbis: Option<OffsetDateTime>,
        /// Bemerkung
        ///
        /// Bemerkung zur Fläche
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Einschraen,
        Einschrnr,
        Datumvon,
        Datumbis,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Einschraen => "einschraen",
                Field::Einschrnr => "einschrnr",
                Field::Datumvon => "datumvon",
                Field::Datumbis => "datumbis",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100023/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Scheidungen nach Scheidungsdatum, Ehedauer sowie Alter und Staatsangeh\u{f6}rigkeit der ehemaligen Ehepartner"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Scheidungen im Kanton Basel-Stadt nach Scheidungsdatum, Ehedauer sowie nach Alter und Staatsangeh\u{f6}rigkeit der Frau bzw. des Mannes. Die Daten werden j\u{e4}hrlich aktualisiert. Vor dem Jahr 1984 ist nur das Total der Scheidungen verf\u{fc}gbar. <br><br>Im Jahr 2000 trat ein neues Scheidungsrecht in Kraft. Im Jahr 2010 wurde dieses angepasst. <br><br>Bis zum Jahr 2006 wurde eine Scheidung in Basel-Stadt gez\u{e4}hlt, wenn die klagende Partei in Basel-Stadt Wohnsitz hatte. Seit dem Jahr 2007 wird eine Scheidung in Basel-Stadt gez\u{e4}hlt, wenn der Mann Wohnsitz in Basel-Stadt hat, oder wenn er im Ausland und die Frau in Basel-Stadt lebt. <br><br>Die hier ver\u{f6}ffentlichten Werte k\u{f6}nnen aus methodischen Gr\u{fc}nden von denjenigen in der \u{f6}ffentlichen Statistik abweichen: In Letzterer werden nachtr\u{e4}glich gemeldete Scheidungen im letzten noch nicht abgeschlossenen Jahr gez\u{e4}hlt. In diesem Datensatz werden sie im Jahr des Scheidungsdatums gez\u{e4}hlt..<br><br>Quelle: Statistik der nat\u{fc}rlichen Bev\u{f6}lkerungsbewegung (BEVNAT) des Bundesamtes f\u{fc}r Statistik (BFS)."]
pub mod scheidungen_nach_scheidungsdatum_ehedauer_sowie_alter_und_staatsangehoerigkeit_der_ehemaligen_ehepartner {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Scheidungsdatum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub scheidungsdatum: Option<Date>,
        /// Jahr
        ///
        /// Scheidungsjahr
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Scheidungsmonat
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Laufnummer der Scheidungswoche im Jahr
        pub woche_in_jahr: Option<i64>,
        /// Datum Wochenstart
        ///
        /// Datum des Montags der Scheidungswoche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_wochenstart_scheidungsdatum: Option<Date>,
        /// Tag in Jahr
        ///
        /// Laufnummer des Tages im Jahr
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Alter der Frau
        ///
        /// Alter der Frau in vollendeten Jahren
        pub persalter_frau_vollendet: Option<String>,
        /// Alter des Mannes
        ///
        /// Alter des Mannes in vollendeten Jahren
        pub persalter_mann_vollendet: Option<String>,
        /// Staatsangehörigkeit der Frau
        ///
        /// Staatsangehörigkeit der Frau (Schweiz/Ausland)
        pub nationalitaet_frau: Option<String>,
        /// Staatsangehörigkeit des Mannes
        ///
        /// Staatsangehörigkeit des Mannes (Schweiz/Ausland)
        pub nationalitaet_mann: Option<String>,
        /// Ehedauer
        ///
        /// Ehedauer in vollendeten Jahren
        pub jahreehedauer_vollendet: Option<i64>,
        /// Anzahl
        ///
        /// Anzahl Scheidungen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Scheidungsdatum,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartScheidungsdatum,
        TagInJahr,
        Wochentag,
        PersalterFrauVollendet,
        PersalterMannVollendet,
        NationalitaetFrau,
        NationalitaetMann,
        JahreehedauerVollendet,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Scheidungsdatum => "scheidungsdatum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartScheidungsdatum => "datum_wochenstart_scheidungsdatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::PersalterFrauVollendet => "persalter_frau_vollendet",
                Field::PersalterMannVollendet => "persalter_mann_vollendet",
                Field::NationalitaetFrau => "nationalitaet_frau",
                Field::NationalitaetMann => "nationalitaet_mann",
                Field::JahreehedauerVollendet => "jahreehedauer_vollendet",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100139/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Buvetten in Gew\u{e4}ssern\u{e4}he"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt Informationen zu den gew\u{e4}ssernahen Buvetten, welche z.B. auf der Karte in der BachApp verzeichnet sind.\u{a0}</p>"]
pub mod buvetten_in_gewaessernaehe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Name
        ///
        /// Name der Buvette
        pub name: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Name,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Name => "name",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100283/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kinder- und Jugendangebote"]
#[doc = ""]
#[doc = "Die offene Kinder- und Jugendarbeit (OKJA) ist ein Freizeitangebot f\u{fc}r Kindern ab 5 Jahren bis jungen Erwachsenen im Alter von bis 25 Jahren. Sie umfasst Angebote wie Jugendzentren, mobile Jugendarbeit, Abenteuerspielpl\u{e4}tze oder Spielmobile. Spezifisches Charakteristikum ist, dass die Angebote offen, freiwillig und partizipativ organisiert sind."]
pub mod kinder_und_jugendangebote {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_KJ
        pub id_kj: Option<i64>,
        /// KI_ANGEBOT
        pub ki_angebot: Option<String>,
        /// JU_ANGEBOT
        pub ju_angebot: Option<String>,
        /// TRAEGER
        pub traeger: Option<String>,
        /// ANGEBOT
        pub angebot: Option<String>,
        /// STRASSE_NR
        pub strasse_nr: Option<String>,
        /// PLZ
        pub plz: Option<i64>,
        /// ORT
        pub ort: Option<String>,
        /// KANTON
        pub kanton: Option<String>,
        /// LINK
        pub link: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdKj,
        KiAngebot,
        JuAngebot,
        Traeger,
        Angebot,
        StrasseNr,
        Plz,
        Ort,
        Kanton,
        Link,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdKj => "id_kj",
                Field::KiAngebot => "ki_angebot",
                Field::JuAngebot => "ju_angebot",
                Field::Traeger => "traeger",
                Field::Angebot => "angebot",
                Field::StrasseNr => "strasse_nr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Kanton => "kanton",
                Field::Link => "link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100024/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Staatsangeh\u{f6}rigkeit und Bezirk"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet Angaben zur Wohnbev\u{f6}lkerung des Kantons Basel-Stadt am Jahresende nach Staatsangeh\u{f6}rigkeit (Schweiz/Ausland) und Kantonsb\u{fc}rgerschaft auf Ebene Bezirk. Personen an administrativen Meldeadressen sind nicht ber\u{fc}cksichtigt. An administrativen Meldeadressen sind Personen aus administrativen Gr\u{fc}nden gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB)."]
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_bezirk {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// BEZ_NAME
        pub bez_name: Option<String>,
        /// Bezirk
        pub bezirk: Option<String>,
        /// BEZ_LABEL
        pub bez_label: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// WOV_NAME
        pub wov_name: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_al: Option<i64>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub gesbev_f: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        BezName,
        Bezirk,
        BezLabel,
        WovId,
        WovName,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BezName => "bez_name",
                Field::Bezirk => "bezirk",
                Field::BezLabel => "bez_label",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100061/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): Fallzahlen ganze Schweiz"]
#[doc = ""]
#[doc = "<p style=\"margin-bottom: 1em; background-color: rgb(244, 245, 246);\"><font face=\"Arial, Helvetica, sans-serif\"><span style=\"font-size: 14px;\">This dataset is based on the <a href=\"https://github.com/openZH/covid_19\" target=\"_blank\">Github repository organized by OpenZH</a>, its contents are filled by employees of the Cantons and volunteers based on official sources. Data for Basel-Stadt are inserted by <a href=\"https://opendata.bs.ch\" target=\"_blank\">Fachstelle f\u{fc}r OGD Basel-Stadt</a> based on the official website of Canton Basel-Stadt. The dataset is refreshed from github every hour, 5 minutes past the hour. Geographical data for the cantons has been added by Opendatasoft in order to produce visualisations.\u{a0}</span></font><br/></p><table class=\"table table-bordered\" style=\"width: 881px; font-family: Arial, Helvetica, sans-serif; font-size: 14px; background-color: rgb(244, 245, 246);\"><tbody><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Field Name</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Description</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Format</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Note<br/></td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">update</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Date and time of notification</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">\u{a0}YYYY-MM-DD-HH-MM</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\"><br/></td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">name<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Name of the reporting canton<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Text<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\"><br/></td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">abbreviation_canton_and_fl</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Abbreviation of the reporting canton</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Text</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\"><br/></td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">ncumul_tested</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of tests performed as of date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Irrespective of canton of residence</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">ncumul_conf</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of confirmed cases as of date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Only cases that reside in the current canton</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">current_hosp (formerly ncumul_hosp) *<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of hospitalised patients on date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Irrespective of canton of residence</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">current_icu (formerly ncumul_icu) *<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of hospitalised patients in ICUs on date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Irrespective of canton of residence</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">current_vent(formerly ncumul_vent) *<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of patients requiring ventilation on date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Irrespective of canton of residence</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">ncumul_released</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of patients released from hospitals or reported recovered as of date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Irrespective of canton of residence</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">ncumul_deceased</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Reported number of deceased as of date</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Only cases that reside in the current canton</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">new_hosp *<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number of new hospitalisations since last date<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Number<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Irrespective of canton of residence</td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">source</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Source of the information</td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">URL link<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\"><br/></td></tr><tr><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">geo_point_2d<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">Geographical centroid of the canton<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\">geo_point_2d<br/></td><td style=\"padding: 0.25em; border-color: rgb(238, 238, 238);\"><br/></td></tr></tbody></table><p style=\"font-family: Arial, Helvetica, sans-serif; margin-bottom: 1em; font-size: 14px; background-color: rgb(244, 245, 246);\"><br/></p><p style=\"font-family: Arial, Helvetica, sans-serif; margin-bottom: 1em; font-size: 14px; background-color: rgb(244, 245, 246);\">*<em>These variables were affected by the format change on April 9th, 2020, which consists in:</em></p><p style=\"font-family: Arial, Helvetica, sans-serif; margin-bottom: 0px; font-size: 14px; background-color: rgb(244, 245, 246);\"><em>- new variable \"new_hosp\"<br/>- variables \"ncumul_hosp\", \"ncumul_icu\", \"ncumul_vent\" have been renamed to \"current_hosp\", \"current_icu\", \"current_vent\", to fit with their nature.<br/>To ensure compatibility with already made dashboards or reuses, these fields have been duplicated to avoid errors when their old names are used; but we strongly recommand to replace their old names by the new as soon as possible.</em></p>"]
pub mod coronavirus_covid_19_fallzahlen_ganze_schweiz {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Date
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Last update
        ///
        /// the precise update time is not always known
        #[serde(with = "time::serde::iso8601::option")]
        pub update: Option<OffsetDateTime>,
        /// Canton
        pub name: Option<String>,
        /// Cumulative number of tests
        ///
        /// cumulative
        pub ncumul_tested: Option<i64>,
        /// Cumulative number of confirmed cases
        ///
        /// cumulative
        pub ncumul_conf: Option<i64>,
        /// Number of new hospitalisations since last day
        pub new_hosp: Option<i64>,
        /// Current number of hospitalised patients
        ///
        /// at the given date
        pub current_hosp: Option<i64>,
        /// Current number of hospitalised patients in ICUs
        ///
        /// at the given date
        pub current_icu: Option<i64>,
        /// Current number of patients requiring ventilation
        ///
        /// at the given date
        pub current_vent: Option<i64>,
        /// Cumulative number of patients released from hospital or recovered
        ///
        /// cumulative
        pub ncumul_released: Option<i64>,
        /// Cumulative number of deceased
        ///
        /// cumulative
        pub ncumul_deceased: Option<i64>,
        /// Number of hospitalised patients in ICUs
        ///
        /// DUPLICATE FOR COMPATIBILITY
        pub ncumul_icu: Option<i64>,
        /// Number of hospitalised patients
        ///
        /// DUPLICATE FOR COMPATIBILITY
        pub ncumul_hosp: Option<i64>,
        /// Number of patients requiring ventilation
        ///
        /// DUPLICATE FOR COMPATIBILITY
        pub ncumul_vent: Option<i64>,
        /// Current number of isolated persons
        pub current_isolated: Option<i64>,
        /// Current number of quarantined persons
        pub current_quarantined: Option<i64>,
        /// Source
        pub source: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Canton abbreviation
        pub abbreviation_canton_and_fl: Option<String>,
        /// Current number of quarantined persons coming from risk areas
        pub current_quarantined_riskareatravel: Option<i64>,
        /// Current quarantined persons (total)
        pub current_quarantined_total: Option<i64>,
        /// Official code Kanton
        pub kan_code: Option<String>,
        /// Official Name Kanton
        pub kan_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        Update,
        Name,
        NcumulTested,
        NcumulConf,
        NewHosp,
        CurrentHosp,
        CurrentIcu,
        CurrentVent,
        NcumulReleased,
        NcumulDeceased,
        NcumulIcu,
        NcumulHosp,
        NcumulVent,
        CurrentIsolated,
        CurrentQuarantined,
        Source,
        AbbreviationCantonAndFl,
        CurrentQuarantinedRiskareatravel,
        CurrentQuarantinedTotal,
        KanCode,
        KanName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Update => "update",
                Field::Name => "name",
                Field::NcumulTested => "ncumul_tested",
                Field::NcumulConf => "ncumul_conf",
                Field::NewHosp => "new_hosp",
                Field::CurrentHosp => "current_hosp",
                Field::CurrentIcu => "current_icu",
                Field::CurrentVent => "current_vent",
                Field::NcumulReleased => "ncumul_released",
                Field::NcumulDeceased => "ncumul_deceased",
                Field::NcumulIcu => "ncumul_icu",
                Field::NcumulHosp => "ncumul_hosp",
                Field::NcumulVent => "ncumul_vent",
                Field::CurrentIsolated => "current_isolated",
                Field::CurrentQuarantined => "current_quarantined",
                Field::Source => "source",
                Field::AbbreviationCantonAndFl => "abbreviation_canton_and_fl",
                Field::CurrentQuarantinedRiskareatravel => "current_quarantined_riskareatravel",
                Field::CurrentQuarantinedTotal => "current_quarantined_total",
                Field::KanCode => "kan_code",
                Field::KanName => "kan_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100077/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Statistische Raumeinheiten: Bezirke"]
#[doc = ""]
#[doc = "Die Bezirke sind Untereinheiten der Wohnviertel. Jedes Wohnviertel mit Ausnahme von Klybeck und Kleinh\u{fc}ningen ist in 2 bis 8 Bezirke unterteilt. Insgesamt werden auf dem gesamten Kantonsgebiet 69 Bezirke unterschieden.\n\nStatistische Nummerierung:\nDie Nummerierung der Bezirke setzt sich zusammen aus der zweistelligen Wohnviertel-Nr. und der einstelligen Bezirks-Nr. (im Label durch einen Punkt getrennt):\n- Beispiel f\u{fc}r den Bezirk Flora (1) im Wohnviertel Matth\u{e4}us (17): BEZ_ID 171, die Bezeichnung (BEZ_Label) lautet 17.1\n- Beispiel f\u{fc}r das Wohnviertel Kleinh\u{fc}ningen ohne Bezirke (19.0): BEZ_ID 190, die Bezeichnung (BEZ_Label) lautet 19.0"]
pub mod statistische_raumeinheiten_bezirke {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BEZ_ID
        pub bez_id: Option<String>,
        /// BEZ_LABEL
        pub bez_label: Option<String>,
        /// BEZ_NAME
        pub bez_name: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        BezId,
        BezLabel,
        BezName,
        WovId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::BezId => "bez_id",
                Field::BezLabel => "bez_label",
                Field::BezName => "bez_name",
                Field::WovId => "wov_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100039/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geschwindigkeitsmonitoring: Einzelmessungen von 2021 bis 2023"]
#[doc = ""]
#[doc = "<p></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Einzelmessungen des\nGeschwindigkeitsmonitorings der Kantonspolizei Basel-Stadt vom Jahr 2021 bis und mit Jahr 2023 (Zeitpunkt des Beginns der Messung).\u{a0}<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Bei den dargestellten\nDaten handelt es sich ausschliesslich um statistische Erhebungen. Diese stehen\nnicht in einem Zusammenhang mit Ordnungsbussen oder einer strafrechtlichen\nVerfolgung. Die statistischen Geschwindigkeitsmessungen dienen der Kantonspolizei\nBasel-Stadt zur \u{dc}berpr\u{fc}fung der Geschwindigkeit sowie der Verkehrssicherheit\n(z.B. Sicherheit an Fussg\u{e4}ngerstreifen) an der betreffenden \u{d6}rtlichkeit. Die\nErgebnisse dienen zur Entscheidung, an welchen \u{d6}rtlichkeiten Handlungsbedarf in\nForm von Geschwindigkeitskontrollen besteht. Jedes Statistikger\u{e4}t besitzt eine\neinzige Punktgeometrie und ist meist mit zwei Richtungen versehen (Richtung 1\nund 2).<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Hinweis: Die\nMessungen sind nicht zwingend repr\u{e4}sentativ f\u{fc}r das ganze Jahr und m\u{fc}ssen im\nKontext des Erhebungsdatums betrachtet werden. Dar\u{fc}ber hinaus wurden gewisse\nMessungen w\u{e4}hrend einer ausserordentlichen Verkehrsf\u{fc}hrung (z.B.\nUmleitungsverkehr infolge von Baustellent\u{e4}tigkeiten etc.) erhoben.\nManipulationen an Ger\u{e4}ten k\u{f6}nnen zu fehlerhaften Messungen f\u{fc}hren.<o:p></o:p></span></p><p>\n\n\n\n\n\n</p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Zum\nGeschwindigkeitsmonitoring sind folgende Datens\u{e4}tze vorhanden:<o:p></o:p></span></p><ul><li>Einzelmessungen ab 2024:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100097\" target=\"_blank\">https://data.bs.ch/explore/dataset/100097</a><a href=\"https://data.bs.ch/explore/dataset/100097\" target=\"_blank\"></a></li><li>Einzelmessungen von 2021 bis 2023 (dieser Datensatz):\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100358\" target=\"_blank\">https://data.bs.ch/explore/dataset/100358</a></li><li>Einzelmessungen bis 2020:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100200\" target=\"_blank\">https://data.bs.ch/explore/dataset/100200</a></li><li>Kennzahlen pro Mess-Standort:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100112\" target=\"_blank\">https://data.bs.ch/explore/dataset/100112</a>\u{a0}</li></ul>Aufgrund der grossen Datenmenge kann es vorkommen, dass der Datensatz nicht vollst\u{e4}ndig heruntergeladen werden kann. Falls dieses Problem auftritt, kann man den vollst\u{e4}ndigen Datensatz und die Einzelmessungen der Messstationen hier herunterladen:<p></p><ul><li>vollst\u{e4}ndiger Datensatz:\u{a0}<a href=\"https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/all_data/geschwindigkeitsmonitoring_data.csv\">https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/all_data/geschwindigkeitsmonitoring_data.csv</a></li><li>Einzelmessungen der Messstationen:\u{a0}<a href=\"https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/data/\">https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/data/</a></li></ul><p>Die Mess-Standorte werden auch auf dem Geoportal Basel-Stadt publiziert:\u{a0}<a \"=\"\" href=\"https://map.geo.bs.ch/s/geschwindigkeit\" target=\"_blank\">https://map.geo.bs.ch/s/geschwindigkeit</a></p>"]
pub mod geschwindigkeitsmonitoring_einzelmessungen_von_2021_bis_2023 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Timestamp
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit in km/h
        pub geschwindigkeit: Option<f64>,
        /// Zeit
        ///
        /// Uhrzeit (hh:mm:ss) einer gemessenen Fahrt
        pub zeit: Option<String>,
        /// Datum
        pub datum: Option<String>,
        /// Datum und Zeit
        ///
        /// Datum und Uhrzeit als Text formatiert
        pub datum_zeit: Option<String>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<f64>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Übertretungsquote
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit überschritten haben
        pub ue_quote: Option<f64>,
        /// Geschwindigkeit V50
        ///
        /// Höchstgeschwindigkeit, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50: Option<f64>,
        /// Geschwindigkeit V85
        ///
        /// Höchstgeschwindigkeit, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85: Option<f64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge während einer Messung
        pub fzg: Option<i64>,
        /// Fahrzeuglänge
        ///
        /// Vom Radar gemessene Fahrzeuglänge
        pub fahrzeuglange: Option<f64>,
        /// Kennzahlen pro Mess-Standort
        ///
        /// Link zum nach der aktuellen Messung gefilterten Datensatz "Kennzahlen pro Mess-Standort"
        pub link_zu_messung: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        MessungId,
        RichtungId,
        Geschwindigkeit,
        Zeit,
        Datum,
        DatumZeit,
        Messbeginn,
        Messende,
        Zone,
        Ort,
        Richtung,
        UeQuote,
        V50,
        V85,
        Strasse,
        StrasseNr,
        Fzg,
        Fahrzeuglange,
        LinkZuMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::MessungId => "messung_id",
                Field::RichtungId => "richtung_id",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Zeit => "zeit",
                Field::Datum => "datum",
                Field::DatumZeit => "datum_zeit",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Zone => "zone",
                Field::Ort => "ort",
                Field::Richtung => "richtung",
                Field::UeQuote => "ue_quote",
                Field::V50 => "v50",
                Field::V85 => "v85",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Fzg => "fzg",
                Field::Fahrzeuglange => "fahrzeuglange",
                Field::LinkZuMessung => "link_zu_messung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100358/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Fischereistatistik Basel-Stadt"]
#[doc = ""]
#[doc = "<p>Die Fischereistatistik enth\u{e4}lt alle Fische, die aus Gew\u{e4}ssern des Kantons Basel-Stadt entnommen worden sind. F\u{e4}nge invasiver Schwarzmeergrundeln (Schwarzmundgrundeln und Kesslergrundeln) werden separat registriert.\u{a0}</p><p>Die Karte der verschiedenen Gew\u{e4}sser gibt einen Hinweis auf die Orte, an denen gefischt wird. Es kann aus ihr nicht abgeleitet werden, wo das Fischen nicht erlaubt ist.\u{a0}</p><p>Die Daten werden j\u{e4}hrlich erg\u{e4}nzt.</p>"]
pub mod fischereistatistik_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr des Fangs
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr: Option<Date>,
        /// Jahr und Monat
        ///
        /// Jahr und Monat des Fangs
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub monat: Option<Date>,
        /// Fischereikarte
        ///
        /// Fischereikarte: https://www.aue.bs.ch/wasser/fischen-basler-rheinknie/fischereikarten.html
        pub fischereikarte: Option<String>,
        /// Gewässer
        ///
        /// Gewässer, wo der Fisch gefangen worden ist
        pub gewasser: Option<String>,
        /// Fischart
        ///
        /// Art des gefangenen Fisches
        pub fischart: Option<String>,
        /// Länge
        ///
        /// Länge des gefangenen Fisches
        pub lange: Option<f64>,
        /// Kesslergrundel
        ///
        /// Anzahl der gefangenen Kesslergrundeln
        pub kesslergrundel: Option<i64>,
        /// Schwarzmundgrundel
        ///
        /// Anzahl der gefangenen Schwarzmundgrundeln
        pub schwarzmundgrundel: Option<i64>,
        /// Geo Shape Gewässer
        pub geo_shape: Option<GeoJson>,
        /// Laufnummer
        pub laufnummer: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        Fischereikarte,
        Gewasser,
        Fischart,
        Lange,
        Kesslergrundel,
        Schwarzmundgrundel,
        Laufnummer,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Fischereikarte => "fischereikarte",
                Field::Gewasser => "gewasser",
                Field::Fischart => "fischart",
                Field::Lange => "lange",
                Field::Kesslergrundel => "kesslergrundel",
                Field::Schwarzmundgrundel => "schwarzmundgrundel",
                Field::Laufnummer => "laufnummer",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100193/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Staatsangeh\u{f6}rigkeit und Block"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet Angaben zur Wohnbev\u{f6}lkerung des Kantons Basel-Stadt am Jahresende nach Staatsangeh\u{f6}rigkeit (Schweiz/Ausland) und Kantonsb\u{fc}rgerschaft auf Ebene Block. Personen an administrativen Meldeadressen sind nicht ber\u{fc}cksichtigt. An administrativen Meldeadressen sind Personen aus administrativen Gr\u{fc}nden gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB). Aus Datenschutzgr\u{fc}nden werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen."]
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_block {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Block
        pub block: Option<String>,
        /// BLO_LABEL
        pub blo_label: Option<String>,
        /// BEZ_ID
        pub bez_id: Option<String>,
        /// BEZ_NAME
        pub bez_name: Option<String>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// WOV_NAME
        pub wov_name: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anzahl_al: Option<i64>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen. Aus Datenschutzgründen werden nur Raumeinheiten mit mindestens 4 Einwohnern ausgewiesen.
        pub gesbev_f: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Block,
        BloLabel,
        BezId,
        BezName,
        WovId,
        WovName,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Block => "block",
                Field::BloLabel => "blo_label",
                Field::BezId => "bez_id",
                Field::BezName => "bez_name",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100062/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kantonsblatt"]
#[doc = ""]
#[doc = "<p>Das Kantonsblatt ist das offizielle Publikationsorgan des Kantons Basel-Stadt. Darin werden Meldungen (Gesetze, Verordnungen, Staatsvertr\u{e4}ge usw.) des Grossen Rats, des Regierungsrats und der Verwaltung ver\u{f6}ffentlicht. Im vorliegenden Datensatz sind die aktuellen \u{fc}ber das offizielle API des Kantonsblatts beziehbaren Meldungen in Tabellenform enthalten.\u{a0}</p><p>Bitte beachten Sie auch die Datenschutzerkl\u{e4}rung des Kantonsblattes und die Hinweise zur Rechtsg\u{fc}ltigkeit der Meldungen unter\u{a0}<a href=\"https://kantonsblatt.ch/tenant-kabbs#!/search/info/privacy-policy\" target=\"_blank\">https://kantonsblatt.ch/tenant-kabbs#!/search/info/privacy-policy</a>.\u{a0}</p>"]
pub mod kantonsblatt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Rubrik
        pub rubric_de: Option<String>,
        /// Rubrik-Code
        ///
        /// Code der Rubrik
        pub rubric: Option<String>,
        /// Unterrubrik
        pub subrubric_de: Option<String>,
        /// Unterrubrik-Code
        ///
        /// Code der Unterrubrik
        pub subrubric: Option<String>,
        /// Veröffentlichungsdatum
        ///
        /// Datum, an dem die Veröffentlichung im Kantonsblatt für die Öffentlichkeit zugänglich gemacht wurde.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub publicationdate: Option<Date>,
        /// Öffentlich einsehbar bis
        ///
        /// Das Dokument kann nur bis zum angegebenen Datum aufgerufen werden.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub expirationdate: Option<Date>,
        /// Sprache
        pub language: Option<String>,
        /// Publizierende Stelle
        ///
        /// Name der publizierenden Stelle
        pub registrationofficedisplayname: Option<String>,
        /// ID - Publizierende Stelle
        ///
        /// Identifikationsnummer der publizierenden Stelle
        pub registrationofficeid: Option<String>,
        /// Strasse
        ///
        /// Strasse der publizierenden Stelle
        pub registrationofficestreet: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer der publizierenden Stelle
        pub registrationofficestreetnumber: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl der publizierenden Stelle
        pub registrationofficeswisszipcode: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinde der publizierenden Stelle
        pub registrationofficetown: Option<String>,
        /// Postfachverfügbarkeit
        ///
        /// Hat die publizierende Stelle ein Postfach? "True" bedeutet Ja, "False" bedeutet Nein.
        pub registrationofficecontainspostofficebox: Option<String>,
        /// Postfachnummer
        pub registrationofficepostofficeboxnumber: Option<String>,
        /// Postfach PLZ
        ///
        /// Postfach Postleitzahl
        pub registrationofficepostofficeboxswisszipcode: Option<String>,
        /// Postfach Gemeinde
        pub registrationofficepostofficeboxtown: Option<String>,
        /// Veröffentlichungs-ID
        ///
        /// Eindeutige Identifikationsnummer der Veröffentlichung. Wird im Gegensatz zur Meldungsnummer für API-Aufrufe und URL benötigt
        pub id: Option<String>,
        /// Meldungsnummer
        ///
        /// Nummer zugehörig zur Veröffentlichung
        pub publicationnumber: Option<String>,
        /// Status
        ///
        /// Nur PUBLISHED (veröffentlicht) vorhanden
        pub publicationstate: Option<String>,
        /// primärer Mandant - Code
        ///
        /// Code des primären veröffentlichenden Amtsblattes
        pub primarytenantcode: Option<String>,
        /// primärer Mandant
        ///
        /// primäres veröffentlichendes Amtsblatt
        pub primarytenantname: Option<String>,
        /// Im Auftrag von
        ///
        /// Name des Auftraggebers
        pub onbehalfof: Option<String>,
        /// Rechtliche Hinweise
        pub legalremedy: Option<String>,
        /// Kantone
        ///
        /// Kürzel der beteiligten Kantone
        pub cantons: Option<String>,
        /// Weitere Mandanten - Code
        ///
        /// Code der zusätzlichen Mandanten, getrennt durch Komma
        pub secondarytenantstenantcode: Option<String>,
        /// Weitere Mandanten
        ///
        /// Zusätzliche Mandanten, getrennt durch Komma
        pub secondarytenantstenantname: Option<String>,
        /// Veröffentlichungsdaten weiterer Mandanten
        ///
        /// Das Veröffentlichungsdatum weiterer Mandanten. In der gleichen Reihenfolge wie in der Spalte "Weitere Mandanten" aufgeführt.
        pub secondarytenantspublicationdate: Option<String>,
        /// Mehrfache Veröffentlichungen
        ///
        /// Falls die Veröffentlichung mehrmals getätigt wurde, werden hier die zugehörigen Meldungsnummern aufgeführt.
        pub repeatedpublicationspublicationnumber: Option<String>,
        /// Veröffentlichungsdaten anderer Veröffentlichungen
        ///
        /// Falls die Veröffentlichung mehrmals getätigt wurde, werden hier die anderen Veröffentlichungsdaten aufgeführt. In der gleichen Reihenfolge wie in der Spalte "Mehrfache Veröffentlichungen" aufgeführt.
        pub repeatedpublicationspublicationdate: Option<String>,
        /// Webansicht
        ///
        /// Webansicht der Veröffentlichung auf der Webseite von www.kantonsblatt.ch (generiert mit Veröffentlichungs-ID)
        pub url_kantonsblatt: Option<String>,
        /// PDF-Dokument
        ///
        /// Downloadlink für die Veröffentlichung als PDF (generiert mit Veröffentlichungs-ID)
        pub url_pdf: Option<String>,
        /// XML-Datei
        ///
        /// Downloadlink für die Veröffentlichung als XML-Datei  (generiert mit Veröffentlichungs-ID)
        pub url_xml: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        RubricDe,
        Rubric,
        SubrubricDe,
        Subrubric,
        Publicationdate,
        Expirationdate,
        Language,
        Registrationofficedisplayname,
        Registrationofficeid,
        Registrationofficestreet,
        Registrationofficestreetnumber,
        Registrationofficeswisszipcode,
        Registrationofficetown,
        Registrationofficecontainspostofficebox,
        Registrationofficepostofficeboxnumber,
        Registrationofficepostofficeboxswisszipcode,
        Registrationofficepostofficeboxtown,
        Id,
        Publicationnumber,
        Publicationstate,
        Primarytenantcode,
        Primarytenantname,
        Onbehalfof,
        Legalremedy,
        Cantons,
        Secondarytenantstenantcode,
        Secondarytenantstenantname,
        Secondarytenantspublicationdate,
        Repeatedpublicationspublicationnumber,
        Repeatedpublicationspublicationdate,
        UrlKantonsblatt,
        UrlPdf,
        UrlXml,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::RubricDe => "rubric_de",
                Field::Rubric => "rubric",
                Field::SubrubricDe => "subrubric_de",
                Field::Subrubric => "subrubric",
                Field::Publicationdate => "publicationdate",
                Field::Expirationdate => "expirationdate",
                Field::Language => "language",
                Field::Registrationofficedisplayname => "registrationofficedisplayname",
                Field::Registrationofficeid => "registrationofficeid",
                Field::Registrationofficestreet => "registrationofficestreet",
                Field::Registrationofficestreetnumber => "registrationofficestreetnumber",
                Field::Registrationofficeswisszipcode => "registrationofficeswisszipcode",
                Field::Registrationofficetown => "registrationofficetown",
                Field::Registrationofficecontainspostofficebox => {
                    "registrationofficecontainspostofficebox"
                }
                Field::Registrationofficepostofficeboxnumber => {
                    "registrationofficepostofficeboxnumber"
                }
                Field::Registrationofficepostofficeboxswisszipcode => {
                    "registrationofficepostofficeboxswisszipcode"
                }
                Field::Registrationofficepostofficeboxtown => "registrationofficepostofficeboxtown",
                Field::Id => "id",
                Field::Publicationnumber => "publicationnumber",
                Field::Publicationstate => "publicationstate",
                Field::Primarytenantcode => "primarytenantcode",
                Field::Primarytenantname => "primarytenantname",
                Field::Onbehalfof => "onbehalfof",
                Field::Legalremedy => "legalremedy",
                Field::Cantons => "cantons",
                Field::Secondarytenantstenantcode => "secondarytenantstenantcode",
                Field::Secondarytenantstenantname => "secondarytenantstenantname",
                Field::Secondarytenantspublicationdate => "secondarytenantspublicationdate",
                Field::Repeatedpublicationspublicationnumber => {
                    "repeatedpublicationspublicationnumber"
                }
                Field::Repeatedpublicationspublicationdate => "repeatedpublicationspublicationdate",
                Field::UrlKantonsblatt => "url_kantonsblatt",
                Field::UrlPdf => "url_pdf",
                Field::UrlXml => "url_xml",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100352/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kunst im \u{f6}ffentlichen Raum"]
#[doc = ""]
#[doc = "\u{dc}berblick \u{fc}ber die \u{f6}ffentlichen Kunstwerke im Eigentum des Kantons Basel-Stadt. Es wird unterschieden zwischen Kunst im \u{f6}ffentlichen Raum (Ki\u{f6}R), die sich auf der Allmend befindet, und Kunst und Bau (KuB), die in Geb\u{e4}uden oder auf den Parzellen von \u{f6}ffentlichen Geb\u{e4}uden zu finden sind."]
pub mod kunst_im_oeffentlichen_raum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Inventar-Nummer
        ///
        /// Eindeutiger Identifikator, Inventar-Nummer
        pub id_invnr: Option<String>,
        /// Gruppe
        ///
        /// Gruppe zur Unterteilung in Kunst und Bau (KuB) und Kunst im öffentlichen Raum (KiöR)
        pub gruppe: Option<String>,
        /// Fotonummer
        ///
        /// Dateiname des Fotos
        pub fotonummer: Option<String>,
        /// Kunstschaffende
        ///
        /// Name der Kunstschaffende
        pub ku_name: Option<String>,
        /// Werktitel
        ///
        /// Titel des Kunstwerks
        pub werktitel: Option<String>,
        /// Datierung
        ///
        /// Datierung des Kunstwerks
        pub datierung: Option<String>,
        /// Standort
        ///
        /// Adresse und genauer Standortbeschrieb des Kunstwerks
        pub standort: Option<String>,
        /// PDF
        ///
        /// Dateiname des PDFs
        pub pdf: Option<String>,
        /// Rückbau
        ///
        /// ist das Werk zurückgebaut
        pub rueckbau: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
        /// Foto-Downloadlink
        ///
        /// Downloadlink
        pub foto_downloadlink: Option<File>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdInvnr,
        Gruppe,
        Fotonummer,
        KuName,
        Werktitel,
        Datierung,
        Standort,
        Pdf,
        Rueckbau,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdInvnr => "id_invnr",
                Field::Gruppe => "gruppe",
                Field::Fotonummer => "fotonummer",
                Field::KuName => "ku_name",
                Field::Werktitel => "werktitel",
                Field::Datierung => "datierung",
                Field::Standort => "standort",
                Field::Pdf => "pdf",
                Field::Rueckbau => "rueckbau",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100214/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Umfrage \u{ab}digitale Mitwirkung\u{bb} 2020"]
#[doc = ""]
#[doc = "<p>Im Auftrag der Staatskanzlei Basel-Stadt wurden 1000 im Kanton Basel-Stadt wohnhafte Schweizer Staatsb\u{fc}rgerinnen und Staatsb\u{fc}rger ab 16 Jahren zum Thema \u{ab}digitale Mitwirkung\u{bb} befragt. Die Umfrage wurde Anfang des Jahres 2020 durchgef\u{fc}hrt und fand in Form eines computergest\u{fc}tzten Telefoninterviews statt.<br/><br/>Dieser Datensatz beinhaltet die Antworten der 1000 befragten Personen. Offene Fragen wurden kategorisiert. Aus Gr\u{fc}nden des Datenschutzes werden das Alter und die h\u{f6}chste abgeschlossene Bildung der Befragten zu Gruppen zusammengefasst und auf die Bekanntgabe des Wohnquartiers verzichtet. Zudem wurden in der Variable\u{a0}\u{ab}Parteibindung\u{bb}\u{a0}nicht im Grossen Rat vertretene Parteien (Stand 6.5.2020) zusammengefasst.</p><p>Eine Abschrift des Interviews finden Sie hier:\u{a0}<a href=\"http://data-bs.ch/staatskanzlei/Umfrage-digitale-mitwirkung/2020/Fragebogen_digitale-Mitwirkung_OpenData.pdf\" target=\"_blank\">http://data-bs.ch/staatskanzlei/Umfrage-digitale-mitwirkung/2020/Fragebogen_digitale-Mitwirkung_OpenData.pdf</a>.</p><p>Den Bericht von gfs Bern zur Umfrage k\u{f6}nnen Sie hier herunterladen:\u{a0}<a href=\"https://www.digitale-mitbestimmung.bs.ch/dam/jcr:96cfb1f0-96f8-4ec0-bbf1-3f566daa1247/2020-Bevoelkerungsbefragung-Digitalisierung-und-Politik-Kanton-Basel-Stadt.pdf\">https://www.digitale-mitbestimmung.bs.ch/dam/jcr:96cfb1f0-96f8-4ec0-bbf1-3f566daa1247/2020-Bevoelkerungsbefragung-Digitalisierung-und-Politik-Kanton-Basel-Stadt.pdf</a></p><p>Weitere Informationen zur digitalen Mitwirkung in Basel-Stadt finden Sie hier: <a _blank\"=\"\" href=\"https://www.digitale-mitbestimmung.bs.ch\" target=\"_blank\">https://www.digitale-mitbestimmung.bs.ch</a>.</p>"]
pub mod umfrage_digitale_mitwirkung_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Altersgruppe
        ///
        /// Darf ich fragen, wie alt Sie sind?
        pub altersgruppe: Option<String>,
        /// An CH-Wahlen 2019 teilgenommen
        ///
        /// Im Oktober 2019 wurde das Schweizer Parlament neu gewählt: Haben Sie an den Wahlen teilgenommen?
        pub w92a: Option<String>,
        /// Parteibindung
        ///
        /// Welche Liste oder Partei haben Sie gewählt bzw. von welcher Partei haben Sie am meisten Kandidatinnen und Kandidaten unterstützt? Unter «nicht im Grossen Rat vertretene Partei» sind die folgenden Nennungen summiert: CSP, BDP, Alternative Linke, Alternative Liste, PdA, solidarität, EDU.
        pub partei: Option<String>,
        /// Teilnahme an künftigen Abstimmungen über politische Fragen in BS
        ///
        /// Wenn in den nächsten 5 Jahren im Kanton Basel-Stadt insgesamt 10 Mal über politische Fragen abgestimmt würde, an wie vielen dieser Abstimmungen werden Sie vermutlich teilnehmen?
        pub verhal: Option<String>,
        /// Ausbildung
        ///
        /// Welche Schule haben Sie selber zuletzt besucht resp. was für eine Berufsausbildung haben Sie? Obligatorische Schule bzw. Sekundarstufe I enthält die Antworten «keine», «Primar-Real-Sekundarschule». Sekundarstuffe II enthält die Antworten «Berufslehere-Berufsschule-KV-Gewerbeschule», «Maturitätsschule, Gymnasium, LehrerInnenseminar, Berufsmaturität». Tertiärstufe enthält die Antworten «Höhere Fach- oder Berufsausbildung, Kunstgewerbeschule», «Höhere Fachschule (z.B. HTL, HWV)», «Technische Hochschulen (ETH), Fachhochschule (FHS)», «Universität».
        pub bildung: Option<String>,
        /// Gewichtung
        ///
        /// Gewichtung der Antwort
        pub gewdef: Option<f64>,
        /// Geschlecht
        ///
        /// Geschlecht des/der Befragten
        pub s11: Option<String>,
        /// CH Staatsbürgerschaft
        ///
        /// Haben Sie die Schweizer Staatsbürgerschaft?
        pub stimm: Option<String>,
        /// Interesse an politischen Fragen
        ///
        /// Ganz allgemein gesprochen, wie sehr sind Sie an politischen Fragen interessiert? Sind Sie…
        pub bast1: Option<String>,
        /// Interesse an der Auswirkung von technologischen Entwicklungen
        ///
        /// Und wie sehr sind Sie an Fragen zur Auswirkung von technologischen Entwicklungen auf unser Alltagsleben interessiert? Sind Sie…
        pub bast2: Option<String>,
        /// Haltung zur Digitalisierung
        ///
        /// Wie stehen Sie zum Thema Digitalisierung? Fühlen sie sich vom rasanten technischen Wandel und der Digitalisierung überhaupt nicht überfordert, teilweise überfordert oder stark überfordert?
        pub bast3: Option<String>,
        /// Bedeutung Digitalisierung für gesellsch. Austausch
        ///
        /// Die Digitalisierung und das Internet haben grosse Auswirkungen auf die Art und Weise, wie wir zusammenleben. Ich nenne Ihnen nun drei separate Bereiche. Bitte sagen Sie mir jeweils, ob die Digitalisierung für Sie in diesen Bereichen primär eine Chance oder primär ein Risiko darstellt, oder ob weder noch der Fall ist. --- Für den gesellschaftlichen und sozialen Austausch unter den Menschen
        pub bast5_1: Option<String>,
        /// Bedeutung Digitalisierung für polit. Mitbestimmung
        ///
        /// Die Digitalisierung und das Internet haben grosse Auswirkungen auf die Art und Weise, wie wir zusammenleben. Ich nenne Ihnen nun drei separate Bereiche. Bitte sagen Sie mir jeweils, ob die Digitalisierung für Sie in diesen Bereichen primär eine Chance oder primär ein Risiko darstellt, oder ob weder noch der Fall ist. --- Für die politische Mitbestimmung der Bürger und Bürgerinnen
        pub bast5_2: Option<String>,
        /// Bedeutung Digitalisierung für Individuum
        ///
        /// Die Digitalisierung und das Internet haben grosse Auswirkungen auf die Art und Weise, wie wir zusammenleben. Ich nenne Ihnen nun drei separate Bereiche. Bitte sagen Sie mir jeweils, ob die Digitalisierung für Sie in diesen Bereichen primär eine Chance oder primär ein Risiko darstellt, oder ob weder noch der Fall ist. --- Für Sie persönlich als Individuum
        pub bast5_3: Option<String>,
        /// eHealth
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Elektronische Speicherung und Verwaltung von Gesundheits- und Patientendaten (eHealth / elektronisches Patientendossier?)
        pub bast6_1: Option<String>,
        /// e-Banking
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Finanztransaktionen über das Internet (e-Banking)
        pub bast6_2: Option<String>,
        /// Steuererklärung online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Die Steuererklärung online Ausfüllen
        pub bast6_3: Option<String>,
        /// Abstimmen und Wählen online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Abstimmen und Wählen über das Internet
        pub bast6_5: Option<String>,
        /// Dokumente / Ausweise online bestellen
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Dokumente wie Ausweise bei Behörden bestellen und Administratives erledigen
        pub bast6_6: Option<String>,
        /// Referendum / Intitiative online unterschreiben
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Ein Referendum oder eine Volksinitiative im Internet unterschreiben
        pub bast6_7: Option<String>,
        /// Rückmeldung / Vorschäge an Verwaltung online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Über Dialogplattformen im Internet der Politik und der Verwaltung Rückmeldungen geben und Vorschläge einbringen
        pub bast6_8: Option<String>,
        /// Mitsprache in Stadt und Quartier online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Über das Internet neue Möglichkeiten zur Mitsprache in Stadt und Quartier nutzen
        pub bast6_9: Option<String>,
        /// Infos über PolitikerInnen online einholen
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Online Informationen über Politikerinnen und Politiker einholen (Smartvote)
        pub bast6_10: Option<String>,
        /// Politische Disussionen online
        ///
        /// Wir haben hier einige Dinge aufgelistet, die durch das Internet möglich sind. Sagen Sie mir bitte jeweils, ob Sie eine dieser Möglichkeiten des Internets bereits heute nutzen oder ob Sie sich auf jeden Fall vorstellen können, diese Dinge in Zukunft im Internet zu machen, unter gewissen Umständen dazu bereit sind, diese Dinge in Zukunft im Internet zu machen oder auf keinen Fall bereit sind, diese Dinge in Zukunft im Internet zu machen. --- Online an politischen Diskussionen teilnehmen und kommentieren
        pub bast6_11: Option<String>,
        /// Wählen / Abstimmen via Handy / Internet
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Wenn ich in Zukunft auch übers Handy oder übers Internet wählen und abstimmen könnte, würde ich öfter an Abstimmungen und Wahlen teilnehmen.
        pub bast7_1: Option<String>,
        /// Kosten sparen mit eVoting
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Indem in Zukunft auch elektronisch gewählt und abgestimmt werden kann, kann der Kanton Kosten sparen und effizienter arbeiten.
        ///3. Der Kanton Basel-Stadt soll in der Schweiz ein Vorreiter
        pub bast7_2: Option<String>,
        /// BS soll Vorreiter sein
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Der Kanton Basel-Stadt soll in der Schweiz ein Vorreiter bei der Nutzung des Internets für die politische Teilnahme sein.
        pub bast7_3: Option<String>,
        /// Informationen über mich
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Durch die Digitalisierung erhält der Staat noch mehr Informationen über mich, die er dann gegen mich verwenden kann.
        pub bast7_5: Option<String>,
        /// Manipulation einfacher
        ///
        /// Wir haben hier einige Aussagen zum Thema Digitalisierung und Politik zusammengestellt. Bitte sagen Sie mir jeweils, ob Sie damit sehr, eher, eher nicht oder überhaupt nicht einverstanden sind: --- Wahlen und Abstimmungen, die über das Internet durchgeführt werden, sind fehleranfälliger und einfacher zu manipulieren als Wahlen und Abstimmungen per Brief oder an der Urne.
        pub bast7_6: Option<String>,
        /// Vertrauen Urne
        ///
        /// Bei der politischen Mitbestimmung ist es wichtig, dass man darauf vertrauen kann, dass die eigene Stimme oder Meinung richtig gezählt wird. Wie gross ist Ihr Vertrauen bei den folgenden drei Möglichkeiten der politischen Mitbestimmung? Bitte sagen Sie mir das auf einer Skala von 0 (überhaupt kein Vertrauen) bis 10 (grösstes Vertrauen). --- politische Mitbestimmung an der Urne respektive vor Ort im Wahllokal
        pub bast8_1: Option<String>,
        /// Vertrauen Brief
        ///
        /// Bei der politischen Mitbestimmung ist es wichtig, dass man darauf vertrauen kann, dass die eigene Stimme oder Meinung richtig gezählt wird. Wie gross ist Ihr Vertrauen bei den folgenden drei Möglichkeiten der politischen Mitbestimmung? Bitte sagen Sie mir das auf einer Skala von 0 (überhaupt kein Vertrauen) bis 10 (grösstes Vertrauen). --- politische Mitbestimmung per Brief und Post
        pub bast8_2: Option<String>,
        /// Vertrauen Internet
        ///
        /// Bei der politischen Mitbestimmung ist es wichtig, dass man darauf vertrauen kann, dass die eigene Stimme oder Meinung richtig gezählt wird. Wie gross ist Ihr Vertrauen bei den folgenden drei Möglichkeiten der politischen Mitbestimmung? Bitte sagen Sie mir das auf einer Skala von 0 (überhaupt kein Vertrauen) bis 10 (grösstes Vertrauen). --- politische Mitbestimmung über das Internet
        pub bast8_3: Option<String>,
        /// Einführung eVoting BS
        ///
        /// Gemäss den Informationen, die Sie heute zum Thema haben, sind sehr, eher, eher nicht oder überhaupt nicht für die Einführung von eVoting im Kanton Basel-Stadt?
        pub bast10: Option<String>,
        /// Hauptgrund für eVoting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_01: Option<String>,
        /// Hauptgrund für eVoting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_02: Option<String>,
        /// Hauptgrund für eVoting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_03: Option<String>,
        /// Hauptgrund für eVoting 4
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast11_04: Option<String>,
        /// Hauptgrund gegen eVoting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_01: Option<String>,
        /// Hauptgrund gegen eVoting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_02: Option<String>,
        /// Hauptgrund gegen eVoting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_03: Option<String>,
        /// Hauptgrund gegen eVoting 4
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_04: Option<String>,
        /// Hauptgrund gegen eVoting 5
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eVoting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast12_05: Option<String>,
        /// eCollecting
        ///
        /// Eine weitere Idee, wie das Internet für die Demokratie genutzt werden kann ist eCollecting. Das heisst, dass in Zukunft Unterschriften für Petitionen und Volksinitiativen auch elektronisch abgegeben werden können. Wären Sie damit sehr einverstanden, eher einverstanden, eher nicht einverstanden oder überhaupt nicht einverstanden?
        pub bast13: Option<String>,
        /// Hauptgrund für eCollecting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast14_01: Option<String>,
        /// Hauptgrund für eCollecting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast14_02: Option<String>,
        /// Hauptgrund für eCollecting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute für die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast14_03: Option<String>,
        /// Hauptgrund gegen eCollecting 1
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_01: Option<String>,
        /// Hauptgrund gegen eCollecting 2
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_02: Option<String>,
        /// Hauptgrund gegen eCollecting 3
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_03: Option<String>,
        /// Hauptgrund gegen eCollecting 4
        ///
        /// Was ist der Hauptgrund, dass Sie heute gegen die Einführung von eCollecting im Kanton Basel-Stadt sind? (offene Frage)
        pub bast15_04: Option<String>,
        /// Prüfung Möglichkeiten Digitalisierung für polit. Mitbestimmung
        ///
        /// Die Behörden des Kantons Basel-Stadt möchten über die nächsten 2 Jahre zusammen mit den Einwohnerinnen und Einwohnern herausfinden, wie sich die Möglichkeiten der Digitalisierung und des Internets für die politische Mitbestimmung nutzen lässt. Finden Sie das eine sehr gute Idee, eine eher gute Idee, eher eine schlechte Idee oder eine sehr schlechte Idee?
        pub bast16: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 1
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_01: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 2
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_02: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 3
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_03: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 4
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_04: Option<String>,
        /// Politische Mitbestimmung in 10 Jahren 5
        ///
        /// Wenn Sie an Ihre politische Mitbestimmung denken, zum Beispiel wählen und abstimmen, wie könnte das in 10 Jahren aussehen? Was sind Ihre Wünsche und Ihre Bedenken? Bitte sagen Sie mit in wenigen Stichworten, was Ihnen als erstes in den Sinn kommt. (offene Frage)
        pub bast17_05: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Altersgruppe,
        W92a,
        Partei,
        Verhal,
        Bildung,
        Gewdef,
        S11,
        Stimm,
        Bast1,
        Bast2,
        Bast3,
        Bast51,
        Bast52,
        Bast53,
        Bast61,
        Bast62,
        Bast63,
        Bast65,
        Bast66,
        Bast67,
        Bast68,
        Bast69,
        Bast610,
        Bast611,
        Bast71,
        Bast72,
        Bast73,
        Bast75,
        Bast76,
        Bast81,
        Bast82,
        Bast83,
        Bast10,
        Bast1101,
        Bast1102,
        Bast1103,
        Bast1104,
        Bast1201,
        Bast1202,
        Bast1203,
        Bast1204,
        Bast1205,
        Bast13,
        Bast1401,
        Bast1402,
        Bast1403,
        Bast1501,
        Bast1502,
        Bast1503,
        Bast1504,
        Bast16,
        Bast1701,
        Bast1702,
        Bast1703,
        Bast1704,
        Bast1705,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Altersgruppe => "altersgruppe",
                Field::W92a => "w92a",
                Field::Partei => "partei",
                Field::Verhal => "verhal",
                Field::Bildung => "bildung",
                Field::Gewdef => "gewdef",
                Field::S11 => "s11",
                Field::Stimm => "stimm",
                Field::Bast1 => "bast1",
                Field::Bast2 => "bast2",
                Field::Bast3 => "bast3",
                Field::Bast51 => "bast5_1",
                Field::Bast52 => "bast5_2",
                Field::Bast53 => "bast5_3",
                Field::Bast61 => "bast6_1",
                Field::Bast62 => "bast6_2",
                Field::Bast63 => "bast6_3",
                Field::Bast65 => "bast6_5",
                Field::Bast66 => "bast6_6",
                Field::Bast67 => "bast6_7",
                Field::Bast68 => "bast6_8",
                Field::Bast69 => "bast6_9",
                Field::Bast610 => "bast6_10",
                Field::Bast611 => "bast6_11",
                Field::Bast71 => "bast7_1",
                Field::Bast72 => "bast7_2",
                Field::Bast73 => "bast7_3",
                Field::Bast75 => "bast7_5",
                Field::Bast76 => "bast7_6",
                Field::Bast81 => "bast8_1",
                Field::Bast82 => "bast8_2",
                Field::Bast83 => "bast8_3",
                Field::Bast10 => "bast10",
                Field::Bast1101 => "bast11_01",
                Field::Bast1102 => "bast11_02",
                Field::Bast1103 => "bast11_03",
                Field::Bast1104 => "bast11_04",
                Field::Bast1201 => "bast12_01",
                Field::Bast1202 => "bast12_02",
                Field::Bast1203 => "bast12_03",
                Field::Bast1204 => "bast12_04",
                Field::Bast1205 => "bast12_05",
                Field::Bast13 => "bast13",
                Field::Bast1401 => "bast14_01",
                Field::Bast1402 => "bast14_02",
                Field::Bast1403 => "bast14_03",
                Field::Bast1501 => "bast15_01",
                Field::Bast1502 => "bast15_02",
                Field::Bast1503 => "bast15_03",
                Field::Bast1504 => "bast15_04",
                Field::Bast16 => "bast16",
                Field::Bast1701 => "bast17_01",
                Field::Bast1702 => "bast17_02",
                Field::Bast1703 => "bast17_03",
                Field::Bast1704 => "bast17_04",
                Field::Bast1705 => "bast17_05",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100083/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Statistische Raumeinheiten: Wohnviertel "]
#[doc = ""]
#[doc = "Zum Kanton Basel-Stadt z\u{e4}hlen die Stadt Basel und die Gemeinden Riehen und Bettingen. Die Stadt Basel ist in 19 statistische Wohnviertel gegliedert. Diese statistische Raumeinteilungen existiert seit \u{fc}ber 100 Jahren unver\u{e4}ndert und erlaubt somit kleinr\u{e4}umige L\u{e4}ngsschnittanalysen des Kantons Basel-Stadt.\n\nStatistische Nummerierung:\nIm Gegensatz zum amtlichen Gemeindeverzeichnis der Schweiz wird f\u{fc}r r\u{e4}umliche Auswertungen auf Gemeinde-Ebene auf die Nummerierung der Wohnviertel zur\u{fc}ckgegriffen:\n- Die Stadt Basel (BFS-Code 2701) hat keine eigene Identifikationsnummer. Auswertungen beruhen auf einem Zusammenzug der 19 Wohnviertel, die von 01 bis 19 nummeriert sind.\n- Die Gemeinde Bettingen (BFS-Code 2702) hat die Wohnviertel-Nr. 20.\n- Die Gemeinde Riehen (BFS-Code 2703) hat die Wohnviertel-Nr. 30."]
pub mod statistische_raumeinheiten_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// WOV_ID
        pub wov_id: Option<String>,
        /// WOV_LABEL
        pub wov_label: Option<String>,
        /// WOV_NAME
        pub wov_name: Option<String>,
        pub gemeinde_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WovId,
        WovLabel,
        WovName,
        GemeindeName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WovId => "wov_id",
                Field::WovLabel => "wov_label",
                Field::WovName => "wov_name",
                Field::GemeindeName => "gemeinde_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100042/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wanderungen (Zuzug, Wegzug und Umzug) Kanton Basel-Stadt"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Anzahl Personen, die in den Kanton Basel-Stadt zuwanderten (Zuzug), aus dem Kanton Basel-Stadt abwanderten (Wegzug) oder innerhalb des Kantons umzogen (Umzug) nach Datum, Staatsangeh\u{f6}rigkeit, Geschlecht, Alter und Detailangaben zum Zuzugs- und Wegzugsort.<br>Die Wanderungsbewegungen sind seit 1985 verf\u{fc}gbar. Detailangaben der Zuzugs- und Wegzugsorte (Gemeinde, Kanton, Land) sind seit 2006 verf\u{fc}gbar.<br>Die hier ver\u{f6}ffentlichten Werte k\u{f6}nnen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik abweichen: In Letzterer werden nachtr\u{e4}glich gemeldete Wanderungsereignisse w\u{e4}hrend vier Monaten gesammelt, danach gelten die Zahlen als definitiv. Sp\u{e4}ter eintreffende Meldungen werden im letzten noch nicht abgeschlossenen Monat gez\u{e4}hlt. In diesem Datensatz werden sie im Monat des Wanderungsereignisses gez\u{e4}hlt."]
pub mod wanderungen_zuzug_wegzug_und_umzug_kanton_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wanderungstyp
        ///
        /// Typ der Wanderungsbewegung: Zuzug, Wegzug und Umzug
        pub ereignis_typ: Option<String>,
        /// Datum
        ///
        /// Datum der Wanderungsbewegung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Jahr
        ///
        /// Jahr der Wanderungsbewegung
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat der Wanderungbewegung
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Kalenderwoche der Wanderungsbewegung
        pub woche_in_jahr: Option<i64>,
        /// Startdatum Woche
        ///
        /// Datum des Montags der Woche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_wochenstart: Option<Date>,
        /// Tag-Nr.
        ///
        /// Laufnummer des Tages innerhalb eines Jahres
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Staatsangehörigkeit
        ///
        /// Staatsangehörigkeit der wandernden Person (Schweiz/Ausland)
        pub nationalitaet: Option<String>,
        /// Geschlecht
        ///
        /// M=männlich, W=weiblich
        pub geschlecht: Option<String>,
        /// Alter
        ///
        /// Alter der wandernden Person in vollendeten Jahren
        pub alter: Option<i64>,
        /// Aufenthaltsdauer in Jahren
        ///
        /// Zeitdauer vom letzten Zuzug nach Basel-Stadt bis zum Wegzug. Nur für wegziehende Personen vorhanden.
        pub aufenthaltsdauer_in_jahren: Option<i64>,
        /// Von Kontinent
        ///
        /// Kontinent, in dem die Wanderungsbewegung startet
        pub von_kontinent: Option<String>,
        /// Von Land
        ///
        /// Land, in dem die Wanderungsbewegung startet
        pub von_land: Option<String>,
        /// Von Kanton
        ///
        /// Kanton, in dem die Wanderungsbewegung startet. Nur für Schweiz bekannt.
        pub von_kanton: Option<String>,
        /// Von Gemeinde
        ///
        /// Gemeinde, in der die Wanderungsbewegung startet. Nur für Schweiz bekannt.
        pub von_gemeinde: Option<String>,
        /// Von Wohnviertel
        ///
        /// Wohnviertel, in dem die Wanderungsbewegung startet. Nur für Kanton Basel-Stadt bekannt.
        pub von_wohnviertel: Option<String>,
        /// Nach Kontinent
        ///
        /// Kontinent, in dem die Wanderungsbewegung endet
        pub nach_kontinent: Option<String>,
        /// Nach Land
        ///
        /// Land, in dem die Wanderungsbewegung endet
        pub nach_land: Option<String>,
        /// Nach Kanton
        ///
        /// Kanton, in dem die Wanderungsbewegung endet. Nur für Schweiz bekannt.
        pub nach_kanton: Option<String>,
        /// Nach Gemeinde
        ///
        /// Gemeinde, in der die Wanderungsbewegung endet. Nur für Schweiz bekannt.
        pub nach_gemeinde: Option<String>,
        /// Nach Wohnviertel
        ///
        /// Wohnviertel, in dem die Wanderungsbewegung endet. Nur für Kanton Basel-Stadt bekannt.
        pub nach_wohnviertel: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        EreignisTyp,
        Datum,
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstart,
        TagInJahr,
        Wochentag,
        Nationalitaet,
        Geschlecht,
        Alter,
        AufenthaltsdauerInJahren,
        VonKontinent,
        VonLand,
        VonKanton,
        VonGemeinde,
        VonWohnviertel,
        NachKontinent,
        NachLand,
        NachKanton,
        NachGemeinde,
        NachWohnviertel,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::EreignisTyp => "ereignis_typ",
                Field::Datum => "datum",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstart => "datum_wochenstart",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::Nationalitaet => "nationalitaet",
                Field::Geschlecht => "geschlecht",
                Field::Alter => "alter",
                Field::AufenthaltsdauerInJahren => "aufenthaltsdauer_in_jahren",
                Field::VonKontinent => "von_kontinent",
                Field::VonLand => "von_land",
                Field::VonKanton => "von_kanton",
                Field::VonGemeinde => "von_gemeinde",
                Field::VonWohnviertel => "von_wohnviertel",
                Field::NachKontinent => "nach_kontinent",
                Field::NachLand => "nach_land",
                Field::NachKanton => "nach_kanton",
                Field::NachGemeinde => "nach_gemeinde",
                Field::NachWohnviertel => "nach_wohnviertel",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100138/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Grossratswahlen nach Berufsgruppe seit 2020"]
#[doc = ""]
#[doc = "<p style=\"\">Dieser Datensatz zeigt die Kandidierenden der Grossratswahlen nach Berufsgruppe seit 2020<br></p>"]
pub mod kandidierende_der_grossratswahlen_nach_berufsgruppe_seit_2020 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Wahljahr
        pub wahljahr: Option<String>,
        /// Berufsgruppe
        pub berufsgruppe: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kandidierende in Berufsgruppe
        pub anzahl: Option<i64>,
        /// Anteil in %
        ///
        /// Anzahl Kandidierende in Berufsgruppe / Anzahl Kandidierende
        pub anteil: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Wahljahr,
        Berufsgruppe,
        Anzahl,
        Anteil,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Wahljahr => "wahljahr",
                Field::Berufsgruppe => "berufsgruppe",
                Field::Anzahl => "anzahl",
                Field::Anteil => "anteil",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100394/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Nachnamen der baselst\u{e4}dtischen Bev\u{f6}lkerung"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Wohnbev\u{f6}lkerung des Kantons Basel-Stadt nach Nachnamen. Die Daten werden j\u{e4}hrlich aktualisiert. Bei mehreren Nachnamen wird nur der erste ber\u{fc}cksichtigt, unabh\u{e4}ngig davon, ob die Nachnamen mit einem Bindestrich verbunden sind oder nicht. Nachnamen, die weniger als viermal vorkommen, werden in der Rubrik \'\u{dc}brige\' zusammengefasst. <br>Die hier ver\u{f6}ffentlichten Werte des Jahres 2011 weichen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik ab: In Letzterer wurde bis zum Jahr 2011 die Bev\u{f6}lkerungszahl durch Fortschreibung ermittelt. Seit dem Jahr 2012 basiert sie direkt auf Auswertungen aus dem kantonalen Einwohnerregister. Die hier ver\u{f6}ffentlichten Werte hingegen basieren seit 2011 auf Auswertungen aus dem Einwohnerregister."]
pub mod nachnamen_der_baselstaedtischen_bevoelkerung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Nachname
        pub nachname: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Nachname,
        Anzahl,
        Jahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Nachname => "nachname",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100127/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Baumkataster: F\u{e4}ll- und Baumersatzliste"]
#[doc = ""]
#[doc = "Der Baumkataster umfasst den durch die Stadtg\u{e4}rtnerei Basel (Gebiet Stadt Basel) und die Gemeinde Riehen (Gebiet Riehen) gepflegten Baumbestand. B\u{e4}ume sind im Kanton Basel-Stadt gem\u{e4}ss Baumschutzgesetz (BSchG) gesch\u{fc}tzt. Die F\u{e4}ll- und Baumersatzliste enth\u{e4}lt diejenigen gesch\u{fc}tzten B\u{e4}ume, welche innerhalb der n\u{e4}chsten 6 Monate gef\u{e4}llt, ersetzt und neu gepflanzt werden m\u{fc}ssen. F\u{e4}llungen werden jeweils im Winterhalbjahr vorgenommen.\n"]
pub mod baumkataster_faell_und_baumersatzliste {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// Baumnummer
        ///
        /// Eindeutige Nummer des Baums
        pub baumnr: Option<String>,
        /// Baumart
        ///
        /// Botanische und deutsche Bezeichnung der Baumart
        pub art: Option<String>,
        /// Baumart lateinisch
        ///
        /// Botanische Bezeichnung der Baumart
        pub baumart_lateinisch: Option<String>,
        /// Baumart deutsch
        ///
        /// Deutsche Bezeichnung der Baumart
        pub baumart_deutsch: Option<String>,
        /// ID_Schutzstatus
        ///
        /// ID des Schutzstatus
        pub id_schutzs: Option<i64>,
        /// Schutzstatus
        ///
        /// Beschreibung des Schutzstatus: "Geschützt (Umfang)": Geschützt wegen gemessenem Baumumfang. "Gemäss Baumschutzgesetz (BSchG)": Baumumfang wurde nicht unbedingt aktuell gemessen, Baum wurde trotzdem konservativ als geschützt eingeteilt. "Geschützt (Ersatzpflanzung)": Aktueller Baum ist geschützt, da er einen vormalig geschützten Baum ersetzt.
        pub schutzstat: Option<String>,
        /// Strasse
        ///
        /// Strasse des Baumstandortes
        pub strasse: Option<String>,
        /// Ersatzart
        ///
        /// Baumart des geplanten Ersatzbaums
        pub ersatzart: Option<String>,
        /// Ersatzdatum
        ///
        /// Datum des geplanten Ersatzes
        pub ersatzdatu: Option<String>,
        /// Ersatzort
        ///
        /// Standort des geplanten Ersatzbaums
        pub ersatzort: Option<String>,
        /// Stammumfang
        pub stammumfan: Option<i64>,
        /// Fällgrund
        ///
        /// Grund für die Fällung des Baums
        pub faellgrund: Option<String>,
        /// Fällgrund - weitere Informationen
        ///
        /// Weitergehende Informationen zur Fällung des Baums
        pub faellgrun1: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Baumnr,
        Art,
        BaumartLateinisch,
        BaumartDeutsch,
        IdSchutzs,
        Schutzstat,
        Strasse,
        Ersatzart,
        Ersatzdatu,
        Ersatzort,
        Stammumfan,
        Faellgrund,
        Faellgrun1,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Baumnr => "baumnr",
                Field::Art => "art",
                Field::BaumartLateinisch => "baumart_lateinisch",
                Field::BaumartDeutsch => "baumart_deutsch",
                Field::IdSchutzs => "id_schutzs",
                Field::Schutzstat => "schutzstat",
                Field::Strasse => "strasse",
                Field::Ersatzart => "ersatzart",
                Field::Ersatzdatu => "ersatzdatu",
                Field::Ersatzort => "ersatzort",
                Field::Stammumfan => "stammumfan",
                Field::Faellgrund => "faellgrund",
                Field::Faellgrun1 => "faellgrun1",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100054/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Leerstehende Wohnungen"]
#[doc = ""]
#[doc = "Als Leerwohnung gilt eine Wohnung, welche am Stichtag (1. Juni) unbesetzt, aber bewohnbar ist und zur dauernden Miete von mindestens drei Monaten oder zum Verkauf angeboten wird. Folgende Wohnungen gelten nicht als Leerwohnungen: a) unbesetzt, aber bereits vermietet oder verkauft; b) unbesetzt, aber nicht zur Miete oder zum Verkauf angeboten; c) nicht mehr als Wohnung (Arztpraxen etc.) angeboten; d) einem beschr\u{e4}nkten Personenkreis vorbehalten (z.B. Dienstwohnung); e) aus bau-, sanit\u{e4}tspolizeilichen oder richterlichen Gr\u{fc}nden gesperrt; f) f\u{fc}r weniger als drei Monate angeboten."]
pub mod leerstehende_wohnungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Wohnviertel-ID
        ///
        /// ID des Wohnviertels
        pub wov_id: Option<String>,
        /// Wohnviertel
        ///
        /// Name des Wohnviertels
        pub wov_name: Option<String>,
        /// Bezirk-ID
        ///
        /// ID des Wohnbezirks
        pub wohnbezirk_id: Option<i64>,
        /// Bezirk Label
        ///
        /// Label des Bezirks
        pub bez_label: Option<String>,
        /// Bezirk
        ///
        /// Name des Wohnbezirks
        pub bez_name: Option<String>,
        /// Total Leerstand
        ///
        /// Gesamtzahl leerstehender Wohnungen nach Bezirk und Zimmerzahl
        pub total: Option<i64>,
        /// Anzahl Zimmer
        ///
        /// Zimmerzahl der Wohnung: Halbe Zimmer werden nicht ausgewiesen
        pub zimmerzahl_ganzzahlig: Option<i64>,
        /// Wohnfläche bis 30m2
        ///
        /// Wohnfläche beträgt bis 30 Quadratmeter
        pub wfl_min_30m2: Option<i64>,
        /// Wohnfläche 31 bis 50m2
        ///
        /// Wohnfläche beträgt 31 bis 50 Quadratmeter
        pub wfl_31m2_50m2: Option<i64>,
        /// Wohnfläche 51 bis 70m2
        ///
        /// Wohnfläche beträgt 51 bis 70 Quadratmeter
        pub wfl_51m2_70m2: Option<i64>,
        /// Wohnfläche 71 bis 90m2
        ///
        /// Wohnfläche beträgt 71 bis 90 Quadratmeter
        pub wfl_71m2_90m2: Option<i64>,
        /// Wohnfläche 91 bis 110m2
        ///
        /// Wohnfläche beträgt 91 bis 110 Quadratmeter
        pub wfl_91m2_110m2: Option<i64>,
        /// Wohnfläche 111 bis 130m2
        ///
        /// Wohnfläche beträgt 111 bis 130 Quadratmeter
        pub wfl_111m2_130m2: Option<i64>,
        /// Wohnfläche ab 131m2
        ///
        /// Wohnfläche beträgt ab 131 Quadratmeter
        pub wfl_131m2_max: Option<i64>,
        /// Wohnfläche unbekannt
        ///
        /// Wohnfläche der Wohnung ist unbekannt
        pub wfl_unbekannt: Option<i64>,
        /// Gebäudetyp EFH
        ///
        /// Gebäudetyp Einfamilienhaus
        pub gb_efh: Option<i64>,
        /// Gebäudetyp MFH
        ///
        /// Gebäudetyp Mehrfamilienhaus
        pub gb_mfh: Option<i64>,
        /// Gebäudetyp gemischte Nutzung
        ///
        /// Gebäudetyp gemischte Nutzung: Gewerbe- und Wohnnutzung im gleichen Gebäude
        pub gb_gemischte_nutzung: Option<i64>,
        /// Gebäudetyp andere
        ///
        /// Anderer Gebäudetyp: Mehrfamilienhaus oder gemischte Nutzung
        pub gb_andere: Option<i64>,
        /// Bauperiode bis 1920
        ///
        /// Bauperiode des Gebäudes bis 1920
        pub pd_min_1920: Option<i64>,
        /// Bauperiode 1921 bis 1950
        ///
        /// Bauperiode des Gebäudes von 1921 bis 1950
        pub pd_1921_1950: Option<i64>,
        /// Bauperiode 1951 bis 1980
        ///
        /// Bauperiode des Gebäudes von 1951 bis 1980
        pub pd_1951_1980: Option<i64>,
        /// Bauperiode 1981 bis 2010
        ///
        /// Bauperiode des Gebäudes von 1981 bis 2010
        pub pd_1981_2010: Option<i64>,
        /// Bauperiode ab 2011
        ///
        /// Bauperiode des Gebäudes ab 2011
        pub pd_2011_max: Option<i64>,
        /// Renovationsstatus renoviert
        ///
        /// Wohnung wurde renoviert, umgebaut oder totalsaniert in den letzten 2 Jahren
        pub rn_renoviert: Option<i64>,
        /// Renovationsstatus nicht renoviert
        ///
        /// Wohnung wurde nicht renoviert in den letzten 2 Jahren
        pub rn_nicht_renoviert: Option<i64>,
        /// Renovationsstatus neu gebaut
        ///
        /// Wohnung wurde neu gebaut in den letzten 2 Jahren
        pub rn_neu_gebaut: Option<i64>,
        /// Angebotsart Miete
        ///
        /// Wohnung wird nur zur Miete angeboten
        pub ang_miete: Option<i64>,
        /// Angebotsart Kauf
        ///
        /// Wohnung wird nur zum Kauf angeboten
        pub ang_kauf: Option<i64>,
        /// Angebotsart Miete und Kauf
        ///
        /// Wohnung wird zum Kauf und zur Miete angeboten
        pub ang_miete_kauf: Option<i64>,
        /// Nettomiete CHF bis 1000
        pub p_min_1000: Option<i64>,
        /// Nettomiete CHF 1001 bis 1250
        pub p_1001_1250: Option<i64>,
        /// Nettomiete CHF 1251 bis 1500
        pub p_1251_1500: Option<i64>,
        /// Nettomiete CHF 1501 bis 1750
        pub p_1501_1750: Option<i64>,
        /// Nettomiete CHF 1751 bis 2000
        pub p_1751_2000: Option<i64>,
        /// Nettomiete CHF 2001 bis 2250
        pub p_2001_2250: Option<i64>,
        /// Nettomiete CHF 2251 bis 2500
        pub p_2251_2500: Option<i64>,
        /// Nettomiete CHF 2501 bis 2750
        pub p_2501_2750: Option<i64>,
        /// Nettomiete CHF 2751 bis 3000
        pub p_2751_3000: Option<i64>,
        /// Nettomiete CHF 3001 bis 3250
        pub p_3001_3250: Option<i64>,
        /// Nettomiete CHF 3251 bis 3500
        pub p_3251_3500: Option<i64>,
        /// Nettomiete unbekannt
        ///
        /// Nettomiete ist unbekannt
        pub p_unbekannt: Option<i64>,
        /// Nettomiete CHF ab 3501
        pub p_3501_max: Option<i64>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        WovId,
        WovName,
        WohnbezirkId,
        BezLabel,
        BezName,
        Total,
        ZimmerzahlGanzzahlig,
        WflMin30m2,
        Wfl31m250m2,
        Wfl51m270m2,
        Wfl71m290m2,
        Wfl91m2110m2,
        Wfl111m2130m2,
        Wfl131m2Max,
        WflUnbekannt,
        GbEfh,
        GbMfh,
        GbGemischteNutzung,
        GbAndere,
        PdMin1920,
        Pd19211950,
        Pd19511980,
        Pd19812010,
        Pd2011Max,
        RnRenoviert,
        RnNichtRenoviert,
        RnNeuGebaut,
        AngMiete,
        AngKauf,
        AngMieteKauf,
        PMin1000,
        P10011250,
        P12511500,
        P15011750,
        P17512000,
        P20012250,
        P22512500,
        P25012750,
        P27513000,
        P30013250,
        P32513500,
        PUnbekannt,
        P3501Max,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::WohnbezirkId => "wohnbezirk_id",
                Field::BezLabel => "bez_label",
                Field::BezName => "bez_name",
                Field::Total => "total",
                Field::ZimmerzahlGanzzahlig => "zimmerzahl_ganzzahlig",
                Field::WflMin30m2 => "wfl_min_30m2",
                Field::Wfl31m250m2 => "wfl_31m2_50m2",
                Field::Wfl51m270m2 => "wfl_51m2_70m2",
                Field::Wfl71m290m2 => "wfl_71m2_90m2",
                Field::Wfl91m2110m2 => "wfl_91m2_110m2",
                Field::Wfl111m2130m2 => "wfl_111m2_130m2",
                Field::Wfl131m2Max => "wfl_131m2_max",
                Field::WflUnbekannt => "wfl_unbekannt",
                Field::GbEfh => "gb_efh",
                Field::GbMfh => "gb_mfh",
                Field::GbGemischteNutzung => "gb_gemischte_nutzung",
                Field::GbAndere => "gb_andere",
                Field::PdMin1920 => "pd_min_1920",
                Field::Pd19211950 => "pd_1921_1950",
                Field::Pd19511980 => "pd_1951_1980",
                Field::Pd19812010 => "pd_1981_2010",
                Field::Pd2011Max => "pd_2011_max",
                Field::RnRenoviert => "rn_renoviert",
                Field::RnNichtRenoviert => "rn_nicht_renoviert",
                Field::RnNeuGebaut => "rn_neu_gebaut",
                Field::AngMiete => "ang_miete",
                Field::AngKauf => "ang_kauf",
                Field::AngMieteKauf => "ang_miete_kauf",
                Field::PMin1000 => "p_min_1000",
                Field::P10011250 => "p_1001_1250",
                Field::P12511500 => "p_1251_1500",
                Field::P15011750 => "p_1501_1750",
                Field::P17512000 => "p_1751_2000",
                Field::P20012250 => "p_2001_2250",
                Field::P22512500 => "p_2251_2500",
                Field::P25012750 => "p_2501_2750",
                Field::P27513000 => "p_2751_3000",
                Field::P30013250 => "p_3001_3250",
                Field::P32513500 => "p_3251_3500",
                Field::PUnbekannt => "p_unbekannt",
                Field::P3501Max => "p_3501_max",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100010/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gesundheitsversorgung (GSV): Pflegeheime"]
#[doc = ""]
#[doc = "Im vorliegenden Datensatz sind Eintr\u{e4}ge mit dem Attribut \"Heimname\" zu finden, bei denen der Wert \"Alle Pflegeheime\" verwendet wird. Diese Bezeichnung dient dazu, Daten zu aggregieren, die die Gesamtheit aller Pflegeheime repr\u{e4}sentieren. Nutzer sollten beachten, dass der Eintrag \"Alle Pflegeheime\" unter \"Heimname\" eine kollektive Perspektive auf die Daten darstellt."]
pub mod gesundheitsversorgung_gsv_pflegeheime {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr der Erhebung
        pub jahr: Option<String>,
        /// ID-Nummer
        ///
        /// Identifikationsnummer des Pflegeheims
        pub id: Option<i64>,
        /// Pflegeheimname
        ///
        /// Name des Pflegeheims
        pub name: Option<String>,
        /// Pflegeplätze
        ///
        /// Anzahl der Pflegeplätze des Pflegeheims
        pub anzahl_pflegeplaetze: Option<i64>,
        /// Pensions- und Pflegetage
        ///
        /// Anzahl der Pensions- und Pflegetage des Pflegeheims
        pub anzahl_pensions_pflegetage: Option<i64>,
        /// Auslastung
        ///
        /// Prozentuale Auslastung des jeweiligens Pflegeheims
        pub auslastung: Option<f64>,
        /// Pflegestufe
        ///
        /// Durchschnittliche Pflegestufe des Pflegeheims
        pub pflegestufe: Option<f64>,
        /// Kosten Pension
        ///
        /// Total der Kosten für Pension und Betreuung
        pub kosten_pension_betreuung: Option<f64>,
        /// KVG-Pflegekosten
        ///
        /// Total der Kosten, die über das Krankenversicherungsgesetz (KVG) abgerechnet wurden.
        pub kvg_pflegekosten: Option<f64>,
        /// Erträge Taxeinnahmen
        ///
        /// Erträge der Taxeinnahmen
        pub ertraege_taxeinnahmen: Option<f64>,
        /// Geopunkte
        pub geopunkte: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Id,
        Name,
        AnzahlPflegeplaetze,
        AnzahlPensionsPflegetage,
        Auslastung,
        Pflegestufe,
        KostenPensionBetreuung,
        KvgPflegekosten,
        ErtraegeTaxeinnahmen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Id => "id",
                Field::Name => "name",
                Field::AnzahlPflegeplaetze => "anzahl_pflegeplaetze",
                Field::AnzahlPensionsPflegetage => "anzahl_pensions_pflegetage",
                Field::Auslastung => "auslastung",
                Field::Pflegestufe => "pflegestufe",
                Field::KostenPensionBetreuung => "kosten_pension_betreuung",
                Field::KvgPflegekosten => "kvg_pflegekosten",
                Field::ErtraegeTaxeinnahmen => "ertraege_taxeinnahmen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100318/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Gestorbene nach Altersklasse, Geschlecht und Sterbedatum"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die verstorbenen Personen im Kanton Basel-Stadt nach Altersklasse (0-64, 65+), Geschlecht und Sterbedatum. Die Daten werden t\u{e4}glich aktualisiert, wobei nur Todesf\u{e4}lle ber\u{fc}cksichtigt werden, die mindestens 15 Tage zur\u{fc}ck liegen. Aufgrund von sp\u{e4}ter gemeldeten Todesf\u{e4}llen kann es jederzeit zu Ver\u{e4}nderungen bei bereits ver\u{f6}ffentlichten Werten kommen.<br><br>Die hier ver\u{f6}ffentlichten Werte k\u{f6}nnen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik abweichen: In Letzterer werden nachtr\u{e4}glich gemeldete Todesf\u{e4}lle w\u{e4}hrend vier Monaten gesammelt, danach gelten die Zahlen als definitiv. Sp\u{e4}ter eintreffende Meldungen werden im letzten noch nicht abgeschlossenen Monat gez\u{e4}hlt. In diesem Datensatz werden sie im Monat des Sterbedatums gez\u{e4}hlt."]
pub mod gestorbene_nach_altersklasse_geschlecht_und_sterbedatum {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr des Todesfalls
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat des Todesfalls
        pub monat: Option<i64>,
        /// Kalenderwoche
        ///
        /// Laufnummer der Woche innerhalb eines Jahres
        pub woche_in_jahr: Option<i64>,
        /// Startdatum Woche
        ///
        /// Datum des Montags der Woche
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_wochenstart_sterbedatum: Option<Date>,
        /// Tag-Nr.
        ///
        /// Laufnummer des Tages innerhalb eines Jahres
        pub tag_in_jahr: Option<i64>,
        /// Wochentag
        pub wochentag: Option<String>,
        /// Sterbedatum
        ///
        /// Datum des Todesfalls
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sterbedatum: Option<Date>,
        /// Anzahl Männer 0-64
        ///
        /// Gestorbene Männer im Alter zwischen 0 und 64 Jahren
        pub anz_maenner_0_64: Option<i64>,
        /// Anzahl Männer 65+
        ///
        /// Gestorbene Männer im Alter von 65 und mehr Jahren
        pub anz_maenner_65_plus: Option<i64>,
        /// Anzahl Frauen 0-64
        ///
        /// Gestorbene Frauen im Alter zwischen 0 und 64 Jahren
        pub anz_frauen_0_64: Option<i64>,
        /// Anzahl Frauen 65+
        ///
        /// Gestorbene Frauen im Alter von 65 und mehr Jahren
        pub anz_frauen_65_plus: Option<i64>,
        /// Anzahl Gestorbene total
        ///
        /// Total gestorbene Personen an einem Tag
        pub anz_total: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        WocheInJahr,
        DatumWochenstartSterbedatum,
        TagInJahr,
        Wochentag,
        Sterbedatum,
        AnzMaenner064,
        AnzMaenner65Plus,
        AnzFrauen064,
        AnzFrauen65Plus,
        AnzTotal,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::WocheInJahr => "woche_in_jahr",
                Field::DatumWochenstartSterbedatum => "datum_wochenstart_sterbedatum",
                Field::TagInJahr => "tag_in_jahr",
                Field::Wochentag => "wochentag",
                Field::Sterbedatum => "sterbedatum",
                Field::AnzMaenner064 => "anz_maenner_0_64",
                Field::AnzMaenner65Plus => "anz_maenner_65_plus",
                Field::AnzFrauen064 => "anz_frauen_0_64",
                Field::AnzFrauen65Plus => "anz_frauen_65_plus",
                Field::AnzTotal => "anz_total",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100079/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Dokumente"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt Dokumente von Gesch\u{e4}ften, die im Grossen Rat des Kantons Basel-Stadt behandelt werden.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch/\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_dokumente {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Dokumentendatum
        ///
        /// Datum des Dokuments (entweder letztes Bearbeitungsdatum oder im Text explizit genanntes Dokumentendatum)
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub dokudatum: Option<Date>,
        /// Laufnummer Dokument
        ///
        /// Laufnummer des Dokuments
        pub dok_laufnr: Option<String>,
        /// Signatur Dokument
        ///
        /// Signatur des Dokuments
        pub signatur_dok: Option<String>,
        /// Titel Dokument
        ///
        /// Nummer und Titel des Dokuments
        pub titel_dok: Option<String>,
        /// Link Dokument
        ///
        /// Link zum Dokument auf der Webseite des Grossen Rates
        pub url_dok: Option<String>,
        /// Laufnummer Geschäft
        ///
        /// Laufnummer des Hauptgeschäfts zum zugehörigen Dokument
        pub laufnr_ges: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Hauptgeschäfts zum zugehörigen Dokument
        pub signatur_ges: Option<String>,
        /// Status Geschäft
        ///
        /// Status des Hauptgeschäfts zum zugehörigen Dokument (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Hauptgeschäfts zum zugehörigen Dokument
        pub titel_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Hauptgeschäfts zum zugehörigen Dokument
        pub ga_rr_gr: Option<String>,
        /// Geschäft grosserrat.bs.ch
        ///
        /// Link zum Hauptgeschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach Hauptgeschäft des aktuellen Dokuments.
        pub url_geschaeft_ods: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Dokudatum,
        DokLaufnr,
        SignaturDok,
        TitelDok,
        UrlDok,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        GaRrGr,
        UrlGes,
        UrlGeschaeftOds,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Dokudatum => "dokudatum",
                Field::DokLaufnr => "dok_laufnr",
                Field::SignaturDok => "signatur_dok",
                Field::TitelDok => "titel_dok",
                Field::UrlDok => "url_dok",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100313/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Monatliche Sterberaten nach Geschlecht und Altersgruppe"]
#[doc = ""]
#[doc = "Rohe und standardisierte Sterberaten des Kantons Basel-Stadt nach Geschlecht und Altersgruppen seit 2012. Die Sterberaten werden monatlich aktualisiert. Aufgrund von verz\u{f6}gerten Ereignis-Meldungen k\u{f6}nnen sich die Werte der Vormonate (Anzahl Todesf\u{e4}lle, Sterbeziffer/-rate) nach einer Aktualisierung leicht \u{e4}ndern. Die standardisierte Sterberate bezieht sich auf die mittlere Bev\u{f6}lkerung des Monats Januar 2012 des Kantons Basel-Stadt. Durch die Standardisierung erh\u{e4}lt man so in der Altersgruppe \"Alle\" eine altersstandardisierte Sterberate f\u{fc}r das jeweilige Geschlecht."]
pub mod monatliche_sterberaten_nach_geschlecht_und_altersgruppe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        ///
        /// Jahr des Todes
        pub jahr: Option<String>,
        /// Monat
        ///
        /// Monat des Todes
        pub monat: Option<i64>,
        /// Jahr und Monat
        ///
        /// Jahr und Monat des Todes in einer Spalte
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr_monat: Option<Date>,
        /// Geschlecht
        pub geschlecht: Option<String>,
        /// Altersgruppe
        ///
        /// Altersgruppe des Verstorbenen.
        pub altersgruppen: Option<String>,
        /// Anzahl Verstorbene
        ///
        /// Gemeldete Anzahl Verstorbene im jeweiligen Jahr, Monat, Geschlecht und Altersgruppe. Quelle: Kantonale Bevölkerungsstatistik
        pub beobachtet_tote: Option<i64>,
        /// Mittlere Bevölkerung
        ///
        /// Mittlere Bevölkerung zum jeweiligen Zeitpunkt des Monats und Jahres für die entsprechende Altersgruppe und Geschlecht. Quelle: Kantonale Bevölkerungsstatistik
        pub mittlere_bev: Option<i64>,
        /// Rohe Sterbeziffer pro 1000 Einwohner
        ///
        /// Anzahl Verstorbene pro 1000 Einwohner des jeweiligen Monats und Jahres für die entsprechende Altersgruppe und Geschlecht. Die Kennzahl berechnet sich aus der Anzahl Todesfälle geteilt durch die mittlere Bevölkerung mal 1000.
        pub sterberate_1000_roh: Option<f64>,
        /// Erwartete Anzahl Verstorbene
        ///
        /// Anhand der rohen Sterbeziffer und der entsprechenden Referenzbevölkerung wird die Anzahl zu erwartender Todesfälle für die jeweilige Gruppe berechnet, unter der Annahme, dass die Bevölkerungsstruktur über die Zeit konstant geblieben wäre.
        pub erwartet_tote: Option<i64>,
        /// Mittlere Referenzbevölkerung
        ///
        /// Die mittlere Bevölkerung des Monats Januar des Jahres 2012 dient als Referenzbevölkerung. Diese Zahl ist für die jeweilige Altersgruppe und Geschlecht konstant und dient dazu die standardisierten Sterberaten zu berechnen, um Vergleiche über die Zeit zu ermöglichen.
        pub mittlere_bev_referenz: Option<i64>,
        /// Standardisierte Sterberate
        ///
        /// Durch Division der erwarteten Todesfälle durch die Referenzbevölkerung lässt sich eine standardisierte Sterberate berechnen. Diese Zahl ermöglicht einen Vergleich über die Zeit unter der Annahme, dass sich die Bevölkerungsstruktur nicht verändert. Für die Altersgruppe Alle" ergibt das eine altersbereinigte Sterberate für das jeweilige Geschlecht."
        pub smr_1000: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Monat,
        JahrMonat,
        Geschlecht,
        Altersgruppen,
        BeobachtetTote,
        MittlereBev,
        Sterberate1000Roh,
        ErwartetTote,
        MittlereBevReferenz,
        Smr1000,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::JahrMonat => "jahr_monat",
                Field::Geschlecht => "geschlecht",
                Field::Altersgruppen => "altersgruppen",
                Field::BeobachtetTote => "beobachtet_tote",
                Field::MittlereBev => "mittlere_bev",
                Field::Sterberate1000Roh => "sterberate_1000_roh",
                Field::ErwartetTote => "erwartet_tote",
                Field::MittlereBevReferenz => "mittlere_bev_referenz",
                Field::Smr1000 => "smr_1000",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100173/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Baumkataster: Baumbestand"]
#[doc = ""]
#[doc = "Der Baumkataster umfasst den durch die Stadtg\u{e4}rtnerei Basel (Gebiet Stadt Basel) und die Gemeinde Riehen (Gebiet Riehen) gepflegten Baumbestand.\u{a0}"]
pub mod baumkataster_baumbestand {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJID
        ///
        /// Laufnummer
        pub objid: Option<String>,
        /// Baumnummer
        ///
        /// Eindeutige Nummer des Baums
        pub baumnr: Option<String>,
        /// Baumart
        ///
        /// Botanische und deutsche Bezeichnung der Baumart
        pub art: Option<String>,
        /// Baumart lateinisch
        ///
        /// Botanische Bezeichnung der Baumart
        pub baumart_lateinisch: Option<String>,
        /// Baumart deutsch
        ///
        /// Deutsche Bezeichnung der Baumart
        pub baumart_deutsch: Option<String>,
        /// Pflanzdatum
        ///
        /// Datum der Baumpflanzung am aktuellen Ort, wenn bekannt; In der Regel werden Bäume in einem Alter von ca. 10 Jahren gepflanzt.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub pflanzdatu: Option<Date>,
        /// Baumalter
        ///
        /// Alter des Baumes bei Publikation des Datensatzes. Entspricht in der Regel der Spalte «Standjahr» plus ca. 10 Jahre.
        pub baumalter: Option<i64>,
        /// Standjahr
        ///
        /// Anzahl Jahre, während derer der Baum am aktuellen Ort steht. Entspricht der Anzahl Jahre, welche zwischen dem Pflanzdatum und der Publikation der Datensatzes liegt.
        pub standjahr: Option<i64>,
        /// ID_Schutzstatus
        ///
        /// ID des Schutzstatus
        pub id_schutzs: Option<i64>,
        /// Schutzstatus
        ///
        /// Beschreibung des Schutzstatus: "Geschützt (Umfang)": Geschützt wegen gemessenem Baumumfang. "Gemäss Baumschutzgesetz (BSchG)": Baumumfang wurde nicht unbedingt aktuell gemessen, Baum wurde trotzdem konservativ als geschützt eingeteilt. "Geschützt (Ersatzpflanzung)": Aktueller Baum ist geschützt, da er einen vormalig geschützten Baum ersetzt.
        pub schutzstat: Option<String>,
        /// Strasse
        ///
        /// Strasse des Baumstandortes
        pub strasse: Option<String>,
        /// Kreis
        ///
        /// Gebietseinteilung durch die Stadtgärtnerei
        pub kreis: Option<String>,
        /// ID_Gruppe
        ///
        /// ID der Gruppe
        pub id_gruppe: Option<i64>,
        /// Gruppe
        ///
        /// Beschreibung der Gruppe
        pub gruppe: Option<String>,
        /// Gemeinde
        ///
        /// Gemeinde des Baumstandorts
        pub gemeinde: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Baumnr,
        Art,
        BaumartLateinisch,
        BaumartDeutsch,
        Pflanzdatu,
        Baumalter,
        Standjahr,
        IdSchutzs,
        Schutzstat,
        Strasse,
        Kreis,
        IdGruppe,
        Gruppe,
        Gemeinde,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Baumnr => "baumnr",
                Field::Art => "art",
                Field::BaumartLateinisch => "baumart_lateinisch",
                Field::BaumartDeutsch => "baumart_deutsch",
                Field::Pflanzdatu => "pflanzdatu",
                Field::Baumalter => "baumalter",
                Field::Standjahr => "standjahr",
                Field::IdSchutzs => "id_schutzs",
                Field::Schutzstat => "schutzstat",
                Field::Strasse => "strasse",
                Field::Kreis => "kreis",
                Field::IdGruppe => "id_gruppe",
                Field::Gruppe => "gruppe",
                Field::Gemeinde => "gemeinde",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100052/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): In Basel-Stadt verabreichte Impfungen"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Anzahl im Kanton Basel-Stadt gegen SARS-CoV-2 geimpfter Personen auf t\u{e4}glicher Basis. Zus\u{e4}tzlich wird angegeben, wie viele Personen im kantonalen Impfzentrum geimpft wurden und wie viele Impfungen durch baselst\u{e4}dtische Spit\u{e4}ler an ihr Gesundheitspersonal verabreicht wurden. Ebenso sind die Impfungen in Arzpraxen und Apotheken separat aufgef\u{fc}hrt. Impfungen im Impfbus werden nicht separat ausgewiesen, sondern sind in der Anzahl im Impfzentrum verabreichten Impfungen integriert. Weiter finden Sie Angaben dar\u{fc}ber, wie viele Personen mit einer ersten resp. einer zweiten Dosis geimpft wurden. \u{a0}</p><p>Die im Kanton Basel-Stadt geimpften Personen m\u{fc}ssen nicht zwingend im Kanton Basel-Stadt wohnen. Angaben zu den geimpften Personen mit Wohnsitz im Kanton Basel-Stadt finden Sie in diesem Datensatz:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100135\" target=\"_blank\">https://data.bs.ch/explore/dataset/100135</a></p><p>Die an dieser Stelle publizierten Zahlen k\u{f6}nnen von jenen Zahlen abweichen, welche \u{fc}ber Kan\u{e4}le von Bundesstellen f\u{fc}r den Kanton Basel-Stadt publiziert sind. Begr\u{fc}nden lassen sich die Differenzen mit unterschiedlichen Aktualisierungszyklen. Es wird ab Montag, 10.5.2021 dieselbe Quelle (Vaccination Monitoring Data Lake, VMDL BAG) verwendet.\u{a0}</p><p>Leider k\u{f6}nnen aufgrund der Quellen\u{e4}nderung die Impfungen der mobilen Equipen nicht mehr separat ausgewiesen werden. Sie werden zu den im Impfzentrum verabreichten Impfungen hinzugez\u{e4}hlt. Da die VMDL-Werte auch r\u{fc}ckwirkend \u{fc}bernommen werden, kommt es zu Abweichungen bei den t\u{e4}glich publizierten Werten gegen\u{fc}ber fr\u{fc}her in diesem Datensatz ver\u{f6}ffentlichten Werten.\u{a0}</p>\n<p>\nAb 5. August 2021 k\u{f6}nnen dritte Impfungen in den Daten enthalten sein. Initial sind ausschliesslich immundefiziente Personen oder Personen mit Stammzellentransplantation zu einer dritten Impfung berechtigt.</p><p>Die Meldepflicht der COVID-Impfungen via VMDL Plattform des Bundes wurde per 1. Juli 2023 aufgehoben. Nach diesem Datum wurden Impfungen deshalb nicht mehr systematisch erfasst. Der vorliegende Datensatz zeigt deshalb Impfungen nur bis 1. Juli 2023.<br></p><p> \n</p>"]
pub mod coronavirus_covid_19_in_basel_stadt_verabreichte_impfungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Total verabreichte Impfungen
        ///
        /// Total bis dato im Kanton Basel-Stadt gegen SARS-CoV-2 verabreichte Impfungen
        pub total_verabreichte_impfungen: Option<i64>,
        /// Total Personen mit erster Dosis
        ///
        /// Total Personen, welche bis dato im Kanton Basel-Stadt mit mindestens einer Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_erster_dosis: Option<i64>,
        /// Total Personen mit ausschliesslich erster Dosis
        ///
        /// Total Personen, welche bis dato im Kanton Basel-Stadt ausschliesslich mit erster Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_ausschliesslich_erster_dosis: Option<i64>,
        /// Total Personen mit zweiter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit zweiter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_zweiter_dosis: Option<i64>,
        /// Total Personen mit dritter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit dritter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_dritter_dosis: Option<i64>,
        /// Total Personen mit vierter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit vierter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_vierter_dosis: Option<i64>,
        /// Total Personen mit fünfter Dosis
        ///
        /// Total Personen, welche im Kanton Basel-Stadt bis dato mit fünfter Dosis gegen SARS-CoV-2 geimpft wurden
        pub total_personen_mit_fuenfter_dosis: Option<i64>,
        /// Im Impfzentrum verabreichte Impfungen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum gegen SARS-CoV-2 verabreichte Impfungen pro Tag
        pub im_impfzentrum_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit erster Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit erster Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit zweiter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit zweiter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit dritter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit dritter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit vierter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit vierter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Impfzentrum mit fünfter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl im kantonalen Impfzentrum mit fünfter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_impfzentrum_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen verabreichte Impfungen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen gegen SARS-CoV-2 verabreichte Impfungen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub in_aph_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit erster Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit erster Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit zweiter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit zweiter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit dritter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit dritter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit vierter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit vierter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Durch mobile Equipen mit fünfter Dosis geimpfte Personen pro Tag (APH etc.)
        ///
        /// Anzahl durch die mobilen Impfequipen mit fünfter Dosis gegen SARS-CoV-2 geimpfte Personen pro Tag (Alters-, Pflegeheime und weitere Institutionen)
        pub im_aph_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Total verabreichte Impfungen pro Tag
        ///
        /// Total im Kanton Basel-Stadt gegen SARS-CoV-2 verabreichte Impfungen pro Tag
        pub total_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Im Spital verabreichte Impfungen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern gegen SARS-CoV-2 verabreichte Impfungen pro Tag
        pub im_spital_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Im Spital mit erster Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit erster Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit zweiter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit zweiter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit dritter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit dritter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit vierter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit vierter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Im Spital mit fünfter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in kantonalen Spitälern mit fünfter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub im_spital_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo verabreichte Impfungen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_verabreichte_impfungen_pro_tag: Option<i64>,
        /// Anderswo mit erster Dosis geimpfte Personen pro tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit erster Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_erster_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit zweiter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit zweiter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_zweiter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit dritter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit dritter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_dritter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit vierter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit vierter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_vierter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Anderswo mit fünfter Dosis geimpfte Personen pro Tag
        ///
        /// Anzahl in anderen kantonalen Institutionen (Arztpraxen, Apotheken, etc.) mit fünfter Dosis gegen SARS-CoV-2 geimpfter Personen pro Tag
        pub anderswo_mit_fuenfter_dosis_geimpfte_personen_pro_tag: Option<i64>,
        /// Total Auffrischimpfungen (Booster)
        ///
        /// Total der im Rahmen der Auffrischimpfung (Booster) verabreichte Impfungen
        pub total_auffrischimpfungen: Option<i64>,
        /// Auffrischimpfungen (Booster) pro Tag
        ///
        /// Anzahl der im Rahmen der Auffrischimpfung (Booster) verabreichte Impfungen an einem Tag
        pub auffrischimpfungen_pro_tag: Option<i64>,
        /// Total Drittimpfungen (oder mehr) als Teil der Grundimmunisierung
        ///
        /// Total der im Rahmen der Grundimmunisierung mit dritter (oder mehr) Dosis verabreichten Impfungen
        pub total_drittimpfungen_u_m_grundimmunisierung: Option<i64>,
        /// Drittimpfungen (oder mehr) als Teil der Grundimmunisierung pro Tag
        ///
        /// Anzahl der im Rahmen der Grundimmunisierung mit dritter (oder mehr) Dosis verabreichten Impfungen
        pub drittimpfungen_u_m_grundimmunisierung_pro_tag: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        TotalVerabreichteImpfungen,
        TotalPersonenMitErsterDosis,
        TotalPersonenMitAusschliesslichErsterDosis,
        TotalPersonenMitZweiterDosis,
        TotalPersonenMitDritterDosis,
        TotalPersonenMitVierterDosis,
        TotalPersonenMitFuenfterDosis,
        ImImpfzentrumVerabreichteImpfungenProTag,
        ImImpfzentrumMitErsterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitZweiterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitDritterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitVierterDosisGeimpftePersonenProTag,
        ImImpfzentrumMitFuenfterDosisGeimpftePersonenProTag,
        InAphVerabreichteImpfungenProTag,
        ImAphMitErsterDosisGeimpftePersonenProTag,
        ImAphMitZweiterDosisGeimpftePersonenProTag,
        ImAphMitDritterDosisGeimpftePersonenProTag,
        ImAphMitVierterDosisGeimpftePersonenProTag,
        ImAphMitFuenfterDosisGeimpftePersonenProTag,
        TotalVerabreichteImpfungenProTag,
        ImSpitalVerabreichteImpfungenProTag,
        ImSpitalMitErsterDosisGeimpftePersonenProTag,
        ImSpitalMitZweiterDosisGeimpftePersonenProTag,
        ImSpitalMitDritterDosisGeimpftePersonenProTag,
        ImSpitalMitVierterDosisGeimpftePersonenProTag,
        ImSpitalMitFuenfterDosisGeimpftePersonenProTag,
        AnderswoVerabreichteImpfungenProTag,
        AnderswoMitErsterDosisGeimpftePersonenProTag,
        AnderswoMitZweiterDosisGeimpftePersonenProTag,
        AnderswoMitDritterDosisGeimpftePersonenProTag,
        AnderswoMitVierterDosisGeimpftePersonenProTag,
        AnderswoMitFuenfterDosisGeimpftePersonenProTag,
        TotalAuffrischimpfungen,
        AuffrischimpfungenProTag,
        TotalDrittimpfungenUMGrundimmunisierung,
        DrittimpfungenUMGrundimmunisierungProTag,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::TotalVerabreichteImpfungen => "total_verabreichte_impfungen",
                Field::TotalPersonenMitErsterDosis => "total_personen_mit_erster_dosis",
                Field::TotalPersonenMitAusschliesslichErsterDosis => {
                    "total_personen_mit_ausschliesslich_erster_dosis"
                }
                Field::TotalPersonenMitZweiterDosis => "total_personen_mit_zweiter_dosis",
                Field::TotalPersonenMitDritterDosis => "total_personen_mit_dritter_dosis",
                Field::TotalPersonenMitVierterDosis => "total_personen_mit_vierter_dosis",
                Field::TotalPersonenMitFuenfterDosis => "total_personen_mit_fuenfter_dosis",
                Field::ImImpfzentrumVerabreichteImpfungenProTag => {
                    "im_impfzentrum_verabreichte_impfungen_pro_tag"
                }
                Field::ImImpfzentrumMitErsterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitZweiterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitDritterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitVierterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImImpfzentrumMitFuenfterDosisGeimpftePersonenProTag => {
                    "im_impfzentrum_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::InAphVerabreichteImpfungenProTag => "in_aph_verabreichte_impfungen_pro_tag",
                Field::ImAphMitErsterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitZweiterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitDritterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitVierterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImAphMitFuenfterDosisGeimpftePersonenProTag => {
                    "im_aph_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::TotalVerabreichteImpfungenProTag => "total_verabreichte_impfungen_pro_tag",
                Field::ImSpitalVerabreichteImpfungenProTag => {
                    "im_spital_verabreichte_impfungen_pro_tag"
                }
                Field::ImSpitalMitErsterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitZweiterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitDritterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitVierterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::ImSpitalMitFuenfterDosisGeimpftePersonenProTag => {
                    "im_spital_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoVerabreichteImpfungenProTag => {
                    "anderswo_verabreichte_impfungen_pro_tag"
                }
                Field::AnderswoMitErsterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_erster_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitZweiterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_zweiter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitDritterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_dritter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitVierterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_vierter_dosis_geimpfte_personen_pro_tag"
                }
                Field::AnderswoMitFuenfterDosisGeimpftePersonenProTag => {
                    "anderswo_mit_fuenfter_dosis_geimpfte_personen_pro_tag"
                }
                Field::TotalAuffrischimpfungen => "total_auffrischimpfungen",
                Field::AuffrischimpfungenProTag => "auffrischimpfungen_pro_tag",
                Field::TotalDrittimpfungenUMGrundimmunisierung => {
                    "total_drittimpfungen_u_m_grundimmunisierung"
                }
                Field::DrittimpfungenUMGrundimmunisierungProTag => {
                    "drittimpfungen_u_m_grundimmunisierung_pro_tag"
                }
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100111/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Tagesordnungen und Traktandenlisten der Grossratssitzungen"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz bietet eine umfassende \u{dc}bersicht \u{fc}ber die Tagesordnungen und die zugeh\u{f6}rigen Traktanden der Grossratssitzungen des Kantons Basel-Stadt.</p><p>Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br><a href=\"https://grosserrat.bs.ch/ratsbetrieb/tagesordnung\" target=\"_blank\">https://grosserrat.bs.ch/ratsbetrieb/tagesordnung</a><br></p>"]
pub mod grosser_rat_tagesordnungen_und_traktandenlisten_der_grossratssitzungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Tagesordnung-ID
        ///
        /// Individuelle Identifikationsnummer der Tagesordnung
        pub tagesordnung_idnr: Option<i64>,
        /// Versanddatum Tagesordnung
        ///
        /// Datum der Aufschaltung und Publikation der Tagesordnung
        #[serde(with = "time::serde::iso8601::option")]
        pub versand: Option<OffsetDateTime>,
        /// Tag 1
        ///
        /// Datum der ersten Sitzung der Tagesordnung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub tag1: Option<Date>,
        /// Sitzungstyp Tag 1
        ///
        /// Beschreibung der ersten Sitzung
        pub text1: Option<String>,
        /// Tag 2
        ///
        /// Datum der zweiten Sitzung der Tagesordnung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub tag2: Option<Date>,
        /// Sitzungstyp Tag 2
        ///
        /// Beschreibung der zweiten Sitzung
        pub text2: Option<String>,
        /// Tag 3
        ///
        /// Datum der dritten Sitzung der Tagesordnung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub tag3: Option<Date>,
        /// Sitzungstyp Tag 3
        ///
        /// Beschreibung der dritten Sitzung
        pub text3: Option<String>,
        /// Bemerkung
        ///
        /// Weitere Informationen zur Tagesordnung
        pub bemerkung: Option<String>,
        /// Tagesordnung auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument der Tagesordnung
        pub url_tagesordnung_dok: Option<String>,
        /// Geschäftsverzeichnis auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument des Geschäftsverzeichnisses
        pub url_geschaeftsverzeichnis: Option<String>,
        /// Sammelmappe auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument der Sammelmappe
        pub url_sammelmappe: Option<String>,
        /// ZIP-Archiv der Session (Achtung - grosse Datei)
        ///
        /// Link zum PDF-Dokument des ZIP-Archivs
        pub url_alle_dokumente: Option<String>,
        /// Vollprotokoll auf grosserrat.bs.ch
        ///
        /// Link zum PDF-Dokument des Vollprotokolls, falls vorhanden
        pub url_vollprotokoll: Option<String>,
        /// Audio-Protokoll Tag 1
        ///
        /// Link zu den Ton- und Videoaufzeichnungen der ersten Sitzung auf protokolle.grosserrat-basel.ch (bis und mit Juni 2023)
        pub url_audioprotokoll_tag1: Option<String>,
        /// Audio-Protokoll Tag 2
        ///
        /// Link zu den Ton- und Videoaufzeichnungen der zweiten Sitzung auf protokolle.grosserrat-basel.ch (bis und mit Juni 2023)
        pub url_audioprotokoll_tag2: Option<String>,
        /// Audio-Protokoll Tag 3
        ///
        /// Link zu den Ton- und Videoaufzeichnungen der dritten Sitzung auf protokolle.grosserrat-basel.ch (bis und mit Januar 2023)
        pub url_audioprotokoll_tag3: Option<String>,
        /// Gruppennummer
        ///
        /// Nummer der Gruppe des Traktandums
        pub gruppennummer: Option<i64>,
        /// Gruppentitel
        ///
        /// Gruppentitel des Traktandums
        pub gruppentitel: Option<String>,
        /// Gruppentitel Position
        ///
        /// Erste Laufnummer der Gruppe
        pub gruppentitel_pos: Option<i64>,
        /// Traktandum-ID
        ///
        /// Individuelle Identifikationsnummer des Traktandums
        pub traktanden_idnr: Option<i64>,
        /// Laufnummer
        pub laufnr: Option<i64>,
        /// Laufnummer 2
        ///
        /// Weitergehende Laufnummer
        pub laufnr_2: Option<i64>,
        /// Status
        ///
        /// Status des Traktandums (erledigt, offen, in Behandlung, abgesetzt, zurückgezogen, 2. Lesung, verschoben)
        pub status: Option<String>,
        /// Titel
        ///
        /// Titel des Traktandums
        pub titel: Option<String>,
        /// Kommissionen
        ///
        /// Die für das Traktandum zuständigen Kommissionen
        pub kommission: Option<String>,
        /// Departemente
        ///
        /// Die für das Traktandum zuständigen Departemente
        pub departement: Option<String>,
        /// Signaturen
        ///
        /// Die zu dem Traktandum zugehörigen Dokumenten-Signaturen (getrennt durch Komma)
        pub signatur: Option<String>,
        /// Geschäfte auf grosserrat.bs.ch
        ///
        /// Links der Geschäfte auf die Webseite des Grossen Rates (getrennt durch Semikolon)
        pub url_ges: Option<String>,
        /// Geschäfte auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach den Geschäften in den Signaturen.
        pub url_geschaeft_ods: Option<String>,
        /// Dokumente auf grosserrat.bs.ch
        ///
        /// Links der Dokumente auf der Webseite des Grossen Rates (getrennt durch Semikolon)
        pub url_dok: Option<String>,
        /// Dokumente auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Dokumente". Gefiltert nach den Signaturen.
        pub url_dokument_ods: Option<String>,
        /// Abstimmungen
        ///
        /// Die zu dem Traktandum zugehörige Abstimmungen. Gespeichert im JSON-Format
        pub abstimmung: Option<String>,
        /// Abstimmungsnummern
        ///
        /// Die dem Traktandum zugehörigen Nummern der Abstimmungen (getrennt durch Komma)
        pub anr: Option<String>,
        /// Abstimmungen auf data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Live-Abstimmungsergebnisse". Gefiltert nach den Abstimmungen.
        pub url_abstimmungen: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TagesordnungIdnr,
        Versand,
        Tag1,
        Text1,
        Tag2,
        Text2,
        Tag3,
        Text3,
        Bemerkung,
        UrlTagesordnungDok,
        UrlGeschaeftsverzeichnis,
        UrlSammelmappe,
        UrlAlleDokumente,
        UrlVollprotokoll,
        UrlAudioprotokollTag1,
        UrlAudioprotokollTag2,
        UrlAudioprotokollTag3,
        Gruppennummer,
        Gruppentitel,
        GruppentitelPos,
        TraktandenIdnr,
        Laufnr,
        Laufnr2,
        Status,
        Titel,
        Kommission,
        Departement,
        Signatur,
        UrlGes,
        UrlGeschaeftOds,
        UrlDok,
        UrlDokumentOds,
        Abstimmung,
        Anr,
        UrlAbstimmungen,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TagesordnungIdnr => "tagesordnung_idnr",
                Field::Versand => "versand",
                Field::Tag1 => "tag1",
                Field::Text1 => "text1",
                Field::Tag2 => "tag2",
                Field::Text2 => "text2",
                Field::Tag3 => "tag3",
                Field::Text3 => "text3",
                Field::Bemerkung => "bemerkung",
                Field::UrlTagesordnungDok => "url_tagesordnung_dok",
                Field::UrlGeschaeftsverzeichnis => "url_geschaeftsverzeichnis",
                Field::UrlSammelmappe => "url_sammelmappe",
                Field::UrlAlleDokumente => "url_alle_dokumente",
                Field::UrlVollprotokoll => "url_vollprotokoll",
                Field::UrlAudioprotokollTag1 => "url_audioprotokoll_tag1",
                Field::UrlAudioprotokollTag2 => "url_audioprotokoll_tag2",
                Field::UrlAudioprotokollTag3 => "url_audioprotokoll_tag3",
                Field::Gruppennummer => "gruppennummer",
                Field::Gruppentitel => "gruppentitel",
                Field::GruppentitelPos => "gruppentitel_pos",
                Field::TraktandenIdnr => "traktanden_idnr",
                Field::Laufnr => "laufnr",
                Field::Laufnr2 => "laufnr_2",
                Field::Status => "status",
                Field::Titel => "titel",
                Field::Kommission => "kommission",
                Field::Departement => "departement",
                Field::Signatur => "signatur",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
                Field::UrlDok => "url_dok",
                Field::UrlDokumentOds => "url_dokument_ods",
                Field::Abstimmung => "abstimmung",
                Field::Anr => "anr",
                Field::UrlAbstimmungen => "url_abstimmungen",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100348/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Zuweisungen von Gesch\u{e4}ften"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt Zuweisungen von Gesch\u{e4}ften, die im Grossen Rat des Kantons Basel-Stadt behandelt werden.</p><p style=\"font-family: sans-serif;\">Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch/\" target=\"_blank\">https://grosserrat.bs.ch</a></p>"]
pub mod grosser_rat_zuweisungen_von_geschaeften {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Kurzname Gremium An
        ///
        /// Kurzname des Gremiums, dem das Geschäft zugewiesen wurde
        pub kurzname_an: Option<String>,
        /// Name Gremium An
        ///
        /// Name des Gremiums, dem das Geschäft zugewiesen wurde
        pub name_an: Option<String>,
        /// ID Gremium An
        ///
        /// Individuelle Identifikationsnummer des Gremiums, dem das Geschäft zugewiesen wurde, innerhalb der Datenbank des Grossen Rates
        pub uni_nr_an: Option<String>,
        /// Link Gremium An
        ///
        /// Link zum Datensatz "Grosser Rat: Gremium". Gefiltert nach dem aktuellen Gremium, dem das Geschäft zugewiesen wurde.
        pub url_gremium_an: Option<String>,
        /// Erledigt Datum
        ///
        /// Datum, an dem die zugewiesene Aufgabe erledigt wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub erledigt: Option<Date>,
        /// Status Zuweisung
        ///
        /// Status der Zuweisung (In Bearbeitung, Fertig, Abgeschlossen oder Abgebrochen). "Abgeschlossen" und "Fertig" unterscheiden sich nur darin, dass bei "Fertig" nur die zugewiesene Aufgabe abgeschlossen ist, aber noch nicht das ganze Geschäft.
        pub status_zuw: Option<String>,
        /// Termin Zuweisung
        ///
        /// Datum, an dem die Zuweisung abgeschlossen sein soll.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub termin: Option<Date>,
        /// Titel Zuweisung
        ///
        /// Titel der Zuweisung
        pub titel_zuw: Option<String>,
        /// Bemerkung
        ///
        /// Bemerkung zur Zuweisung
        pub bem: Option<String>,
        /// Laufnummer Geschäft
        ///
        /// Laufnummer des Geschäfts zur zugehörigen Zuweisung
        pub laufnr_ges: Option<String>,
        /// Signatur Geschäft
        ///
        /// Signatur des Geschäfts zur zugehörigen Zuweisung
        pub signatur_ges: Option<String>,
        /// Status Geschäft
        ///
        /// Status des Geschäfts zur zugehörigen Zuweisung (In Bearbeitung oder Abgeschlossen)
        pub status_ges: Option<String>,
        /// Titel Geschäft
        ///
        /// Titel des Geschäfts zur zugehörigen Zuweisung
        pub titel_ges: Option<String>,
        /// Typ Geschäft
        ///
        /// Typ des Geschäfts zur zugehörigen Zuweisung
        pub ga_rr_gr: Option<String>,
        /// Geschäft grosserrat.bs.ch
        ///
        /// Link zum Geschäft auf der Webseite des Grossen Rates
        pub url_ges: Option<String>,
        /// Geschäft data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach aktuellem Geschäft.
        pub url_geschaeft_ods: Option<String>,
        /// Kurzname Gremium Von
        ///
        /// Kurzname des Gremiums, das das Geschäft zuweist
        pub kurzname_von: Option<String>,
        /// Name Gremium Von
        ///
        /// Name des Gremiums, das das Geschäft zuweist
        pub name_von: Option<String>,
        /// ID Gremium Von
        ///
        /// Individuelle Identifikationsnummer des Gremiums, das das Geschäft zuweist, innerhalb der Datenbank des Grossen Rates
        pub uni_nr_von: Option<String>,
        /// Link Gremium Von
        ///
        /// Link zum Datensatz "Grosser Rat: Gremium". Gefiltert nach dem aktuellem Gremium, das das Geschäft zugewiesen hat.
        pub url_gremium_von: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        KurznameAn,
        NameAn,
        UniNrAn,
        UrlGremiumAn,
        Erledigt,
        StatusZuw,
        Termin,
        TitelZuw,
        Bem,
        LaufnrGes,
        SignaturGes,
        StatusGes,
        TitelGes,
        GaRrGr,
        UrlGes,
        UrlGeschaeftOds,
        KurznameVon,
        NameVon,
        UniNrVon,
        UrlGremiumVon,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::KurznameAn => "kurzname_an",
                Field::NameAn => "name_an",
                Field::UniNrAn => "uni_nr_an",
                Field::UrlGremiumAn => "url_gremium_an",
                Field::Erledigt => "erledigt",
                Field::StatusZuw => "status_zuw",
                Field::Termin => "termin",
                Field::TitelZuw => "titel_zuw",
                Field::Bem => "bem",
                Field::LaufnrGes => "laufnr_ges",
                Field::SignaturGes => "signatur_ges",
                Field::StatusGes => "status_ges",
                Field::TitelGes => "titel_ges",
                Field::GaRrGr => "ga_rr_gr",
                Field::UrlGes => "url_ges",
                Field::UrlGeschaeftOds => "url_geschaeft_ods",
                Field::KurznameVon => "kurzname_von",
                Field::NameVon => "name_von",
                Field::UniNrVon => "uni_nr_von",
                Field::UrlGremiumVon => "url_gremium_von",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100312/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "EuroAirport: T\u{e4}gliche Flugbewegungen, Passagiere und Fracht"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Flugbewegungen sowie Angaben zur Anzahl Passagiere und zur bef\u{f6}rderten Fracht auf dem EuroAirport Basel Mulhouse Freiburg f\u{fc}r jeden Tag ab 1. Januar 2019.</p>"]
pub mod euroairport_taegliche_flugbewegungen_passagiere_und_fracht {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub date: Option<Date>,
        /// Kategorie
        ///
        /// Andere Kategorien = allgemeiner und anderer nicht-gewerblicher Verkehr
        pub kategorie: Option<String>,
        /// Flugpassagiere
        ///
        /// Anzahl Passagiere
        pub pax: Option<i64>,
        /// Luftfracht
        ///
        /// in Tonnen
        pub fret: Option<f64>,
        /// Flugbewegungen
        ///
        /// Starts und Landungen
        pub mvt: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Date,
        Kategorie,
        Pax,
        Fret,
        Mvt,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Date => "date",
                Field::Kategorie => "kategorie",
                Field::Pax => "pax",
                Field::Fret => "fret",
                Field::Mvt => "mvt",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100078/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Bezirk"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Wohnbev\u{f6}lkerung des Kantons Basel-Stadt auf Ebene Bezirk. Die Daten werden monatlich aktualisiert. Bis zum Jahr 2011 sind nur die Jahresendbest\u{e4}nde verf\u{fc}gbar.<br>Die hier ver\u{f6}ffentlichten Werte der Jahre 1979 bis 2011 weichen aus methodischen Gr\u{fc}nden von denjenigen in der kantonalen \u{f6}ffentlichen Statistik ab: In Letzterer wurde bis zum Jahr 2011 die Bev\u{f6}lkerungszahl durch Fortschreibung ermittelt. Seit dem Jahr 2012 basiert sie direkt auf Auswertungen aus dem kantonalen Einwohnerregister. Die hier ver\u{f6}ffentlichten Werte hingegen basieren seit 1979 auf Auswertungen aus dem Einwohnerregister."]
pub mod wohnbevoelkerung_nach_bezirk {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// Wohnviertel-ID
        pub wov_id: Option<String>,
        /// Bezirk
        pub wohnbezirk: Option<String>,
        /// Bezirks-ID
        pub bez_id: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Personen
        pub anzahl: Option<i64>,
        /// Jahr
        pub jahr: Option<String>,
        /// Monat
        pub monat: Option<i64>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Wohnviertel,
        WovId,
        Wohnbezirk,
        BezId,
        Gemeinde,
        Anzahl,
        Jahr,
        Monat,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Wohnviertel => "wohnviertel",
                Field::WovId => "wov_id",
                Field::Wohnbezirk => "wohnbezirk",
                Field::BezId => "bez_id",
                Field::Gemeinde => "gemeinde",
                Field::Anzahl => "anzahl",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100125/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Feinstaubmessungen auf BVB-Trams"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Feinstaubmessungen (PM2.5 und PM10) vom Dach der BVB-Trams, auf denen Mikrosensoren installiert worden sind. Ein Sensor war jeweils auf einem Tram des Typs \"Flexity lang\" montiert, ausser die Sensoren 236 und 240, die zu Qualit\u{e4}tssicherungszwecken station\u{e4}r an den Luftmessstationen \"Feldbergstrasse\" und \"St. Johann-Platz\" installiert waren.</p><p>\n\nDie Messkampagne startete im Dezember 2019 und endete im M\u{e4}rz 2020. Es werden nachtr\u{e4}glich keine weiteren Messdaten dazukommen und der Datensatz wird nicht mehr aktualisiert.\n</p><p></p><p>\nWeitere Informationen zum Projekt Atmo-VISION sind in der <a href=\"https://www.bs.ch/nm/2020-atmovision-luftmessungen-auf-basler-tramlinien-wsu.html\" target=\"_blank\">Medienmitteilung</a> und auf der Website des <a href=\"https://www.baselland.ch/politik-und-behorden/direktionen/bau-und-umweltschutzdirektion/lufthygiene/lufthygiene/luftqualitat/atmovision-projekte\" target=\"_blank\">Lufthygieneamt beider Basel</a> zu finden. Den Bericht des Projektes gibt es <a href=\"https://www.baselland.ch/politik-und-behorden/direktionen/bau-und-umweltschutzdirektion/lufthygiene/lufthygiene/luftqualitat/atmovision-projekte/downloads/2020-11.pdf/@@download/file/2020-11-02_LHA_AtmoVision_Bericht_Feinstaubmesssungen_Tram.pdf\" target=\"_blank\">hier</a> als PDF-Datei.</p><p>\u{c4}nderungsprotokoll:<br/>27.06.2023 - Aktualisierungsintervall von \"IRREG\" auf \"NEVER\" ge\u{e4}ndert.</p><p></p>"]
pub mod feinstaubmessungen_auf_bvb_trams {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum und Zeit
        ///
        /// Datum und Zeit in UTC
        #[serde(with = "time::serde::iso8601::option")]
        pub time: Option<OffsetDateTime>,
        /// Sensoren-ID
        ///
        /// Identitätsnummer des Feinstaubsensors
        ///Sensoren 236 und 240 sind stationär aufgestellt.
        ///Sensoren 227, 228, 234, 235 und 237 sind auf den Trams montiert.
        pub sensornr: Option<i64>,
        /// PM2.5
        ///
        /// Feinstaub mit Partikelgrösse < 2.5 tausendstel Millimeter
        pub pm25: Option<f64>,
        /// PM10
        ///
        /// Feinstaub mit Partikelgrösse < 10 tausendstel Millimeter
        pub pm10: Option<f64>,
        /// Geopunkte
        ///
        /// Standort der Messung
        pub column_7: Option<GeoPoint2d>,
        /// Längengrad
        pub longitude: Option<f64>,
        /// Breitengrad
        pub latitude: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Time,
        Sensornr,
        Pm25,
        Pm10,
        Longitude,
        Latitude,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Time => "time",
                Field::Sensornr => "sensornr",
                Field::Pm25 => "pm25",
                Field::Pm10 => "pm10",
                Field::Longitude => "longitude",
                Field::Latitude => "latitude",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100113/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "BachApp: Extras"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz enth\u{e4}lt Informationen, welche noch in keinem anderen kantonalen System gef\u{fc}hrt werden, aber f\u{fc}r die BachApp ben\u{f6}tigt werden.\u{a0}</p>"]
pub mod bachapp_extras {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Status
        pub status: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Untertitel
        pub untertitel: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        SichtbarVon,
        SichtbarBis,
        Status,
        Titel,
        Untertitel,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Status => "status",
                Field::Titel => "titel",
                Field::Untertitel => "untertitel",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100290/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Veranstaltungen mit potenziellem Einfluss auf Veloverkehr"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt ausgew\u{e4}hlte Veranstaltungen und Veranstaltungsreihen. Der Datensatz ist urspr\u{fc}nglich aufgebaut worden, um das Verkehrsaufkommen bei kantonalen Fahrrad-Z\u{e4}hlstellen \u{2013} welches unter anderem auch durch Veranstaltungen beeinflusst wird \u{2013} besser interpretieren zu k\u{f6}nnen. Aus diesem Grund sind nicht alle Veranstaltungen auf dem Kantonsgebiet im Datensatz enthalten, sondern nur diejenigen, von denen man sich einen potentiellen Einfluss auf die Anzahl an Z\u{e4}hlstellen gez\u{e4}hlten Velos erwartet. Der Datensatz wird durch das Statistische Amt Basel-Stadt nach bestem Wissen und Gewissen gepflegt und aktualisiert. Es besteht kein Anspruch auf Richtigkeit oder Vollst\u{e4}ndigkeit der gemachten Angaben. </p><p>Bei Veranstaltungen, welche nicht einer eindeutigen \u{d6}rtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo m\u{f6}glich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht m\u{f6}glich war, wurde keine \u{d6}rtlichkeit erfasst.</p>"]
pub mod veranstaltungen_mit_potenziellem_einfluss_auf_veloverkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Termin-ID
        ///
        /// ID eines Termins. Beispiel: Der Bummelsonntag hat innerhalb eines Jahres verschiedene Termin-Ids.
        pub termin_key: Option<i64>,
        /// Veranstaltung-ID
        ///
        /// ID einer Veranstaltung über alle Jahre. Beispiel: Die Fasnacht hat über alle Jahre dieselbe Veranstaltungs-ID.
        pub veranstaltung_key: Option<i64>,
        /// Name
        ///
        /// Name der Veranstaltung
        pub name: Option<String>,
        /// Code
        ///
        /// Code der Veranstaltung
        pub code: Option<String>,
        /// Kategorie
        ///
        /// Kategorie der Veranstaltung
        pub kategorie_name: Option<String>,
        /// Aktiv-Code
        ///
        /// Anzeige, ob eine Veranstaltung noch durchgeführt wird oder nicht. Wertebereich: 1=aktiv, 0=inaktiv.
        pub aktiv_code: Option<i64>,
        /// Wiederkehrend-Code
        ///
        /// Anzeige, ob eine Veranstaltung einmal oder mehrmals durchgeführt wird. Wertebereich: 1=wiederkehrend, 0=nicht wiederkehrend.
        pub wiederkehrend_code: Option<i64>,
        /// Start der Erfassung
        ///
        /// Datum, ab welchem eine Veranstaltung erfasst wurde.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub erfasst_ab: Option<Date>,
        /// Veranstaltungstag
        ///
        /// Tag, an welchem eine Veranstaltung stattfindet
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub tag_datum: Option<Date>,
        /// Jahr
        ///
        /// Jahr, in welchem eine Veranstaltung stattfindet
        pub jahr_nummer: Option<String>,
        /// Dauer in Tagen
        ///
        /// Dauer der Veranstaltung in Tagen
        pub dauer_in_tagen: Option<i64>,
        /// Startdatum
        ///
        /// Erster Tag der Veranstaltung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_von: Option<Date>,
        /// Enddatum
        ///
        /// Letzter Tag der Veranstaltung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_bis: Option<Date>,
        /// Blockseite
        ///
        /// Blockseite, an der die Veranstaltung stattfindet; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub eingang_id_blockseite: Option<i64>,
        /// Geo-Punkt
        ///
        /// Geo-Koordinaten; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub geo_point_2d: Option<GeoPoint2d>,
        /// X-Koordinate
        ///
        /// X-Koordinate des Gebäudes; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht) wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub gebaeude_koordinate_x: Option<String>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate des Gebäudes;Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub gebaeude_koordinate_y: Option<String>,
        /// Strassenname
        ///
        /// Strassenname; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub strasse_name_kanton: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, an welcher die Veranstaltung stattfindet; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub eingang_hausnummer: Option<String>,
        /// Block-ID
        ///
        /// ID des Blocks; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnblock_id_kdm_vzbbb: Option<i64>,
        /// Bezirk-ID
        ///
        /// ID des Bezirks; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnbezirk_id_kdm: Option<i64>,
        /// Bezirk
        ///
        /// Name des Bezirks; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnbezirk_name: Option<String>,
        /// Wohnviertel-ID
        ///
        /// ID des Wohnviertels oder der Landgemeinde; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnviertel_id_kdm: Option<i64>,
        /// Wohnviertel
        ///
        /// Name des Wohnviertels oder der Landgemeinde; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub wohnviertel_name: Option<String>,
        /// Gemeinde
        ///
        /// Name der Gemeinde; Bei Veranstaltungen, welche nicht einer eindeutigen Örtlichkeit zugeordnet werden konnten (z.B. Basler Fasnacht), wurde wo möglich eine Adresse erfasst, an der besonders viel Personenaufkommen erwartet wird. Wo dies nicht möglich war, wurde keine Örtlichkeit erfasst.
        pub gemeinde_name: Option<String>,
        /// Wiederkehrend
        ///
        /// Anzeige, ob eine Veranstaltung einmal oder mehrmals durchgeführt wird.
        pub wiederkehrend: Option<String>,
        /// Aktiv
        ///
        /// Anzeige, ob eine Veranstaltung noch durchgeführt wird oder nicht.
        pub aktiv: Option<String>,
        /// Beschreibung
        ///
        /// Beschreibung der Veranstaltung
        pub beschreibung: Option<String>,
        /// Bemerkungen
        ///
        /// Bemerkungen zur Veranstaltung
        pub veranstaltung_bemerkung: Option<String>,
        /// Hinweise
        ///
        /// Hinweise zu einem Termin
        pub termin_bemerkung: Option<String>,
        /// Beschreibung der Kategorie
        ///
        /// Beschreibung der Veranstaltungskategorie
        pub kategorie_beschreibung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TerminKey,
        VeranstaltungKey,
        Name,
        Code,
        KategorieName,
        AktivCode,
        WiederkehrendCode,
        ErfasstAb,
        TagDatum,
        JahrNummer,
        DauerInTagen,
        DatumVon,
        DatumBis,
        EingangIdBlockseite,
        GebaeudeKoordinateX,
        GebaeudeKoordinateY,
        StrasseNameKanton,
        EingangHausnummer,
        WohnblockIdKdmVzbbb,
        WohnbezirkIdKdm,
        WohnbezirkName,
        WohnviertelIdKdm,
        WohnviertelName,
        GemeindeName,
        Wiederkehrend,
        Aktiv,
        Beschreibung,
        VeranstaltungBemerkung,
        TerminBemerkung,
        KategorieBeschreibung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TerminKey => "termin_key",
                Field::VeranstaltungKey => "veranstaltung_key",
                Field::Name => "name",
                Field::Code => "code",
                Field::KategorieName => "kategorie_name",
                Field::AktivCode => "aktiv_code",
                Field::WiederkehrendCode => "wiederkehrend_code",
                Field::ErfasstAb => "erfasst_ab",
                Field::TagDatum => "tag_datum",
                Field::JahrNummer => "jahr_nummer",
                Field::DauerInTagen => "dauer_in_tagen",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
                Field::EingangIdBlockseite => "eingang_id_blockseite",
                Field::GebaeudeKoordinateX => "gebaeude_koordinate_x",
                Field::GebaeudeKoordinateY => "gebaeude_koordinate_y",
                Field::StrasseNameKanton => "strasse_name_kanton",
                Field::EingangHausnummer => "eingang_hausnummer",
                Field::WohnblockIdKdmVzbbb => "wohnblock_id_kdm_vzbbb",
                Field::WohnbezirkIdKdm => "wohnbezirk_id_kdm",
                Field::WohnbezirkName => "wohnbezirk_name",
                Field::WohnviertelIdKdm => "wohnviertel_id_kdm",
                Field::WohnviertelName => "wohnviertel_name",
                Field::GemeindeName => "gemeinde_name",
                Field::Wiederkehrend => "wiederkehrend",
                Field::Aktiv => "aktiv",
                Field::Beschreibung => "beschreibung",
                Field::VeranstaltungBemerkung => "veranstaltung_bemerkung",
                Field::TerminBemerkung => "termin_bemerkung",
                Field::KategorieBeschreibung => "kategorie_beschreibung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100074/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geb\u{e4}udeadressen und -informationen"]
#[doc = ""]
#[doc = "Geb\u{e4}udeadressen aller im kantonalen Datenmarkt gef\u{fc}hrten Geb\u{e4}ude (siehe <a href=\"https://www.gesetzessammlung.bs.ch/app/de/texts_of_law/153.310\" target=\"_blank\">https://www.gesetzessammlung.bs.ch/app/de/texts_of_law/153.310</a>)."]
pub mod gebaeudeadressen_und_informationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        ///
        pub geo_point_2d: Option<GeoPoint2d>,
        ///
        pub geo_shape: Option<GeoJson>,
        /// Objekt-ID
        ///
        ///
        pub objid: Option<String>,
        /// Gebäudeadresse-ID
        ///
        /// Gebäudeadresselaufnummer
        pub gebadrlauf: Option<String>,
        /// Gebäude-ID
        ///
        /// Gebäudelaufnummer
        pub geblaufnr: Option<String>,
        /// Strassencode
        ///
        /// Strassenkennzahl
        pub str_code: Option<String>,
        /// Strassen-ID
        ///
        /// Strassenidentifikator
        pub str_id: Option<String>,
        /// Strassenname
        ///
        ///
        pub str_name: Option<String>,
        /// Hausnummer
        ///
        ///
        pub hausnr: Option<String>,
        /// Hausnummerzusatz
        ///
        /// Kleinbuchstaben (a-z) werden als Zusatz zur Hausnummer verwendet (z.B. 18a, 18b).
        pub hausnr_zus: Option<String>,
        /// Hausnummerindex
        ///
        /// Die zu einem Hauptgebäude gehörenden Nebengebäude werden mit der Hausnummer des Hauptgebäudes, einem Punkt und einem fortlaufenden Index nummeriert (z.B. 19.1, 19.2).
        pub hausnr_idx: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Ort
        ///
        ///
        pub ort: Option<String>,
        /// EDID
        ///
        /// Eidgenössischer Adressidentifikator, siehe auch https://www.housing-stat.ch/de/help/faq/id.html
        pub eidgident: Option<i64>,
        /// Abfuhrzone
        ///
        /// Der Adresse zugewiesene Abfuhrzonen (siehe auch Datensatz https://data.bs.ch/explore/dataset/100095)
        pub abfuhrzone: Option<String>,
        /// Gebäudestatus
        ///
        /// Bestehende (1004), abgebrochene (1007), projektierte (1001) bzw. sich im Bau befindende (1003) Gebäude sind verschiedene Gebäudestati.
        pub gebstatus: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objid,
        Gebadrlauf,
        Geblaufnr,
        StrCode,
        StrId,
        StrName,
        Hausnr,
        HausnrZus,
        HausnrIdx,
        Plz,
        Ort,
        Eidgident,
        Abfuhrzone,
        Gebstatus,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objid => "objid",
                Field::Gebadrlauf => "gebadrlauf",
                Field::Geblaufnr => "geblaufnr",
                Field::StrCode => "str_code",
                Field::StrId => "str_id",
                Field::StrName => "str_name",
                Field::Hausnr => "hausnr",
                Field::HausnrZus => "hausnr_zus",
                Field::HausnrIdx => "hausnr_idx",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Eidgident => "eidgident",
                Field::Abfuhrzone => "abfuhrzone",
                Field::Gebstatus => "gebstatus",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100259/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Parkfl\u{e4}chen"]
#[doc = ""]
#[doc = "<p>In Basel stehen auf dem Stadtgebiet ungef\u{e4}hr 100\'000 \u{f6}ffentliche und private Auto-Parkpl\u{e4}tze zur Verf\u{fc}gung. Rund ein Viertel davon befindet sich auf Allmend. Ein Grossteil dieser Parkpl\u{e4}tze befinden in der Blauen Zone und stehen haupts\u{e4}chlich den Anwohnerinnen und Anwohner der Quartiere zur Verf\u{fc}gung. Daneben gibt es weitere Parkplatztypen: Geb\u{fc}hrenpflichtige Parkpl\u{e4}tze, Parkpl\u{e4}tze f\u{fc}r Velos und Motorr\u{e4}der, Parkpl\u{e4}tze f\u{fc}r Cars, usw.</p>\n\n<p>Die unterschiedlichen Bewirtschaftungsarten der Parkpl\u{e4}tze haben zum Ziel, dass nebst der Anwohnerschaft auch Besucher, der Detailhandel sowie das Gewerbe von den Parkpl\u{e4}tzen profitieren k\u{f6}nnen und der Parksuchverkehr reduziert werden kann. Bei den geb\u{fc}hrenpflichtigen Parkpl\u{e4}tzen sind die Parkgeb\u{fc}hren gebietsabh\u{e4}ngig.</p>\n\n<p>Die vorliegenden Daten zeigen den aktuellen Stand der erfassten Parkpl\u{e4}tze.\u{a0}Die nicht markierten Parkfl\u{e4}chen auf dem Bruderholz sind nicht enthalten. Grob gesch\u{e4}tzt sind dies etwa 1\'400 Parkpl\u{e4}tze in der Blauen Zone. Wegen Baustellen, Veranstaltungen oder aus anderen Gr\u{fc}nde kann es sein, dass Parkpl\u{e4}tze vor\u{fc}bergehend nicht zur Verf\u{fc}gung stehen. Auch ist es m\u{f6}glich, dass gewisse Parkpl\u{e4}tze im Rahmen von Umbauprojekten bereits aufgehoben wurden, das Projekt aber noch nicht abgeschlossen und somit auch der Datensatz noch nicht nachgef\u{fc}hrt ist.</p>\n\n"]
pub mod parkflaechen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<String>,
        /// Strasse
        ///
        /// Name der Strasse, in der sich die Parkfläche befindet.
        pub strasse: Option<String>,
        /// Anzahl Parkplätze pro Parkfeld
        ///
        /// Anzahl der Parkplätze, die in dieser Parkfläche zur Verfügung stehen.
        pub anzahl_parkfelder: Option<i64>,
        /// Parkflächentyp
        ///
        /// Kategorie der Parkfläche, z.B. Blaue Zone, Weisse Zone, etc.
        pub typ: Option<String>,
        /// Tarif-Gebiet
        ///
        /// Vier verschiedene Kategorien (-, A, B, C)
        pub tarif_gebiet: Option<String>,
        /// Tarif pro Stunde
        ///
        /// Hängt von Tarif Gebiet ab.
        pub sopfg_geb: Option<i64>,
        /// Tarif-ID
        ///
        /// Eindeutige Kennung für den spezifischen Tarif.
        pub tarif_id: Option<i64>,
        /// Tarif-Subzone
        ///
        /// Weitere Unterteilung von Tarif Gebiet
        pub tarif_code: Option<String>,
        /// Gebührenpflichtiger Zeitraum
        ///
        /// Hängt von Tarif-Subzone ab
        pub gebpflicht: Option<String>,
        /// Maximale Parkierdauer
        ///
        /// Hängt von Tarif-Subzone ab
        pub maxparkz: Option<i64>,
        /// Zeitraum ohne max. Parkierdauer
        ///
        /// Hängt von Tarif-Subzone ab
        pub keinl: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl
        pub plz: Option<String>,
        /// Wohnviertel-ID
        ///
        /// Eindeutige Kennung für das Wohnviertel, in dem die Parkfläche liegt.
        pub wov_id: Option<String>,
        /// Wohnviertel
        ///
        /// Name des Wohnviertels, in dem sich die Parkfläche befindet.
        pub wov_name: Option<String>,
        /// Bezirks-ID
        ///
        /// Eindeutige Kennung für den Bezirk, in dem sich die Parkfläche befindet.
        pub bez_id: Option<String>,
        /// Bezirk
        ///
        /// Name des Bezirks, in dem sich die Parkfläche befindet.
        pub bez_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Strasse,
        AnzahlParkfelder,
        Typ,
        TarifGebiet,
        SopfgGeb,
        TarifId,
        TarifCode,
        Gebpflicht,
        Maxparkz,
        Keinl,
        Plz,
        WovId,
        WovName,
        BezId,
        BezName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Strasse => "strasse",
                Field::AnzahlParkfelder => "anzahl_parkfelder",
                Field::Typ => "typ",
                Field::TarifGebiet => "tarif_gebiet",
                Field::SopfgGeb => "sopfg_geb",
                Field::TarifId => "tarif_id",
                Field::TarifCode => "tarif_code",
                Field::Gebpflicht => "gebpflicht",
                Field::Maxparkz => "maxparkz",
                Field::Keinl => "keinl",
                Field::Plz => "plz",
                Field::WovId => "wov_id",
                Field::WovName => "wov_name",
                Field::BezId => "bez_id",
                Field::BezName => "bez_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100329/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Geschwindigkeitsmonitoring: Einzelmessungen ab 2024"]
#[doc = ""]
#[doc = "<p></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: Arial, sans-serif; font-size: 10.5pt;\">Einzelmessungen des\nGeschwindigkeitsmonitorings der Kantonspolizei Basel-Stadt ab 2024 (Zeitpunkt des Beginns der Messung).</span><br></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Bei den dargestellten\nDaten handelt es sich ausschliesslich um statistische Erhebungen. Diese stehen\nnicht in einem Zusammenhang mit Ordnungsbussen oder einer strafrechtlichen\nVerfolgung. Die statistischen Geschwindigkeitsmessungen dienen der Kantonspolizei\nBasel-Stadt zur \u{dc}berpr\u{fc}fung der Geschwindigkeit sowie der Verkehrssicherheit\n(z.B. Sicherheit an Fussg\u{e4}ngerstreifen) an der betreffenden \u{d6}rtlichkeit. Die\nErgebnisse dienen zur Entscheidung, an welchen \u{d6}rtlichkeiten Handlungsbedarf in\nForm von Geschwindigkeitskontrollen besteht. Jedes Statistikger\u{e4}t besitzt eine\neinzige Punktgeometrie und ist meist mit zwei Richtungen versehen (Richtung 1\nund 2).<o:p></o:p></span></p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Hinweis: Die\nMessungen sind nicht zwingend repr\u{e4}sentativ f\u{fc}r das ganze Jahr und m\u{fc}ssen im\nKontext des Erhebungsdatums betrachtet werden. Dar\u{fc}ber hinaus wurden gewisse\nMessungen w\u{e4}hrend einer ausserordentlichen Verkehrsf\u{fc}hrung (z.B.\nUmleitungsverkehr infolge von Baustellent\u{e4}tigkeiten etc.) erhoben.\nManipulationen an Ger\u{e4}ten k\u{f6}nnen zu fehlerhaften Messungen f\u{fc}hren.<o:p></o:p></span></p><p>\n\n\n\n\n\n</p><p class=\"MsoNormal\" style=\"margin-bottom: 12pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Zum\nGeschwindigkeitsmonitoring sind folgende Datens\u{e4}tze vorhanden:<o:p></o:p></span></p><ul><li>Einzelmessungen ab 2024 (dieser Datensatz):\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100097\" target=\"_blank\">https://data.bs.ch/explore/dataset/100097</a><a href=\"https://data.bs.ch/explore/dataset/100097\" target=\"_blank\"></a></li><li>Einzelmessungen von 2021 bis 2023:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100358\" target=\"_blank\">https://data.bs.ch/explore/dataset/100358</a><br></li><li>Einzelmessungen bis 2020:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100200\" target=\"_blank\">https://data.bs.ch/explore/dataset/100200</a></li><li>Kennzahlen pro Mess-Standort:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100112\" target=\"_blank\">https://data.bs.ch/explore/dataset/100112</a>\u{a0}</li></ul>Aufgrund der grossen Datenmenge kann es vorkommen, dass der Datensatz nicht vollst\u{e4}ndig heruntergeladen werden kann. Falls dieses Problem auftritt, kann man den vollst\u{e4}ndigen Datensatz und die Einzelmessungen der Messstationen hier herunterladen:<p></p><ul><li>vollst\u{e4}ndiger Datensatz:\u{a0}<a href=\"https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/all_data/geschwindigkeitsmonitoring_data.csv\">https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/all_data/geschwindigkeitsmonitoring_data.csv</a></li><li>Einzelmessungen der Messstationen:\u{a0}<a href=\"https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/data/\">https://data-bs.ch/stata/kapo/geschwindigkeitsmonitoring/data/</a></li></ul><p>Die Mess-Standorte werden auch auf dem Geoportal Basel-Stadt publiziert:\u{a0}<a href=\"https://map.geo.bs.ch/s/geschwindigkeit\" target=\"_blank\">https://map.geo.bs.ch/s/geschwindigkeit</a></p>"]
pub mod geschwindigkeitsmonitoring_einzelmessungen_ab_2024 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Timestamp
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit in km/h
        pub geschwindigkeit: Option<f64>,
        /// Zeit
        ///
        /// Uhrzeit (hh:mm:ss) einer gemessenen Fahrt
        pub zeit: Option<String>,
        /// Datum
        pub datum: Option<String>,
        /// Datum und Zeit
        ///
        /// Datum und Uhrzeit als Text formatiert
        pub datum_zeit: Option<String>,
        /// Messbeginn
        ///
        /// Datum, an welchem ein Messgerät an einem Standort ausgebracht wurde
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Datum, bis zu welchem ein Messgerät an einem Standort im Einsatz war
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Zone
        ///
        /// geltende Höchstgeschwindigkeit am Standort der Messung
        pub zone: Option<f64>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// Übertretungsquote
        ///
        /// Anteil der Fahrzeuge, welche die geltende Höchstgeschwindigkeit überschritten haben
        pub ue_quote: Option<f64>,
        /// Geschwindigkeit V50
        ///
        /// Höchstgeschwindigkeit, welche von 50% der Fahrzeuge nicht überschritten wird
        pub v50: Option<f64>,
        /// Geschwindigkeit V85
        ///
        /// Höchstgeschwindigkeit, welche von 85% der Fahrzeuge nicht überschritten wird
        pub v85: Option<f64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge während einer Messung
        pub fzg: Option<i64>,
        /// Fahrzeuglänge
        ///
        /// Vom Radar gemessene Fahrzeuglänge
        pub fahrzeuglange: Option<f64>,
        /// Kennzahlen pro Mess-Standort
        ///
        /// Link zum nach der aktuellen Messung gefilterten Datensatz "Kennzahlen pro Mess-Standort"
        pub link_zu_messung: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        MessungId,
        RichtungId,
        Geschwindigkeit,
        Zeit,
        Datum,
        DatumZeit,
        Messbeginn,
        Messende,
        Zone,
        Ort,
        Richtung,
        UeQuote,
        V50,
        V85,
        Strasse,
        StrasseNr,
        Fzg,
        Fahrzeuglange,
        LinkZuMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::MessungId => "messung_id",
                Field::RichtungId => "richtung_id",
                Field::Geschwindigkeit => "geschwindigkeit",
                Field::Zeit => "zeit",
                Field::Datum => "datum",
                Field::DatumZeit => "datum_zeit",
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Zone => "zone",
                Field::Ort => "ort",
                Field::Richtung => "richtung",
                Field::UeQuote => "ue_quote",
                Field::V50 => "v50",
                Field::V85 => "v85",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Fzg => "fzg",
                Field::Fahrzeuglange => "fahrzeuglange",
                Field::LinkZuMessung => "link_zu_messung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100097/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abfuhrtermine"]
#[doc = ""]
#[doc = "<p>Abfuhrtermine der Stadtreinigung (Tiefbauamt) der Stadt Basel. Siehe auch <a href=\"http://www.tiefbauamt.bs.ch/abfuhrplaene\" target=\"_blank\">http://www.tiefbauamt.bs.ch/abfuhrplaene</a>. Abfuhranmeldung unter <a href=\"http://www.tiefbauamt.bs.ch/abfuhranmeldung\" target=\"_blank\">http://www.tiefbauamt.bs.ch/abfuhranmeldung</a></p>"]
pub mod abfuhrtermine {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Termin
        ///
        /// Datum der Abfuhr
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub termin: Option<Date>,
        /// Art
        ///
        /// Art der Abfuhr
        pub art: Option<String>,
        /// Wochentag
        ///
        /// Wochentag des Abfuhrtermins
        pub wochentag: Option<String>,
        /// Tag der Woche
        ///
        /// Wochentag als Zahl (1=Montag, 2=Dienstag, etc.)
        pub dayofweek: Option<i64>,
        /// Zone
        ///
        /// Abfuhrzone
        pub zone: Option<String>,
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Termin,
        Art,
        Wochentag,
        Dayofweek,
        Zone,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Termin => "termin",
                Field::Art => "art",
                Field::Wochentag => "wochentag",
                Field::Dayofweek => "dayofweek",
                Field::Zone => "zone",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100096/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Liegenschaften: Parzellen"]
#[doc = ""]
#[doc = "Der Datensatz beinhaltet alle Liegenschaften des Kantons. Es wird zwischen Liegenschaft und Allmendparzelle unterschieden."]
pub mod liegenschaften_parzellen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Geo Punkt
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Name Art Liegenschaft
        ///
        /// Unterschieden wird zwischen Liegenschaft und Allmendparzelle.
        pub r1_art_txt: Option<String>,
        /// Fläche in Quadratmeter m2
        ///
        /// Fläche gemäss Eigentumsauskunft in Quadratmeter m2
        pub flaechenma: Option<i64>,
        /// EGRID
        ///
        /// Die Eidgenössische Grundstücksidentifikation (E-GRID) dient der eindeutigen Identifikation jedes Grundstücks gemäss schweizerischem Grundbuchrecht.
        pub r1_egris_e: Option<String>,
        /// Parzellennummer
        ///
        /// Die Parzellennummer ist einer Parzelle, also einem Stück Land, eindeutig zugeordnet. Anhand dieser Nummer ist es möglich, Parzellen zu identifizieren und weitere Informationen zu ihnen einzuholen.
        pub parzellennummer: Option<String>,
        /// Sektion
        ///
        /// Sektion des Grundbuchkreises
        pub r1_sektion: Option<String>,
        /// NBIdent
        ///
        /// Nummerierungsbereich-Identifikator
        pub r1_nbident: Option<String>,
        /// Objektnummer
        ///
        /// Anhand dieser Nummer ist es möglich, Parzellen zu identifizieren und weitere Informationen zu ihnen einzuholen. Setzt sich zusammen aus Parzellennummer und Index.
        pub r1_nummer: Option<String>,
        /// Code Art Liegenschaft
        ///
        /// Code zur Art der Liegenschaft
        pub r1_art: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        R1ArtTxt,
        Flaechenma,
        R1EgrisE,
        Parzellennummer,
        R1Sektion,
        R1Nbident,
        R1Nummer,
        R1Art,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::R1ArtTxt => "r1_art_txt",
                Field::Flaechenma => "flaechenma",
                Field::R1EgrisE => "r1_egris_e",
                Field::Parzellennummer => "parzellennummer",
                Field::R1Sektion => "r1_sektion",
                Field::R1Nbident => "r1_nbident",
                Field::R1Nummer => "r1_nummer",
                Field::R1Art => "r1_art",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100201/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte der Z\u{e4}hlstellen f\u{fc}r Verkehrsz\u{e4}hldaten"]
#[doc = ""]
#[doc = "Standorte der Dauerz\u{e4}hlstellen f\u{fc}r den motorisierten Individualverkehr (MIV) mit eigens f\u{fc}r die Z\u{e4}hlung installierten Induktionsschleifen und an den Induktionsschleifen von Lichtsignalanlagen (LSA). Zus\u{e4}tzlich die Standorte der Fussg\u{e4}nger- und Veloz\u{e4}hlstellen sowie der Kurzzeitz\u{e4}hlstellen."]
pub mod standorte_der_zaehlstellen_fuer_verkehrszaehldaten {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID_ZST
        pub id_zst: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// GEMEINDE
        pub gemeinde: Option<String>,
        /// KLASSE
        pub klasse: Option<String>,
        /// KOMBINIERT
        pub kombiniert: Option<String>,
        /// ART
        pub art: Option<String>,
        /// ARME
        pub arme: Option<f64>,
        /// FAHRSTREIF
        pub fahrstreif: Option<f64>,
        /// ZWECK
        pub zweck: Option<String>,
        /// TYP
        pub typ: Option<String>,
        /// STRTYP
        pub strtyp: Option<String>,
        /// EIGENTUM
        pub eigentum: Option<String>,
        /// BETRIEBNAH
        #[serde(with = "time::serde::iso8601::option")]
        pub betriebnah: Option<OffsetDateTime>,
        /// BETRIEBZUS
        pub betriebzus: Option<String>,
        /// LINK
        pub link: Option<String>,
        /// FORMAT
        pub format: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdZst,
        Name,
        Gemeinde,
        Klasse,
        Kombiniert,
        Art,
        Arme,
        Fahrstreif,
        Zweck,
        Typ,
        Strtyp,
        Eigentum,
        Betriebnah,
        Betriebzus,
        Link,
        Format,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdZst => "id_zst",
                Field::Name => "name",
                Field::Gemeinde => "gemeinde",
                Field::Klasse => "klasse",
                Field::Kombiniert => "kombiniert",
                Field::Art => "art",
                Field::Arme => "arme",
                Field::Fahrstreif => "fahrstreif",
                Field::Zweck => "zweck",
                Field::Typ => "typ",
                Field::Strtyp => "strtyp",
                Field::Eigentum => "eigentum",
                Field::Betriebnah => "betriebnah",
                Field::Betriebzus => "betriebzus",
                Field::Link => "link",
                Field::Format => "format",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100038/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "G\u{fc}teklassen \u{f6}ffentlicher Verkehr"]
#[doc = ""]
#[doc = "Die G\u{fc}teklassen zeigen auf, wie gut ein Gebiet mit dem \u{f6}ffentlichen Verkehr erschlossen ist. Die Klasse ist abh\u{e4}ngig von dem Transportmittel (Kleinbus, Bus, Tram, S-Bahn, Fernverkehrszug), dem jeweiligen Takt und der Distanz zur Haltestelle. Die Klasse zeigt die beste Erschliessung auf."]
pub mod gueteklassen_oeffentlicher_verkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// OBJECTID
        pub objectid: Option<i64>,
        /// OEVGKl
        pub oevgkl: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Objectid,
        Oevgkl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Objectid => "objectid",
                Field::Oevgkl => "oevgkl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100022/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "T\u{e4}gliche Logiern\u{e4}chte, verf\u{fc}gbare und belegte Zimmer"]
#[doc = ""]
#[doc = "Dieser Datensatz zeigt die Anzahl Logiern\u{e4}chte, verf\u{fc}gbare und belegte Zimmer in baselst\u{e4}dtischen Hotels nach Kategorie auf t\u{e4}glicher Basis."]
pub mod taegliche_logiernaechte_verfuegbare_und_belegte_zimmer {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// Hotelkategorie
        ///
        /// Hotelkategorie; 1- und 2-Sterne, 3-Sterne, 4- und 5-Sterne, Übrige. Die Kategorie Übrige umfasst: Hotels, die (noch) nicht kategorisiert wurden sowie B&Bs und Jugendherbergen.
        pub hotelkategorie: Option<String>,
        /// Anzahl Logiernächte
        ///
        /// Anzahl Übernachtungen an einem bestimmten Tag in baselstädtischen Hotels
        pub anzlogiernaechte: Option<i64>,
        /// Anzahl verfügbare Zimmer
        ///
        /// Anzahl Zimmer, welche an einem bestimmten Tag in einem baselstädtischen Hotel zur Verfügung stehen
        pub anzzimmerverfuegbarundgeoeffnet: Option<i64>,
        /// Anzahl belegte Zimmer
        ///
        /// Anzahl an einem bestimmten Tag belegte Zimmer in einem baselstädtischen Hotel
        pub anzzimmerbelegungen: Option<i64>,
        /// Jahr
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr: Option<Date>,
        /// Monat
        pub monat: Option<i64>,
        /// Tag
        pub tag: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Hotelkategorie,
        Anzlogiernaechte,
        Anzzimmerverfuegbarundgeoeffnet,
        Anzzimmerbelegungen,
        Jahr,
        Monat,
        Tag,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Hotelkategorie => "hotelkategorie",
                Field::Anzlogiernaechte => "anzlogiernaechte",
                Field::Anzzimmerverfuegbarundgeoeffnet => "anzzimmerverfuegbarundgeoeffnet",
                Field::Anzzimmerbelegungen => "anzzimmerbelegungen",
                Field::Jahr => "jahr",
                Field::Monat => "monat",
                Field::Tag => "tag",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100106/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Bade-, Trinkwasser- und Zierbrunnen in Basel"]
#[doc = ""]
#[doc = "<p>In der Stadt Basel betreibt IWB \u{fc}ber 200 \u{f6}ffentliche Brunnen. Sie sind Kulturgut und \u{ab}Visitenkarte\u{bb} der Stadt. <a href=\"https://www.iwb.ch/brunnen\" target=\"_blank\">https://www.iwb.ch/brunnen</a><a href=\"https://www.iwb.ch/brunnen\" target=\"_blank\"></a><br/>Wenn Sie Fragen oder Anliegen rund um die Basler Brunnen haben, empfehlen wir Ihnen, sich direkt an die Industriellen Werke Basel (IWB) zu wenden, die f\u{fc}r diese Angelegenheiten zust\u{e4}ndig sind. F\u{fc}r weitere Informationen und Kontaktdetails besuchen Sie bitte die offizielle Webseite der IWB: <a href=\"https://www.iwb.ch/servicecenter/kontakt\" target=\"_blank\">https://www.iwb.ch/servicecenter/kontakt</a><br/></p><p>In einigen Brunnen ist auch Baden m\u{f6}glich und vom Eigent\u{fc}mer, dem Kanton Basel-Stadt, toleriert, jedoch auf eigene Verantwortung und Gefahr. Wir bitten darum, die Brunnen sauber zu hinterlassen und auf Anwohner R\u{fc}cksicht zu nehmen.\u{a0}</p>"]
pub mod bade_trinkwasser_und_zierbrunnen_in_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// Description
        pub desc: Option<String>,
        /// Picture
        pub gx_media_links: Option<File>,
        pub picture_link: Option<String>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
        Desc,
        PictureLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::Desc => "desc",
                Field::PictureLink => "picture_link",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100008/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Geimpfte Personen mit Wohnsitz in Basel-Stadt"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die SARS-CoV-2-Impfungen, welche an Personen mit Wohnsitz im Kanton Basel-Stadt verabreicht wurden nach Impfstatus. Unterschieden wird dabei auf oberster Ebene in teilweise geimpfte Personen, vollst\u{e4}ndig geimpfte Personen und Personen mit Auffrischimpfung. Die Definitionen dieser Einteilung finden Sie in den Spaltenbeschreibungen resp. im Datensatzschema.\u{a0}</p><p>Die Datenbasis bildet der Vaccination Monitoring Data Lake (VMDL) des BAG. Der Datensatz wird st\u{fc}ndlich aktualisiert.\u{a0}</p><p>Anmerkung: Die geimpften Personen wohnen im Kanton Basel-Stadt, m\u{fc}ssen aber nicht zwingend auch im Kanton Basel-Stadt geimpft worden sein. Aus diesem Grund unterscheiden sich die hier publizierten Zahlen auch von jenen im\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100111\" target=\"_blank\">Datensatz mit den im Kanton Basel-Stadt verabreichten Impfungen</a>.</p><p>Methodische Hinweise:<br/>Als vollst\u{e4}ndig geimpft gelten folgende Personen:</p><ul><li>Mindestens zwei Dosen einer Mehrdosisimpfung</li><li>Eine Dosis einer Einmaldosisimpfung</li><li>Genesene (positiver PCR-Test) und mindestens eine Dosis einer Einmal- oder einer Mehrdosisimpfung</li></ul><p>Als teilweise geimpft gelten folgende Personen:</p><ul><li>Erste Dosis einer Mehrdosisimpfung</li></ul><p>Als mit mindestens einer Dosis geimpft gelten folgende Personen:</p><ul><li>Mindestens eine Dosis einer Einmal- oder einer Mehrfachdosisimpfung</li></ul><p>Als Impfung aufgefrischt gelten folgende Personen:</p><ul><li>Mindestens dritte Dosis einer Mehrfachdosisimpfung nach abgeschlossener Grundimmunisierung durch Mehrdosisimpfung</li><li>Genesene (positiver PCR-Test) mit zweiter Dosis einer Mehrdosisimpfung</li><li>Erste Dosis einer Mehrdosisimpfung nach abgeschlossener Grundimmunisierung durch eine Einmaldosisimpfung</li></ul><p>Der Code f\u{fc}r die Berechnung der verschiedenen Impftypen kann unter diesem Link eingesehen werden:\u{a0}<a href=\"https://github.com/opendatabs/data-processing/blob/master/bag_coronavirus/src/etl_vmdl_impftyp.py\" target=\"_blank\">https://github.com/opendatabs/data-processing/blob/master/bag_coronavirus/src/etl_vmdl_impftyp.py</a><a href=\"https://github.com/opendatabs/data-processing/blob/master/bag_coronavirus/src/etl_vmdl_impftyp.py\" target=\"_blank\"></a></p><p>Die Meldepflicht der COVID-Impfungen via VMDL Plattform des Bundes wurde per 1. Juli 2023 aufgehoben. Nach diesem Datum wurden Impfungen deshalb nicht mehr systematisch erfasst. Der vorliegende Datensatz zeigt deshalb Impfungen nur bis 1. Juli 2023.<br/></p>"]
pub mod coronavirus_covid_19_geimpfte_personen_mit_wohnsitz_in_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub vacc_day: Option<Date>,
        /// Vollständig Geimpfte
        ///
        /// Anzahl Personen, welche als vollständig gegen SARS-CoV-2 geimpft gelten. Dieser Status kann auf verschiedene Weise erreicht werden.
        pub vollstaendig_geimpft: Option<i64>,
        /// Teilweise Geimpfte
        ///
        /// Anzahl Personen, welche als teilweise gegen SARS-CoV-2 geimpft gelten.
        pub teilweise_geimpft: Option<i64>,
        /// Mit mind. einer Dosis Geimpfte
        ///
        /// Anzahl Personen, welche mit mindestens einer Dosis gegen SARS-CoV-2 geimpft sind.
        pub mit_mindestens_einer_dosis_geimpft: Option<i64>,
        /// Auffrischimpfung (Booster)
        ///
        /// Anzahl Personen, welche zusätzlich zur Grundimmunisierung eine Auffrischimpfung gegen SARS-CoV-2 erhalten haben.
        pub impfung_aufgefrischt: Option<i64>,
        /// Neu teilweise Geimpfte
        ///
        /// Anzahl Personen, welche an einem bestimmten Datum gegenüber dem Vortag neu als teilweise gegen SARS-CoV-2 geimpft gelten.
        pub neu_teilweise_geimpft: Option<i64>,
        /// Neu vollständig Geimpfte
        ///
        /// Anzahl Personen, welche an einem bestimmten Datum gegenüber dem Vortag neu als vollständig gegen SARS-CoV-2 geimpft gelten.
        pub neu_vollstaendig_geimpft: Option<i64>,
        /// Neu mit Auffrischimpfung (Booster)
        ///
        /// Anzahl Personen, welche an einem bestimmten Datum gegenüber dem Vortag neu als zusätzlich mit einer Auffrischimpfung gegen SARS-CoV-2 geimpft gelten.
        pub neu_impfung_aufgefrischt: Option<i64>,
        /// Anteil vollst. Geimpfte
        ///
        /// Anteil vollständig gegen SARS-CoV-2 geimpfter Personen an der Wohnbevölkerung
        pub anteil_vollstaendig_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Anteil teilw. Geimpfte
        ///
        /// Anteil teilweise gegen SARS-CoV-2 geimpfter Personen an der Wohnbevölkerung
        pub anteil_teilweise_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Anteil mit Auffrischimpfung
        ///
        /// Anteil Personen, welche zusätzlich zur Grundimmunisierung eine Auffrischimpfung gegen SARS-CoV-2 erhalten haben an der Gesamtbevölkerung.
        pub anteil_impfung_aufgefrischt_an_wohnbevoelkerung: Option<f64>,
        /// Anteil mit mind. 1 Dosis Geimpfte
        ///
        /// Anteil Personen, welche mit mindestens einer Dosis gegen SARS-CoV-2 geimpft sind an der Gesamtbevölkerung.
        pub anteil_mit_mindestens_einer_dosis_geimpft: Option<f64>,
        /// 1. Dosis Mehrdosisimpfung (Grundimmunisierung)
        ///
        /// Anzahl Personen, welche mit der ersten Dosis einer Mehrfachdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x11_erste_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// 2. Dosis Mehrdosisimpfung (Grundimmunisierung)
        ///
        /// Anzahl Personen, welche im Rahmen der Grundimmunisierung mit der zweiten Dosis einer Mehrdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x12_zweite_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// Genesen mit 1. Dosis Mehrdosisimpfung
        ///
        /// Anzahl Personen, welche als genesen gelten (positiver PCR-Test) und zusätzlich mit einer ersten Dosis einer Mehrdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x101_genesen_mit_erster_dosis_einer_mehrdosisimpfung: Option<i64>,
        /// 3. Impfungen Auffrischimpfung
        ///
        /// Anzahl Personen, welche im Rahmen der Auffrischimpfung mit mindestens einer dritten Dosis gegen SARS-CoV-2 geimpft sind.
        pub x29_mindestens_dritte_dosis_einer_mehrdosisimpfung_auffrischimpfung: Option<i64>,
        /// 3. Impfungen Grundimmunisierung
        ///
        /// Anzahl Personen, welche im Rahmen der Grundimmunisierung mit mindestens drei Dosen einer Mehrdosisimpfung gegen SARS-CoV-2 geimpft sind.
        pub x19_mindestens_dritte_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// Impfung mit Einmaldosis (Grundimmunisierung)
        ///
        /// Anzahl Personen, welche im Rahmen der Grundimmunisierung mit einer Einmaldosisimpfung gegen SARS-COV-2 geimpft sind.
        pub x1_impfung_mit_einmaldosis_grundimmunisierung: Option<i64>,
        /// Genesen mit Einmaldosis
        ///
        /// Anzahl Personen, welche als genesen gelten (positiver PCR-Test) und zusätzlich im Rahmen der Grundimmunisierung mit einer Einmaldosisimpfung gegen SARS-COV-2 geimpft sind.
        pub x100_genesen_mit_einmaldosis: Option<i64>,
        /// 2. Dosis mit Mehrdosisimpfung (Auffrischimpfung)
        ///
        /// Anzahl Personen, welche im Rahmen der Auffrischimpfung (nach Grundimmunisierung mit Einmaldosisimpfung) mit einer zweiten Dosis einer Mehrdosisimpfung gegen SRAS-CoV-2 geimpft sind.
        pub x22_zweite_dosis_mit_einer_mehrdosisimpfung_auffrischimpfung_einer_impfung_mit_einmaldosis:
            Option<i64>,
        /// Andere
        ///
        /// Andere Impftypen
        pub x1_andere: Option<i64>,
        /// Bevölkerungszahl Statpop
        ///
        /// Bevölkerungszähl gemäss Bundesamt für Statistik (STATPOP)
        pub bevoelkerungszahl_statpop: Option<i64>,
        /// Anteil mit mindestens dritter Dosis geimpft an Wohnbevölkerung
        ///
        /// Anteil Personen, welche mit mindestens dritter Dosis gegen SARS-CoV-2 geimpft sind an der Gesamtbevölkerung.
        pub anteil_mit_mindestens_dritter_dosis_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Anteil mit mindestens zweiter Auffrischimpfung geimpft an Wohnbevölkerung
        ///
        /// Anteil Personen, welche mit mindestens zweiter Auffrischimpfung gegen SARS-CoV-2 geimpft sind an der Gesamtbevölkerung.
        pub anteil_mit_mindestens_zweiter_auffrischimpfung_geimpft_an_wohnbevoelkerung: Option<f64>,
        /// Genesen mit 2. Dosis Grundimmunisierung
        ///
        /// Anzahl genesene Personen (positiver PCR-Test), welche mit 2. Dosis einer Mehrdosisimpfung im Rahmen der Grundimmunisierung gegen SARS-CoV-2 geimpft sind.
        pub x102_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_grundimmunisierung: Option<i64>,
        /// Genesen mit 2. Dosis (Auffrischimpfung)
        ///
        /// Anzahl genesene Personen (positiver PCR-Test), welche mit 2. Dosis einer Mehrdosisimpfung im Rahmen der Auffrischimpfung gegen SARS-CoV-2 geimpft sind.
        pub x202_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_auffrischimpfung: Option<i64>,
        /// Mind. 2. Auffrischimpfung
        ///
        /// Anzahl Personen, welche mindestens eine zweite Auffrischimpfung erhalten haben.
        pub x39_mindestens_zweite_auffrischimpfung: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        VaccDay,
        VollstaendigGeimpft,
        TeilweiseGeimpft,
        MitMindestensEinerDosisGeimpft,
        ImpfungAufgefrischt,
        NeuTeilweiseGeimpft,
        NeuVollstaendigGeimpft,
        NeuImpfungAufgefrischt,
        AnteilVollstaendigGeimpftAnWohnbevoelkerung,
        AnteilTeilweiseGeimpftAnWohnbevoelkerung,
        AnteilImpfungAufgefrischtAnWohnbevoelkerung,
        AnteilMitMindestensEinerDosisGeimpft,
        X11ErsteDosisEinerMehrdosisimpfungGrundimmunisierung,
        X12ZweiteDosisEinerMehrdosisimpfungGrundimmunisierung,
        X101GenesenMitErsterDosisEinerMehrdosisimpfung,
        X29MindestensDritteDosisEinerMehrdosisimpfungAuffrischimpfung,
        X19MindestensDritteDosisEinerMehrdosisimpfungGrundimmunisierung,
        X1ImpfungMitEinmaldosisGrundimmunisierung,
        X100GenesenMitEinmaldosis,
        X22ZweiteDosisMitEinerMehrdosisimpfungAuffrischimpfungEinerImpfungMitEinmaldosis,
        X1Andere,
        BevoelkerungszahlStatpop,
        AnteilMitMindestensDritterDosisGeimpftAnWohnbevoelkerung,
        AnteilMitMindestensZweiterAuffrischimpfungGeimpftAnWohnbevoelkerung,
        X102GenesenMitZweiterDosisEinerMehrdosisimpfungGrundimmunisierung,
        X202GenesenMitZweiterDosisEinerMehrdosisimpfungAuffrischimpfung,
        X39MindestensZweiteAuffrischimpfung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
Field::VaccDay => "vacc_day",
Field::VollstaendigGeimpft => "vollstaendig_geimpft",
Field::TeilweiseGeimpft => "teilweise_geimpft",
Field::MitMindestensEinerDosisGeimpft => "mit_mindestens_einer_dosis_geimpft",
Field::ImpfungAufgefrischt => "impfung_aufgefrischt",
Field::NeuTeilweiseGeimpft => "neu_teilweise_geimpft",
Field::NeuVollstaendigGeimpft => "neu_vollstaendig_geimpft",
Field::NeuImpfungAufgefrischt => "neu_impfung_aufgefrischt",
Field::AnteilVollstaendigGeimpftAnWohnbevoelkerung => "anteil_vollstaendig_geimpft_an_wohnbevoelkerung",
Field::AnteilTeilweiseGeimpftAnWohnbevoelkerung => "anteil_teilweise_geimpft_an_wohnbevoelkerung",
Field::AnteilImpfungAufgefrischtAnWohnbevoelkerung => "anteil_impfung_aufgefrischt_an_wohnbevoelkerung",
Field::AnteilMitMindestensEinerDosisGeimpft => "anteil_mit_mindestens_einer_dosis_geimpft",
Field::X11ErsteDosisEinerMehrdosisimpfungGrundimmunisierung => "11_erste_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X12ZweiteDosisEinerMehrdosisimpfungGrundimmunisierung => "12_zweite_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X101GenesenMitErsterDosisEinerMehrdosisimpfung => "101_genesen_mit_erster_dosis_einer_mehrdosisimpfung",
Field::X29MindestensDritteDosisEinerMehrdosisimpfungAuffrischimpfung => "29_mindestens_dritte_dosis_einer_mehrdosisimpfung_auffrischimpfung",
Field::X19MindestensDritteDosisEinerMehrdosisimpfungGrundimmunisierung => "19_mindestens_dritte_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X1ImpfungMitEinmaldosisGrundimmunisierung => "1_impfung_mit_einmaldosis_grundimmunisierung",
Field::X100GenesenMitEinmaldosis => "100_genesen_mit_einmaldosis",
Field::X22ZweiteDosisMitEinerMehrdosisimpfungAuffrischimpfungEinerImpfungMitEinmaldosis => "22_zweite_dosis_mit_einer_mehrdosisimpfung_auffrischimpfung_einer_impfung_mit_einmaldosis",
Field::X1Andere => "1_andere",
Field::BevoelkerungszahlStatpop => "bevoelkerungszahl_statpop",
Field::AnteilMitMindestensDritterDosisGeimpftAnWohnbevoelkerung => "anteil_mit_mindestens_dritter_dosis_geimpft_an_wohnbevoelkerung",
Field::AnteilMitMindestensZweiterAuffrischimpfungGeimpftAnWohnbevoelkerung => "anteil_mit_mindestens_zweiter_auffrischimpfung_geimpft_an_wohnbevoelkerung",
Field::X102GenesenMitZweiterDosisEinerMehrdosisimpfungGrundimmunisierung => "102_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_grundimmunisierung",
Field::X202GenesenMitZweiterDosisEinerMehrdosisimpfungAuffrischimpfung => "202_genesen_mit_zweiter_dosis_einer_mehrdosisimpfung_auffrischimpfung",
Field::X39MindestensZweiteAuffrischimpfung => "39_mindestens_zweite_auffrischimpfung",
}
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100162/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wasserstand Grundwasser: Langj\u{e4}hrige Statistiken"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die absoluten extremalen Messwerte (kleinster Wert \u{201e}10YMin\u{201c} bzw. gr\u{f6}sster Wert \u{201e}10YMax\u{201c}) und den Mittelwert aller Messwerte (\u{201e}Mean\u{201c}) der Grundwasserst\u{e4}nde in m \u{fc}. M. des kantonalen Grundwassermessnetzes und in der angegebenen Periode (startStatist bis endStatist, d.h. i. d. R. 10 Jahre).</p><p>Weitere Informationen: <a href=\"https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html\">https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html</a></p>"]
pub mod wasserstand_grundwasser_langjaehrige_statistiken {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationId
        ///
        /// Identifikationsnummer
        pub stationid: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// 10YMin
        ///
        /// kleinster Messwert (nach 10 Jahren)
        pub x10ymin: Option<f64>,
        /// 10YMean
        ///
        /// Mittelwert aller Messwerte (nach 10 Jahren)
        pub x10ymean: Option<f64>,
        /// 10YMax
        ///
        /// grösster Messwert (nach 10 Jahren)
        pub x10ymax: Option<f64>,
        /// startStatist
        ///
        /// Start Messung
        pub startstatist: Option<String>,
        /// endStatist
        ///
        /// Ende Messung
        pub endstatist: Option<String>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_start_timestamp: Option<OffsetDateTime>,
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub stat_end_timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Stationnr,
        Stationid,
        Stationname,
        Sensornr,
        Sensname,
        Lat,
        Lon,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        X10ymin,
        X10ymean,
        X10ymax,
        Startstatist,
        Endstatist,
        BohrkatasterLink,
        StatStartTimestamp,
        StatEndTimestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Stationnr => "stationnr",
                Field::Stationid => "stationid",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::X10ymin => "10ymin",
                Field::X10ymean => "10ymean",
                Field::X10ymax => "10ymax",
                Field::Startstatist => "startstatist",
                Field::Endstatist => "endstatist",
                Field::BohrkatasterLink => "bohrkataster_link",
                Field::StatStartTimestamp => "stat_start_timestamp",
                Field::StatEndTimestamp => "stat_end_timestamp",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100180/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Sauberkeitsindex pro Monat und Strassenabschnitt"]
#[doc = ""]
#[doc = "<p class=\"\">Dieser Datensatz enth\u{e4}lt den Sauberkeitsindex f\u{fc}r alle Strassenabschnitte in der Stadt Basel. Zur Berechnung des Sauberkeitsindex wird wie folgt vorgegangen:</p><p>Auf den Kehrrichtfahrzeugen sind Kameras installiert, die w\u{e4}hrend der Eins\u{e4}tze Videoaufnahmen der Strassen machen. Ein Computer durchsucht anschliessend diese Videoaufnahmen nach Abf\u{e4}llen. Dieser sortiert die Abf\u{e4}lle in verschiedene Abfallkategorien (Zigarettenstummel, Papier, PET-Flaschen etc.) und z\u{e4}hlt die Anzahl der gefundenen Abf\u{e4}lle jeder Kategorie. Zus\u{e4}tzlich wird f\u{fc}r jede Abfallkategorie der Verschmutzungsgrad und der St\u{f6}rfaktor bestimmt. Daraus wird der Sauberkeitsindex berechnet. Danach werden die Videoaufnahmen aus Datenschutzgr\u{fc}nden umgehend gel\u{f6}scht.</p><p></p><p>Der Sauberkeitsindex wird auf einer Skala von 0 bis 5 angegeben, wobei die Werte folgendermassen beurteilt werden:<br><span style=\"font-family: inherit; font-size: 0.875rem;\">Kleiner als 3: schlecht<br></span><span style=\"font-family: inherit; font-size: 0.875rem;\">Zwischen 3 und 4: mittel<br></span><span style=\"font-family: inherit; font-size: 0.875rem;\">Gr\u{f6}sser als 4: gut</span></p><p>\nDer Grosse Rat beauftragt das Tiefbauamt mit dem Erreichen eines Indexes f\u{fc}r die gesamte Stadt von mindestens 4.5.\n</p><p></p><p></p><p></p><p class=\"\">Der Datensatz wird monatlich mit den Daten des Vormonats aktualisiert.</p>"]
pub mod sauberkeitsindex_pro_monat_und_strassenabschnitt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datenstand
        ///
        /// Stand der Daten zu einem bestimmten Zeitpunkt
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datenstand: Option<Date>,
        /// ID Strassenabschnitt
        ///
        /// Eindeutiger Identifikator
        pub id: Option<String>,
        /// Strassenabschnitt
        ///
        /// Name des Strassenabschnitts
        pub strasse: Option<String>,
        /// CCI
        ///
        /// CCI steht für «Clean City Index» und ist der Sauberkeitsindex, der zwischen 0 (schmutzig) bis 5 (sauber) liegt.
        pub cci: Option<f64>,
        /// Anzahl Messungen
        ///
        /// Die Anzahl der Messungen umfasst die Anzahl der Durchfahrten des Kehrrichtlastwagens im jeweiligen Strassenabschnitt pro Monat.
        pub anzahl_messungen: Option<i64>,
        /// Letzte Messung
        ///
        /// Die letzte Messung des Sauberkeitsindexes des jeweiligen Strassenabschnitts.
        #[serde(with = "time::serde::iso8601::option")]
        pub letzte_messung: Option<OffsetDateTime>,
        /// Geometry
        pub geometry: Option<GeoJson>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datenstand,
        Id,
        Strasse,
        Cci,
        AnzahlMessungen,
        LetzteMessung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datenstand => "datenstand",
                Field::Id => "id",
                Field::Strasse => "strasse",
                Field::Cci => "cci",
                Field::AnzahlMessungen => "anzahl_messungen",
                Field::LetzteMessung => "letzte_messung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100288/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Nutzungsplan - Zonenplan Stadt Basel:  \u{dc}berlagernde Festlegungen"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet Informationen \u{fc}ber die Grundnutzung \u{fc}berlagernder Fl\u{e4}chen und ist ein Teil des Geodatenmodelles des Kantons Basel-Stadt zum Thema ?Nutzungsplanung?.<br>Weitere Daten zum Thema ?Nutzungsplanung?: <a href=\"https://data.bs.ch/explore/?refine.tags=Nutzungsplanung\">https://data.bs.ch/explore/?refine.tags=Nutzungsplanung</a>"]
pub mod nutzungsplan_zonenplan_stadt_basel_ueberlagernde_festlegungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id_Überlagende_Festlegung
        ///
        /// Eindeutiger Identifikator
        pub idueberfes: Option<String>,
        /// Festlegung überlagernd
        ///
        /// Art der Festlegung
        pub festueber: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Verbindlichkeit
        pub verbindli: Option<String>,
        /// Schutzzweck
        ///
        /// Schutzzweck von Natur- und Landschaftsschutzzonen
        pub schutzzwec: Option<String>,
        /// rekurshängig
        ///
        /// 1 (bzw. true) wenn ein Rekurs vorhanden ist. Wenn ein Rekurs hängig ist, enthält das Objekt die neue, geplante Ausprägung, entgegen dem Geschäftsstatus ist diese jedoch noch nicht in Kraft.
        pub rekurshaen: Option<String>,
        /// Bezeichnung
        ///
        /// Bezeichnung der Festlegung
        pub bezeichnng: Option<String>,
        /// Id_Geschäft
        ///
        /// Eindeutiger Identifikator
        pub idgeschae: Option<String>,
        /// Geschäftsstatus
        pub geschaesta: Option<String>,
        /// Datum Status
        #[serde(with = "time::serde::iso8601::option")]
        pub datumstat: Option<OffsetDateTime>,
        /// Geolink
        pub geolink: Option<String>,
        /// Geschäftsbezeichnung
        pub geschaebez: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idueberfes,
        Festueber,
        Verbindli,
        Schutzzwec,
        Rekurshaen,
        Bezeichnng,
        Idgeschae,
        Geschaesta,
        Datumstat,
        Geolink,
        Geschaebez,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idueberfes => "idueberfes",
                Field::Festueber => "festueber",
                Field::Verbindli => "verbindli",
                Field::Schutzzwec => "schutzzwec",
                Field::Rekurshaen => "rekurshaen",
                Field::Bezeichnng => "bezeichnng",
                Field::Idgeschae => "idgeschae",
                Field::Geschaesta => "geschaesta",
                Field::Datumstat => "datumstat",
                Field::Geolink => "geolink",
                Field::Geschaebez => "geschaebez",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100234/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Bohrkataster"]
#[doc = ""]
#[doc = "Diese Karte zeigt alle \u{f6}ffentlich einsehbaren Bohrungen, Erdw\u{e4}rmesonden und Sondierbohrungen, die i. d. R. ins Grundwasser reichen. Sie gibt Auskunft \u{fc}ber die Art, den Zustand und die Dimensionen der Bohrungen und enth\u{e4}lt Informationen zum Untergrund."]
pub mod bohrkataster {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Art der Bohrung
        pub art: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Grundwasserdaten (0/1)
        ///
        /// Grundwasserdaten vorhanden (0 = Nein, 1 = Ja)
        pub grundwasserdaten: Option<String>,
        /// Flurabstand
        ///
        /// Differenz Höhe Gelände und Grundwasserspiegel
        pub flurabstand: Option<f64>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID-Bohrung
        ///
        /// Eindeutiger Identifikator
        pub id_bohrung: Option<i64>,
        /// Erdwärmesonde vorhanden
        pub geothermal: Option<i64>,
        /// Vollständige Laufnummer
        pub catnum45: Option<String>,
        /// X-Koordinate
        ///
        /// X-Koordinate der Bohrung
        pub xkoord: Option<i64>,
        /// Y-Koordinate
        ///
        /// Y-Koordinate der Bohrung
        pub ykoord: Option<i64>,
        /// Schrägbohrung (0/1)
        ///
        /// 0 = Nein, 1 = Ja
        pub schraeg: Option<String>,
        /// Bohrjahr
        ///
        /// Erstellungsjahr der Bohrung
        pub erstellung: Option<i64>,
        /// Strasse
        pub strasse: Option<String>,
        /// Hausnummer
        pub hausnummer: Option<String>,
        /// Bohransatz-Kote
        ///
        /// Kote Ansatz der Bohrung m.ü.M
        pub hoehestart: Option<f64>,
        /// Oberkante Fels-Kote
        ///
        /// Kote Felsoberfläche der Bohrung m.ü.M
        pub hoehefels: Option<f64>,
        /// Oberkante Fels-Stratigraphie
        ///
        /// Beschreibung Felsoberfläche (z.B. Cyrenenmergel)
        pub artfels: Option<String>,
        /// Sohle-Kote
        ///
        /// Kote Sohle der Bohrung m.ü.M.
        pub hoehesole: Option<f64>,
        /// Im hydrografischen Jahrbuch
        ///
        /// Bohrung im hydrografischen Jahrbuch vorhanden, 0 = Nein, 1 = Ja
        pub jahrbuch: Option<i64>,
        /// Zustand der Bohrung
        ///
        /// messbar, verschlammt, etc. (Zustand einer Messstelle)
        pub zuststelle: Option<String>,
        /// Höhe des Geländes
        pub hoehegelae: Option<f64>,
        /// Geplant (0/1)
        ///
        /// Geplante Bohrung (wird für online Visualisierung "geplante Bohrung" verwendet), 0 = Nein, 1 = Ja
        pub bohgeplant: Option<i64>,
        /// Rohrdurchmesser
        ///
        /// Durchmesser des eingebauten Rohrs in mm
        pub rohrdurchm: Option<f64>,
        /// Höhe Rohrabschnitt oben
        ///
        /// Höhe des Rohrabschnitts gemesen oben in m ü. M.
        pub rohrhoehet: Option<f64>,
        /// Höhe Rohrabschnitt unten
        ///
        /// Höhe des Rohrabschnitts gemesen unten in m ü. M.
        pub rohrhoeheb: Option<f64>,
        /// Grundwasserspiegel
        ///
        /// Höhe des Grundwasserstandes in m ü. M
        pub heohegwl: Option<f64>,
        /// Format des Datums
        ///
        /// Format des Datums (dd.mm.yyyy)
        pub datumforma: Option<String>,
        /// Datum des Grundwasserstandes
        ///
        /// Datum des Grundwasserstandes (z.B. 04.11.1965)
        pub datumgwl: Option<String>,
        /// Bohrprofil-Dokument
        ///
        /// Bohrprofil-Dokument zur Bohrung
        pub dokbohrpro: Option<String>,
        /// Situationsplan-Dokument
        ///
        /// Situationsplan-Dokument zur Bohrung
        pub doksituat: Option<String>,
        /// Bild zur Bohrung
        pub bildbohrun: Option<String>,
        /// Art der Grundwassermessstelle
        pub gwlmesssta: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Art,
        Grundwasserdaten,
        Flurabstand,
        IdBohrung,
        Geothermal,
        Catnum45,
        Xkoord,
        Ykoord,
        Schraeg,
        Erstellung,
        Strasse,
        Hausnummer,
        Hoehestart,
        Hoehefels,
        Artfels,
        Hoehesole,
        Jahrbuch,
        Zuststelle,
        Hoehegelae,
        Bohgeplant,
        Rohrdurchm,
        Rohrhoehet,
        Rohrhoeheb,
        Heohegwl,
        Datumforma,
        Datumgwl,
        Dokbohrpro,
        Doksituat,
        Bildbohrun,
        Gwlmesssta,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Art => "art",
                Field::Grundwasserdaten => "grundwasserdaten",
                Field::Flurabstand => "flurabstand",
                Field::IdBohrung => "id_bohrung",
                Field::Geothermal => "geothermal",
                Field::Catnum45 => "catnum45",
                Field::Xkoord => "xkoord",
                Field::Ykoord => "ykoord",
                Field::Schraeg => "schraeg",
                Field::Erstellung => "erstellung",
                Field::Strasse => "strasse",
                Field::Hausnummer => "hausnummer",
                Field::Hoehestart => "hoehestart",
                Field::Hoehefels => "hoehefels",
                Field::Artfels => "artfels",
                Field::Hoehesole => "hoehesole",
                Field::Jahrbuch => "jahrbuch",
                Field::Zuststelle => "zuststelle",
                Field::Hoehegelae => "hoehegelae",
                Field::Bohgeplant => "bohgeplant",
                Field::Rohrdurchm => "rohrdurchm",
                Field::Rohrhoehet => "rohrhoehet",
                Field::Rohrhoeheb => "rohrhoeheb",
                Field::Heohegwl => "heohegwl",
                Field::Datumforma => "datumforma",
                Field::Datumgwl => "datumgwl",
                Field::Dokbohrpro => "dokbohrpro",
                Field::Doksituat => "doksituat",
                Field::Bildbohrun => "bildbohrun",
                Field::Gwlmesssta => "gwlmesssta",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100182/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Staatsangeh\u{f6}rigkeit und Gemeinde"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet Angaben zur Wohnbev\u{f6}lkerung des Kantons Basel-Stadt am Jahresende nach Staatsangeh\u{f6}rigkeit (Schweiz/Ausland) und Kantonsb\u{fc}rgerschaft auf Ebene Gemeinde. Personen an administrativen Meldeadressen sind nicht ber\u{fc}cksichtigt. An administrativen Meldeadressen sind Personen aus administrativen Gr\u{fc}nden gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB)."]
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_gemeinde {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub gemeindename: Option<String>,
        /// Gemeinde
        pub gemeinde: Option<i64>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_al: Option<i64>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub gesbev_f: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Gemeindename,
        Gemeinde,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Gemeindename => "gemeindename",
                Field::Gemeinde => "gemeinde",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100059/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Unfallschwerpunkte"]
#[doc = ""]
#[doc = "Seit 2013 ist der Artikel 6a des Strassenverkehrsgesetz (SVG) in Kraft. Alle Strasseneigent\u{fc}mer werden darin unter anderem zur geb\u{fc}hrenden Ber\u{fc}cksichtigung der Verkehrssicherheitsaspekte bei Planung, Bau, Unterhalt und Betrieb von Strassen sowie zur Analyse des Strassennetzes auf Unfallschwerpunkte (USP) verpflichtet. Die Analyse der USP erfolgt gem\u{e4}ss der Schweizer Norm SN 641 724 des Schweizerischen Verbandes der Strassen- und Verkehrsfachleute (VSS). F\u{fc}r das gew\u{e4}hlte Jahr werden USP f\u{fc}r jeweils das angegebene und die zwei vorherigen Jahre dargestellt."]
pub mod unfallschwerpunkte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Id-Unfallschwerpunkt
        ///
        /// Eindeutiger Identifikator
        pub id_ufsp: Option<String>,
        /// Kategorie
        ///
        /// Kategorie des Unfallschwerpunktes
        pub kategorie: Option<String>,
        /// Beschreibung der Kategorie des Unfallschwerpunktes
        pub kategoriebeschreibung: Option<String>,
        /// Jahr
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub jahr: Option<Date>,
        /// Strasse
        ///
        /// Strassenname
        pub strasse: Option<String>,
        /// Anlagetyp
        pub anlagetyp: Option<String>,
        /// Lichtsignalanlage
        ///
        /// Ist eine Lichtsignalanlage vorhanden
        pub lichtsign: Option<String>,
        /// Gemeinde
        pub ortschaft: Option<String>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdUfsp,
        Kategorie,
        Kategoriebeschreibung,
        Jahr,
        Strasse,
        Anlagetyp,
        Lichtsign,
        Ortschaft,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdUfsp => "id_ufsp",
                Field::Kategorie => "kategorie",
                Field::Kategoriebeschreibung => "kategoriebeschreibung",
                Field::Jahr => "jahr",
                Field::Strasse => "strasse",
                Field::Anlagetyp => "anlagetyp",
                Field::Lichtsign => "lichtsign",
                Field::Ortschaft => "ortschaft",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100216/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Allmendbewilligungen"]
#[doc = ""]
#[doc = "Allmendbewilligungen beinhaltet s\u{e4}mtliche Nutzungen, welche im \u{f6}ffentlichen Raum (Allmend) stattfinden. Die dargestellten genutzten Fl\u{e4}chen sind nicht verbindlich."]
pub mod allmendbewilligungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        ///
        /// Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// BegehrenID
        ///
        /// Kennziffer des Begehrens. Ein Begehren kann mehrere Adressbelegungen umfassen.
        pub begehrenid: Option<i64>,
        /// LokalitätID
        ///
        /// Kennziffer des Standorts
        pub lokalitaid: Option<i64>,
        /// BelegungID
        ///
        /// Kennziffer der Belegung
        pub belegungid: Option<i64>,
        /// Bezeichnung
        ///
        /// Beschreibung der Belegung
        pub bezeichng: Option<String>,
        /// BegehrensartID
        ///
        /// Kennziffer der Art des Begehrens
        pub artbeg_id: Option<i64>,
        /// Begehrensart-Bezeichnung
        ///
        /// Bezeichnung der Art des Begehrens
        pub artbeg_bez: Option<String>,
        /// Eingangsdatum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub eingangsdatum: Option<Date>,
        /// Entscheid-Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub entscheid_datum: Option<Date>,
        /// EntscheidID
        ///
        /// Kennziffer der Entscheidkategorie
        pub entsch_id: Option<i64>,
        /// Entscheid-Bezeichnung
        ///
        /// Name der Entscheidkategorie
        pub entsch_bez: Option<String>,
        /// StrassenID
        ///
        /// Strassen-Nummer
        pub strassenid: Option<i64>,
        /// BelegungsartID
        ///
        /// Kennziffer der Art der Belegung
        pub belgartid: Option<i64>,
        /// Belegungsart-Bezeichnung
        ///
        /// Name der Art der Belegung
        pub belgartbez: Option<String>,
        /// BelastungsartID
        ///
        /// Kennziffer der Belastungsart
        pub belaartid: Option<i64>,
        /// Belastungsart-Bezeichnung
        ///
        /// Name der Belastungsart
        pub belaartbez: Option<String>,
        /// MerkmalID
        ///
        /// Kennziffer des Merkmals des Geschäfts
        pub merkmal_id: Option<i64>,
        /// Geschäftsmerkmal-Bezeichnung
        ///
        /// Name des Merkmals des Geschäfts
        pub merkmalbez: Option<String>,
        /// MerkmalWert
        ///
        /// Wert des Merkmals des Geschäfts, z. B. Baukosten
        pub merkmalwrt: Option<String>,
        /// EinheitID
        ///
        /// Kennziffer der Einheit
        pub einheit_id: Option<i64>,
        /// Belegungseinheit-Bezeichnung
        ///
        /// Einheit, in welcher die Belegung erfasst ist. Kosten werden über die Einheit berechnet. Z.B. m2 oder Wochen.
        pub einheitbez: Option<String>,
        /// BelegungsstatusID
        ///
        /// Kennziffer des Status der Belegung
        pub belestatid: Option<i64>,
        /// Belegungsstatus-Bezeichung
        ///
        /// Name des Status der Belegung
        pub belestatbe: Option<String>,
        /// IDUnique
        pub idunique: Option<String>,
        /// DatumEing
        pub datumeing: Option<String>,
        /// DatumEnts
        pub datuments: Option<String>,
        /// Datum_von
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_von: Option<Date>,
        /// Datum_bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum_bis: Option<Date>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Begehrenid,
        Lokalitaid,
        Belegungid,
        Bezeichng,
        ArtbegId,
        ArtbegBez,
        Eingangsdatum,
        EntscheidDatum,
        EntschId,
        EntschBez,
        Strassenid,
        Belgartid,
        Belgartbez,
        Belaartid,
        Belaartbez,
        MerkmalId,
        Merkmalbez,
        Merkmalwrt,
        EinheitId,
        Einheitbez,
        Belestatid,
        Belestatbe,
        Idunique,
        Datumeing,
        Datuments,
        DatumVon,
        DatumBis,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Begehrenid => "begehrenid",
                Field::Lokalitaid => "lokalitaid",
                Field::Belegungid => "belegungid",
                Field::Bezeichng => "bezeichng",
                Field::ArtbegId => "artbeg_id",
                Field::ArtbegBez => "artbeg_bez",
                Field::Eingangsdatum => "eingangsdatum",
                Field::EntscheidDatum => "entscheid_datum",
                Field::EntschId => "entsch_id",
                Field::EntschBez => "entsch_bez",
                Field::Strassenid => "strassenid",
                Field::Belgartid => "belgartid",
                Field::Belgartbez => "belgartbez",
                Field::Belaartid => "belaartid",
                Field::Belaartbez => "belaartbez",
                Field::MerkmalId => "merkmal_id",
                Field::Merkmalbez => "merkmalbez",
                Field::Merkmalwrt => "merkmalwrt",
                Field::EinheitId => "einheit_id",
                Field::Einheitbez => "einheitbez",
                Field::Belestatid => "belestatid",
                Field::Belestatbe => "belestatbe",
                Field::Idunique => "idunique",
                Field::Datumeing => "datumeing",
                Field::Datuments => "datuments",
                Field::DatumVon => "datum_von",
                Field::DatumBis => "datum_bis",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100018/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (Covid-19): Fallzahlen und Inzidenzen Basel-Stadt"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz im Kanton Basel-Stadt sowie die kumulierten Werte \u{fc}ber die letzten 7 resp. 14 Tage, die jeweiligen Mittelwerte und die Inzidenzen pro 100 000 EinwohnerInnen gem\u{e4}ss <a href=\"https://www.bfs.admin.ch/bfs/de/home/statistiken/bevoelkerung/erhebungen/statpop.html\" target=\"_blank\">STATPOP</a>.\u{a0}</p><p>Die Zahlen werden gem\u{e4}ss dem Datum des Test-Resultats ausgewiesen, also gem\u{e4}ss jenem Datum, an dem ein Testresultat vorliegt. Dies geschieht in aller Regel innerhalb von 24 Stunden nach einem erfolgten Test. Bei nachtr\u{e4}glich eintreffenden Meldungen werden die Zahlen der Vortage entsprechend korrigiert.</p><p></p><ul style=\"box-sizing: border-box; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;\"></ul><p></p><p><b style=\"box-sizing: border-box; font-weight: bolder;\">\u{c4}nderungsprotokoll:</b></p><ul><li>Die Erhebung der Werte wurde per 5. Juli 2023 sistiert. Der Datensatz wird nicht mehr aktualisiert.\u{a0}Aktualisierungsintervall von \"WEEKLY\" auf \"NEVER\" ge\u{e4}ndert.</li></ul><p><br/></p>"]
pub mod coronavirus_covid_19_fallzahlen_und_inzidenzen_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum Testresultat
        ///
        /// Datum, an welchem das Testresultat vorliegt. In der Regel liegt ein Testresultat innerhalb von 24 Stunden nach dem erfolgten Test vor.
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub test_datum: Option<Date>,
        /// Tägliche Fälle Basel-Stadt
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz im Kanton Basel-Stadt
        pub faelle_bs: Option<i64>,
        /// Kumulierte Fälle Basel-Stadt
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz im Kanton Basel-Stadt
        pub faelle_bs_kum: Option<i64>,
        /// Tägliche Fälle Basel
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz in der Stadt Basel
        pub faelle_basel: Option<i64>,
        /// Kumulierte Fälle Basel
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz in der Stadt Basel
        pub faelle_basel_kum: Option<i64>,
        /// Tägliche Fälle Riehen
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz in der Gemeinde Riehen
        pub faelle_riehen: Option<i64>,
        /// Kumulierte Fälle Riehen
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz in der Gemeinde Riehen
        pub faelle_riehen_kum: Option<i64>,
        /// Tägliche Fälle Bettingen
        ///
        /// Anzahl positiv auf SARS-CoV-2 getesteter Personen am Datum Test-Resultat mit Wohnsitz in der Gemeinde Bettingen
        pub faelle_bettingen: Option<i64>,
        /// Kumulierte Fälle Bettingen
        ///
        /// Kumulierte Anzahl positiv auf SARS-CoV-2 getesteter Personen mit Wohnsitz in der Gemeinde Bettingen
        pub faelle_bettingen_kum: Option<i64>,
        /// 7d-Inzidenz Basel-Stadt
        ///
        /// 7-Tage-Inzidenz Basel-Stadt; berechnet nach der Formel: (("Kumulierte Fälle BS" heute) minus ("Kumulierte Fälle BS" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz07_bs: Option<f64>,
        /// 14d-Inzidenz Basel-Stadt
        ///
        /// 14-Tage-Inzidenz Basel-Stadt; berechnet nach der Formel: (("Kumulierte Fälle BS" heute) minus ("Kumulierte Fälle BS" heute-14 Tage) durch (Einwohnerzahl durch 100 000 Personen))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz14_bs: Option<f64>,
        /// Summe 7 Tage Basel-Stadt
        ///
        /// Summe der Anzahl positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz in Basel-Stadt der letzten 7 Tage
        pub summe_07_tage_bs: Option<i64>,
        /// Summe 14 Tage Basel-Stadt
        ///
        /// Summe der Anzahl positiv auf SARS-Cov-2 getesteten Personen mit Wohnsitz in Basel-Stadt der letzten 14 Tage
        pub summe_14_tage_bs: Option<i64>,
        /// Mittel 7 Tage Basel-Stadt
        ///
        /// Mittel der Anzahl positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz in Basel-Stadt pro Tag über die letzten 7 Tage
        pub mittel_07_tage_bs: Option<f64>,
        /// Mittel 14 Tage Basel-Stadt
        ///
        /// Mittel der Anzahl positiv auf SARS-CoV-2 getesteten Personen mit Wohnsitz in Basel-Stadt pro Tag über die letzten 14 Tage
        pub mittel_14_tage_bs: Option<f64>,
        /// 7d-Inzidenz Basel
        ///
        /// 7-Tage-Inzidenz Basel; berechnet nach der Formel: (("Kumulierte Fälle Basel" heute) minus ("Kumulierte Fälle Basel" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_basel_07: Option<f64>,
        /// 14d-Inzidenz Basel
        ///
        /// 14-Tage-Inzidenz Basel; berechnet nach der Formel: (("Kumulierte Fälle Basel" heute) minus ("Kumulierte Fälle Basel" heute-14 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_basel_14: Option<f64>,
        /// 7d-Inzidenz Riehen
        ///
        /// 7-Tage-Inzidenz Riehen; berechnet nach der Formel: (("Kumulierte Fälle Riehen" heute) minus ("Kumulierte Fälle Riehen" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_riehen_07: Option<f64>,
        /// 14d-Inzidenz Riehen
        ///
        /// 14-Tage-Inzidenz Riehen; berechnet nach der Formel: (("Kumulierte Fälle Riehen" heute) minus ("Kumulierte Fälle Riehen" heute-14 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_riehen_14: Option<f64>,
        /// 7d-Inzidenz Bettingen
        ///
        /// 7-Tage-Inzidenz Bettingen; berechnet nach der Formel: (("Kumulierte Fälle Bettingen" heute) minus ("Kumulierte Fälle Bettingen" heute-7 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_bettingen_07: Option<f64>,
        /// 14d-Inzidenz Bettingen
        ///
        /// 14-Tage-Inzidenz Bettingen; berechnet nach der Formel: (("Kumulierte Fälle Bettingen" heute) minus ("Kumulierte Fälle Bettingen" heute-14 Tage) geteilt durch (Einwohnerzahl durch 100 000))); Einwohnerzahl gemäss STATPOP.
        pub inzidenz_bettingen_14: Option<f64>,
        /// Wochentag Nummer
        ///
        /// Nummer des Wochentags (Montag=0, Sonntag=6)
        pub weekday_nr: Option<i64>,
        /// Weekday
        ///
        /// Name des Wochentags auf Englisch
        pub weekday: Option<String>,
        /// Wochentag
        ///
        /// Name des Wochentags auf Deutsch
        pub wochentag: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TestDatum,
        FaelleBs,
        FaelleBsKum,
        FaelleBasel,
        FaelleBaselKum,
        FaelleRiehen,
        FaelleRiehenKum,
        FaelleBettingen,
        FaelleBettingenKum,
        Inzidenz07Bs,
        Inzidenz14Bs,
        Summe07TageBs,
        Summe14TageBs,
        Mittel07TageBs,
        Mittel14TageBs,
        InzidenzBasel07,
        InzidenzBasel14,
        InzidenzRiehen07,
        InzidenzRiehen14,
        InzidenzBettingen07,
        InzidenzBettingen14,
        WeekdayNr,
        Weekday,
        Wochentag,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TestDatum => "test_datum",
                Field::FaelleBs => "faelle_bs",
                Field::FaelleBsKum => "faelle_bs_kum",
                Field::FaelleBasel => "faelle_basel",
                Field::FaelleBaselKum => "faelle_basel_kum",
                Field::FaelleRiehen => "faelle_riehen",
                Field::FaelleRiehenKum => "faelle_riehen_kum",
                Field::FaelleBettingen => "faelle_bettingen",
                Field::FaelleBettingenKum => "faelle_bettingen_kum",
                Field::Inzidenz07Bs => "inzidenz07_bs",
                Field::Inzidenz14Bs => "inzidenz14_bs",
                Field::Summe07TageBs => "summe_07_tage_bs",
                Field::Summe14TageBs => "summe_14_tage_bs",
                Field::Mittel07TageBs => "mittel_07_tage_bs",
                Field::Mittel14TageBs => "mittel_14_tage_bs",
                Field::InzidenzBasel07 => "inzidenz_basel_07",
                Field::InzidenzBasel14 => "inzidenz_basel_14",
                Field::InzidenzRiehen07 => "inzidenz_riehen_07",
                Field::InzidenzRiehen14 => "inzidenz_riehen_14",
                Field::InzidenzBettingen07 => "inzidenz_bettingen_07",
                Field::InzidenzBettingen14 => "inzidenz_bettingen_14",
                Field::WeekdayNr => "weekday_nr",
                Field::Weekday => "weekday",
                Field::Wochentag => "wochentag",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100108/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Verkehrsl\u{e4}rm"]
#[doc = ""]
#[doc = "<p>Das Amt f\u{fc}r Umwelt und Energie (AUE) testet im Rahmen des Projekts \u{ab}Smarte Strasse\u{bb} einen akustischen Sensor bez\u{fc}glich Funktionalit\u{e4}t, Genauigkeit und Zuverl\u{e4}ssigkeit. Der L\u{e4}rmsensor erfasst Umgebungsger\u{e4}usche und erkennt mittels k\u{fc}nstlicher Intelligenz die individuellen L\u{e4}rmprofile verschiedener Fahrzeuge. Dadurch kann der Sensor dazu verwendet werden, in Echtzeit richtungsgetrennte Verkehrsz\u{e4}hlungen durchzuf\u{fc}hren, und die L\u{e4}rmeinwirkung sowie die Geschwindigkeit einzelner Verkehrsteilnehmer zu erfassen.</p><p><b>Wichtig:</b> Die Werte in der Spalte \u{ab}Mittelungspegel\u{bb} beschreiben ab dem 16.02.2022 um 06:55 Uhr den A-bewerteten \u{e4}quivalenten Dauerschallpegel (Leq). Zuvor wurde der energetisch gemittelte Terzpegel abgebildet.<br/></p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b>Hinweis: Die Sensoren an der Gundeldingerstrasse wurden am 29.6.23 abmontiert. Es werden keine Daten mehr erhoben.</b></p><p>\u{c4}nderungsprotokoll: <br/>29.06.2023 - Aktualisierungsintervall von \"CONT\" auf \"NEVER\" ge\u{e4}ndert.<br/></p>"]
pub mod smarte_strasse_verkehrslaerm {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Mittelungspegel
        ///
        /// Gemittelter Schalldruckpegel in dB(A) über 5 Minuten
        pub general_level: Option<f64>,
        /// 25 Hz
        ///
        /// Terzbandpegel bei 25 Hz über 5 Minuten
        pub level_00025: Option<f64>,
        /// 31.5 Hz
        ///
        /// Terzbandpegel bei 31.5 Hz über 5 Minuten
        pub level_00031_5: Option<f64>,
        /// 40 Hz
        ///
        /// Terzbandpegel bei 40 Hz über 5 Minuten
        pub level_00040: Option<f64>,
        /// 50 Hz
        ///
        /// Terzbandpegel bei 50 Hz über 5 Minuten
        pub level_00050: Option<f64>,
        /// 63 Hz
        ///
        /// Terzbandpegel bei 63 Hz über 5 Minuten
        pub level_00063: Option<f64>,
        /// 80 Hz
        ///
        /// Terzbandpegel bei 80 Hz über 5 Minuten
        pub level_00080: Option<f64>,
        /// 100 Hz
        ///
        /// Terzbandpegel bei 100 Hz über 5 Minuten
        pub level_00100: Option<f64>,
        /// 125 Hz
        ///
        /// Terzbandpegel bei 125 Hz über 5 Minuten
        pub level_00125: Option<f64>,
        /// 160 Hz
        ///
        /// Terzbandpegel bei 160 Hz über 5 Minuten
        pub level_00160: Option<f64>,
        /// 200 Hz
        ///
        /// Terzbandpegel bei 200 Hz über 5 Minuten
        pub level_00200: Option<f64>,
        /// 250 Hz
        ///
        /// Terzbandpegel bei 250 Hz über 5 Minuten
        pub level_00250: Option<f64>,
        /// 315 Hz
        ///
        /// Terzbandpegel bei 315 Hz über 5 Minuten
        pub level_00315: Option<f64>,
        /// 400 Hz
        ///
        /// Terzbandpegel bei 400 Hz über 5 Minuten
        pub level_00400: Option<f64>,
        /// 500 Hz
        ///
        /// Terzbandpegel bei 500 Hz über 5 Minuten
        pub level_00500: Option<f64>,
        /// 630 Hz
        ///
        /// Terzbandpegel bei 630 Hz über 5 Minuten
        pub level_00630: Option<f64>,
        /// 800 Hz
        ///
        /// Terzbandpegel bei 800 Hz über 5 Minuten
        pub level_00800: Option<f64>,
        /// 1000 Hz
        ///
        /// Terzbandpegel bei 1000 Hz über 5 Minuten
        pub level_01000: Option<f64>,
        /// 1250 Hz
        ///
        /// Terzbandpegel bei 1250 Hz über 5 Minuten
        pub level_01250: Option<f64>,
        /// 1600 Hz
        ///
        /// Terzbandpegel bei 1600 Hz über 5 Minuten
        pub level_01600: Option<f64>,
        /// 2000 Hz
        ///
        /// Terzbandpegel bei 2000 Hz über 5 Minuten
        pub level_02000: Option<f64>,
        /// 2500 Hz
        ///
        /// Terzbandpegel bei 2500 Hz über 5 Minuten
        pub level_02500: Option<f64>,
        /// 3150 Hz
        ///
        /// Terzbandpegel bei 3150 Hz über 5 Minuten
        pub level_03150: Option<f64>,
        /// 4000 Hz
        ///
        /// Terzbandpegel bei 4000 Hz über 5 Minuten
        pub level_04000: Option<f64>,
        /// 5000 Hz
        ///
        /// Terzbandpegel bei 5000 Hz über 5 Minuten
        pub level_05000: Option<f64>,
        /// 6300 Hz
        ///
        /// Terzbandpegel bei 6300 Hz über 5 Minuten
        pub level_06300: Option<f64>,
        /// 8000 Hz
        ///
        /// Terzbandpegel bei 8000 Hz über 5 Minuten
        pub level_08000: Option<f64>,
        /// 10000 Hz
        ///
        /// Terzbandpegel bei 10000 Hz über 5 Minuten
        pub level_10000: Option<f64>,
        /// 12500 Hz
        ///
        /// Terzbandpegel bei 12500 Hz über 5 Minuten
        pub level_12500: Option<f64>,
        /// 16000 Hz
        ///
        /// Terzbandpegel bei 16000 Hz über 5 Minuten
        pub level_16000: Option<f64>,
        pub timestamp_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        GeneralLevel,
        Level00025,
        Level000315,
        Level00040,
        Level00050,
        Level00063,
        Level00080,
        Level00100,
        Level00125,
        Level00160,
        Level00200,
        Level00250,
        Level00315,
        Level00400,
        Level00500,
        Level00630,
        Level00800,
        Level01000,
        Level01250,
        Level01600,
        Level02000,
        Level02500,
        Level03150,
        Level04000,
        Level05000,
        Level06300,
        Level08000,
        Level10000,
        Level12500,
        Level16000,
        TimestampText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::GeneralLevel => "general_level",
                Field::Level00025 => "level_00025",
                Field::Level000315 => "level_00031_5",
                Field::Level00040 => "level_00040",
                Field::Level00050 => "level_00050",
                Field::Level00063 => "level_00063",
                Field::Level00080 => "level_00080",
                Field::Level00100 => "level_00100",
                Field::Level00125 => "level_00125",
                Field::Level00160 => "level_00160",
                Field::Level00200 => "level_00200",
                Field::Level00250 => "level_00250",
                Field::Level00315 => "level_00315",
                Field::Level00400 => "level_00400",
                Field::Level00500 => "level_00500",
                Field::Level00630 => "level_00630",
                Field::Level00800 => "level_00800",
                Field::Level01000 => "level_01000",
                Field::Level01250 => "level_01250",
                Field::Level01600 => "level_01600",
                Field::Level02000 => "level_02000",
                Field::Level02500 => "level_02500",
                Field::Level03150 => "level_03150",
                Field::Level04000 => "level_04000",
                Field::Level05000 => "level_05000",
                Field::Level06300 => "level_06300",
                Field::Level08000 => "level_08000",
                Field::Level10000 => "level_10000",
                Field::Level12500 => "level_12500",
                Field::Level16000 => "level_16000",
                Field::TimestampText => "timestamp_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100170/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Geschwindigkeitsmessungen"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt Geschwindigkeit und Lautst\u{e4}rke von Fahrzeugen mit der dazugeh\u{f6}rigen Zeitangabe. Aus Datenschutzgr\u{fc}nden werden jeweils Gruppen von 20 Fahrzeugen gebildet, die Reihenfolge randomisiert, und nur nur jeweils Start- und Endzeitpunkt des jeweiligen Zeitintervalls angegeben.\u{a0}</p><p><b>Wichtig:</b> Die Geschwindigkeits-Werte vor dem 25.03.2022 um 11:35 Uhr sind nicht kalibriert. Je nach Fahrspur werden diese Werte daher um bis zu 40% zu tief angegeben.\u{a0}</p><p class=\"\" style=\"font-family: sans-serif;\"><b>Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</b></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Hinweis: Die Sensoren an der Gundeldingerstrasse wurden am 29.6.23 abmontiert. Es werden keine Daten mehr erhoben.</span></p><p style=\"font-family: sans-serif; margin-bottom: 1em;\">\u{c4}nderungsprotokoll:<br/>29.06.2023 - Aktualisierungsintervall von \"CONT\" auf \"NEVER\" ge\u{e4}ndert.</p>"]
pub mod smarte_strasse_geschwindigkeitsmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Startzeit
        ///
        /// Startzeit des Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub localdatetime_interval_start: Option<OffsetDateTime>,
        /// Stoppzeit
        ///
        /// Stoppzeit des Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub localdatetime_interval_end: Option<OffsetDateTime>,
        /// Geschwindigkeit
        ///
        /// Geschwindigkeit bei Durchfahrt in km/h
        pub speed: Option<f64>,
        /// Schalldruckpegel
        ///
        /// Schalldruckpegel bei Durchfahrt in dB(A)
        pub level: Option<f64>,
        /// Fahrzeug-Zufallszahl
        ///
        /// Zufällig nummerierte Reihenfolge
        pub vehicle_rand_number: Option<i64>,
        /// Intervalldauer Text
        ///
        /// Dauer des Messintervalls in Textform
        pub interval_length_string: Option<String>,
        /// Intervalldauer Sek.
        ///
        /// Dauer des Messintervalls in Sekunden
        pub interval_length_seconds: Option<f64>,
        /// localDateTime_interval_start_text
        pub localdatetime_interval_start_text: Option<String>,
        /// localDateTime_interval_end_text
        pub localdatetime_interval_end_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        LocaldatetimeIntervalStart,
        LocaldatetimeIntervalEnd,
        Speed,
        Level,
        VehicleRandNumber,
        IntervalLengthString,
        IntervalLengthSeconds,
        LocaldatetimeIntervalStartText,
        LocaldatetimeIntervalEndText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::LocaldatetimeIntervalStart => "localdatetime_interval_start",
                Field::LocaldatetimeIntervalEnd => "localdatetime_interval_end",
                Field::Speed => "speed",
                Field::Level => "level",
                Field::VehicleRandNumber => "vehicle_rand_number",
                Field::IntervalLengthString => "interval_length_string",
                Field::IntervalLengthSeconds => "interval_length_seconds",
                Field::LocaldatetimeIntervalStartText => "localdatetime_interval_start_text",
                Field::LocaldatetimeIntervalEndText => "localdatetime_interval_end_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100175/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsz\u{e4}hldaten motorisierter Individualverkehr"]
#[doc = ""]
#[doc = "<p>Resultate der Messungen der\u{a0}Dauerz\u{e4}hlstellen und Kurzzeitz\u{e4}hlstellen f\u{fc}r den Motorisierten Individualverkehr.\u{a0}</p><p>Aus Kostengr\u{fc}nden sind nur die Werte des aktuellen Jahres und der letzten zwei Jahre als Tabelle / Visualisierung sichtbar bzw. via API abgreifbar. Die vollst\u{e4}ndigen Daten ab dem Jahr 2014 k\u{f6}nnen hier heruntergeladen werden: </p><ul><li><a href=\"https://data-bs.ch/mobilitaet/converted_MIV_Class_10_1.csv\">Leicht aufbereiteter Datensatz: https://data-bs.ch/mobilitaet/converted_MIV_Class_10_1.csv</a> </li><li><a href=\"https://data-bs.ch/mobilitaet/MIV_Class_10_1.csv\">Rohdaten: https://data-bs.ch/mobilitaet/MIV_Class_10_1.csv</a></li></ul><p>Die Daten einzelner Jahre ab dem Jahr 2014 k\u{f6}nnen heruntergeladen werden unter der URL mit dem Muster\u{a0}https://data-bs.ch/mobilitaet/[JAHR]_MIV_Class_10_1.csv, also zum Beispiel f\u{fc}r das Jahr 2020 hier: <a href=\"https://data-bs.ch/mobilitaet/2020_MIV_Class_10_1.csv\" target=\"_blank\">https://data-bs.ch/mobilitaet/2020_MIV_Class_10_1.csv</a>.</p><p>Die Z\u{e4}hlstellen sind auf MET eingestellt (Spalten TimeFrom und TimeTo), d.h. die Zeitumstellung wird wie in Mitteleuropa ausgef\u{fc}hrt. Bei der Umstellung von Winter- auf Sommerzeit fehlt die Stunde der Umstellung, dieser Tag hat dann 23 Stunden. Bei der Umstellung von Sommer- auf Winterzeit ist eine Stunde zu viel enthalten (der Tag hat dann 25 Stunden), die Stunde der Umstellung ist dann doppelt, aber mit unterschiedlichen Verkehrsdaten (da die gleiche Stunde zweimal durchlaufen wird).<br/></p>"]
pub mod verkehrszaehldaten_motorisierter_individualverkehr {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ZST_NR
        ///
        /// Zählstellennummer
        pub zst_nr: Option<String>,
        /// SiteCode
        ///
        /// Zählstellencode
        pub sitecode: Option<String>,
        /// SiteName
        ///
        /// Zählstellenname
        pub sitename: Option<String>,
        /// DateTimeFrom
        ///
        /// Datum und Uhrzeit Messbeginn (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimefrom: Option<OffsetDateTime>,
        /// DateTimeTo
        ///
        /// Datum und Uhrzeit Messende (in UTC)
        #[serde(with = "time::serde::iso8601::option")]
        pub datetimeto: Option<OffsetDateTime>,
        /// DirectionName
        ///
        /// Richtung/Strassenseite
        pub directionname: Option<String>,
        /// LaneCode
        ///
        /// Spurnummer
        pub lanecode: Option<i64>,
        /// LaneName
        ///
        /// Spurname
        pub lanename: Option<String>,
        /// ValuesApproved
        ///
        /// Daten validiert (1 ja, 0 nein) [Validierte Verkehrszahlen sind kontrollierte und ergänzte Rohdaten. Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesapproved: Option<i64>,
        /// ValuesEdited
        ///
        /// Ersatzwerte (1 ja, 0 nein) [Fehlwerte werden dann ergänzt, wenn sie aufgrund von technischen Problemen entstanden sind.]
        pub valuesedited: Option<i64>,
        /// TrafficType
        ///
        /// Verkehrsmittel (MIV = motorisierter Individualverkehr)
        pub traffictype: Option<String>,
        /// Total
        ///
        /// Anzahl Fahrzeuge
        pub total: Option<i64>,
        /// MR
        ///
        /// Motorrad
        pub mr: Option<i64>,
        /// PW
        ///
        /// Personenwagen
        pub pw: Option<i64>,
        /// PW+
        ///
        /// Personenwagen mit Anhänger
        pub pw0: Option<i64>,
        /// Lief
        ///
        /// Lieferwagen
        pub lief: Option<i64>,
        /// Lief+
        ///
        /// Lieferwagen mit Anhänger
        pub lief0: Option<i64>,
        /// Lief+Aufl.
        ///
        /// Lieferwagen mit Auflieger
        pub lief_aufl: Option<i64>,
        /// LW
        ///
        /// Lastwagen
        pub lw: Option<i64>,
        /// LW+
        ///
        /// Lastwagen mit Anhänger
        pub lw0: Option<i64>,
        /// Sattelzug
        pub sattelzug: Option<i64>,
        /// Bus
        pub bus: Option<i64>,
        /// nicht klassifizierbare Fahrzeuge
        pub andere: Option<i64>,
        /// Year
        ///
        /// Jahr
        pub year: Option<String>,
        /// Month
        ///
        /// Monat (1=Januar, 12=Dezember)
        pub month: Option<i64>,
        /// Day
        ///
        /// Tag
        pub day: Option<i64>,
        /// Weekday
        ///
        /// Wochentag (0=Montag, 6=Sonntag)
        pub weekday: Option<i64>,
        /// HourFrom
        ///
        /// Stunde des Messbeginns
        pub hourfrom: Option<i64>,
        /// Date
        ///
        /// Datum der Messung als Text
        pub date: Option<String>,
        /// TimeFrom
        ///
        /// Zeit Messbeginn als Text
        pub timefrom: Option<String>,
        /// TimeTo
        ///
        /// Zeit Messende als Text
        pub timeto: Option<String>,
        /// DayOfYear
        ///
        /// Nummer des Tages innerhalb des aktuellen Jahres
        pub dayofyear: Option<i64>,
        /// Zst_id
        pub zst_id: Option<i64>,
        /// Geo Point
        ///
        /// Standort der Zählstelle
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        ZstNr,
        Sitecode,
        Sitename,
        Datetimefrom,
        Datetimeto,
        Directionname,
        Lanecode,
        Lanename,
        Valuesapproved,
        Valuesedited,
        Traffictype,
        Total,
        Mr,
        Pw,
        Pw0,
        Lief,
        Lief0,
        LiefAufl,
        Lw,
        Lw0,
        Sattelzug,
        Bus,
        Andere,
        Year,
        Month,
        Day,
        Weekday,
        Hourfrom,
        Date,
        Timefrom,
        Timeto,
        Dayofyear,
        ZstId,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::ZstNr => "zst_nr",
                Field::Sitecode => "sitecode",
                Field::Sitename => "sitename",
                Field::Datetimefrom => "datetimefrom",
                Field::Datetimeto => "datetimeto",
                Field::Directionname => "directionname",
                Field::Lanecode => "lanecode",
                Field::Lanename => "lanename",
                Field::Valuesapproved => "valuesapproved",
                Field::Valuesedited => "valuesedited",
                Field::Traffictype => "traffictype",
                Field::Total => "total",
                Field::Mr => "mr",
                Field::Pw => "pw",
                Field::Pw0 => "pw0",
                Field::Lief => "lief",
                Field::Lief0 => "lief0",
                Field::LiefAufl => "lief_aufl",
                Field::Lw => "lw",
                Field::Lw0 => "lw0",
                Field::Sattelzug => "sattelzug",
                Field::Bus => "bus",
                Field::Andere => "andere",
                Field::Year => "year",
                Field::Month => "month",
                Field::Day => "day",
                Field::Weekday => "weekday",
                Field::Hourfrom => "hourfrom",
                Field::Date => "date",
                Field::Timefrom => "timefrom",
                Field::Timeto => "timeto",
                Field::Dayofyear => "dayofyear",
                Field::ZstId => "zst_id",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100006/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Strassen und Wege: Durchgangsstrassen"]
#[doc = ""]
#[doc = "Dieser Datensatz ist Teil des kantonalen Geodatenmodells des Kantons Basel-Stadt \"Strassen und Wege\" und stellt die Durchgangsstrassen dar. <br>Weitere Daten zu \"Strassen und Wege\": <a href=\"https://data.bs.ch/explore/?refine.tags=Strassen+und+Wege\">https://data.bs.ch/explore/?refine.tags=Strassen+und+Wege</a><br>\nDie Durchgangsstrassen zeigen die Durchgangsstrassen gem\u{e4}ss Durchgangsverordnung unterteilt nach Hauptstrassen, Nationalstrassen (A) und Europastrassen (E)."]
pub mod strassen_und_wege_durchgangsstrassen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Durchgangsstrasse
        ///
        /// Eindeutiger Identifikator der Durchgangsstrassen
        pub id_dgstr: Option<i64>,
        /// Strassennummer
        ///
        /// Hauptstrassennummer
        pub strassennr: Option<String>,
        /// Strassentyp
        pub strtyp: Option<String>,
        /// Strecke
        pub strecke: Option<String>,
        /// Bemerkung
        pub bemerkung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdDgstr,
        Strassennr,
        Strtyp,
        Strecke,
        Bemerkung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdDgstr => "id_dgstr",
                Field::Strassennr => "strassennr",
                Field::Strtyp => "strtyp",
                Field::Strecke => "strecke",
                Field::Bemerkung => "bemerkung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100242/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Coronavirus (COVID-19): SARS-CoV-2 im Abwasser und positiv auf SARS-CoV-2 getestete Personen"]
#[doc = ""]
#[doc = "<p><span style=\"font-weight: bolder;\">Figur<br/></span><span>Der Datensatz zeigt den 7-Tage-Median der RNA-Kopien des angegebenen Virus jeweils pro Tag und 100\u{2018}000 Personen im Abwasser der Abwasserreinigungs-Anlage (ARA) Basel sowie den 7-Tage-Median der entsprechenden Fallzahlen. Der Datensatz wird i.d.R. jeweils dienstags mit den Daten bis vorangegangenem Sonntag aktualisiert. In einzelnen Wochen kann es zu Verschiebungen kommen.</span></p><p style=\"\"><span style=\"font-family: sans-serif; font-weight: bolder;\">Messung<br/></span>Die ProRheno AG (Betreiber der ARA Basel) entnimmt jeweils eine 24h-Probe des Rohabwassers, welche durch das Kantonale Laboratorium Basel-Stadt (KL BS) auf RNA der angegebenen Viren untersucht wird. Die Messmethodik wurde dabei seit Beginn des Monitorings nicht ver\u{e4}ndert: siehe Publikation\u{a0}<a href=\"https://smw.ch/index.php/smw/article/view/3226\" style=\"font-family: sans-serif;\" target=\"_blank\">https://smw.ch/index.php/smw/article/view/3226</a>. Die Plausibilit\u{e4}t der Werte wird laufend anhand interner Qualit\u{e4}tsparameter \u{fc}berpr\u{fc}ft. Das Untersuchungsgebiet umfasst das Einzugsgebiet der ARA Basel, welches sich haupts\u{e4}chlich aus dem Kanton Basel-Stadt sowie den Gemeinden Allschwil, Binningen, Birsfelden, Bottmingen, Oberwil und Sch\u{f6}nenbuch (alle Kanton Baselland) zusammensetzt. Bis Ende Juni 2023 wurden die Messwerte des KL BS auch auf dem Abwasser-Dashboard des BAG\u{a0}<a href=\"https://www.covid19.admin.ch/de/epidemiologic/waste-water?wasteWaterFacility=270101\" style=\"font-family: sans-serif;\" target=\"_blank\">Covid-\u{2060}19 Schweiz | Coronavirus | Dashboard (https://www.covid19.admin.ch/de/epidemiologic/waste-water?wasteWaterFacility=270101)</a>\u{a0}dargestellt. Ab Juli 2023 werden auf dieser Seite die Messwerte der EAWAG\u{a0}<a href=\"https://www.eawag.ch/de/abteilung/sww/projekte/sars-cov2-im-abwasser/\" style=\"font-family: sans-serif;\" target=\"_blank\">SARS-CoV2 im Abwasser - Eawag</a>\u{a0}(<a href=\"https://www.eawag.ch/de/abteilung/sww/projekte/sars-cov2-im-abwasser/\" style=\"font-family: sans-serif;\" target=\"_blank\">https://www.eawag.ch/de/abteilung/sww/projekte/sars-cov2-im-abwasser/</a>) publiziert, welche ebenfalls das Rohabwasser der ARA Basel untersucht. Die vom KL BS und der EAWAG verwendeten Untersuchungsmethoden sind sehr \u{e4}hnlich aber nicht identisch.\u{a0}Aus diesem Grund kann es zu Abweichungen kommen. Die Messungen werden unabh\u{e4}ngig von der EAWAG durch das KL BS weitergef\u{fc}hrt, um zeitn\u{e4}here Messwerte, mit zus\u{e4}tzlichen Normierungsfaktoren und die Flexibilit\u{e4}t zur Integration weiterer Analyte zu erhalten.</p><p style=\"\">Hinweis: Die urspr\u{fc}nglich dargestellten Werte vom 22.03. bis 01.10.2023 mussten aufgrund einer falschen Einstellung in der Messger\u{e4}tesoftware, die Einfluss auf die RNA-Quantifizierung hat, nach unten korrigiert werden und sind nun korrekt dargestellt.</p><div><br/></div><p style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Fallzahlen<br/></span>Die Fallzahlen entsprechen der Anzahl der best\u{e4}tigten und dem Kanton gemeldeten F\u{e4}lle der dargestellten Infektionen im Einzugsgebiet der ARA Basel.<br/></p><p style=\"font-family: sans-serif; margin-bottom: 0px;\"><span style=\"font-weight: bolder;\">Interpretation der Kurven<br/></span><span>Beim Monitoring von Viren im Abwasser geht es in erster Linie darum, Trends zu erkennen (insbesondere nat\u{fc}rlich die Zunahme eines zirkulierenden Virus). Es ist nicht m\u{f6}glich, daraus eine bestimmte Fallzahl oder den Schweregrad einer Infektion abzuleiten. Ein Vergleich des Kurvenausschlags (H\u{f6}he der Peaks) zu verschiedenen Zeitpunkten ist kaum m\u{f6}glich, da z.B. unterschiedliche Virusvarianten zu unterschiedlichen Virusmengen pro Fall f\u{fc}hren. Unterschiedliche Virusvarianten k\u{f6}nnen auch die Symptomatik beeinflussen, so dass z.B. Infektionen bei Menschen spurlos verlaufen, aber dennoch Viren ins Abwasser abgegeben werden.</span></p><p class=\"MsoNormal\"><span style=\'font-family:\"Arial\",\"sans-serif\"\'><o:p></o:p></span></p>"]
pub mod coronavirus_covid_19_sars_cov_2_im_abwasser_und_positiv_auf_sars_cov_2_getestete_personen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// 7d-Median SARS-CoV-2 Abwasser
        ///
        /// 7-Tage-Median der SARS-CoV-2 RNA-Kopien pro Tag und 100'000 Personen
        pub x7_tagemedian_of_e_n1_n2_pro_tag_100_000_pers: Option<f64>,
        /// 7d-Median SARS-CoV-2-Fälle
        ///
        /// 7-Tage-Median der positiv auf SARS-CoV-2 getesteten Personen im Einzugsgebiet der ARA Basel (Kt. BS + 6 Gemeinden BL)
        pub x7t_median_bs_bl: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        X7TagemedianOfEN1N2ProTag100000Pers,
        X7tMedianBsBl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::X7TagemedianOfEN1N2ProTag100000Pers => {
                    "7_tagemedian_of_e_n1_n2_pro_tag_100_000_pers"
                }
                Field::X7tMedianBsBl => "7t_median_bs_bl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100187/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsberuhigte Zonen: Tempo 30 - Zone"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet die signalisierten Tempo 30-Zonen und -Strecken.<br>Die verkehrsberuhigten Zonen setzen sich aus Fussg\u{e4}ngerzonen, Begegnungszonen und Tempo 30-Zonen zusammen. Ebenso ist der Perimeter des Verkehrskonzepts Innenstadt mit der Kernzone mit eingeschr\u{e4}nktem Motorfahrzeugverkehr dargestellt.<br>Weitere Daten zu \"Verkehrsberuhigte Zonen\": <a href=\"https://data.bs.ch/explore/?refine.tags=Verkehrsberuhigte+Zonen\">https://data.bs.ch/explore/?refine.tags=Verkehrsberuhigte+Zonen</a>"]
pub mod verkehrsberuhigte_zonen_tempo_30_zone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Tempo30Zone
        ///
        /// Eindeutiger Identifikator der Tempo30Zonen
        pub id_tempo30: Option<String>,
        /// Regime
        ///
        /// Regime der Zone
        pub regime: Option<String>,
        /// Regimenummer
        ///
        /// Nummer des Regimes
        pub regimenr: Option<String>,
        /// Name
        ///
        /// Name des Regimes
        pub name: Option<String>,
        /// Umsetzungsdatum
        ///
        /// Datum der Umsetzung
        pub umdatum: Option<String>,
        /// Umsetzungsjahr
        ///
        /// Jahr der Umsetzung
        pub umjahr: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdTempo30,
        Regime,
        Regimenr,
        Name,
        Umdatum,
        Umjahr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdTempo30 => "id_tempo30",
                Field::Regime => "regime",
                Field::Regimenr => "regimenr",
                Field::Name => "name",
                Field::Umdatum => "umdatum",
                Field::Umjahr => "umjahr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100252/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Verkehrsberuhigte Zonen: Begegnungszone"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet die signalisierten Begegnungszonen.<br>Die verkehrsberuhigten Zonen setzen sich aus Fussg\u{e4}ngerzonen, Begegnungszonen und Tempo 30-Zonen zusammen. Ebenso ist der Perimeter des Verkehrskonzepts Innenstadt mit der Kernzone mit eingeschr\u{e4}nktem Motorfahrzeugverkehr dargestellt.<br>Weitere Daten zu \"Verkehrsberuhigte Zonen\": <a href=\"https://data.bs.ch/explore/?refine.tags=Verkehrsberuhigte+Zonen\">https://data.bs.ch/explore/?refine.tags=Verkehrsberuhigte+Zonen</a>"]
pub mod verkehrsberuhigte_zonen_begegnungszone {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Begegnungszone
        ///
        /// Eindeutiger Identifikator der Begegnungszonen
        pub id_begegnu: Option<String>,
        /// Regime
        ///
        /// Regime der Zone
        pub regime: Option<String>,
        /// Regimenummer
        ///
        /// Nummer des Regimes
        pub regimenr: Option<String>,
        /// Name
        ///
        /// Name des Regimes
        pub name: Option<String>,
        /// Umsetzungsdatum
        ///
        /// Datum der Umsetzung
        pub umdatum: Option<String>,
        /// Umsetzungsjahr
        ///
        /// Jahr der Umsetzung
        pub umjahr: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IdBegegnu,
        Regime,
        Regimenr,
        Name,
        Umdatum,
        Umjahr,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IdBegegnu => "id_begegnu",
                Field::Regime => "regime",
                Field::Regimenr => "regimenr",
                Field::Name => "name",
                Field::Umdatum => "umdatum",
                Field::Umjahr => "umjahr",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100215/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "BachApp: Am Fluss"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt Informationstexte und FAQs, inkl. Details zur Kampagne #RHYLAX (<a href=\"https://www.entwicklung.bs.ch/stadtteile/rhylax.html\" target=\"_blank\">https://www.entwicklung.bs.ch/stadtteile/rhylax.html</a>) des Kantons, welche in der BachApp ver\u{f6}ffentlicht werden.\u{a0}</p>"]
pub mod bachapp_am_fluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        pub id: Option<i64>,
        /// Status
        pub status: Option<String>,
        /// Sichtbar_von
        ///
        /// Sichtbar ab
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_von: Option<Date>,
        /// Sichtbar_bis
        ///
        /// Sichtbar bis
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub sichtbar_bis: Option<Date>,
        /// Kategorie
        ///
        /// Art des Informationstext
        pub kategorie: Option<String>,
        /// Thema
        ///
        /// Thema, das die Information betrifft
        pub titel_kurz: Option<String>,
        /// Titel
        pub titel: Option<String>,
        /// Informationstext
        pub text: Option<String>,
        /// Icon
        pub icon: Option<String>,
        /// Image_Top
        pub image_top: Option<String>,
        /// Shape
        pub shape: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Status,
        SichtbarVon,
        SichtbarBis,
        Kategorie,
        TitelKurz,
        Titel,
        Text,
        Icon,
        ImageTop,
        Shape,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Status => "status",
                Field::SichtbarVon => "sichtbar_von",
                Field::SichtbarBis => "sichtbar_bis",
                Field::Kategorie => "kategorie",
                Field::TitelKurz => "titel_kurz",
                Field::Titel => "titel",
                Field::Text => "text",
                Field::Icon => "icon",
                Field::ImageTop => "image_top",
                Field::Shape => "shape",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100255/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Lohntabelle des Kantons Basel-Stadt"]
#[doc = ""]
#[doc = "Jahreslohn (inkl. 13. Monatslohn), Monatslohn, Stundenlohn nach Lohnklassen, Lohnstufe und Jahr. Da es seit dem 01.07.2022 einen kantonalen Mindestlohn gibt, wurden im Jahr 2022 zwei Lohntabellen publiziert. Bei der Lohntabelle ab dem G\u{fc}ltigkeitsdatum 01.07.2022 wurden die L\u{f6}hne nach dem Mindestlohngesetz angepasst."]
pub mod lohntabelle_des_kantons_basel_stadt {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Jahr
        pub jahr: Option<String>,
        /// Gueltigkeit
        ///
        /// Gültigkeit der Lohntabelle
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gueltigkeit: Option<Date>,
        /// Lohnklassen
        pub lohnklassen: Option<i64>,
        /// Lohnstufe
        pub lohnstufe: Option<String>,
        /// Jahreslohn ohne 13. Monatslohn
        ///
        /// Bruttojahreslohn ohne 13. Monatslohn
        pub jahrbruttolohnohne13: Option<i64>,
        /// Monatslohn ohne 13. Monatslohn
        ///
        /// Bruttomonatslohn ohne 13. Monatslohn
        pub monatbruttoohne13: Option<f64>,
        /// Stundenlohn ohne 13. Monatslohn
        ///
        /// Bruttostudenlohn ohne 13. Monatslohn
        pub stundenbruttoohne13: Option<f64>,
        /// Jahreslohn inkl. 13. Monatslohn
        ///
        /// Bruttojahreslohn inkl. 13.Monatslohn
        pub jahrbruttolohnmit13: Option<f64>,
        /// Sortiervariable
        ///
        /// Sortiervariable für die Spalte mit den Lohnstufen
        pub sortiervariable: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Jahr,
        Gueltigkeit,
        Lohnklassen,
        Lohnstufe,
        Jahrbruttolohnohne13,
        Monatbruttoohne13,
        Stundenbruttoohne13,
        Jahrbruttolohnmit13,
        Sortiervariable,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Jahr => "jahr",
                Field::Gueltigkeit => "gueltigkeit",
                Field::Lohnklassen => "lohnklassen",
                Field::Lohnstufe => "lohnstufe",
                Field::Jahrbruttolohnohne13 => "jahrbruttolohnohne13",
                Field::Monatbruttoohne13 => "monatbruttoohne13",
                Field::Stundenbruttoohne13 => "stundenbruttoohne13",
                Field::Jahrbruttolohnmit13 => "jahrbruttolohnmit13",
                Field::Sortiervariable => "sortiervariable",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100123/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Basel Info: Interessante Orte (POI)"]
#[doc = ""]
#[doc = "Basel Info ist das Fussg\u{e4}ngerorientierungssystem f\u{fc}r Basel-Stadt. Die detailreich gestalteten Karten erm\u{f6}glichen den Nutzern, die Stadt selbstst\u{e4}ndig zu Fuss oder mit dem \u{f6}V zu entdecken. Zus\u{e4}tzlich bieten 38 Gruppen von Points of Interest, unterteilt in 8 Klassen, n\u{fc}tzliche Informationen f\u{fc}r Touristen und Anwohner gleichermassen."]
pub mod basel_info_interessante_orte_poi {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// TID
        pub tid: Option<i64>,
        /// NAME
        pub name: Option<String>,
        /// SUBKATGEO
        pub subkatgeo: Option<String>,
        /// KATEGORIE
        pub kategorie: Option<String>,
        /// BESCHREIBG
        pub beschreibg: Option<String>,
        /// ART
        pub art: Option<String>,
        /// STRASSE
        pub strasse: Option<String>,
        /// ORT
        pub ort: Option<String>,
        /// TELEFON
        pub telefon: Option<String>,
        /// WWW_LINK
        pub www_link: Option<String>,
        /// Map Links
        pub map_links: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Tid,
        Name,
        Subkatgeo,
        Kategorie,
        Beschreibg,
        Art,
        Strasse,
        Ort,
        Telefon,
        WwwLink,
        MapLinks,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Tid => "tid",
                Field::Name => "name",
                Field::Subkatgeo => "subkatgeo",
                Field::Kategorie => "kategorie",
                Field::Beschreibg => "beschreibg",
                Field::Art => "art",
                Field::Strasse => "strasse",
                Field::Ort => "ort",
                Field::Telefon => "telefon",
                Field::WwwLink => "www_link",
                Field::MapLinks => "map_links",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100015/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Luftqualit\u{e4}t Vergleichsmessungen"]
#[doc = ""]
#[doc = "<p>Das <a href=\"https://www.baselland.ch/politik-und-behorden/direktionen/bau-und-umweltschutzdirektion/lufthygiene\" target=\"_blank\">Lufthygieneamt beider Basel</a> (LHA) testet im Projekt \u{ab}Smarte Strasse\u{bb} kosteneffiziente Mikrosensoren auf ihre Genauigkeit und Zuverl\u{e4}ssigkeit. Der installierte Sensor vom Typ \u{ab}Nubo\u{bb} der Firma Sensirion AG ist in der Lage, die Konzentration verschiedener Schadstoffe in der Luft in Echtzeit zu ermitteln. Gemessen werden die Gehalte der Gase Stickstoffdioxid (NO2) und Ozon (O3), sowie die feinere Fraktion des Feinstaubs \u{ab}PM2.5\u{bb}. Dieser Datensatz enth\u{e4}lt die Daten von drei \u{ab}Nubo\u{bb}- Sensoren, welche an den permanenten Messstationen des LHA am St. Johanns-Platz, an der Feldbergstrasse und auf der Autobahn A2 in der Hard installiert und gegen die Referenzmessger\u{e4}te des LHA verglichen werden.</p><p>Genaue Standorte dieser Sensoren:\u{a0}</p><ul><li>Feldbergstrasse: 2611747 / 1268491, <a href=\"https://map.geo.admin.ch/?X=268491&amp;Y=611747&amp;zoom=9&amp;lang=de&amp;topic=ech&amp;bgLayer=ch.swisstopo.pixelkarte-farbe&amp;crosshair=bowl&amp;layers=ch.swisstopo.zeitreihen,ch.bfs.gebaeude_wohnungs_register,ch.bav.haltestellen-oev,ch.swisstopo.swisstlm3d-wanderwege,ch.astra.wanderland-sperrungen_umleitungen&amp;layers_opacity=1,1,1,0.8,0.8&amp;layers_visibility=false,false,false,false,false&amp;layers_timestamp=18641231,,,,\" target=\"_blank\">Kartenansicht</a></li><li>St. Johanns-Platz: 2610790 / 1268370, <a href=\"https://map.geo.admin.ch/?X=268370&amp;Y=610790&amp;zoom=9&amp;lang=de&amp;topic=ech&amp;bgLayer=ch.swisstopo.pixelkarte-farbe&amp;crosshair=bowl&amp;layers=ch.swisstopo.zeitreihen,ch.bfs.gebaeude_wohnungs_register,ch.bav.haltestellen-oev,ch.swisstopo.swisstlm3d-wanderwege,ch.astra.wanderland-sperrungen_umleitungen&amp;layers_opacity=1,1,1,0.8,0.8&amp;layers_visibility=false,false,false,false,false&amp;layers_timestamp=18641231,,,,\" target=\"_blank\">Kartenansicht</a></li><li>A2 Hard: 2615839 / 1265282, <a href=\"https://map.geo.admin.ch/?X=265282&amp;Y=615839&amp;zoom=9&amp;lang=de&amp;topic=ech&amp;bgLayer=ch.swisstopo.pixelkarte-farbe&amp;crosshair=bowl&amp;layers=ch.swisstopo.zeitreihen,ch.bfs.gebaeude_wohnungs_register,ch.bav.haltestellen-oev,ch.swisstopo.swisstlm3d-wanderwege,ch.astra.wanderland-sperrungen_umleitungen&amp;layers_opacity=1,1,1,0.8,0.8&amp;layers_visibility=false,false,false,false,false&amp;layers_timestamp=18641231,,,,\" target=\"_blank\">Kartenansicht</a></li></ul><p>Weitere Informationen zur Luftqualit\u{e4}t in der Region Basel sind auf <a href=\"https://www.luftqualitaet.ch\" target=\"_blank\">www.luftqualitaet.ch</a>\n verf\u{fc}gbar. Hintergrundinformationen zu Ozon und Feinstaub auf den Webseiten <a href=\"https://www.ozon-info.ch\" target=\"_blank\">www.ozon-info.ch</a> und <a href=\"https://www.feinstaub.ch\" target=\"_blank\">www.feinstaub.ch</a>. Angaben zu den gesundheitlichen Auswirkungen der Luftverschmutzung auf der Webseite <a href=\"https://www.swisstph.ch/de/projects/ludok/healtheffects/\" target=\"_blank\">https://www.swisstph.ch/de/projects/ludok/healtheffects/</a>.</p><p class=\"\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</p><ul><li>Die Luftqualit\u{e4}ts-Daten der Sensoren an der smarten Strasse finden Sie hier:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100093\" target=\"_blank\">https://data.bs.ch/explore/dataset/100093</a>\u{a0}</li><li>Die Maximalwerte (O3) und Mittelwerte (NO2, PM 2.5) des Vortages sind zudem unter folgendem Datensatz zu finden: <a href=\"https://data.bs.ch/explore/dataset/100174\" target=\"_blank\">https://data.bs.ch/explore/dataset/100174</a></li><li>Weitere Informationen zum Projekt\u{a0}\u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b>Hinweis: <br/>Die Luft-Sensoren an der Gundeldingerstrasse wurden am 29.6.23 abmontiert. Seit Anfang/Mitte Juni wurden keine Daten mehr erhoben.</b><br/></p>"]
pub mod smarte_strasse_luftqualitaet_vergleichsmessungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Zeitstempel = Anfangszeit des 30 minütigen Messintervalls
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// A2 Hard NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor A2 Hard
        pub a2hard_no2: Option<f64>,
        /// A2 Hard O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor A2 Hard
        pub a2hard_o3: Option<f64>,
        /// A2 Hard PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor A2 Hard
        pub a2hard_pm25: Option<f64>,
        /// Feldbergstrasse NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor Feldbergstrasse
        pub feldbergstr2_no2: Option<f64>,
        /// Feldbergstrasse O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor Feldbergstrasse
        pub feldbergstr2_o3: Option<f64>,
        /// Feldbergstrasse PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor Feldbergstrasse
        pub feldbergstr2_pm25: Option<f64>,
        /// St. Johannsplatz NO2
        ///
        /// Halbstundenmittelwert NO2 [µg/m3] - Sensor St. Johannsplatz
        pub stjohann2_no2: Option<f64>,
        /// St. Johannsplatz O3
        ///
        /// Halbstundenmittelwert O3 [µg/m3] - Sensor St. Johannsplatz
        pub stjohann2_o3: Option<f64>,
        /// St. Johannsplatz PM2.5
        ///
        /// Halbstundenmittelwert PM2.5 [µg/m3] - Sensor St. Johannsplatz
        pub stjohann2_pm25: Option<f64>,
        pub timestamp_text: Option<String>,
        /// Anfangszeit
        pub anfangszeit: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        A2hardNo2,
        A2hardO3,
        A2hardPm25,
        Feldbergstr2No2,
        Feldbergstr2O3,
        Feldbergstr2Pm25,
        Stjohann2No2,
        Stjohann2O3,
        Stjohann2Pm25,
        TimestampText,
        Anfangszeit,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::A2hardNo2 => "a2hard_no2",
                Field::A2hardO3 => "a2hard_o3",
                Field::A2hardPm25 => "a2hard_pm25",
                Field::Feldbergstr2No2 => "feldbergstr2_no2",
                Field::Feldbergstr2O3 => "feldbergstr2_o3",
                Field::Feldbergstr2Pm25 => "feldbergstr2_pm25",
                Field::Stjohann2No2 => "stjohann2_no2",
                Field::Stjohann2O3 => "stjohann2_o3",
                Field::Stjohann2Pm25 => "stjohann2_pm25",
                Field::TimestampText => "timestamp_text",
                Field::Anfangszeit => "anfangszeit",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100178/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Fl\u{e4}chen der Schulstandorte (Gemeinde Basel)"]
#[doc = ""]
#[doc = "Die Karte zeigt die Fl\u{e4}chen der Schulstandorte (Kinderg\u{e4}rten, Primar-, Sekundarschule, Gymnasium, Zentrum f\u{fc}r Br\u{fc}ckenangebote, Allgemeine Gewerbeschule, Fachmaturit\u{e4}tsschule, Spezialangebote sowie Tagesstrukturen, Sportpl\u{e4}tze, Turnhallen ausserhalb von Schulstandorten und Schwimmhallen) der Gemeinde Basel. Mehr Informationen zu den Schulstandorten sind in diesem Datensatz zu finden: <a href=\"https://data.bs.ch/explore/dataset/100029/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100029/</a>"]
pub mod flaechen_der_schulstandorte_gemeinde_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Schulstandort
        ///
        /// Bezeichnung des Schulstandorts
        pub schulstand: Option<String>,
        /// Schultyp
        ///
        /// Art des Schulhauses
        pub schultyp: Option<String>,
        /// Strasse
        ///
        /// Strassenname des Schulhauses
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer des Schulhauses
        pub hausnr: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl des Schulhauses
        pub plz: Option<String>,
        /// Ortschaft
        ///
        /// Ortschaftsname des Schulhauses
        pub ort: Option<String>,
        /// Link
        ///
        /// Internetadresse des Schulhauses
        pub link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Schulstand,
        Schultyp,
        Strasse,
        Hausnr,
        Plz,
        Ort,
        Link,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Schulstand => "schulstand",
                Field::Schultyp => "schultyp",
                Field::Strasse => "strasse",
                Field::Hausnr => "hausnr",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::Link => "link",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100342/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rheintr\u{fc}bung kontinuierlich"]
#[doc = ""]
#[doc = "<p class=\"\"></p><div style=\"text-align: left;\"><p class=\"MsoNormal\" style=\"margin-bottom: 0.0001pt; line-height: normal; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif;\">Kontinuierlich gemessene Tr\u{fc}bungsmesswerte der\u{a0}<a href=\"https://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html\" target=\"_blank\"><span style=\"background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Rhein\u{fc}berwachungsstation\nWeil am Rhein</span></a>\u{a0}(RUES, siehe\nhttps://www.aue.bs.ch/umweltanalytik/rheinueberwachungsstation-weil-am-rhein.html),\njeweils gemittelt \u{fc}ber eine Stunde.\u{a0}<br/>\n\u{a0}<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\" style=\"margin-bottom:0cm;margin-bottom:.0001pt;line-height:\nnormal\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Erkl\u{e4}rung zur Einheit:\u{a0}Die Tr\u{fc}bung einer\nFl\u{fc}ssigkeit wird optisch ermittelt, jedoch mittels elektronischer Auswertung\ngemessen. Die Wellenl\u{e4}nge der Mess-Strahlung liegt \u{fc}blicherweise im\nInfrarotbereich bei 860 nm (nach ISO 7027).\u{a0}<br/>\n<br/>\nFNU: Formazine Nephelometric Unit \u{2013} Streulichtmessung (Winkel 90\u{b0}) gem\u{e4}\u{df} den\nVorschriften der Norm ISO 7027\u{a0}<br/>\n<br/>\n<o:p></o:p></span></p>\n\n<p class=\"MsoNormal\" style=\"margin-bottom:0cm;margin-bottom:.0001pt;line-height:\nnormal\"><span style=\"font-size: 10.5pt; font-family: Arial, sans-serif; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Messbetrieb / Unterhalt:\u{a0}<a href=\"https://www.aue.bs.ch/\" target=\"_blank\">Amt\nf\u{fc}r Umwelt und Energie Basel-Stadt (AUE-BS)</a>\u{a0}<br/>\n(siehe https://www.aue.bs.ch/)<o:p></o:p></span></p></div><p></p><p></p>"]
pub mod rheintruebung_kontinuierlich {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start
        ///
        /// Start der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub startzeitpunkt: Option<OffsetDateTime>,
        /// Ende
        ///
        /// Ende der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub endezeitpunkt: Option<OffsetDateTime>,
        /// Trübung [FNU]
        ///
        /// Stundenmittelwert der Trübung gemessen in FNU ("Formazin Nephelometric Unit", was auf Deutsch "Nephelometrische Formazin-Einheit" bedeutet)
        pub rus_w_o_ms_tr: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Startzeitpunkt,
        Endezeitpunkt,
        RusWOMsTr,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Startzeitpunkt => "startzeitpunkt",
                Field::Endezeitpunkt => "endezeitpunkt",
                Field::RusWOMsTr => "rus_w_o_ms_tr",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100323/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Luftqualit\u{e4}t Station Chrischona"]
#[doc = ""]
#[doc = "<p>Standortbeschreibung: Die Messstation befindet sich auf halber H\u{f6}he des Chrischonaturms. Dieser liegt auf einer Anh\u{f6}he \u{f6}stlich der Stadt Basel. In der N\u{e4}he der Station Chrischona befinden sich keine Abgasquellen. Sie gibt die Luftsituation wieder im l\u{e4}ndlichen Umland der Stadt Basel, auf einer H\u{f6}henlage von 640m \u{fc}ber Meer. In diesem H\u{f6}henbereich liegt oft auch die Inversion in der Nordwestschweiz.</p><p>Lage: L\u{e4}ndlich unterhalb 1000 m \u{fc}.M., keine Bebauung</p><p>Koordinaten: 2618695 / 1269030 bzw. N 47\u{b0} 34.302 E 7\u{b0} 41.225; 636 m \u{fc}. M.</p><p>Geografische Lage: Schwarzwaldrand</p><p>Siedlungsgr\u{f6}sse: ausserhalb</p>"]
pub mod luftqualitaet_station_chrischona {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum/Zeit
        #[serde(with = "time::serde::iso8601::option")]
        pub datum_zeit: Option<OffsetDateTime>,
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp_text: Option<OffsetDateTime>,
        pub o3_stundenmittelwerte_ug_m3: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        DatumZeit,
        TimestampText,
        O3StundenmittelwerteUgM3,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::DatumZeit => "datum_zeit",
                Field::TimestampText => "timestamp_text",
                Field::O3StundenmittelwerteUgM3 => "o3_stundenmittelwerte_ug_m3",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100048/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Grosser Rat: Ratsmitgliedschaften"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Ratsmitglieder des Grossen Rates des Kantons Basel-Stadt.</p><p>Pro Datenpunkt wird eine Mitgliedschaft im Grossen Rat gezeigt. Dies kann also zu mehreren Eintr\u{e4}gen der gleichen Person f\u{fc}hren, falls diese Person nach einem Unterbruch wieder in den Grossen Rat gew\u{e4}hlt wurde.</p><p>Die Daten k\u{f6}nnen auch auf der Webseite des Grossen Rates eingesehen werden:<br/><a href=\"https://grosserrat.bs.ch/mitglieder\" target=\"_blank\">https://grosserrat.bs.ch/mitglieder</a></p>"]
pub mod grosser_rat_ratsmitgliedschaften {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Aktiv
        ///
        /// Mitgliedschaft in momentan laufender Legislaturperiode
        pub ist_aktuell_grossrat: Option<String>,
        /// Anrede
        ///
        /// Die Anrede nach amtlichem Geschlecht
        pub anrede: Option<String>,
        /// Titel
        ///
        /// Akademischer Titel des (ehemaligen) Grossratsmitglieds
        pub titel: Option<String>,
        /// Name
        ///
        /// Nachname des (ehemaligen) Grossratsmitglieds
        pub name: Option<String>,
        /// Vorname
        ///
        /// Vorname des (ehemaligen) Grossratsmitglieds
        pub vorname: Option<String>,
        /// Name, Vorname
        ///
        /// Name und Vorname des (ehemaligen) Grossratsmitglieds
        pub name_vorname: Option<String>,
        /// Geburtsdatum
        ///
        /// Geburtsdatum des (ehemaligen) Grossratsmitglieds
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gebdatum: Option<Date>,
        /// Sitz Nr.
        ///
        /// Nummer des Sitzes des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub gr_sitzplatz: Option<i64>,
        /// Wahlkreis
        ///
        /// Wahlkreis des (ehemaligen) Grossratsmitglieds
        pub gr_wahlkreis: Option<String>,
        /// Partei
        ///
        /// Parteizugehörigkeit des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei: Option<String>,
        /// Partei abgekürzt
        ///
        /// Abkürzung der Parteizugehörigkeit des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub partei_kname: Option<String>,
        /// Beginn Grossratsmitgliedschaft
        ///
        /// Startdatum der Mitgliedschaft im Grossen Rat
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gr_beginn: Option<Date>,
        /// Ende Grossratsmitgliedschaft
        ///
        /// Enddatum der Mitgliedschaft im Grossen Rat
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub gr_ende: Option<Date>,
        /// Ratsmitglied grosserrat.bs.ch
        ///
        /// Link zum (ehemaligen) Grossratsmitglied auf der Webseite des Grossen Rates
        pub url: Option<String>,
        /// ID
        ///
        /// Individuelle Identifikationsnummer des (ehemaligen) Grossratsmitglied innerhalb der Datenbank des Grossen Rates
        pub uni_nr: Option<String>,
        /// Strasse
        ///
        /// Strasse an der das Grossratsmitglied wohnhaft ist.
        pub strasse: Option<String>,
        /// PLZ
        ///
        /// Postleitzahl an der das Grossratsmitglied wohnhaft ist.
        pub plz: Option<String>,
        /// Ort
        ///
        /// Ortschaft in der das Grossratsmitglied wohnhaft ist.
        pub ort: Option<String>,
        /// Berufliche Tätigkeit
        ///
        /// Berufliche Tätigkeit des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub gr_beruf: Option<String>,
        /// Arbeitgeber
        ///
        /// Arbeitgeber des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub gr_arbeitgeber: Option<String>,
        /// Homepage
        ///
        /// Homepage des Grossratsmitglieds (nur vorhanden, falls aktuelles Grossratsmitglied)
        pub homepage: Option<String>,
        /// Gremiumsmitgliedschaften data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Mitgliedschaften in Gremien". Gefiltert nach aktuellem Grossratsmitglied.
        pub url_gremiumsmitgliedschaften: Option<String>,
        /// Interessensbindungen data.bs.ch
        ///
        /// Link zum Datensatz "Grosser Rat: Interessensbindungen Ratsmitglieder". Gefiltert nach aktuellem Grossratsmitglied.
        pub url_interessensbindungen: Option<String>,
        /// Urheber von
        ///
        /// Link zum Datensatz "Grosser Rat: Geschäfte". Gefiltert nach Geschäften, denen das aktuelle Grossratsmitglied als Urheber dient.
        pub url_urheber: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        IstAktuellGrossrat,
        Anrede,
        Titel,
        Name,
        Vorname,
        NameVorname,
        Gebdatum,
        GrSitzplatz,
        GrWahlkreis,
        Partei,
        ParteiKname,
        GrBeginn,
        GrEnde,
        Url,
        UniNr,
        Strasse,
        Plz,
        Ort,
        GrBeruf,
        GrArbeitgeber,
        Homepage,
        UrlGremiumsmitgliedschaften,
        UrlInteressensbindungen,
        UrlUrheber,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::IstAktuellGrossrat => "ist_aktuell_grossrat",
                Field::Anrede => "anrede",
                Field::Titel => "titel",
                Field::Name => "name",
                Field::Vorname => "vorname",
                Field::NameVorname => "name_vorname",
                Field::Gebdatum => "gebdatum",
                Field::GrSitzplatz => "gr_sitzplatz",
                Field::GrWahlkreis => "gr_wahlkreis",
                Field::Partei => "partei",
                Field::ParteiKname => "partei_kname",
                Field::GrBeginn => "gr_beginn",
                Field::GrEnde => "gr_ende",
                Field::Url => "url",
                Field::UniNr => "uni_nr",
                Field::Strasse => "strasse",
                Field::Plz => "plz",
                Field::Ort => "ort",
                Field::GrBeruf => "gr_beruf",
                Field::GrArbeitgeber => "gr_arbeitgeber",
                Field::Homepage => "homepage",
                Field::UrlGremiumsmitgliedschaften => "url_gremiumsmitgliedschaften",
                Field::UrlInteressensbindungen => "url_interessensbindungen",
                Field::UrlUrheber => "url_urheber",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100307/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wohnbev\u{f6}lkerung nach Staatsangeh\u{f6}rigkeit und Wohnviertel"]
#[doc = ""]
#[doc = "Dieser Datensatz beinhaltet Angaben zur Wohnbev\u{f6}lkerung des Kantons Basel-Stadt am Jahresende nach Staatsangeh\u{f6}rigkeit (Schweiz/Ausland) und Kantonsb\u{fc}rgerschaft auf Ebene Wohnviertel. Personen an administrativen Meldeadressen sind nicht ber\u{fc}cksichtigt. An administrativen Meldeadressen sind Personen aus administrativen Gr\u{fc}nden gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB)."]
pub mod wohnbevoelkerung_nach_staatsangehoerigkeit_und_wohnviertel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// WOV_NAME
        pub wov_name: Option<String>,
        /// Wohnviertel
        pub wohnviertel: Option<String>,
        /// WOV_LABEL
        pub wov_label: Option<String>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Jahr
        pub jahr: Option<String>,
        /// Anteil Ausländer
        ///
        /// Anteil Ausländer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen. An administrativen Meldeadressen sind Personen aus administrativen Gründen gemeldet, welche dort aber keinen physischen Wohnsitz haben (z.B. KESB).
        pub anteil_al: Option<f64>,
        /// Anteil Kantonsbürger
        ///
        /// Anteil Kantonsbürger an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bs: Option<f64>,
        /// Anteil Kantonsbürger an der Schweizer Bevölkerung
        ///
        /// Anteil Kantonsbürger an der schweizerischen Bevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_bsanch: Option<f64>,
        /// Anteil Schweizer
        ///
        /// Anteil Schweizer an der Gesamtbevölkerung; Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anteil_ch: Option<f64>,
        /// Anzahl Ausländer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_al: Option<String>,
        /// Anzahl Kantonsbürger
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_bs: Option<i64>,
        /// Anzahl Schweizer
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub anzahl_ch: Option<i64>,
        /// Anzahl Gesamtbevölkerung
        ///
        /// Jahresendbestand, exkl. Personen an administrativen Meldeadressen.
        pub gesbev_f: Option<i64>,
        pub gemeinde_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        WovName,
        Wohnviertel,
        WovLabel,
        Jahr,
        AnteilAl,
        AnteilBs,
        AnteilBsanch,
        AnteilCh,
        AnzahlAl,
        AnzahlBs,
        AnzahlCh,
        GesbevF,
        GemeindeName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::WovName => "wov_name",
                Field::Wohnviertel => "wohnviertel",
                Field::WovLabel => "wov_label",
                Field::Jahr => "jahr",
                Field::AnteilAl => "anteil_al",
                Field::AnteilBs => "anteil_bs",
                Field::AnteilBsanch => "anteil_bsanch",
                Field::AnteilCh => "anteil_ch",
                Field::AnzahlAl => "anzahl_al",
                Field::AnzahlBs => "anzahl_bs",
                Field::AnzahlCh => "anzahl_ch",
                Field::GesbevF => "gesbev_f",
                Field::GemeindeName => "gemeinde_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100060/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Einzugsgebiet der ARA Basel"]
#[doc = ""]
#[doc = "<p>Das Untersuchungsgebiet des Abwassermonitoring umfasst das Einzugsgebiet der ARA Basel, welches sich haupts\u{e4}chlich aus dem Kanton Basel-Stadt sowie den Gemeinden Allschwil, Binningen, Birsfelden, Bottmingen, Oberwil und Sch\u{f6}nenbuch (alle Kanton Baselland) zusammensetzt.<br/></p>"]
pub mod einzugsgebiet_der_ara_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Name
        pub name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100336/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Fischereiverbotszonen Rhein"]
#[doc = ""]
#[doc = "<p>Der Datensatz beinhaltet die Zonen innerhalb des Kantons Basel-Stadt, in welchen das Fischen nicht erlaubt ist.\u{a0}</p>"]
pub mod fischereiverbotszonen_rhein {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// ID
        ///
        /// Identifikationsnummer
        pub id: Option<i64>,
        /// Beschreibung
        pub beschreibung: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        Beschreibung,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::Beschreibung => "beschreibung",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100278/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rhein Wasserstand, Pegel und Abfluss"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt den Wasserstand und die Abflussmenge des Rheins in Basel auf der Kleinbasler Seite auf H\u{f6}he des Birs-Zuflusses. Es liegen aktuelle Werte alle 5 Minuten vor. Die Messungen werden im Auftrag des Bundesamts f\u{fc}r Umwelt durchgef\u{fc}hrt (siehe <a href=\"https://www.hydrodaten.admin.ch/de/2289.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/2289.html</a>).</p>\n<p>Der Pegel wird berechnet als [Wasserstand] - 240 m \u{fc}. M., siehe <a href=\"https://port-of-switzerland.ch/hafenservice/pegel/\" target=\"_blank\">https://port-of-switzerland.ch/hafenservice/pegel</a>.\u{a0}</p>"]
pub mod rhein_wasserstand_pegel_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmetern pro Sekunde
        pub abfluss: Option<f64>,
        /// Pegel
        ///
        /// Pegelstand in cm über dem Pegelnullstand von 240 m ü. M.
        pub pegelhoehe: Option<f64>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Abfluss,
        Pegelhoehe,
        Pegel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Abfluss => "abfluss",
                Field::Pegelhoehe => "pegelhoehe",
                Field::Pegel => "pegel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100089/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Rohdaten-Zeitreihe der Belegung der Elektroauto-Ladestationen der IWB"]
#[doc = ""]
#[doc = "<p>IWB baut im Kanton Basel-Stadt ein Netz leistungsf\u{e4}higer \u{f6}ffentlich zug\u{e4}nglicher Ladestationen auf, um der umweltfreundlichen und gerade f\u{fc}r Ballungsgebiete idealen Elektromobilit\u{e4}t entscheidende Impulse zu geben. </p>\n\n<p>In der Pilotphase wurden die Parkpl\u{e4}tze mit LoRa-angebunden Sensoren ausgestattet. Ziel war es festzustellen, ob Parkpl\u{e4}tze durch Fahrzeuge besetzt werden, ohne dass diese einen aktiven Ladevorgang vornehmen. Nach internen Abstimmungen wird die IWB die \u{dc}bermittlung der Daten ab ca. Mitte September 2022 nicht weiterf\u{fc}hren. Gr\u{fc}nde daf\u{fc}r sind Schwierigkeiten bei der \u{dc}bertragung der Werte sowie eine fehlende Relevanz f\u{fc}r die Praxis. Beim Roll-Out der weiteren \u{f6}ffentlichen Ladestationen auf Allmend werden voraussichtlich keine LoRa-Sensoren mehr verbaut.</p>\n\n<p>Echtzeitdaten zur Belegung der Elektroauto-Ladestationen der gesamten Schweiz basierend auf dem Status des Ladevorgangs sind hier zu finden:\u{a0}<a href=\"https://opendata.swiss/de/dataset/ladestationen\" target=\"_blank\">https://opendata.swiss/de/dataset/ladestationen</a></p>\n\n<p>Hier finden Sie die Zeitreihe der Rohdaten zur Belegung der Ladestationen. </p><p><b>Die vorliegenden Rohdaten enthalten insbesondere ab Mai 2021 viele doppelte Eintr\u{e4}ge, da die Sensoren ihre Belegung jeweils mehrfach und in verschiedenen Abst\u{e4}nden melden, auch ohne dass eine Status\u{e4}nderung (belegt/frei) erfolgt ist.\u{a0}</b></p><p>Die deduplizierte Zeitreihe ist hier zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100196\" target=\"_blank\">https://data.bs.ch/explore/dataset/100196</a>. Diese zeigt alle Status\u{e4}nderungen.\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100196\" target=\"_blank\"></a></p><p>Der Datensatz mit nur den aktuellsten Statusmeldungen ist hier zu finden:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100004\" target=\"_blank\">https://data.bs.ch/explore/dataset/100004</a><a href=\"https://data.bs.ch/explore/dataset/100004\" target=\"_blank\"></a></p><p>\u{c4}nderungsprotokoll:<br/>20.09.2022 - Aktualisierungsintervall von \"CONT\" auf \"NEVER\" ge\u{e4}ndert.</p>\n"]
pub mod rohdaten_zeitreihe_der_belegung_der_elektroauto_ladestationen_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Strasse und Hausnummer
        pub addresse: Option<String>,
        /// Ladeleistung
        pub power: Option<String>,
        /// Ort
        pub location: Option<String>,
        /// Parkfeld-Nr
        ///
        /// Eine Ladestation kann mehrere Parkfelder haben
        pub parkingfield: Option<i64>,
        /// Total Parkfelder
        ///
        /// Anzahl Parkfelder einer Ladestation
        pub totalparkings: Option<i64>,
        /// Available / Occupied entspricht frei / belegt
        pub status: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Addresse,
        Power,
        Location,
        Parkingfield,
        Totalparkings,
        Status,
        Timestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Addresse => "addresse",
                Field::Power => "power",
                Field::Location => "location",
                Field::Parkingfield => "parkingfield",
                Field::Totalparkings => "totalparkings",
                Field::Status => "status",
                Field::Timestamp => "timestamp",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100149/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kandidierende der Grossratswahlen 2024 nach H\u{e4}ufigkeit der Kandidatur seit 2008"]
#[doc = ""]
#[doc = "<p style=\"\">Dieser Datensatz zeigt die Kandidierenden der Grossratswahlen 2024 nach H\u{e4}ufigkeit ihrer Kandidatur seit 2008<br></p>"]
pub mod kandidierende_der_grossratswahlen_2024_nach_haeufigkeit_der_kandidatur_seit_2008 {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Häufigkeit
        ///
        /// Häufigkeit von Kandidaturen
        pub haufigkeit: Option<String>,
        /// Kandidaturen
        ///
        /// Kandidaturen seit 2008
        pub kandidaturen: Option<String>,
        /// Gewählt (2008 bis 2020)
        ///
        /// Gewählt zwischen 2008 bis 2020
        pub gewahlt: Option<String>,
        /// Anzahl
        ///
        /// Anzahl Kandidierende
        pub anzahl: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Haufigkeit,
        Kandidaturen,
        Gewahlt,
        Anzahl,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Haufigkeit => "haufigkeit",
                Field::Kandidaturen => "kandidaturen",
                Field::Gewahlt => "gewahlt",
                Field::Anzahl => "anzahl",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100393/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Kennzahlen der Abstimmungen"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Dieser Datensatz zeigt die Resultate aller Volksabstimmungen seit dem 27. September 2020 f\u{fc}r den Kanton Basel-Stadt. Es werden verschiedene Kennzahlen nach Gemeinde differenziert.</p><p style=\"font-family: sans-serif;\">Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im\u{a0}<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">https://www.kantonsblatt.ch/#!/search/publications</a>) des Kantons Basel-Stadt publiziert werden.</p><p style=\"font-family: sans-serif;\">Detaillierte Resultate auf Wahllokal-Ebene findet man im Datensatz\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100345\" target=\"_blank\">\"Abstimmungen Details\"</a>\u{a0}(<a href=\"https://data.bs.ch/explore/dataset/100345\" target=\"_blank\">https://data.bs.ch/explore/dataset/100345</a>)</p><p style=\"font-family: sans-serif;\">Eine Liste der Wahllokale findet man im Datensatz \"<a href=\"https://data.bs.ch/explore/dataset/100098\" target=\"_blank\">Wahllokale Kanton Basel-Stadt</a>\" (<a href=\"https://data.bs.ch/explore/dataset/100098\" target=\"_blank\">https://data.bs.ch/explore/dataset/100098</a>)</p>"]
pub mod kennzahlen_der_abstimmungen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Gemeinde-ID
        pub gemein_id: Option<i64>,
        /// Gemeinde
        pub gemein_name: Option<String>,
        /// ID
        ///
        /// Die ID besteht aus dem Datum, der ID der Vorlage und der ID der Gemeinde
        pub id: Option<String>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen)
        pub result_art: Option<String>,
        /// Stimmberechtigte
        ///
        /// Anzahl der Stimmberechtigten
        pub stimmber_anz: Option<i64>,
        /// Stimmberechtigte Männer
        ///
        /// Anzahl der stimmberechtigten Männer
        pub stimmber_anz_m: Option<i64>,
        /// Stimmberechtigte Frauen
        ///
        /// Anzahl der stimmberechtigten Frauen
        pub stimmber_anz_f: Option<i64>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Stimmbeteiligung
        ///
        /// Anzahl gültige Stimmzettel geteilt durch Anzahl Stimmberechtigte im Kanton Basel-Stadt
        pub durchschn_stimmbet_pro_abst_art: Option<f64>,
        /// Anteil brieflich Stimmende
        ///
        /// Anzahl brieflich abgegebene Stimmen geteilt durch Anzahl abgegebener Stimmen
        pub durchschn_briefl_ant_pro_abst_art: Option<f64>,
        /// Anzahl elektronisch Stimmende
        ///
        /// Anzahl elektronisch Stimmender
        pub anz_elektr_pro_abst_art: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<f64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteil der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag vorliegt oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag am Total der Stimmen mit gültiger Antwort
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Gegenvorschlag
        pub gege_oga_anz: Option<i64>,
        /// Stimmen ohne gültige Antwort Stichfrage
        pub sti_oga_anz: Option<i64>,
        /// Datum (Text)
        pub abst_datum_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        AbstDatum,
        AbstId,
        AbstTitel,
        AbstIdTitel,
        AbstArt,
        GemeinId,
        GemeinName,
        Id,
        ResultArt,
        StimmberAnz,
        StimmberAnzM,
        StimmberAnzF,
        StimmrAnz,
        DurchschnStimmbetProAbstArt,
        DurchschnBrieflAntProAbstArt,
        AnzElektrProAbstArt,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        InitOgaAnz,
        GegeOgaAnz,
        StiOgaAnz,
        AbstDatumText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::AbstDatum => "abst_datum",
                Field::AbstId => "abst_id",
                Field::AbstTitel => "abst_titel",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstArt => "abst_art",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::Id => "id",
                Field::ResultArt => "result_art",
                Field::StimmberAnz => "stimmber_anz",
                Field::StimmberAnzM => "stimmber_anz_m",
                Field::StimmberAnzF => "stimmber_anz_f",
                Field::StimmrAnz => "stimmr_anz",
                Field::DurchschnStimmbetProAbstArt => "durchschn_stimmbet_pro_abst_art",
                Field::DurchschnBrieflAntProAbstArt => "durchschn_briefl_ant_pro_abst_art",
                Field::AnzElektrProAbstArt => "anz_elektr_pro_abst_art",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::InitOgaAnz => "init_oga_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::AbstDatumText => "abst_datum_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100346/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Durchschnittlicher Tagesverkehr (basierend auf dem Geschwindigkeitsmonitoring der Kantonspolizei)"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz resultiert aus dem Daten des Geschwindigkeitsmonitorings der Kantonspolizei Basel-Stadt (siehe <a href=\"https://data.bs.ch/explore/?sort=modified&amp;q=%22geschwindigkeitsmonitoring+Einzelmessungen%22\" target=\"_blank\">https://data.bs.ch/explore/?sort=modified&amp;q=%22geschwindigkeitsmonitoring+Einzelmessungen%22</a>). Es wird zu jeder Messung und Richtung (ein Messger\u{e4}t an einem Standort misst in zwei Richtungen) der durchschnittliche Tagesverkehr berechnet. </p><p>\n\nHinweis: Die Messungen sind nicht zwingend repr\u{e4}sentativ f\u{fc}r das ganze Jahr und m\u{fc}ssen im Kontext des Erhebungsdatums betrachtet werden. Dar\u{fc}ber hinaus wurden gewisse Messungen w\u{e4}hrend einer ausserordentlichen Verkehrsf\u{fc}hrung (z.B. Umleitungsverkehr infolge von Baustellent\u{e4}tigkeiten etc.) erhoben. Diese Messungen sind ab dem Jahr 2022 in der Spalte \u{ab}Ausserordentliche Verkehrsf\u{fc}hrung\u{bb} mit \u{ab}True\u{bb} gekennzeichnet. Manipulationen an Ger\u{e4}ten k\u{f6}nnen zu fehlerhaften Messungen f\u{fc}hren.\n</p>"]
pub mod durchschnittlicher_tagesverkehr_basierend_auf_dem_geschwindigkeitsmonitoring_der_kantonspolizei {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messung-ID
        ///
        /// Laufnummer der Messung; eine Messung beinhaltet alle Fahrten eines Messgeräts an einem Standort
        pub messung_id: Option<i64>,
        /// Strasse
        ///
        /// Name der Strasse, an welcher ein Messgerät ausgebracht wurde
        pub strasse: Option<String>,
        /// Hausnummer
        ///
        /// Hausnummer, bei welcher ein Messgerät ausgebracht wurde
        pub strasse_nr: Option<String>,
        /// Ort
        ///
        /// Gemeinde am Standort einer Messung
        pub ort: Option<String>,
        /// Koordinaten
        pub the_geom: Option<GeoJson>,
        /// ausserordendliche Verkehrsführung
        ///
        /// Messung während ausserordentlicher Verkehrsführung
        pub extraordinary_traffic_routing: Option<String>,
        /// Anfangszeit
        ///
        /// Anfangszeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub min_timestamp: Option<OffsetDateTime>,
        /// Endzeit
        ///
        /// Endzeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub max_timestamp: Option<OffsetDateTime>,
        /// Messdauer (Stunden)
        ///
        /// Messdauer in Stunden
        pub messdauer_h: Option<f64>,
        /// Richtung ID
        ///
        /// ID der Richtung; In einer Messung werden i.d.R. Fahrten in zwei Richtungen gemessen.
        pub richtung_id: Option<i64>,
        /// Richtung
        ///
        /// Fahrtrichtung
        pub richtung: Option<String>,
        /// Anzahl Fahrzeuge
        ///
        /// Anzahl gemessene Fahrzeuge
        pub count: Option<i64>,
        /// Anzahl Fahrzeuge bis 3.5 m
        ///
        /// Anzahl Fahrzeuge der Längenklasse bis 3.5 m
        pub count_lt_3_5m: Option<i64>,
        /// Anzahl Fahrzeuge zwischen 3.5 m und 8 m
        ///
        /// Anzahl Fahrzeuge der Längenklasse zwischen 3.5 m und 8 m
        pub count_3_5_to_lt_8m: Option<i64>,
        /// Anzahl Fahrzeuge ab 8 m
        ///
        /// Anzahl Fahrzeuge der Längenklasse 8 m oder grösser
        pub count_gte_8m: Option<i64>,
        /// Durchschnittlicher Tagesverkehr (DTV)
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum
        pub dtv: Option<f64>,
        /// DTV Fahrzeuge bis 3.5 m
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum der Fahrzeuge der Längenklasse bis 3.5 m
        pub dtv_lt_3_5m: Option<f64>,
        /// DTV Fahrzeuge zwischen 3.5 m und 8 m
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum der Fahrzeuge der Längenklasse zwischen 3.5 m und 8 m
        pub dtv_3_5_to_lt_8m: Option<f64>,
        /// DTV Fahrzeuge ab 8 m
        ///
        /// Durchschnittlicher Tagesverkehr im Erhebungszeitraum der Fahrzeuge der Längenklasse über 8 m
        pub dtv_gte_8m: Option<f64>,
        /// Datensatz-ID
        ///
        /// Datensatz-ID der Einzelmessungen
        pub dataset_id: Option<i64>,
        /// Einzelmessungen
        ///
        /// Link zu den Einzelmessungen
        pub link_zu_einzelmessungen: Option<String>,
        /// Anfangszeit (Text)
        ///
        /// Anfangszeit der Messung im Textformat
        pub min_timestamp_text: Option<String>,
        /// Endzeit (Text)
        ///
        /// Endzeit der Messung im Textformat
        pub max_timestamp_text: Option<String>,
        /// geographische Koordinaten
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        MessungId,
        Strasse,
        StrasseNr,
        Ort,
        ExtraordinaryTrafficRouting,
        MinTimestamp,
        MaxTimestamp,
        MessdauerH,
        RichtungId,
        Richtung,
        Count,
        CountLt35m,
        Count35ToLt8m,
        CountGte8m,
        Dtv,
        DtvLt35m,
        Dtv35ToLt8m,
        DtvGte8m,
        DatasetId,
        LinkZuEinzelmessungen,
        MinTimestampText,
        MaxTimestampText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::MessungId => "messung_id",
                Field::Strasse => "strasse",
                Field::StrasseNr => "strasse_nr",
                Field::Ort => "ort",
                Field::ExtraordinaryTrafficRouting => "extraordinary_traffic_routing",
                Field::MinTimestamp => "min_timestamp",
                Field::MaxTimestamp => "max_timestamp",
                Field::MessdauerH => "messdauer_h",
                Field::RichtungId => "richtung_id",
                Field::Richtung => "richtung",
                Field::Count => "count",
                Field::CountLt35m => "count_lt_3_5m",
                Field::Count35ToLt8m => "count_3_5_to_lt_8m",
                Field::CountGte8m => "count_gte_8m",
                Field::Dtv => "dtv",
                Field::DtvLt35m => "dtv_lt_3_5m",
                Field::Dtv35ToLt8m => "dtv_3_5_to_lt_8m",
                Field::DtvGte8m => "dtv_gte_8m",
                Field::DatasetId => "dataset_id",
                Field::LinkZuEinzelmessungen => "link_zu_einzelmessungen",
                Field::MinTimestampText => "min_timestamp_text",
                Field::MaxTimestampText => "max_timestamp_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100199/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wiese Wasserstand und Abfluss"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt den Wasserstand und die Abflussmenge der Wiese in Basel etwa auf H\u{f6}he der Br\u{fc}cke bei der Wiesenstrasse \u{fc}ber die Wiese. Es liegen aktuelle Werte alle 5 Minuten vor. Die Messungen werden im Auftrag des Bundesamts f\u{fc}r Umwelt durchgef\u{fc}hrt (siehe <a href=\"https://www.hydrodaten.admin.ch/de/2199.html\" target=\"_blank\">https://www.hydrodaten.admin.ch/de/2199.html</a>).</p>"]
pub mod wiese_wasserstand_und_abfluss {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Abflussmenge
        ///
        /// Abfliessende Wassermenge in Kubikmetern pro Sekunde
        pub abfluss: Option<f64>,
        /// Wasserstand
        ///
        /// Pegelstand in Metern über Meer
        pub pegel: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Abfluss,
        Pegel,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Abfluss => "abfluss",
                Field::Pegel => "pegel",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100235/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Parkplatzbelegung"]
#[doc = ""]
#[doc = "<p style=\"font-family: sans-serif;\">Der Datensatz zeigt die Anzahl besetzter und freier Parkpl\u{e4}tze in den beiden Zonen \u{ab}blau\u{bb} und \u{ab}gelb\u{bb}.</p><p style=\"font-family: sans-serif;\"><b>Die Detektion freier Parkpl\u{e4}tze mittels Kamera befindet sich noch in der Testphase. Aus diesem Grund sind die Werte mit Vorsicht zu geniessen und k\u{f6}nnen von den tats\u{e4}chlichen Zust\u{e4}nden abweichen.</b><br/></p><p style=\"font-family: sans-serif;\">Zus\u{e4}tzlich relevante Datens\u{e4}tze f\u{fc}r die Parkplatzbelegung:</p><ul><li><a href=\"https://data.bs.ch/explore/dataset/100171/\" target=\"_blank\">Zu- und Wegfahrten, Parkplatzauslastung</a></li><li><a href=\"https://data.bs.ch/explore/dataset/100176/\" target=\"_blank\">Parkplatz-Zonen</a></li></ul><p class=\"\" style=\"font-family: sans-serif;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</p><ul><li>Weitere Informationen zum Projekt\u{a0}\u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><b>Die Parkplatz-Kamera an der Gundeldingerstrasse wurde am Dienstag 4.10.2022 abmontiert. Es werden keine Daten mehr erhoben.</b><br/></p>"]
pub mod smarte_strasse_parkplatzbelegung {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Blau: Total Parkplätze
        ///
        /// Total Anzahl erfasster blauer Parkplätze
        pub blue_total: Option<i64>,
        /// Blau: verfügbar
        ///
        /// Anzahl verfügbarer blauer Parkplätze
        pub blue_available: Option<i64>,
        /// Blau: besetzt
        ///
        /// Anzahl besetzte blaue Parkplätze
        pub blue_occupied: Option<i64>,
        /// Gelb: Total Parkplätze
        ///
        /// Total Anzahl erfasste gelbe Parkplätze
        pub yellow_total: Option<i64>,
        /// Gelb: verfügbar
        ///
        /// Anzahl verfügbare gelbe Parkplätze
        pub yellow_available: Option<i64>,
        /// Gelb: besetzt
        ///
        /// Anzahl besetzte gelbe Parkplätze
        pub yellow_occupied: Option<i64>,
        pub timestamp_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        BlueTotal,
        BlueAvailable,
        BlueOccupied,
        YellowTotal,
        YellowAvailable,
        YellowOccupied,
        TimestampText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::BlueTotal => "blue_total",
                Field::BlueAvailable => "blue_available",
                Field::BlueOccupied => "blue_occupied",
                Field::YellowTotal => "yellow_total",
                Field::YellowAvailable => "yellow_available",
                Field::YellowOccupied => "yellow_occupied",
                Field::TimestampText => "timestamp_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100160/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Temperatur Grundwasser"]
#[doc = ""]
#[doc = "<p>Der Datensatz enth\u{e4}lt die Grundwassertemparturen in \u{b0}C des kantonalen Grundwassermessnetzes. Es weist zur Zeit um die 80 Messstationen auf. Bei den Stationen, die mit einer Datenfern\u{fc}bertragung ausger\u{fc}stet sind, liegen tagesaktuelle Stundenwerte vor.</p><p>Jede Messstation ist mit der Katasternummer gem\u{e4}ss Bohrkataster des Kantons Basel-Stadt versehen (<a href=\"https://data.bs.ch/explore/dataset/100182\" target=\"_blank\">https://data.bs.ch/explore/dataset/100182</a>). Die Bohrungen sind auch auf MapBS unter dem Thema Geologie abrufbar (<a href=\"http://www.geo.bs.ch/bohrkataster\" target=\"_blank\">www.geo.bs.ch/bohrkataster</a>).</p><p>Weitere Informationen: <a href=\"https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html\" target=\"_blank\">https://www.aue.bs.ch/wasser/grundwasser/grundwasserpegel-grundwasserqualitaet.html</a></p>"]
pub mod temperatur_grundwasser {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel der Messung in lokaler Zeit (Basel)
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// StationNr
        ///
        /// Katasternummer gemäss Bohrkataster, 10-stellig, prefixed mit 0
        pub stationnr: Option<String>,
        /// StationName
        ///
        /// Name der Messtation inkl. Stationsnummer in Klammern
        pub stationname: Option<String>,
        /// SensorNr
        ///
        /// Nummer der Messgrösse, siehe auch Spalte "SensName"
        pub sensornr: Option<i64>,
        /// SensName
        ///
        /// Messgrösse
        pub sensname: Option<String>,
        /// Value
        ///
        /// Messwert: Grundwassertemperatur [°C]
        pub value: Option<f64>,
        /// Standort der Messung
        pub geo_point_2d: Option<GeoPoint2d>,
        /// XCoord
        ///
        /// X-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub xcoord: Option<i64>,
        /// YCoord
        ///
        /// Y-Koordinate im Koordinatensystem LV95 (EPSG:2056)
        pub ycoord: Option<i64>,
        /// topTerrain
        ///
        /// Terrainhöhe [m ü. M.] bei der Messstelle
        pub topterrain: Option<f64>,
        /// refPoint
        ///
        /// Abstichkote (= Pegelbezugspunkt) in m ü. M.
        pub refpoint: Option<f64>,
        /// Status
        ///
        /// Rohadaten/ungeprüfte Daten (raw)
        ///bereinigte/geprüfte Daten (cleansed)
        pub status: Option<String>,
        /// on/offline
        pub on_offline: Option<String>,
        /// Date
        ///
        /// Datum in mitteleuropäischer Winterzeit (UTC+1)
        pub date: Option<String>,
        /// Time
        ///
        /// Zeit in mitteleuropäischer Winterzeit (UTC+1)
        pub time: Option<String>,
        /// Zeitstempel in mitteleuropäischer Winterzeit (UTC+1)
        pub timestamp_text: Option<String>,
        /// StationId
        ///
        /// Katasternummer gemäss Bohrkataster
        pub stationid: Option<String>,
        /// Koordinate im Format WGS84
        pub lat: Option<f64>,
        /// Koordinate im Format WGS84
        pub lon: Option<f64>,
        /// bohrkataster-link
        pub bohrkataster_link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Stationnr,
        Stationname,
        Sensornr,
        Sensname,
        Value,
        Xcoord,
        Ycoord,
        Topterrain,
        Refpoint,
        Status,
        OnOffline,
        Date,
        Time,
        TimestampText,
        Stationid,
        Lat,
        Lon,
        BohrkatasterLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Stationnr => "stationnr",
                Field::Stationname => "stationname",
                Field::Sensornr => "sensornr",
                Field::Sensname => "sensname",
                Field::Value => "value",
                Field::Xcoord => "xcoord",
                Field::Ycoord => "ycoord",
                Field::Topterrain => "topterrain",
                Field::Refpoint => "refpoint",
                Field::Status => "status",
                Field::OnOffline => "on_offline",
                Field::Date => "date",
                Field::Time => "time",
                Field::TimestampText => "timestamp_text",
                Field::Stationid => "stationid",
                Field::Lat => "lat",
                Field::Lon => "lon",
                Field::BohrkatasterLink => "bohrkataster_link",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100179/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Belegung der Elektroauto-Ladestationen der IWB"]
#[doc = ""]
#[doc = "<p>IWB baut im Kanton Basel-Stadt ein Netz leistungsf\u{e4}higer \u{f6}ffentlich zug\u{e4}nglicher Ladestationen auf, um der umweltfreundlichen und gerade f\u{fc}r Ballungsgebiete idealen Elektromobilit\u{e4}t entscheidende Impulse zu geben.\u{a0}</p><p>In der Pilotphase wurden die Parkpl\u{e4}tze mit LoRa-angebunden Sensoren ausgestattet. Ziel war es festzustellen, ob Parkpl\u{e4}tze durch Fahrzeuge besetzt werden, ohne dass diese einen aktiven Ladevorgang vornehmen. Nach internen Abstimmungen wird die IWB die \u{dc}bermittlung der Daten ab ca. Mitte September 2022 nicht weiterf\u{fc}hren. Gr\u{fc}nde daf\u{fc}r sind Schwierigkeiten bei der \u{dc}bertragung der Werte sowie eine fehlende Relevanz f\u{fc}r die Praxis. Beim Roll-Out der weiteren \u{f6}ffentlichen Ladestationen auf Allmend werden voraussichtlich keine LoRa-Sensoren mehr verbaut.\u{a0}</p><p>Echtzeitdaten zur Belegung der Elektroauto-Ladestationen der gesamten Schweiz basierend auf dem Status des Ladevorgangs sind hier zu finden:\u{a0}<a href=\"https://opendata.swiss/de/dataset/ladestationen\" target=\"_blank\">https://opendata.swiss/de/dataset/ladestationen</a></p>"]
pub mod belegung_der_elektroauto_ladestationen_der_iwb {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        pub addresse: Option<String>,
        pub power: Option<String>,
        pub location: Option<String>,
        pub geo_point_2d: Option<GeoPoint2d>,
        pub parkingfield: Option<i64>,
        pub totalparkings: Option<i64>,
        pub status: Option<String>,
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Addresse,
        Power,
        Location,
        Parkingfield,
        Totalparkings,
        Status,
        Timestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Addresse => "addresse",
                Field::Power => "power",
                Field::Location => "location",
                Field::Parkingfield => "parkingfield",
                Field::Totalparkings => "totalparkings",
                Field::Status => "status",
                Field::Timestamp => "timestamp",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100004/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abstimmungen Details"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Resultate aller Volksabstimmungen seit dem 27. September 2020 f\u{fc}r den Kanton Basel-Stadt auf Ebene Wahllokal.</p><p>Bitte beachten Sie, dass die offiziell g\u{fc}ltigen Schlussresultate im <a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">Kantonsblatt</a>\u{a0}(<a href=\"https://www.kantonsblatt.ch/#!/search/publications\" target=\"_blank\">https://www.kantonsblatt.ch/#!/search/publications</a>) des Kantons Basel-Stadt publiziert werden.</p><p>Die Gesamtresultate der Abstimmungen und die Resultate auf Gemeindeebene findet man im Datensatz <a href=\"https://data.bs.ch/explore/dataset/100346\" target=\"_blank\">\"Abstimmungen Kennzahlen\"</a> (<a href=\"https://data.bs.ch/explore/dataset/100346\" target=\"_blank\">https://data.bs.ch/explore/dataset/100346</a>)</p><p>Eine Liste der Wahllokale findet man im Datensatz \"<a href=\"https://data.bs.ch/explore/dataset/100098\" target=\"_blank\">Wahllokale Kanton Basel-Stadt</a>\" (<a href=\"https://data.bs.ch/explore/dataset/100098\" target=\"_blank\">https://data.bs.ch/explore/dataset/100098</a>)</p>"]
pub mod abstimmungen_details {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        ///
        /// Datum der Abstimmung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub abst_datum: Option<Date>,
        /// Vorlage-ID
        ///
        /// Laufnummer der Vorlage
        pub abst_id: Option<i64>,
        /// Titel
        ///
        /// Titel der Vorlage
        pub abst_titel: Option<String>,
        /// ID und Titel der Vorlage
        pub abst_id_titel: Option<String>,
        /// Art der Vorlage
        ///
        /// Art der Vorlage; national oder kantonal
        pub abst_art: Option<String>,
        /// Gemeinde-ID
        ///
        /// Numerische Kennung, die jeder Gemeinde eine eindeutige Identifikation zuweist
        pub gemein_id: Option<i64>,
        /// Gemeinde
        ///
        /// Die "Gemeinde" bezeichnet die geografische oder politische Einheit, in der die Abstimmung oder Wahl stattgefunden hat
        pub gemein_name: Option<String>,
        /// Wahllokal-ID
        ///
        /// Numerische Kennung, die jedem Wahllokal eine eindeutige Identifikation zugewiesen wird
        pub wahllok_id: Option<i64>,
        /// Wahllokal
        ///
        /// Standort, an dem die Abstimmung durchgeführt wurde
        pub wahllok_name: Option<String>,
        /// ID
        ///
        /// Die ID besteht aus dem Datum, der ID der Vorlage und der ID des Wahllokals
        pub id: Option<String>,
        /// Resultattyp
        ///
        /// Zwischenresultat (brieflich Stimmende) oder Schlussresultat (alle Stimmen). Zwischenresultate werden durch Schlussresultate überschrieben.
        pub result_art: Option<String>,
        /// Stimmrechtsausweise
        ///
        /// Anzahl Stimmrechtsausweise
        pub stimmr_anz: Option<i64>,
        /// Eingelegte Stimmzettel
        ///
        /// Anzahl eingelegter Stimmzettel
        pub eingel_anz: Option<i64>,
        /// Leere Stimmzettel
        ///
        /// Anzahl leer eingelegter Stimmzettel
        pub leer_anz: Option<i64>,
        /// Ungültige Stimmzettel
        ///
        /// Anzahl ungültiger Stimmzettel
        pub unguelt_anz: Option<i64>,
        /// Gültige Stimmzettel
        ///
        /// Anzahl gültiger Stimmzettel
        pub guelt_anz: Option<i64>,
        /// Ja-Stimmen
        ///
        /// Anzahl Ja-Stimmen
        pub ja_anz: Option<i64>,
        /// Nein-Stimmen
        ///
        /// Anzahl Nein-Stimmen
        pub nein_anz: Option<i64>,
        /// Anteil Ja-Stimmen
        ///
        /// Anteill der Ja-Stimmen am Total der Stimmen mit gültiger Antwort
        pub anteil_ja_stimmen: Option<f64>,
        /// Abstimmungstyp
        ///
        /// Angabe, ob für eine Vorlage ein Gegenvorschlag zur Verfügung steht oder nicht
        pub abst_typ: Option<String>,
        /// Ja-Stimmen Gegenvorschlag
        ///
        /// Anzahl Ja-Stimmen für den Gegenvorschlag
        pub gege_ja_anz: Option<i64>,
        /// Nein-Stimmen Gegenvorschlag
        ///
        /// Anzahl Nein-Stimmen für den Gegenvorschlag
        pub gege_nein_anz: Option<i64>,
        /// Stichfrage Initiative
        ///
        /// Anzahl Stimmen bei der Stichfrage für die Initiative
        pub sti_initiative_anz: Option<i64>,
        /// Stichfrage Gegenvorschlag
        ///
        /// Anzahl Stimmen bei der Stichfrage für den Gegenvorschlag
        pub sti_gegenvorschlag_anz: Option<i64>,
        /// Anteil Ja-Stimmen Gegenvorschlag
        ///
        /// Anteil der Ja-Stimmen für den Gegenvorschlag
        pub gege_anteil_ja_stimmen: Option<f64>,
        /// Stichfrage Anteil Initiative
        ///
        /// Anteil der Stimmen bei der Stichfrage für die Initiative
        pub sti_anteil_init_stimmen: Option<f64>,
        /// Stimmen ohne gültige Antwort
        ///
        /// Anzahl Stimmen ohne gültige Antwort zu einer Vorlage
        pub init_oga_anz: Option<i64>,
        /// Gegenvorschlag Stimmen ohne gültige Antwort
        pub gege_oga_anz: Option<i64>,
        /// Stichfrage Stimmen ohne gültige Antwort
        pub sti_oga_anz: Option<i64>,
        /// Datum der Abstimmung
        pub abst_datum_text: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        AbstDatum,
        AbstId,
        AbstTitel,
        AbstIdTitel,
        AbstArt,
        GemeinId,
        GemeinName,
        WahllokId,
        WahllokName,
        Id,
        ResultArt,
        StimmrAnz,
        EingelAnz,
        LeerAnz,
        UngueltAnz,
        GueltAnz,
        JaAnz,
        NeinAnz,
        AnteilJaStimmen,
        AbstTyp,
        GegeJaAnz,
        GegeNeinAnz,
        StiInitiativeAnz,
        StiGegenvorschlagAnz,
        GegeAnteilJaStimmen,
        StiAnteilInitStimmen,
        InitOgaAnz,
        GegeOgaAnz,
        StiOgaAnz,
        AbstDatumText,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::AbstDatum => "abst_datum",
                Field::AbstId => "abst_id",
                Field::AbstTitel => "abst_titel",
                Field::AbstIdTitel => "abst_id_titel",
                Field::AbstArt => "abst_art",
                Field::GemeinId => "gemein_id",
                Field::GemeinName => "gemein_name",
                Field::WahllokId => "wahllok_id",
                Field::WahllokName => "wahllok_name",
                Field::Id => "id",
                Field::ResultArt => "result_art",
                Field::StimmrAnz => "stimmr_anz",
                Field::EingelAnz => "eingel_anz",
                Field::LeerAnz => "leer_anz",
                Field::UngueltAnz => "unguelt_anz",
                Field::GueltAnz => "guelt_anz",
                Field::JaAnz => "ja_anz",
                Field::NeinAnz => "nein_anz",
                Field::AnteilJaStimmen => "anteil_ja_stimmen",
                Field::AbstTyp => "abst_typ",
                Field::GegeJaAnz => "gege_ja_anz",
                Field::GegeNeinAnz => "gege_nein_anz",
                Field::StiInitiativeAnz => "sti_initiative_anz",
                Field::StiGegenvorschlagAnz => "sti_gegenvorschlag_anz",
                Field::GegeAnteilJaStimmen => "gege_anteil_ja_stimmen",
                Field::StiAnteilInitStimmen => "sti_anteil_init_stimmen",
                Field::InitOgaAnz => "init_oga_anz",
                Field::GegeOgaAnz => "gege_oga_anz",
                Field::StiOgaAnz => "sti_oga_anz",
                Field::AbstDatumText => "abst_datum_text",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100345/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Temperatur Wiese"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die st\u{fc}ndlichen Temperaturwerte der Wiese an.</p><p>Koordinaten:\u{a0}<a href=\"https://map.geo.bs.ch/s/7z0Q\" target=\"_blank\">47.581638577259945, 7.59193858146811</a></p>"]
pub mod temperatur_wiese {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        ///
        /// Datum und Uhrzeit
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp_text: Option<OffsetDateTime>,
        /// Temperatur
        ///
        /// Temperatur in Grad Celsius
        pub temperatur: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        TimestampText,
        Temperatur,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::TimestampText => "timestamp_text",
                Field::Temperatur => "temperatur",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100269/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wetterstation Rosental Mitte"]
#[doc = ""]
#[doc = "<p>Die Wetterstation wurde im Rahmen der \u{ab}Transformation\u{a0}<a href=\"https://rosentalmitte.ch/\" target=\"_blank\">Rosental Mitte</a>\u{bb} installiert. Das Areal soll dabei etappenweise f\u{fc}r die \u{d6}ffentlichkeit zug\u{e4}nglich gemacht und zu einem vollwertigen Stadtteil entwickelt werden. </p><p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft. Die Wetterstation zeichnet w\u{e4}hrend der \u{dc}berwachung u.a. Windrichtungen und Windgeschwindigkeiten auf, die bei der Interpretation der Immissionsmessungen hilfreich sind.</p>"]
pub mod wetterstation_rosental_mitte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Zeitstempel
        #[serde(with = "time::serde::iso8601::option")]
        pub timestamp: Option<OffsetDateTime>,
        /// Niederschlag
        ///
        /// Total der Niederschläge innerhalb der letzten Stunde
        pub precipitation: Option<f64>,
        /// Luftfeuchtigkeit
        ///
        /// Luftfeuchtigkeit bezieht sich auf die Menge an Wassertröpfchen oder Wasserdampf, die in der Luft vorhanden sind.
        pub relativehumidityhc: Option<f64>,
        /// Globalstrahlung [W/m2]
        ///
        /// Globalstrahlung ist die Menge an Sonnenenergie, die auf eine horizontale Fläche in einer bestimmten Zeitspanne (normalerweise in Stunden) auftrifft.
        pub solarradiation: Option<f64>,
        /// Lufttemperatur
        ///
        /// Lufttemperatur bezieht sich auf die Masseinheit der Wärmeenergie, die in der Luft vorhanden ist.
        pub airtemperaturehc: Option<f64>,
        /// Windgeschwindigkeit
        ///
        /// Windgeschwindigkeit bezieht sich auf die Geschwindigkeit, mit der sich Luft in horizontaler Richtung bewegt.
        pub windspeedultrasonic: Option<f64>,
        /// Windrichtung
        ///
        /// Windrichtung bezieht sich auf die Richtung, aus der der Wind weht. Sie wird normalerweise in Grad gemessen, wobei 0 Grad für Nord, 90 Grad für Ost, 180 Grad für Süd und 270 Grad für West steht.
        pub winddirultrasonic: Option<f64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Timestamp,
        Precipitation,
        Relativehumidityhc,
        Solarradiation,
        Airtemperaturehc,
        Windspeedultrasonic,
        Winddirultrasonic,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Timestamp => "timestamp",
                Field::Precipitation => "precipitation",
                Field::Relativehumidityhc => "relativehumidityhc",
                Field::Solarradiation => "solarradiation",
                Field::Airtemperaturehc => "airtemperaturehc",
                Field::Windspeedultrasonic => "windspeedultrasonic",
                Field::Winddirultrasonic => "winddirultrasonic",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100294/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Transformation Areal Rosental: Standorte"]
#[doc = ""]
#[doc = "<p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten im Rahmen der \u{ab}Transformation <a href=\"https://rosentalmitte.ch/\" target=\"_blank\">Rosental Mitte</a>\u{bb} \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft <a href=\"https://data.bs.ch/pages/rosental-dashboard/\" target=\"_blank\">(Dashboard)</a>.\u{a0}</p><p>\u{c4}nderungsprotokoll:<br>23.4.2024: Die Messstation ROSEN 3 wurde verschoben. Alte geografische Breiten- und L\u{e4}ngengrade 47.567827676637364, 7.603804744961502. Neue Breiten- und L\u{e4}gengrade\u{a0}47.567997530870265, 7.60479830196066.</p><div><br></div>"]
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_standorte {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Name
        pub name: Option<String>,
        /// X-Koordinate
        pub x_coord: Option<f64>,
        /// Y-Koordinate
        pub y_coord: Option<f64>,
        pub geo_point_2d: Option<GeoPoint2d>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Name,
        XCoord,
        YCoord,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Name => "name",
                Field::XCoord => "x_coord",
                Field::YCoord => "y_coord",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100293/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Abwassermonitoring: Influenza und RSV"]
#[doc = ""]
#[doc = "<p><b>Figur<br></b><span>Der Datensatz zeigt den 7-Tage-Median der RNA-Kopien des angegebenen Virus jeweils pro Tag und 100\u{2018}000 Personen im Abwasser der Abwasserreinigungs-Anlage (ARA) Basel sowie den 7-Tage-Median der entsprechenden Fallzahlen. Der Datensatz wird i.d.R. jeweils dienstags mit den Daten bis vorangegangenem Sonntag aktualisiert. In einzelnen Wochen kann es zu Verschiebungen kommen.</span></p><p><span style=\"font-weight: bolder;\">Messung<br></span>Die ProRheno AG (Betreiber der ARA Basel) entnimmt jeweils eine 24h-Probe des Rohabwassers, welche durch das Kantonale Laboratorium Basel-Stadt (KL BS) auf RNA der angegebenen Viren untersucht wird. Die Messmethodik wurde dabei seit Beginn des Monitorings nicht ver\u{e4}ndert: siehe Publikation\u{a0}<a href=\"https://smw.ch/index.php/smw/article/view/3226\" target=\"_blank\">https://smw.ch/index.php/smw/article/view/3226</a>. Die Plausibilit\u{e4}t der Werte wird laufend anhand interner Qualit\u{e4}tsparameter \u{fc}berpr\u{fc}ft. Das Untersuchungsgebiet umfasst das Einzugsgebiet der ARA Basel, welches sich haupts\u{e4}chlich aus dem Kanton Basel-Stadt sowie den Gemeinden Allschwil, Binningen, Birsfelden, Bottmingen, Oberwil und Sch\u{f6}nenbuch (alle Kanton Baselland) zusammensetzt. Bis Ende Juni 2023 wurden die Messwerte des KL BS auch auf dem Abwasser-Dashboard des BAG\u{a0}<a href=\"https://www.covid19.admin.ch/de/epidemiologic/waste-water?wasteWaterFacility=270101\" target=\"_blank\">Covid-\u{2060}19 Schweiz | Coronavirus | Dashboard (https://www.covid19.admin.ch/de/epidemiologic/waste-water?wasteWaterFacility=270101)</a>\u{a0}dargestellt. Ab Juli 2023 werden auf dieser Seite die Messwerte der EAWAG\u{a0}<a href=\"https://www.eawag.ch/de/abteilung/sww/projekte/sars-cov2-im-abwasser/\" target=\"_blank\">SARS-CoV2 im Abwasser - Eawag</a>\u{a0}(<a href=\"https://www.eawag.ch/de/abteilung/sww/projekte/sars-cov2-im-abwasser/\" target=\"_blank\">https://www.eawag.ch/de/abteilung/sww/projekte/sars-cov2-im-abwasser/</a>) publiziert, welche ebenfalls das Rohabwasser der ARA Basel untersucht. Die vom KL BS und der EAWAG verwendeten Untersuchungsmethoden sind sehr \u{e4}hnlich aber nicht identisch.</p><p><span style=\'font-size:11.0pt;font-family:\"Arial\",sans-serif;\nmso-fareast-font-family:Calibri;mso-fareast-theme-font:minor-latin;mso-ansi-language:\nDE-CH;mso-fareast-language:EN-US;mso-bidi-language:AR-SA\'>In den Zeitr\u{e4}umen\n29.4. bis 1.8.2022 (ausser 1.6.2022 und 5.6.2022) und 30.5.2023 bis 3.9.2023\nwurden keine Abwasserproben auf Influenza und RSV untersucht.</span><br></p><p><b>Fallzahlen <br></b>Die Fallzahlen entsprechen der Anzahl der best\u{e4}tigten und dem Kanton gemeldeten F\u{e4}lle der dargestellten Infektionen im Einzugsgebiet der ARA Basel.<br></p><p><b>Interpretation der Kurven<br></b><span\">Beim Monitoring von Viren im Abwasser geht es in erster Linie darum, Trends zu erkennen (insbesondere nat\u{fc}rlich die Zunahme eines zirkulierenden Virus). Es ist nicht m\u{f6}glich, daraus eine bestimmte Fallzahl oder den Schweregrad einer Infektion abzuleiten. Ein Vergleich des Kurvenausschlags (H\u{f6}he der Peaks) zu verschiedenen Zeitpunkten ist kaum m\u{f6}glich, da z.B. unterschiedliche Virusvarianten zu unterschiedlichen Virusmengen pro Fall f\u{fc}hren. Unterschiedliche Virusvarianten k\u{f6}nnen auch die Symptomatik beeinflussen, so dass z.B. Infektionen bei Menschen spurlos verlaufen, aber dennoch Viren ins Abwasser abgegeben werden.</span\"></p>\n\n<div class=\"html_button btn-left\">\n    <a class=\"btn customButton large\" href=\"https://data.bs.ch/pages/abwassermonitoring-dashboard/\">Hier gehts zum Dashboard</a>\n</div>"]
pub mod abwassermonitoring_influenza_und_rsv {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Datum
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub datum: Option<Date>,
        /// KW
        pub kw: Option<i64>,
        /// Sample Ba-Nr.
        pub sample_ba_nr: Option<String>,
        /// InfA (gc/PCR)
        pub infa_gc_pcr: Option<f64>,
        /// InfB (gc/PCR)
        pub infb_gc_pcr: Option<f64>,
        /// RSV (gc/PCR)
        pub rsv_gc_pcr: Option<f64>,
        /// InfA (gc/L)
        pub infa_gc_l: Option<f64>,
        /// InfB (gc/L)
        pub infb_gc_l: Option<f64>,
        /// RSV (gc/L)
        pub rsv_gc_l: Option<f64>,
        /// InfA (gc/L) 7-d median
        pub infa_gc_l_7_d_median: Option<f64>,
        /// InfB (gc/L) 7-d median
        pub infb_gc_l_7_d_median: Option<f64>,
        /// RSV (gc/L) 7-d median
        pub rsv_gc_l_7_d_median: Option<f64>,
        /// InfA (gc /100'000 P)
        pub infa_gc_100_000_p: Option<f64>,
        /// InfB (gc/100'000 P)
        pub infb_gc_100_000_p: Option<f64>,
        /// RSV (gc /100'000 P)
        pub rsv_gc_100_000_p: Option<f64>,
        /// InfA (gc/100'000 P) 7-d median
        pub infa_gc_100_000_p_7_d_median: Option<f64>,
        /// InfB (gc/100'000 P) 7-d median
        pub infb_gc_100_000_p_7_d_median: Option<f64>,
        /// RSV (gc/100'000 P) 7-d median
        pub rsv_gc_100_000_p_7_d_median: Option<f64>,
        /// InfA (gc/PMMoV)
        pub infa_gc_pmmov: Option<f64>,
        /// InfB (gc/PMMoV)
        pub infb_gc_pmmov: Option<f64>,
        /// RSV (gc /PMMoV)
        pub rsv_gc_pmmov: Option<f64>,
        /// InfA (gc/PMMoV) 7-d median
        pub infa_gc_pmmov_7_d_median: Option<f64>,
        /// InfB (gc/PMMoV) 7-d median
        pub infb_gc_pmmov_7_d_median: Option<f64>,
        /// RSV (gc/PMMoV) 7-d median
        pub rsv_gc_pmmov_7_d_median: Option<f64>,
        /// weekly_Anz_pos_RSV
        pub kw_anz_pos_rsv_usb: Option<i64>,
        /// Anz_pos_A_BS
        pub anz_pos_a_bs: Option<i64>,
        /// Anz_pos_B_BS
        pub anz_pos_b_bs: Option<i64>,
        /// Anz_pos_H1_BS
        pub anz_pos_h1_bs: Option<i64>,
        /// Anz.pos.A_BL
        pub anz_pos_a_bl: Option<i64>,
        /// Anz.pos.B_BL
        pub anz_pos_b_bl: Option<i64>,
        /// Anz.pos.all_BL
        pub anz_pos_all_bl: Option<i64>,
        /// InfA_BS+BL
        pub infa_bs_bl: Option<i64>,
        /// InfB_BS+BL
        pub infb_bs_bl: Option<i64>,
        /// 7t_median_InfA
        pub x7t_median_infa: Option<i64>,
        /// 7t_median_InfB
        pub x7t_median_infb: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Datum,
        Kw,
        SampleBaNr,
        InfaGcPcr,
        InfbGcPcr,
        RsvGcPcr,
        InfaGcL,
        InfbGcL,
        RsvGcL,
        InfaGcL7DMedian,
        InfbGcL7DMedian,
        RsvGcL7DMedian,
        InfaGc100000P,
        InfbGc100000P,
        RsvGc100000P,
        InfaGc100000P7DMedian,
        InfbGc100000P7DMedian,
        RsvGc100000P7DMedian,
        InfaGcPmmov,
        InfbGcPmmov,
        RsvGcPmmov,
        InfaGcPmmov7DMedian,
        InfbGcPmmov7DMedian,
        RsvGcPmmov7DMedian,
        KwAnzPosRsvUsb,
        AnzPosABs,
        AnzPosBBs,
        AnzPosH1Bs,
        AnzPosABl,
        AnzPosBBl,
        AnzPosAllBl,
        InfaBsBl,
        InfbBsBl,
        X7tMedianInfa,
        X7tMedianInfb,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Datum => "datum",
                Field::Kw => "kw",
                Field::SampleBaNr => "sample_ba_nr",
                Field::InfaGcPcr => "infa_gc_pcr",
                Field::InfbGcPcr => "infb_gc_pcr",
                Field::RsvGcPcr => "rsv_gc_pcr",
                Field::InfaGcL => "infa_gc_l",
                Field::InfbGcL => "infb_gc_l",
                Field::RsvGcL => "rsv_gc_l",
                Field::InfaGcL7DMedian => "infa_gc_l_7_d_median",
                Field::InfbGcL7DMedian => "infb_gc_l_7_d_median",
                Field::RsvGcL7DMedian => "rsv_gc_l_7_d_median",
                Field::InfaGc100000P => "infa_gc_100_000_p",
                Field::InfbGc100000P => "infb_gc_100_000_p",
                Field::RsvGc100000P => "rsv_gc_100_000_p",
                Field::InfaGc100000P7DMedian => "infa_gc_100_000_p_7_d_median",
                Field::InfbGc100000P7DMedian => "infb_gc_100_000_p_7_d_median",
                Field::RsvGc100000P7DMedian => "rsv_gc_100_000_p_7_d_median",
                Field::InfaGcPmmov => "infa_gc_pmmov",
                Field::InfbGcPmmov => "infb_gc_pmmov",
                Field::RsvGcPmmov => "rsv_gc_pmmov",
                Field::InfaGcPmmov7DMedian => "infa_gc_pmmov_7_d_median",
                Field::InfbGcPmmov7DMedian => "infb_gc_pmmov_7_d_median",
                Field::RsvGcPmmov7DMedian => "rsv_gc_pmmov_7_d_median",
                Field::KwAnzPosRsvUsb => "kw_anz_pos_rsv_usb",
                Field::AnzPosABs => "anz_pos_a_bs",
                Field::AnzPosBBs => "anz_pos_b_bs",
                Field::AnzPosH1Bs => "anz_pos_h1_bs",
                Field::AnzPosABl => "anz_pos_a_bl",
                Field::AnzPosBBl => "anz_pos_b_bl",
                Field::AnzPosAllBl => "anz_pos_all_bl",
                Field::InfaBsBl => "infa_bs_bl",
                Field::InfbBsBl => "infb_bs_bl",
                Field::X7tMedianInfa => "7t_median_infa",
                Field::X7tMedianInfb => "7t_median_infb",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100302/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Wilde Abfall-Deponien"]
#[doc = ""]
#[doc = "<p>Dieser Datensatz zeigt die Abf\u{e4}lle, welche an unerlaubten Orten, in nicht geb\u{fc}hrenpflichtigen S\u{e4}cken oder/und zur Unzeit deponiert wurden und durch die Stadtreinigung der Abfallkontrolle des Amts f\u{fc}r Umwelt und Energie gemeldet wurden.\u{a0}<br><br>Die genauen geographischen Koordinaten werden einem 50x50 Meter Raster zugeteilt. Der s\u{fc}d-westliche Eckpunkt dieses Rasters wird jeweils als Geopunkt ausgewiesen, um die Anonymit\u{e4}t zu garantieren.\u{a0} \u{a0}</p>"]
pub mod wilde_abfall_deponien {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// ID
        ///
        /// Laufnummer
        pub id: Option<String>,
        /// Zeitpunkt der Meldung
        ///
        ///
        #[serde(with = "time::serde::iso8601::option")]
        pub bearbeitungszeit_meldung: Option<OffsetDateTime>,
        /// Abfallkategorie
        ///
        /// Kategorisierung; AUE steht für das Amt für Umwelt und Energie.
        pub abfallkategorie: Option<String>,
        /// Geopunkt
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Wohnviertel
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub wov_name: Option<String>,
        /// Bezirk
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub bez_name: Option<String>,
        /// Wohnviertel-ID
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub wov_id_bez: Option<String>,
        /// Bezirk-ID
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub bez_id: Option<String>,
        /// Bezirk Label
        ///
        /// Einzelne Einträge können keinem Bezirk resp. Wohnviertel zugeordnet werden.
        pub bez_label: Option<String>,
        /// Gemeinde
        pub gemeinde_name: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Id,
        BearbeitungszeitMeldung,
        Abfallkategorie,
        WovName,
        BezName,
        WovIdBez,
        BezId,
        BezLabel,
        GemeindeName,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Id => "id",
                Field::BearbeitungszeitMeldung => "bearbeitungszeit_meldung",
                Field::Abfallkategorie => "abfallkategorie",
                Field::WovName => "wov_name",
                Field::BezName => "bez_name",
                Field::WovIdBez => "wov_id_bez",
                Field::BezId => "bez_id",
                Field::BezLabel => "bez_label",
                Field::GemeindeName => "gemeinde_name",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100070/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smarte Strasse: Elektroauto-Ladestationen"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Inhalte, die beim Laden eines E-Fahrzeugs erhoben werden. Diese Daten werden von der E-Ladestation erhoben, die im Rahmen des Projekts \u{ab}Smarte Strasse\u{bb} in Basel installiert wurde. Diese E-Ladestation wurde mit minimalem Ressourcenaufwand montiert, indem man ein Kabelverteilkasten (KVK) um genutzt hat.</p><p class=\"\" style=\"font-family: sans-serif;\"><span style=\"font-weight: bolder;\">Weitere Informationen und Daten rund um das Projekt \u{ab}Smarte Strasse\u{bb} finden Sie unter den folgenden Links:</span></p><ul><li>Weitere Informationen zum Projekt \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html\" target=\"_blank\">https://www.entwicklung.bs.ch/grundlagen/smart-city/smarte-strasse.html</a>\u{a0}</li><li>Genaue Standorte aller Sensoren:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100114/table/\" target=\"_blank\">https://data.bs.ch/explore/dataset/100114/table/</a>\u{a0}</li><li>Weitere Datens\u{e4}tze rund um das Thema \u{ab}Smarte Strasse\u{bb}:\u{a0}<a href=\"https://data.bs.ch/explore/?refine.tags=smarte+strasse\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=smarte+strasse</a>\u{a0}</li></ul><p><br/></p>"]
pub mod smarte_strasse_elektroauto_ladestationen {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Start Time
        ///
        /// Start Zeitpunkt des Ladevorgangs
        #[serde(with = "time::serde::iso8601::option")]
        pub starttime: Option<OffsetDateTime>,
        /// Stop Time
        ///
        /// Ende des Ladevorgangs
        #[serde(with = "time::serde::iso8601::option")]
        pub stoptime: Option<OffsetDateTime>,
        /// Duration min
        ///
        /// Ladedauer in Minuten
        pub duration: Option<i64>,
        /// [Wh]
        ///
        /// Lademenge in Wh
        pub watthour: Option<i64>,
        /// [kWh]
        ///
        /// Lademenge in [kWh]
        pub kilowatthour: Option<f64>,
        /// Ladeleistung
        ///
        /// Maximale Ladeleistung der Ladestation
        pub station_capacity: Option<i64>,
        /// Connector
        ///
        /// Anschluss 1 oder 2 der Ladestation
        pub connectorid: Option<i64>,
        /// Location Latitude
        ///
        /// Standort GPS Koordinaten Breitengrad
        pub station_location_coordinates_lat: Option<f64>,
        /// Location Longitude
        ///
        /// Standort GPS Koordinaten Längengrad
        pub station_location_coordinates_lng: Option<f64>,
        /// Connector Type
        ///
        /// Anschluss/ Stecker Typ
        pub station_connectortype: Option<i64>,
        /// station.location
        pub station_location: Option<GeoPoint2d>,
        /// startTimeText
        pub starttimetext: Option<String>,
        /// stopTimeText
        pub stoptimetext: Option<String>,
        pub time_measured: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Starttime,
        Stoptime,
        Duration,
        Watthour,
        Kilowatthour,
        StationCapacity,
        Connectorid,
        StationLocationCoordinatesLat,
        StationLocationCoordinatesLng,
        StationConnectortype,
        Starttimetext,
        Stoptimetext,
        TimeMeasured,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Starttime => "starttime",
                Field::Stoptime => "stoptime",
                Field::Duration => "duration",
                Field::Watthour => "watthour",
                Field::Kilowatthour => "kilowatthour",
                Field::StationCapacity => "station_capacity",
                Field::Connectorid => "connectorid",
                Field::StationLocationCoordinatesLat => "station_location_coordinates_lat",
                Field::StationLocationCoordinatesLng => "station_location_coordinates_lng",
                Field::StationConnectortype => "station_connectortype",
                Field::Starttimetext => "starttimetext",
                Field::Stoptimetext => "stoptimetext",
                Field::TimeMeasured => "time_measured",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100047/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Zeitreihe der Belegung \u{f6}ffentlicher Parkh\u{e4}user Basel"]
#[doc = ""]
#[doc = "<p>St\u{fc}ndlich aktualisierte Belegungsdaten der \u{f6}ffentlichen Parkh\u{e4}user der Stadt Basel, bezogen \u{fc}ber den<a href=\"http://www.parkleitsystem-basel.ch/rss_feed.php\" target=\"_blank\"> RSS Feed</a> des <a href=\"http://www.parkleitsystem-basel.ch\" target=\"_blank\">Parkleitsystems Basel</a>.\u{a0}</p><p>Historische Daten mit kleinerer zeitlicher Aufl\u{f6}sung k\u{f6}nnen auch \u{fc}ber das API von ParkenDD bezogen werden, wie hier am Beispiel der Parkh\u{e4}user der Stadt Z\u{fc}rich beschrieben:\u{a0}<a href=\"https://opendatazurich.github.io/parkendd-api\" target=\"_blank\">https://opendatazurich.github.io/parkendd-api</a>\u{a0}(die Parkh\u{e4}user von Basel sind \u{fc}ber diese URL abrufbar: <a href=\"https://api.parkendd.de/Basel\" target=\"_blank\">https://api.parkendd.de/Basel</a>).\u{a0}</p><p>Die Standorte der Parkh\u{e4}user sind in diesem Datensatz ersichtlich:\u{a0}<a href=\"https://data.bs.ch/explore/dataset/100044\" target=\"_blank\">https://data.bs.ch/explore/dataset/100044</a>\u{a0}</p><p><span style=\"font-family: inherit; font-size: 0.875rem;\">\u{c4}nderungsprotokoll:<br></span><span style=\"font-family: inherit; font-size: 0.875rem;\">14.08.2023 - Neue Spalte \"auslastungen\" wurde hinzugef\u{fc}gt.</span></p>"]
pub mod zeitreihe_der_belegung_oeffentlicher_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Publikationszeit
        ///
        /// Datum und Uhrzeit der Publikation des Wertes
        #[serde(with = "time::serde::iso8601::option")]
        pub published: Option<OffsetDateTime>,
        /// Anzahl frei
        ///
        /// Anzahl freie Parkplätze
        pub free: Option<i64>,
        /// Total Plätze
        ///
        /// Anzahl Plätze insgesamt
        pub total: Option<i64>,
        /// Anteil belegter Parkplätze in Prozent
        pub auslastungen: Option<f64>,
        /// Eindeutige ID des Parkhauses
        pub id: Option<String>,
        /// Eindeutige ID des Parkhauses weltweit
        pub id2: Option<String>,
        /// Titel
        ///
        /// Name des Parkhauses
        pub title: Option<String>,
        /// Name
        ///
        /// Name des Parkhauses ohne den Text "Parkhaus"
        pub name: Option<String>,
        /// Adresse
        pub address: Option<String>,
        /// Link zu den Detailinformationen des jeweiligen Parkhauses
        pub link: Option<String>,
        /// Standort des Parkhauses
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Beschreibung
        ///
        /// Text, der die Anzahl freier Parkplätze enthält
        pub description: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Published,
        Free,
        Total,
        Auslastungen,
        Id,
        Id2,
        Title,
        Name,
        Address,
        Link,
        Description,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Published => "published",
                Field::Free => "free",
                Field::Total => "total",
                Field::Auslastungen => "auslastungen",
                Field::Id => "id",
                Field::Id2 => "id2",
                Field::Title => "title",
                Field::Name => "name",
                Field::Address => "address",
                Field::Link => "link",
                Field::Description => "description",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100014/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Solarkataster: Solarpotenzial"]
#[doc = ""]
#[doc = "\u{dc}ber den Solarkataster kann abgesch\u{e4}tzt werden, wie gut sich die Dach- und Fassadenfl\u{e4}chen im Kantonsgebiet f\u{fc}r die solare Nutzung eignen. Die ausgewiesenen Potenziale beruhen auf Modellrechnungen und stellen keine exakten Messwerte dar.\n<br> S\u{e4}mtliche Datens\u{e4}tze zu dem Produkt \"Solarkataster\": <a href=\"https://data.bs.ch/explore/?refine.tags=solarkataster\" target=\"_blank\">https://data.bs.ch/explore/?refine.tags=solarkataster</a> \n<br><strong>Zus\u{e4}tzliche Informationen</strong>\n<br>Die ausgewiesenen Potenziale beruhen auf Strahlungsmodellierungen der Firma Laserdata GmbH aus Innsbruck und stellen keine exakten Messwerte dar. Sie k\u{f6}nnen lediglich eine grobe Absch\u{e4}tzung zur Eignung einer Dachfl\u{e4}che f\u{fc}r eine solare Nutzung erm\u{f6}glichen.\nDie Berechnung der solaren Globalstrahlung basiert auf dem 0.5m-Oberfl\u{e4}chenmodell der Laserscan-Befliegung vom Fr\u{fc}hjahr 2021 sowie der Fassaden des 3D Stadtmodells des Kantons Basel-Stadt. Die Geb\u{e4}udeumrisse stammen aus der Ebene Bodenbedeckung der Amtlichen Vermessung vom 20.07.2021 und die Dachkanten vom 3D-Stadmodell Stand: 26.05.2021.\n\n<br>Die Berechnungsschritte umfassen im Einzelnen:\n<br>- \u{dc}bernahme des digitalen Oberfl\u{e4}chenmodells (DSM) sowie des 3D Stadtmodells vom Auftraggeber (z.B: des Kantons Basel-Stadt) in Softwaremodule der Firma Laserdata GmbH aus Innsbruck, Datenbankaufbau DSM, umliegendes Digitales Gel\u{e4}ndemodell (DGM), Indexierung, Tile-Generierung\n<br>\n- Strahlungsmodellierung der Dachfl\u{e4}chen auf Rasterbasis DGM (Topographie) und DSM (Nahverschattung) \u{fc}ber ein astronomisches Jahr hinweg,\n<br>\n- Strahlungsmodellierung der Geb\u{e4}udefassaden \u{fc}ber synthetisch erzeugte Fassadenpunkte mit Neigung und Ausrichtung auf Basis des 3D Stadtmodells, DGM (Topographie) und DSM (Nahverschattung) \u{fc}ber ein astronomisches Jahr hinweg\n<br>\n- Berechnung von f\u{fc}r verschiedene Zeitr\u{e4}ume berechnete Globalstrahlungs-Rasterdatens\u{e4}tzen (insbesondere Sommer-, Winterhalbjahr, Jahressummenwert) des Solarpotenzials der Hausd\u{e4}cher. Einheit: Kilowattstunden pro m\u{b2} und Bezugszeitraum\n<br>\n- Korrektur der unter clear sky Bedingungen modellierten Globalstrahlung anhand von meteorologischen Messwerten\n<br>\n- Einteilung der Eignung der Dachfl\u{e4}chen zur solaren Nutzung in vom Auftraggeber bestimmte Klassen f\u{fc}r Photovoltaik sowie Solarthermie unter Ber\u{fc}cksichtigung von definierten Mindestfl\u{e4}chen\n<br>\n- Zonalstatistik der Rasterinformationen des Solarpotenzials sowie der Fassadeneinstrahlung als Attributdaten zu einem Vektorlayer der Geb\u{e4}udeumrisse des Auftraggebers des Kantons Basel-Stadt"]
pub mod solarkataster_solarpotenzial {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Geo Point
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Geo Shape
        pub geo_shape: Option<GeoJson>,
        /// Id_Gebäude
        ///
        /// Identifikator des Gebäudes
        pub idgebaeude: Option<i64>,
        /// Gebäudenummer
        ///
        /// GWR-Nummer des Gebäudes
        pub gebaeudenr: Option<i64>,
        /// Photovoltaik Beste Eignung
        ///
        /// Dachfläche mit bester Eignung für Photovoltaik in m2 (> 1100 kWh/m2a und 10m2 Mindestfläche)
        pub pv_best_ei: Option<f64>,
        /// Photovoltaik Gute Eignung
        ///
        /// Dachfläche mit guter Eignung für Photovoltaik in m2 (800 bis 1100 kWh/m2a und 10m2 Mindestfläche)
        pub pv_gute_ei: Option<f64>,
        /// Fassade Gute Eignung
        ///
        /// Fassadenfläche mit guter Eignung für Photovoltaik in m2 (>600kWh/m2a)
        pub f_gute_ei: Option<f64>,
        /// Solarthermie Beste Eignung
        ///
        /// Dachfläche mit bester Eignung für Solarthermie in m2 (> 1100 kWh/m2a und 5m2 Mindestfläche)
        pub st_best_ei: Option<f64>,
        /// Solarthermie Gute Eignung
        ///
        /// Dachfläche mit guter Eignung für Solarthermie in m2 (800 bis 1100 kWh/m2a und 5m2 Mindestfläche)
        pub st_gute_ei: Option<f64>,
        /// Photovoltaik Ertrag Jahr
        ///
        /// Möglicher Stromertrag pro Jahr für Dachflächen mit Photovoltaik in kWh
        pub pv_ertrg_j: Option<i64>,
        /// Photovoltaik Ertrag Winter
        ///
        /// Möglicher Stromertrag pro Winterhalbjahr für Dachflächen mit Photovoltaik in kWh
        pub pv_ertrg_w: Option<i64>,
        /// Photovoltaik Ertrag Sommer
        ///
        /// Möglicher Stromertrag pro Sommerhalbjahr für Dachflächen mit Photovoltaik in kWh
        pub pv_ertrg_s: Option<i64>,
        /// Fassade Ertrag Jahr
        ///
        /// Möglicher Stromertrag pro Jahr für Fassadenflächen mit Photovoltaik in kWh
        pub f_ertrg_j: Option<i64>,
        /// Fassade Ertrag Winter
        ///
        /// Möglicher Stromertrag pro Winterhalbjahr für Fassadenflächen mit Photovoltaik in kWh
        pub f_ertrg_w: Option<i64>,
        /// Fassade Ertrag Sommer
        ///
        /// Möglicher Stromertrag pro Sommerhalbjahr für Fassadenflächen mit Photovoltaik in kWh
        pub f_ertrg_s: Option<i64>,
        /// Solarthermie Ertrag Jahr
        ///
        /// Möglicher Wärmeertrag pro Jahr für Dachflächen mit Solarthermie in kWh
        pub st_ertrg_j: Option<i64>,
        /// Solarthermie Ertrag Winter
        ///
        /// Möglicher Wärmeertrag pro Winterhalbjahr für Dachflächen mit Solarthermie in kWh
        pub st_ertrg_w: Option<i64>,
        /// Solarthermie Ertrag Sommer
        ///
        /// Möglicher Wärmeertrag pro Sommerhalbjahr für Dachflächen mit Solarthermie in kWh
        pub st_ertrg_s: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Idgebaeude,
        Gebaeudenr,
        PvBestEi,
        PvGuteEi,
        FGuteEi,
        StBestEi,
        StGuteEi,
        PvErtrgJ,
        PvErtrgW,
        PvErtrgS,
        FErtrgJ,
        FErtrgW,
        FErtrgS,
        StErtrgJ,
        StErtrgW,
        StErtrgS,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Idgebaeude => "idgebaeude",
                Field::Gebaeudenr => "gebaeudenr",
                Field::PvBestEi => "pv_best_ei",
                Field::PvGuteEi => "pv_gute_ei",
                Field::FGuteEi => "f_gute_ei",
                Field::StBestEi => "st_best_ei",
                Field::StGuteEi => "st_gute_ei",
                Field::PvErtrgJ => "pv_ertrg_j",
                Field::PvErtrgW => "pv_ertrg_w",
                Field::PvErtrgS => "pv_ertrg_s",
                Field::FErtrgJ => "f_ertrg_j",
                Field::FErtrgW => "f_ertrg_w",
                Field::FErtrgS => "f_ertrg_s",
                Field::StErtrgJ => "st_ertrg_j",
                Field::StErtrgW => "st_ertrg_w",
                Field::StErtrgS => "st_ertrg_s",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100382/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Standorte Mess-Stationen Smart Climate Luftklima"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt die Standorte der Mess-Stationen f\u{fc}r den Datensatz <a href=\"https://data.bs.ch/explore/dataset/100009\" target=\"_blank\">\u{ab}Luftklima Smart Regio Basel\u{bb}</a>.</p><p><b>\u{c4}nderungsprotokoll:</b></p><p><b>18.04.2024:</b> Die Koordinaten werden automatisch plausibilisiert. Es werde nur Koordinaten angezeigt, die in einem bestimmten Umkreis von Basel sind. Der Code dazu ist hier verf\u{fc}gbar:\u{a0}<a href=\"https://github.com/opendatabs/data-processing/blob/master/meteoblue_wolf/etl.py\" target=\"_blank\">https://github.com/opendatabs/data-processing/blob/master/meteoblue_wolf/etl.py</a>\u{a0}</p>"]
pub mod standorte_mess_stationen_smart_climate_luftklima {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station-ID
        ///
        /// ID der Wetterstation
        pub name_original: Option<String>,
        /// Name
        ///
        /// Name der Wetterstation
        pub name_custom: Option<String>,
        /// Werte seit
        ///
        /// Älteste Aufzeichnung von Wetterdaten durch diese Station
        #[serde(with = "time::serde::iso8601::option")]
        pub dates_min_date: Option<OffsetDateTime>,
        /// Werte bis
        ///
        /// Neuste Aufzeichnung von Wetterdaten durch diese Station
        #[serde(with = "time::serde::iso8601::option")]
        pub dates_max_date: Option<OffsetDateTime>,
        /// Koordinaten
        ///
        /// Automatisch plausibilisierte Koordinaten
        pub coords: Option<GeoPoint2d>,
        /// Längengrad
        pub lon: Option<f64>,
        /// Breitengrad
        pub lat: Option<f64>,
        /// Stadtklima Basel Link
        ///
        /// Link auf die entsprechende Station auf der "Stadtklima Basel" Website, wo historische Daten und Vorhersagen abgerufen werden können.
        pub stadtklima_basel_link: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        NameOriginal,
        NameCustom,
        DatesMinDate,
        DatesMaxDate,
        Lon,
        Lat,
        StadtklimaBaselLink,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::NameOriginal => "name_original",
                Field::NameCustom => "name_custom",
                Field::DatesMinDate => "dates_min_date",
                Field::DatesMaxDate => "dates_max_date",
                Field::Lon => "lon",
                Field::Lat => "lat",
                Field::StadtklimaBaselLink => "stadtklima_basel_link",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100082/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Smart Climate Luftklima"]
#[doc = ""]
#[doc = "<p>Der Datensatz zeigt st\u{fc}ndlich aktualisierte Angaben zu Lufttemperatur und Niederschlag, welche \u{fc}ber Sensoren von meteoblue gemessen werden.\u{a0}</p><p>Es handelt sich um Rohdaten, welche nicht plausibilisiert oder korrigiert sind.</p><p>Die geografischen Koordinaten der Sensoren sind im Datensatz <a href=\"https://data.bs.ch/explore/dataset/100082\" target=\"_blank\">\u{ab}Standorte der Mess-Stationen Luftklima Smart Regio Basel\u{bb}</a> verf\u{fc}gbar.</p>"]
pub mod smart_climate_luftklima {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Station-ID
        ///
        /// ID der Wetterstation
        pub name_original: Option<String>,
        /// Name
        ///
        /// Name der Wetterstation
        pub name_custom: Option<String>,
        /// Zeitstempel
        ///
        /// Datum und Zeit der Messung
        #[serde(with = "time::serde::iso8601::option")]
        pub dates_max_date: Option<OffsetDateTime>,
        /// Lufttemperatur
        pub meta_airtemp: Option<f64>,
        /// Regen in 1 h
        ///
        /// Total der Niederschläge innerhalb der letzten Stunde
        pub meta_rain_1h_val: Option<f64>,
        /// Regen in 24 h
        ///
        /// Total der Niederschläge innerhalb der letzten 24 Stunden
        pub meta_rain24h_sum: Option<f64>,
        /// Regen in 48 h
        ///
        /// Total der Niederschläge innerhalb der letzten 48 Stunden
        pub meta_rain48h_sum: Option<f64>,
        /// Koordinaten
        pub coords: Option<GeoPoint2d>,
        /// Stadtklima Basel Link
        ///
        /// Link auf die entsprechende Station auf der "Stadtklima Basel" Website, wo historische Daten und Vorhersagen abgerufen werden können.
        pub stadtklima_basel_link: Option<String>,
        /// Unix Zeitstempel
        ///
        /// Zeitstempel der Messung in Sekunden seit 1. Januar 1970
        pub unix_timestamp: Option<i64>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        NameOriginal,
        NameCustom,
        DatesMaxDate,
        MetaAirtemp,
        MetaRain1hVal,
        MetaRain24hSum,
        MetaRain48hSum,
        StadtklimaBaselLink,
        UnixTimestamp,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::NameOriginal => "name_original",
                Field::NameCustom => "name_custom",
                Field::DatesMaxDate => "dates_max_date",
                Field::MetaAirtemp => "meta_airtemp",
                Field::MetaRain1hVal => "meta_rain_1h_val",
                Field::MetaRain24hSum => "meta_rain24h_sum",
                Field::MetaRain48hSum => "meta_rain48h_sum",
                Field::StadtklimaBaselLink => "stadtklima_basel_link",
                Field::UnixTimestamp => "unix_timestamp",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100009/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "\u{dc}berwachung Luftqualit\u{e4}t Transformation Areal Rosental: Staubgebundene Schadstoffe"]
#[doc = ""]
#[doc = "<p>Bedingt durch die fr\u{fc}here Nutzung des Rosental Areals \u{2013} auch bekannt als die Wiege der Basler Chemie - ist der Untergrund mit Schadstoffen belastet. W\u{e4}hrend der Tiefbauarbeiten im Rahmen der \u{ab}Transformation <a href=\"https://rosentalmitte.ch/\" target=\"_blank\">Rosental Mitte</a>\u{bb} \u{fc}berwacht das <a href=\"http://www.basler-luft.ch/\" target=\"_blank\">Lufthygieneamt beider Basel (LHA)</a> die Immissionen mittels Messungen der Luft <a href=\"https://data.bs.ch/pages/rosental-dashboard/\" target=\"_blank\">(Dashboard)</a>.\u{a0}</p><p>\u{c4}nderungsprotokoll:<br>23.4.2024: Die Messstation ROSEN 3 wurde verschoben. Alte geografische Breiten- und L\u{e4}ngengrade 47.567827676637364, 7.603804744961502. Neue Breiten- und L\u{e4}gengrade\u{a0}47.567997530870265, 7.60479830196066.<br></p><div><br></div>"]
pub mod ueberwachung_luftqualitaet_transformation_areal_rosental_staubgebundene_schadstoffe {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Messbeginn
        ///
        /// Beginn der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messbeginn: Option<Date>,
        /// Messende
        ///
        /// Ende der Messung
        #[serde(
            serialize_with = "serialize_date",
            deserialize_with = "deserialize_date"
        )]
        pub messende: Option<Date>,
        /// Standort
        ///
        /// Name des Standorts
        pub standort: Option<String>,
        /// Parameter
        ///
        /// Gemessener Stoff
        pub parameter: Option<String>,
        /// Messwert
        ///
        /// Gemessener Wert
        pub messwert: Option<String>,
        /// Messwert (Zahlenformat bis auf 3 Dezimalstellen)
        ///
        /// Gemessener Wert bis auf 3 Dezimalstellen
        pub messwert_zahlenformat: Option<f64>,
        /// 3_dezimalstellen_messwert
        ///
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub x3_dezimalstellen_messwert: Option<f64>,
        /// 4_dezimalstellen_messwert
        ///
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub x4_dezimalstellen_messwert: Option<f64>,
        /// 5_dezimalstellen_messwert
        ///
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub x5_dezimalstellen_messwert: Option<f64>,
        /// Interventionswert
        pub interventionswert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub interventionswert_3_dez: Option<f64>,
        /// Warnwert
        pub warnwert: Option<f64>,
        /// Dieses Attribut wird verwendet, um die Anzahl der Dezimalstellen für die Darstellung von Messwerten im Rosental-Dashboard anzupassen. Diese Anpassung ist notwendig, da die Darstellungsoptionen im Datenportal begrenzt sind. Mit diesem Attribut können wir sicherstellen, dass die Dezimalstellen in der Visualisierung genau so angezeigt werden, wie es für die Präsentation der Daten erforderlich ist.
        pub warnwert_3_dez: Option<f64>,
        /// Einheit
        ///
        /// Einheit, in welcher der Wert gemessen wird
        pub einheit: Option<String>,
        /// Messmethode
        pub messmethode: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Messbeginn,
        Messende,
        Standort,
        Parameter,
        Messwert,
        MesswertZahlenformat,
        X3DezimalstellenMesswert,
        X4DezimalstellenMesswert,
        X5DezimalstellenMesswert,
        Interventionswert,
        Interventionswert3Dez,
        Warnwert,
        Warnwert3Dez,
        Einheit,
        Messmethode,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Messbeginn => "messbeginn",
                Field::Messende => "messende",
                Field::Standort => "standort",
                Field::Parameter => "parameter",
                Field::Messwert => "messwert",
                Field::MesswertZahlenformat => "messwert_zahlenformat",
                Field::X3DezimalstellenMesswert => "3_dezimalstellen_messwert",
                Field::X4DezimalstellenMesswert => "4_dezimalstellen_messwert",
                Field::X5DezimalstellenMesswert => "5_dezimalstellen_messwert",
                Field::Interventionswert => "interventionswert",
                Field::Interventionswert3Dez => "interventionswert_3_dez",
                Field::Warnwert => "warnwert",
                Field::Warnwert3Dez => "warnwert_3_dez",
                Field::Einheit => "einheit",
                Field::Messmethode => "messmethode",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100274/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}

#[doc = "Aktuelle Belegung der \u{f6}ffentlichen Parkh\u{e4}user Basel"]
#[doc = ""]
#[doc = "<p>Min\u{fc}tlich aktualisierte Belegungsdaten der \u{f6}ffentlich zug\u{e4}nglichen Parkh\u{e4}user der Stadt Basel, bezogen \u{fc}ber den<a href=\"http://www.parkleitsystem-basel.ch/rss_feed.php\" target=\"_blank\"> RSS Feed</a> des <a href=\"http://www.parkleitsystem-basel.ch\" target=\"_blank\">Parkleitsystems Basel</a>.</p>\n\n<p>Historische Daten sind in diesem Datensatz vorhanden: <a href=\"https://data.bs.ch/explore/dataset/100014\" target=\"_blank\">https://data.bs.ch/explore/dataset/100014</a>.\u{a0}</p>"]
pub mod aktuelle_belegung_der_oeffentlichen_parkhaeuser_basel {
    use super::*;

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Record {
        /// Titel
        ///
        /// Name des Parkhauses
        pub title: Option<String>,
        /// Publikationszeit
        ///
        /// Datum und Uhrzeit der Publikation des Wertes
        #[serde(with = "time::serde::iso8601::option")]
        pub published: Option<OffsetDateTime>,
        /// Anzahl frei
        ///
        /// Anzahl freie Parkplätze
        pub free: Option<i64>,
        /// Total
        ///
        /// Anzahl Parkplätze total
        pub total: Option<i64>,
        /// Anteil frei
        ///
        /// Anteil freier Parkplätze
        pub anteil_frei: Option<f64>,
        /// Auslastung
        ///
        /// Anteil belegter Parkplätze
        pub auslastung: Option<f64>,
        /// Auslastung in Prozent
        ///
        /// Anteil belegter Parkplätze in Prozent
        pub auslastung_prozent: Option<f64>,
        /// Link
        ///
        /// Link zu den Detailinformationen des jeweiligen Parkhauses
        pub link: Option<String>,
        /// Standort des Parkhauses
        pub geo_point_2d: Option<GeoPoint2d>,
        /// Beschreibung
        ///
        /// Text, der die Anzahl freier Parkplätze enthält
        pub description: Option<String>,
        /// Name
        pub name: Option<String>,
        pub id2: Option<String>,
    }

    #[derive(Deserialize, Serialize, Debug, Clone)]
    pub struct Data {
        pub total_count: u64,
        pub results: Vec<Record>,
    }

    #[derive(Debug, Clone, Copy)]
    pub enum Field {
        Title,
        Published,
        Free,
        Total,
        AnteilFrei,
        Auslastung,
        AuslastungProzent,
        Link,
        Description,
        Name,
        Id2,
    }

    impl Field {
        fn name(self) -> &'static str {
            match self {
                Field::Title => "title",
                Field::Published => "published",
                Field::Free => "free",
                Field::Total => "total",
                Field::AnteilFrei => "anteil_frei",
                Field::Auslastung => "auslastung",
                Field::AuslastungProzent => "auslastung_prozent",
                Field::Link => "link",
                Field::Description => "description",
                Field::Name => "name",
                Field::Id2 => "id2",
            }
        }
    }

    #[derive(Debug, Clone, Default)]
    pub struct Order(String);

    impl Order {
        pub fn new() -> Self {
            Self(String::new())
        }

        pub fn ascending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}`", field.name()));
            self
        }

        pub fn descending(mut self, field: Field) -> Self {
            if !self.0.is_empty() {
                self.0.push_str(", ");
            }
            self.0.push_str(&format!("`{}` desc", field.name()));
            self
        }
    }

    #[derive(Debug, Clone)]
    pub struct Filter(String);

    impl Filter {
        pub fn is_null(field: Field) -> Self {
            Self(format!("`{}` is null", field.name()))
        }

        pub fn is_not_null(field: Field) -> Self {
            Self(format!("`{}` is not null", field.name()))
        }

        pub fn equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` = \"{}\"", field.name(), escape(value)))
        }

        pub fn equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` = {value}", field.name()))
        }

        pub fn not_equal_str(field: Field, value: &str) -> Self {
            Self(format!("`{}` != \"{}\"", field.name(), escape(value)))
        }

        pub fn not_equal_num(field: Field, value: f64) -> Self {
            Self(format!("`{}` != {value}", field.name()))
        }

        pub fn greater(field: Field, value: f64) -> Self {
            Self(format!("{} > {value}", field.name()))
        }

        pub fn greater_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} >= {value}", field.name()))
        }

        pub fn less(field: Field, value: f64) -> Self {
            Self(format!("{} < {value}", field.name()))
        }

        pub fn less_or_equal(field: Field, value: f64) -> Self {
            Self(format!("{} <= {value}", field.name()))
        }

        pub fn starts_with(field: Field, value: &str) -> Self {
            Self(format!(
                "startswith(`{}`, \"{}\")",
                field.name(),
                escape(value)
            ))
        }

        pub fn search(field: Field, value: &str) -> Self {
            Self(format!("search(`{}`, \"{}\")", field.name(), escape(value)))
        }

        pub fn and(self, other: Self) -> Self {
            Self(format!("({}) and ({})", self.0, other.0))
        }

        pub fn or(self, other: Self) -> Self {
            Self(format!("({}) or ({})", self.0, other.0))
        }

        pub fn not(self) -> Self {
            Self(format!("not ({})", self.0))
        }
    }

    pub async fn get(
        limit: u8,
        offset: u64,
        order: Order,
        filter: Option<Filter>,
    ) -> Result<Data, Box<dyn std::error::Error>> {
        let limit = if limit > 100 { 100 } else { limit };
        let filter = filter.map(|filter| filter.0).unwrap_or(String::new());
        let url = format!("https://data.bs.ch/api/explore/v2.1/catalog/datasets/100088/records?limit={limit}&offset={offset}");
        let url =
            reqwest::Url::parse_with_params(&url, &[("order_by", order.0), ("where", filter)])?;
        let response = reqwest::get(url).await?.text().await?;
        let data: Data = serde_json::from_str(&response)?;
        Ok(data)
    }
}
